{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { EditOperation } from '../core/editOperation.js';\nimport { Range } from '../core/range.js';\nexport class TrimTrailingWhitespaceCommand {\n  constructor(selection, cursors, trimInRegexesAndStrings) {\n    this._selection = selection;\n    this._cursors = cursors;\n    this._selectionId = null;\n    this._trimInRegexesAndStrings = trimInRegexesAndStrings;\n  }\n  getEditOperations(model, builder) {\n    const ops = trimTrailingWhitespace(model, this._cursors, this._trimInRegexesAndStrings);\n    for (let i = 0, len = ops.length; i < len; i++) {\n      const op = ops[i];\n      builder.addEditOperation(op.range, op.text);\n    }\n    this._selectionId = builder.trackSelection(this._selection);\n  }\n  computeCursorState(model, helper) {\n    return helper.getTrackedSelection(this._selectionId);\n  }\n}\n/**\n * Generate commands for trimming trailing whitespace on a model and ignore lines on which cursors are sitting.\n */\nexport function trimTrailingWhitespace(model, cursors, trimInRegexesAndStrings) {\n  // Sort cursors ascending\n  cursors.sort((a, b) => {\n    if (a.lineNumber === b.lineNumber) {\n      return a.column - b.column;\n    }\n    return a.lineNumber - b.lineNumber;\n  });\n  // Reduce multiple cursors on the same line and only keep the last one on the line\n  for (let i = cursors.length - 2; i >= 0; i--) {\n    if (cursors[i].lineNumber === cursors[i + 1].lineNumber) {\n      // Remove cursor at `i`\n      cursors.splice(i, 1);\n    }\n  }\n  const r = [];\n  let rLen = 0;\n  let cursorIndex = 0;\n  const cursorLen = cursors.length;\n  for (let lineNumber = 1, lineCount = model.getLineCount(); lineNumber <= lineCount; lineNumber++) {\n    const lineContent = model.getLineContent(lineNumber);\n    const maxLineColumn = lineContent.length + 1;\n    let minEditColumn = 0;\n    if (cursorIndex < cursorLen && cursors[cursorIndex].lineNumber === lineNumber) {\n      minEditColumn = cursors[cursorIndex].column;\n      cursorIndex++;\n      if (minEditColumn === maxLineColumn) {\n        // The cursor is at the end of the line => no edits for sure on this line\n        continue;\n      }\n    }\n    if (lineContent.length === 0) {\n      continue;\n    }\n    const lastNonWhitespaceIndex = strings.lastNonWhitespaceIndex(lineContent);\n    let fromColumn = 0;\n    if (lastNonWhitespaceIndex === -1) {\n      // Entire line is whitespace\n      fromColumn = 1;\n    } else if (lastNonWhitespaceIndex !== lineContent.length - 1) {\n      // There is trailing whitespace\n      fromColumn = lastNonWhitespaceIndex + 2;\n    } else {\n      // There is no trailing whitespace\n      continue;\n    }\n    if (!trimInRegexesAndStrings) {\n      if (!model.tokenization.hasAccurateTokensForLine(lineNumber)) {\n        // We don't want to force line tokenization, as that can be expensive, but we also don't want to trim\n        // trailing whitespace in lines that are not tokenized yet, as that can be wrong and trim whitespace from\n        // lines that the user requested we don't. So we bail out if the tokens are not accurate for this line.\n        continue;\n      }\n      const lineTokens = model.tokenization.getLineTokens(lineNumber);\n      const fromColumnType = lineTokens.getStandardTokenType(lineTokens.findTokenIndexAtOffset(fromColumn));\n      if (fromColumnType === 2 /* StandardTokenType.String */ || fromColumnType === 3 /* StandardTokenType.RegEx */) {\n        continue;\n      }\n    }\n    fromColumn = Math.max(minEditColumn, fromColumn);\n    r[rLen++] = EditOperation.delete(new Range(lineNumber, fromColumn, lineNumber, maxLineColumn));\n  }\n  return r;\n}","map":{"version":3,"names":["strings","EditOperation","Range","TrimTrailingWhitespaceCommand","constructor","selection","cursors","trimInRegexesAndStrings","_selection","_cursors","_selectionId","_trimInRegexesAndStrings","getEditOperations","model","builder","ops","trimTrailingWhitespace","i","len","length","op","addEditOperation","range","text","trackSelection","computeCursorState","helper","getTrackedSelection","sort","a","b","lineNumber","column","splice","r","rLen","cursorIndex","cursorLen","lineCount","getLineCount","lineContent","getLineContent","maxLineColumn","minEditColumn","lastNonWhitespaceIndex","fromColumn","tokenization","hasAccurateTokensForLine","lineTokens","getLineTokens","fromColumnType","getStandardTokenType","findTokenIndexAtOffset","Math","max","delete"],"sources":["/home/arslan/modojo/node_modules/monaco-editor/esm/vs/editor/common/commands/trimTrailingWhitespaceCommand.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { EditOperation } from '../core/editOperation.js';\nimport { Range } from '../core/range.js';\nexport class TrimTrailingWhitespaceCommand {\n    constructor(selection, cursors, trimInRegexesAndStrings) {\n        this._selection = selection;\n        this._cursors = cursors;\n        this._selectionId = null;\n        this._trimInRegexesAndStrings = trimInRegexesAndStrings;\n    }\n    getEditOperations(model, builder) {\n        const ops = trimTrailingWhitespace(model, this._cursors, this._trimInRegexesAndStrings);\n        for (let i = 0, len = ops.length; i < len; i++) {\n            const op = ops[i];\n            builder.addEditOperation(op.range, op.text);\n        }\n        this._selectionId = builder.trackSelection(this._selection);\n    }\n    computeCursorState(model, helper) {\n        return helper.getTrackedSelection(this._selectionId);\n    }\n}\n/**\n * Generate commands for trimming trailing whitespace on a model and ignore lines on which cursors are sitting.\n */\nexport function trimTrailingWhitespace(model, cursors, trimInRegexesAndStrings) {\n    // Sort cursors ascending\n    cursors.sort((a, b) => {\n        if (a.lineNumber === b.lineNumber) {\n            return a.column - b.column;\n        }\n        return a.lineNumber - b.lineNumber;\n    });\n    // Reduce multiple cursors on the same line and only keep the last one on the line\n    for (let i = cursors.length - 2; i >= 0; i--) {\n        if (cursors[i].lineNumber === cursors[i + 1].lineNumber) {\n            // Remove cursor at `i`\n            cursors.splice(i, 1);\n        }\n    }\n    const r = [];\n    let rLen = 0;\n    let cursorIndex = 0;\n    const cursorLen = cursors.length;\n    for (let lineNumber = 1, lineCount = model.getLineCount(); lineNumber <= lineCount; lineNumber++) {\n        const lineContent = model.getLineContent(lineNumber);\n        const maxLineColumn = lineContent.length + 1;\n        let minEditColumn = 0;\n        if (cursorIndex < cursorLen && cursors[cursorIndex].lineNumber === lineNumber) {\n            minEditColumn = cursors[cursorIndex].column;\n            cursorIndex++;\n            if (minEditColumn === maxLineColumn) {\n                // The cursor is at the end of the line => no edits for sure on this line\n                continue;\n            }\n        }\n        if (lineContent.length === 0) {\n            continue;\n        }\n        const lastNonWhitespaceIndex = strings.lastNonWhitespaceIndex(lineContent);\n        let fromColumn = 0;\n        if (lastNonWhitespaceIndex === -1) {\n            // Entire line is whitespace\n            fromColumn = 1;\n        }\n        else if (lastNonWhitespaceIndex !== lineContent.length - 1) {\n            // There is trailing whitespace\n            fromColumn = lastNonWhitespaceIndex + 2;\n        }\n        else {\n            // There is no trailing whitespace\n            continue;\n        }\n        if (!trimInRegexesAndStrings) {\n            if (!model.tokenization.hasAccurateTokensForLine(lineNumber)) {\n                // We don't want to force line tokenization, as that can be expensive, but we also don't want to trim\n                // trailing whitespace in lines that are not tokenized yet, as that can be wrong and trim whitespace from\n                // lines that the user requested we don't. So we bail out if the tokens are not accurate for this line.\n                continue;\n            }\n            const lineTokens = model.tokenization.getLineTokens(lineNumber);\n            const fromColumnType = lineTokens.getStandardTokenType(lineTokens.findTokenIndexAtOffset(fromColumn));\n            if (fromColumnType === 2 /* StandardTokenType.String */ || fromColumnType === 3 /* StandardTokenType.RegEx */) {\n                continue;\n            }\n        }\n        fromColumn = Math.max(minEditColumn, fromColumn);\n        r[rLen++] = EditOperation.delete(new Range(lineNumber, fromColumn, lineNumber, maxLineColumn));\n    }\n    return r;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}