{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { SingleCursorState } from '../cursorCommon.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport class WordOperations {\n  static _createWord(lineContent, wordType, nextCharClass, start, end) {\n    // console.log('WORD ==> ' + start + ' => ' + end + ':::: <<<' + lineContent.substring(start, end) + '>>>');\n    return {\n      start: start,\n      end: end,\n      wordType: wordType,\n      nextCharClass: nextCharClass\n    };\n  }\n  static _createIntlWord(intlWord, nextCharClass) {\n    // console.log('INTL WORD ==> ' + intlWord.index + ' => ' + intlWord.index + intlWord.segment.length + ':::: <<<' + intlWord.segment + '>>>');\n    return {\n      start: intlWord.index,\n      end: intlWord.index + intlWord.segment.length,\n      wordType: 1 /* WordType.Regular */,\n      nextCharClass: nextCharClass\n    };\n  }\n  static _findPreviousWordOnLine(wordSeparators, model, position) {\n    const lineContent = model.getLineContent(position.lineNumber);\n    return this._doFindPreviousWordOnLine(lineContent, wordSeparators, position);\n  }\n  static _doFindPreviousWordOnLine(lineContent, wordSeparators, position) {\n    let wordType = 0 /* WordType.None */;\n    const previousIntlWord = wordSeparators.findPrevIntlWordBeforeOrAtOffset(lineContent, position.column - 2);\n    for (let chIndex = position.column - 2; chIndex >= 0; chIndex--) {\n      const chCode = lineContent.charCodeAt(chIndex);\n      const chClass = wordSeparators.get(chCode);\n      if (previousIntlWord && chIndex === previousIntlWord.index) {\n        return this._createIntlWord(previousIntlWord, chClass);\n      }\n      if (chClass === 0 /* WordCharacterClass.Regular */) {\n        if (wordType === 2 /* WordType.Separator */) {\n          return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n        }\n        wordType = 1 /* WordType.Regular */;\n      } else if (chClass === 2 /* WordCharacterClass.WordSeparator */) {\n        if (wordType === 1 /* WordType.Regular */) {\n          return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n        }\n        wordType = 2 /* WordType.Separator */;\n      } else if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n        if (wordType !== 0 /* WordType.None */) {\n          return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n        }\n      }\n    }\n    if (wordType !== 0 /* WordType.None */) {\n      return this._createWord(lineContent, wordType, 1 /* WordCharacterClass.Whitespace */, 0, this._findEndOfWord(lineContent, wordSeparators, wordType, 0));\n    }\n    return null;\n  }\n  static _findEndOfWord(lineContent, wordSeparators, wordType, startIndex) {\n    const nextIntlWord = wordSeparators.findNextIntlWordAtOrAfterOffset(lineContent, startIndex);\n    const len = lineContent.length;\n    for (let chIndex = startIndex; chIndex < len; chIndex++) {\n      const chCode = lineContent.charCodeAt(chIndex);\n      const chClass = wordSeparators.get(chCode);\n      if (nextIntlWord && chIndex === nextIntlWord.index + nextIntlWord.segment.length) {\n        return chIndex;\n      }\n      if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n        return chIndex;\n      }\n      if (wordType === 1 /* WordType.Regular */ && chClass === 2 /* WordCharacterClass.WordSeparator */) {\n        return chIndex;\n      }\n      if (wordType === 2 /* WordType.Separator */ && chClass === 0 /* WordCharacterClass.Regular */) {\n        return chIndex;\n      }\n    }\n    return len;\n  }\n  static _findNextWordOnLine(wordSeparators, model, position) {\n    const lineContent = model.getLineContent(position.lineNumber);\n    return this._doFindNextWordOnLine(lineContent, wordSeparators, position);\n  }\n  static _doFindNextWordOnLine(lineContent, wordSeparators, position) {\n    let wordType = 0 /* WordType.None */;\n    const len = lineContent.length;\n    const nextIntlWord = wordSeparators.findNextIntlWordAtOrAfterOffset(lineContent, position.column - 1);\n    for (let chIndex = position.column - 1; chIndex < len; chIndex++) {\n      const chCode = lineContent.charCodeAt(chIndex);\n      const chClass = wordSeparators.get(chCode);\n      if (nextIntlWord && chIndex === nextIntlWord.index) {\n        return this._createIntlWord(nextIntlWord, chClass);\n      }\n      if (chClass === 0 /* WordCharacterClass.Regular */) {\n        if (wordType === 2 /* WordType.Separator */) {\n          return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n        }\n        wordType = 1 /* WordType.Regular */;\n      } else if (chClass === 2 /* WordCharacterClass.WordSeparator */) {\n        if (wordType === 1 /* WordType.Regular */) {\n          return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n        }\n        wordType = 2 /* WordType.Separator */;\n      } else if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n        if (wordType !== 0 /* WordType.None */) {\n          return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n        }\n      }\n    }\n    if (wordType !== 0 /* WordType.None */) {\n      return this._createWord(lineContent, wordType, 1 /* WordCharacterClass.Whitespace */, this._findStartOfWord(lineContent, wordSeparators, wordType, len - 1), len);\n    }\n    return null;\n  }\n  static _findStartOfWord(lineContent, wordSeparators, wordType, startIndex) {\n    const previousIntlWord = wordSeparators.findPrevIntlWordBeforeOrAtOffset(lineContent, startIndex);\n    for (let chIndex = startIndex; chIndex >= 0; chIndex--) {\n      const chCode = lineContent.charCodeAt(chIndex);\n      const chClass = wordSeparators.get(chCode);\n      if (previousIntlWord && chIndex === previousIntlWord.index) {\n        return chIndex;\n      }\n      if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n        return chIndex + 1;\n      }\n      if (wordType === 1 /* WordType.Regular */ && chClass === 2 /* WordCharacterClass.WordSeparator */) {\n        return chIndex + 1;\n      }\n      if (wordType === 2 /* WordType.Separator */ && chClass === 0 /* WordCharacterClass.Regular */) {\n        return chIndex + 1;\n      }\n    }\n    return 0;\n  }\n  static moveWordLeft(wordSeparators, model, position, wordNavigationType) {\n    let lineNumber = position.lineNumber;\n    let column = position.column;\n    if (column === 1) {\n      if (lineNumber > 1) {\n        lineNumber = lineNumber - 1;\n        column = model.getLineMaxColumn(lineNumber);\n      }\n    }\n    let prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n    if (wordNavigationType === 0 /* WordNavigationType.WordStart */) {\n      return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n    }\n    if (wordNavigationType === 1 /* WordNavigationType.WordStartFast */) {\n      if (prevWordOnLine && prevWordOnLine.wordType === 2 /* WordType.Separator */ && prevWordOnLine.end - prevWordOnLine.start === 1 && prevWordOnLine.nextCharClass === 0 /* WordCharacterClass.Regular */) {\n        // Skip over a word made up of one single separator and followed by a regular character\n        prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n      }\n      return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n    }\n    if (wordNavigationType === 3 /* WordNavigationType.WordAccessibility */) {\n      while (prevWordOnLine && prevWordOnLine.wordType === 2 /* WordType.Separator */) {\n        // Skip over words made up of only separators\n        prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n      }\n      return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n    }\n    // We are stopping at the ending of words\n    if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n      prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n    }\n    return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.end + 1 : 1);\n  }\n  static _moveWordPartLeft(model, position) {\n    const lineNumber = position.lineNumber;\n    const maxColumn = model.getLineMaxColumn(lineNumber);\n    if (position.column === 1) {\n      return lineNumber > 1 ? new Position(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)) : position;\n    }\n    const lineContent = model.getLineContent(lineNumber);\n    for (let column = position.column - 1; column > 1; column--) {\n      const left = lineContent.charCodeAt(column - 2);\n      const right = lineContent.charCodeAt(column - 1);\n      if (left === 95 /* CharCode.Underline */ && right !== 95 /* CharCode.Underline */) {\n        // snake_case_variables\n        return new Position(lineNumber, column);\n      }\n      if (left === 45 /* CharCode.Dash */ && right !== 45 /* CharCode.Dash */) {\n        // kebab-case-variables\n        return new Position(lineNumber, column);\n      }\n      if ((strings.isLowerAsciiLetter(left) || strings.isAsciiDigit(left)) && strings.isUpperAsciiLetter(right)) {\n        // camelCaseVariables\n        return new Position(lineNumber, column);\n      }\n      if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n        // thisIsACamelCaseWithOneLetterWords\n        if (column + 1 < maxColumn) {\n          const rightRight = lineContent.charCodeAt(column);\n          if (strings.isLowerAsciiLetter(rightRight) || strings.isAsciiDigit(rightRight)) {\n            return new Position(lineNumber, column);\n          }\n        }\n      }\n    }\n    return new Position(lineNumber, 1);\n  }\n  static moveWordRight(wordSeparators, model, position, wordNavigationType) {\n    let lineNumber = position.lineNumber;\n    let column = position.column;\n    let movedDown = false;\n    if (column === model.getLineMaxColumn(lineNumber)) {\n      if (lineNumber < model.getLineCount()) {\n        movedDown = true;\n        lineNumber = lineNumber + 1;\n        column = 1;\n      }\n    }\n    let nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n    if (wordNavigationType === 2 /* WordNavigationType.WordEnd */) {\n      if (nextWordOnLine && nextWordOnLine.wordType === 2 /* WordType.Separator */) {\n        if (nextWordOnLine.end - nextWordOnLine.start === 1 && nextWordOnLine.nextCharClass === 0 /* WordCharacterClass.Regular */) {\n          // Skip over a word made up of one single separator and followed by a regular character\n          nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n        }\n      }\n      if (nextWordOnLine) {\n        column = nextWordOnLine.end + 1;\n      } else {\n        column = model.getLineMaxColumn(lineNumber);\n      }\n    } else if (wordNavigationType === 3 /* WordNavigationType.WordAccessibility */) {\n      if (movedDown) {\n        // If we move to the next line, pretend that the cursor is right before the first character.\n        // This is needed when the first word starts right at the first character - and in order not to miss it,\n        // we need to start before.\n        column = 0;\n      }\n      while (nextWordOnLine && (nextWordOnLine.wordType === 2 /* WordType.Separator */ || nextWordOnLine.start + 1 <= column)) {\n        // Skip over a word made up of one single separator\n        // Also skip over word if it begins before current cursor position to ascertain we're moving forward at least 1 character.\n        nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n      }\n      if (nextWordOnLine) {\n        column = nextWordOnLine.start + 1;\n      } else {\n        column = model.getLineMaxColumn(lineNumber);\n      }\n    } else {\n      if (nextWordOnLine && !movedDown && column >= nextWordOnLine.start + 1) {\n        nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n      }\n      if (nextWordOnLine) {\n        column = nextWordOnLine.start + 1;\n      } else {\n        column = model.getLineMaxColumn(lineNumber);\n      }\n    }\n    return new Position(lineNumber, column);\n  }\n  static _moveWordPartRight(model, position) {\n    const lineNumber = position.lineNumber;\n    const maxColumn = model.getLineMaxColumn(lineNumber);\n    if (position.column === maxColumn) {\n      return lineNumber < model.getLineCount() ? new Position(lineNumber + 1, 1) : position;\n    }\n    const lineContent = model.getLineContent(lineNumber);\n    for (let column = position.column + 1; column < maxColumn; column++) {\n      const left = lineContent.charCodeAt(column - 2);\n      const right = lineContent.charCodeAt(column - 1);\n      if (left !== 95 /* CharCode.Underline */ && right === 95 /* CharCode.Underline */) {\n        // snake_case_variables\n        return new Position(lineNumber, column);\n      }\n      if (left !== 45 /* CharCode.Dash */ && right === 45 /* CharCode.Dash */) {\n        // kebab-case-variables\n        return new Position(lineNumber, column);\n      }\n      if ((strings.isLowerAsciiLetter(left) || strings.isAsciiDigit(left)) && strings.isUpperAsciiLetter(right)) {\n        // camelCaseVariables\n        return new Position(lineNumber, column);\n      }\n      if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n        // thisIsACamelCaseWithOneLetterWords\n        if (column + 1 < maxColumn) {\n          const rightRight = lineContent.charCodeAt(column);\n          if (strings.isLowerAsciiLetter(rightRight) || strings.isAsciiDigit(rightRight)) {\n            return new Position(lineNumber, column);\n          }\n        }\n      }\n    }\n    return new Position(lineNumber, maxColumn);\n  }\n  static _deleteWordLeftWhitespace(model, position) {\n    const lineContent = model.getLineContent(position.lineNumber);\n    const startIndex = position.column - 2;\n    const lastNonWhitespace = strings.lastNonWhitespaceIndex(lineContent, startIndex);\n    if (lastNonWhitespace + 1 < startIndex) {\n      return new Range(position.lineNumber, lastNonWhitespace + 2, position.lineNumber, position.column);\n    }\n    return null;\n  }\n  static deleteWordLeft(ctx, wordNavigationType) {\n    const wordSeparators = ctx.wordSeparators;\n    const model = ctx.model;\n    const selection = ctx.selection;\n    const whitespaceHeuristics = ctx.whitespaceHeuristics;\n    if (!selection.isEmpty()) {\n      return selection;\n    }\n    if (DeleteOperations.isAutoClosingPairDelete(ctx.autoClosingDelete, ctx.autoClosingBrackets, ctx.autoClosingQuotes, ctx.autoClosingPairs.autoClosingPairsOpenByEnd, ctx.model, [ctx.selection], ctx.autoClosedCharacters)) {\n      const position = ctx.selection.getPosition();\n      return new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);\n    }\n    const position = new Position(selection.positionLineNumber, selection.positionColumn);\n    let lineNumber = position.lineNumber;\n    let column = position.column;\n    if (lineNumber === 1 && column === 1) {\n      // Ignore deleting at beginning of file\n      return null;\n    }\n    if (whitespaceHeuristics) {\n      const r = this._deleteWordLeftWhitespace(model, position);\n      if (r) {\n        return r;\n      }\n    }\n    let prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n    if (wordNavigationType === 0 /* WordNavigationType.WordStart */) {\n      if (prevWordOnLine) {\n        column = prevWordOnLine.start + 1;\n      } else {\n        if (column > 1) {\n          column = 1;\n        } else {\n          lineNumber--;\n          column = model.getLineMaxColumn(lineNumber);\n        }\n      }\n    } else {\n      if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n        prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n      }\n      if (prevWordOnLine) {\n        column = prevWordOnLine.end + 1;\n      } else {\n        if (column > 1) {\n          column = 1;\n        } else {\n          lineNumber--;\n          column = model.getLineMaxColumn(lineNumber);\n        }\n      }\n    }\n    return new Range(lineNumber, column, position.lineNumber, position.column);\n  }\n  static deleteInsideWord(wordSeparators, model, selection) {\n    if (!selection.isEmpty()) {\n      return selection;\n    }\n    const position = new Position(selection.positionLineNumber, selection.positionColumn);\n    const r = this._deleteInsideWordWhitespace(model, position);\n    if (r) {\n      return r;\n    }\n    return this._deleteInsideWordDetermineDeleteRange(wordSeparators, model, position);\n  }\n  static _charAtIsWhitespace(str, index) {\n    const charCode = str.charCodeAt(index);\n    return charCode === 32 /* CharCode.Space */ || charCode === 9 /* CharCode.Tab */;\n  }\n  static _deleteInsideWordWhitespace(model, position) {\n    const lineContent = model.getLineContent(position.lineNumber);\n    const lineContentLength = lineContent.length;\n    if (lineContentLength === 0) {\n      // empty line\n      return null;\n    }\n    let leftIndex = Math.max(position.column - 2, 0);\n    if (!this._charAtIsWhitespace(lineContent, leftIndex)) {\n      // touches a non-whitespace character to the left\n      return null;\n    }\n    let rightIndex = Math.min(position.column - 1, lineContentLength - 1);\n    if (!this._charAtIsWhitespace(lineContent, rightIndex)) {\n      // touches a non-whitespace character to the right\n      return null;\n    }\n    // walk over whitespace to the left\n    while (leftIndex > 0 && this._charAtIsWhitespace(lineContent, leftIndex - 1)) {\n      leftIndex--;\n    }\n    // walk over whitespace to the right\n    while (rightIndex + 1 < lineContentLength && this._charAtIsWhitespace(lineContent, rightIndex + 1)) {\n      rightIndex++;\n    }\n    return new Range(position.lineNumber, leftIndex + 1, position.lineNumber, rightIndex + 2);\n  }\n  static _deleteInsideWordDetermineDeleteRange(wordSeparators, model, position) {\n    const lineContent = model.getLineContent(position.lineNumber);\n    const lineLength = lineContent.length;\n    if (lineLength === 0) {\n      // empty line\n      if (position.lineNumber > 1) {\n        return new Range(position.lineNumber - 1, model.getLineMaxColumn(position.lineNumber - 1), position.lineNumber, 1);\n      } else {\n        if (position.lineNumber < model.getLineCount()) {\n          return new Range(position.lineNumber, 1, position.lineNumber + 1, 1);\n        } else {\n          // empty model\n          return new Range(position.lineNumber, 1, position.lineNumber, 1);\n        }\n      }\n    }\n    const touchesWord = word => {\n      return word.start + 1 <= position.column && position.column <= word.end + 1;\n    };\n    const createRangeWithPosition = (startColumn, endColumn) => {\n      startColumn = Math.min(startColumn, position.column);\n      endColumn = Math.max(endColumn, position.column);\n      return new Range(position.lineNumber, startColumn, position.lineNumber, endColumn);\n    };\n    const deleteWordAndAdjacentWhitespace = word => {\n      let startColumn = word.start + 1;\n      let endColumn = word.end + 1;\n      let expandedToTheRight = false;\n      while (endColumn - 1 < lineLength && this._charAtIsWhitespace(lineContent, endColumn - 1)) {\n        expandedToTheRight = true;\n        endColumn++;\n      }\n      if (!expandedToTheRight) {\n        while (startColumn > 1 && this._charAtIsWhitespace(lineContent, startColumn - 2)) {\n          startColumn--;\n        }\n      }\n      return createRangeWithPosition(startColumn, endColumn);\n    };\n    const prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n    if (prevWordOnLine && touchesWord(prevWordOnLine)) {\n      return deleteWordAndAdjacentWhitespace(prevWordOnLine);\n    }\n    const nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n    if (nextWordOnLine && touchesWord(nextWordOnLine)) {\n      return deleteWordAndAdjacentWhitespace(nextWordOnLine);\n    }\n    if (prevWordOnLine && nextWordOnLine) {\n      return createRangeWithPosition(prevWordOnLine.end + 1, nextWordOnLine.start + 1);\n    }\n    if (prevWordOnLine) {\n      return createRangeWithPosition(prevWordOnLine.start + 1, prevWordOnLine.end + 1);\n    }\n    if (nextWordOnLine) {\n      return createRangeWithPosition(nextWordOnLine.start + 1, nextWordOnLine.end + 1);\n    }\n    return createRangeWithPosition(1, lineLength + 1);\n  }\n  static _deleteWordPartLeft(model, selection) {\n    if (!selection.isEmpty()) {\n      return selection;\n    }\n    const pos = selection.getPosition();\n    const toPosition = WordOperations._moveWordPartLeft(model, pos);\n    return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n  }\n  static _findFirstNonWhitespaceChar(str, startIndex) {\n    const len = str.length;\n    for (let chIndex = startIndex; chIndex < len; chIndex++) {\n      const ch = str.charAt(chIndex);\n      if (ch !== ' ' && ch !== '\\t') {\n        return chIndex;\n      }\n    }\n    return len;\n  }\n  static _deleteWordRightWhitespace(model, position) {\n    const lineContent = model.getLineContent(position.lineNumber);\n    const startIndex = position.column - 1;\n    const firstNonWhitespace = this._findFirstNonWhitespaceChar(lineContent, startIndex);\n    if (startIndex + 1 < firstNonWhitespace) {\n      // bingo\n      return new Range(position.lineNumber, position.column, position.lineNumber, firstNonWhitespace + 1);\n    }\n    return null;\n  }\n  static deleteWordRight(ctx, wordNavigationType) {\n    const wordSeparators = ctx.wordSeparators;\n    const model = ctx.model;\n    const selection = ctx.selection;\n    const whitespaceHeuristics = ctx.whitespaceHeuristics;\n    if (!selection.isEmpty()) {\n      return selection;\n    }\n    const position = new Position(selection.positionLineNumber, selection.positionColumn);\n    let lineNumber = position.lineNumber;\n    let column = position.column;\n    const lineCount = model.getLineCount();\n    const maxColumn = model.getLineMaxColumn(lineNumber);\n    if (lineNumber === lineCount && column === maxColumn) {\n      // Ignore deleting at end of file\n      return null;\n    }\n    if (whitespaceHeuristics) {\n      const r = this._deleteWordRightWhitespace(model, position);\n      if (r) {\n        return r;\n      }\n    }\n    let nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n    if (wordNavigationType === 2 /* WordNavigationType.WordEnd */) {\n      if (nextWordOnLine) {\n        column = nextWordOnLine.end + 1;\n      } else {\n        if (column < maxColumn || lineNumber === lineCount) {\n          column = maxColumn;\n        } else {\n          lineNumber++;\n          nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n          if (nextWordOnLine) {\n            column = nextWordOnLine.start + 1;\n          } else {\n            column = model.getLineMaxColumn(lineNumber);\n          }\n        }\n      }\n    } else {\n      if (nextWordOnLine && column >= nextWordOnLine.start + 1) {\n        nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n      }\n      if (nextWordOnLine) {\n        column = nextWordOnLine.start + 1;\n      } else {\n        if (column < maxColumn || lineNumber === lineCount) {\n          column = maxColumn;\n        } else {\n          lineNumber++;\n          nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n          if (nextWordOnLine) {\n            column = nextWordOnLine.start + 1;\n          } else {\n            column = model.getLineMaxColumn(lineNumber);\n          }\n        }\n      }\n    }\n    return new Range(lineNumber, column, position.lineNumber, position.column);\n  }\n  static _deleteWordPartRight(model, selection) {\n    if (!selection.isEmpty()) {\n      return selection;\n    }\n    const pos = selection.getPosition();\n    const toPosition = WordOperations._moveWordPartRight(model, pos);\n    return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n  }\n  static _createWordAtPosition(model, lineNumber, word) {\n    const range = new Range(lineNumber, word.start + 1, lineNumber, word.end + 1);\n    return {\n      word: model.getValueInRange(range),\n      startColumn: range.startColumn,\n      endColumn: range.endColumn\n    };\n  }\n  static getWordAtPosition(model, _wordSeparators, _intlSegmenterLocales, position) {\n    const wordSeparators = getMapForWordSeparators(_wordSeparators, _intlSegmenterLocales);\n    const prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n    if (prevWord && prevWord.wordType === 1 /* WordType.Regular */ && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n      return WordOperations._createWordAtPosition(model, position.lineNumber, prevWord);\n    }\n    const nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n    if (nextWord && nextWord.wordType === 1 /* WordType.Regular */ && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n      return WordOperations._createWordAtPosition(model, position.lineNumber, nextWord);\n    }\n    return null;\n  }\n  static word(config, model, cursor, inSelectionMode, position) {\n    const wordSeparators = getMapForWordSeparators(config.wordSeparators, config.wordSegmenterLocales);\n    const prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n    const nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n    if (!inSelectionMode) {\n      // Entering word selection for the first time\n      let startColumn;\n      let endColumn;\n      if (prevWord && prevWord.wordType === 1 /* WordType.Regular */ && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n        // isTouchingPrevWord\n        startColumn = prevWord.start + 1;\n        endColumn = prevWord.end + 1;\n      } else if (nextWord && nextWord.wordType === 1 /* WordType.Regular */ && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n        // isTouchingNextWord\n        startColumn = nextWord.start + 1;\n        endColumn = nextWord.end + 1;\n      } else {\n        if (prevWord) {\n          startColumn = prevWord.end + 1;\n        } else {\n          startColumn = 1;\n        }\n        if (nextWord) {\n          endColumn = nextWord.start + 1;\n        } else {\n          endColumn = model.getLineMaxColumn(position.lineNumber);\n        }\n      }\n      return new SingleCursorState(new Range(position.lineNumber, startColumn, position.lineNumber, endColumn), 1 /* SelectionStartKind.Word */, 0, new Position(position.lineNumber, endColumn), 0);\n    }\n    let startColumn;\n    let endColumn;\n    if (prevWord && prevWord.wordType === 1 /* WordType.Regular */ && prevWord.start < position.column - 1 && position.column - 1 < prevWord.end) {\n      // isInsidePrevWord\n      startColumn = prevWord.start + 1;\n      endColumn = prevWord.end + 1;\n    } else if (nextWord && nextWord.wordType === 1 /* WordType.Regular */ && nextWord.start < position.column - 1 && position.column - 1 < nextWord.end) {\n      // isInsideNextWord\n      startColumn = nextWord.start + 1;\n      endColumn = nextWord.end + 1;\n    } else {\n      startColumn = position.column;\n      endColumn = position.column;\n    }\n    const lineNumber = position.lineNumber;\n    let column;\n    if (cursor.selectionStart.containsPosition(position)) {\n      column = cursor.selectionStart.endColumn;\n    } else if (position.isBeforeOrEqual(cursor.selectionStart.getStartPosition())) {\n      column = startColumn;\n      const possiblePosition = new Position(lineNumber, column);\n      if (cursor.selectionStart.containsPosition(possiblePosition)) {\n        column = cursor.selectionStart.endColumn;\n      }\n    } else {\n      column = endColumn;\n      const possiblePosition = new Position(lineNumber, column);\n      if (cursor.selectionStart.containsPosition(possiblePosition)) {\n        column = cursor.selectionStart.startColumn;\n      }\n    }\n    return cursor.move(true, lineNumber, column, 0);\n  }\n}\nexport class WordPartOperations extends WordOperations {\n  static deleteWordPartLeft(ctx) {\n    const candidates = enforceDefined([WordOperations.deleteWordLeft(ctx, 0 /* WordNavigationType.WordStart */), WordOperations.deleteWordLeft(ctx, 2 /* WordNavigationType.WordEnd */), WordOperations._deleteWordPartLeft(ctx.model, ctx.selection)]);\n    candidates.sort(Range.compareRangesUsingEnds);\n    return candidates[2];\n  }\n  static deleteWordPartRight(ctx) {\n    const candidates = enforceDefined([WordOperations.deleteWordRight(ctx, 0 /* WordNavigationType.WordStart */), WordOperations.deleteWordRight(ctx, 2 /* WordNavigationType.WordEnd */), WordOperations._deleteWordPartRight(ctx.model, ctx.selection)]);\n    candidates.sort(Range.compareRangesUsingStarts);\n    return candidates[0];\n  }\n  static moveWordPartLeft(wordSeparators, model, position) {\n    const candidates = enforceDefined([WordOperations.moveWordLeft(wordSeparators, model, position, 0 /* WordNavigationType.WordStart */), WordOperations.moveWordLeft(wordSeparators, model, position, 2 /* WordNavigationType.WordEnd */), WordOperations._moveWordPartLeft(model, position)]);\n    candidates.sort(Position.compare);\n    return candidates[2];\n  }\n  static moveWordPartRight(wordSeparators, model, position) {\n    const candidates = enforceDefined([WordOperations.moveWordRight(wordSeparators, model, position, 0 /* WordNavigationType.WordStart */), WordOperations.moveWordRight(wordSeparators, model, position, 2 /* WordNavigationType.WordEnd */), WordOperations._moveWordPartRight(model, position)]);\n    candidates.sort(Position.compare);\n    return candidates[0];\n  }\n}\nfunction enforceDefined(arr) {\n  return arr.filter(el => Boolean(el));\n}","map":{"version":3,"names":["strings","SingleCursorState","DeleteOperations","getMapForWordSeparators","Position","Range","WordOperations","_createWord","lineContent","wordType","nextCharClass","start","end","_createIntlWord","intlWord","index","segment","length","_findPreviousWordOnLine","wordSeparators","model","position","getLineContent","lineNumber","_doFindPreviousWordOnLine","previousIntlWord","findPrevIntlWordBeforeOrAtOffset","column","chIndex","chCode","charCodeAt","chClass","get","_findEndOfWord","startIndex","nextIntlWord","findNextIntlWordAtOrAfterOffset","len","_findNextWordOnLine","_doFindNextWordOnLine","_findStartOfWord","moveWordLeft","wordNavigationType","getLineMaxColumn","prevWordOnLine","_moveWordPartLeft","maxColumn","left","right","isLowerAsciiLetter","isAsciiDigit","isUpperAsciiLetter","rightRight","moveWordRight","movedDown","getLineCount","nextWordOnLine","_moveWordPartRight","_deleteWordLeftWhitespace","lastNonWhitespace","lastNonWhitespaceIndex","deleteWordLeft","ctx","selection","whitespaceHeuristics","isEmpty","isAutoClosingPairDelete","autoClosingDelete","autoClosingBrackets","autoClosingQuotes","autoClosingPairs","autoClosingPairsOpenByEnd","autoClosedCharacters","getPosition","positionLineNumber","positionColumn","r","deleteInsideWord","_deleteInsideWordWhitespace","_deleteInsideWordDetermineDeleteRange","_charAtIsWhitespace","str","charCode","lineContentLength","leftIndex","Math","max","rightIndex","min","lineLength","touchesWord","word","createRangeWithPosition","startColumn","endColumn","deleteWordAndAdjacentWhitespace","expandedToTheRight","_deleteWordPartLeft","pos","toPosition","_findFirstNonWhitespaceChar","ch","charAt","_deleteWordRightWhitespace","firstNonWhitespace","deleteWordRight","lineCount","_deleteWordPartRight","_createWordAtPosition","range","getValueInRange","getWordAtPosition","_wordSeparators","_intlSegmenterLocales","prevWord","nextWord","config","cursor","inSelectionMode","wordSegmenterLocales","selectionStart","containsPosition","isBeforeOrEqual","getStartPosition","possiblePosition","move","WordPartOperations","deleteWordPartLeft","candidates","enforceDefined","sort","compareRangesUsingEnds","deleteWordPartRight","compareRangesUsingStarts","moveWordPartLeft","compare","moveWordPartRight","arr","filter","el","Boolean"],"sources":["/home/arslan/modojo/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorWordOperations.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { SingleCursorState } from '../cursorCommon.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport class WordOperations {\n    static _createWord(lineContent, wordType, nextCharClass, start, end) {\n        // console.log('WORD ==> ' + start + ' => ' + end + ':::: <<<' + lineContent.substring(start, end) + '>>>');\n        return { start: start, end: end, wordType: wordType, nextCharClass: nextCharClass };\n    }\n    static _createIntlWord(intlWord, nextCharClass) {\n        // console.log('INTL WORD ==> ' + intlWord.index + ' => ' + intlWord.index + intlWord.segment.length + ':::: <<<' + intlWord.segment + '>>>');\n        return { start: intlWord.index, end: intlWord.index + intlWord.segment.length, wordType: 1 /* WordType.Regular */, nextCharClass: nextCharClass };\n    }\n    static _findPreviousWordOnLine(wordSeparators, model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        return this._doFindPreviousWordOnLine(lineContent, wordSeparators, position);\n    }\n    static _doFindPreviousWordOnLine(lineContent, wordSeparators, position) {\n        let wordType = 0 /* WordType.None */;\n        const previousIntlWord = wordSeparators.findPrevIntlWordBeforeOrAtOffset(lineContent, position.column - 2);\n        for (let chIndex = position.column - 2; chIndex >= 0; chIndex--) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (previousIntlWord && chIndex === previousIntlWord.index) {\n                return this._createIntlWord(previousIntlWord, chClass);\n            }\n            if (chClass === 0 /* WordCharacterClass.Regular */) {\n                if (wordType === 2 /* WordType.Separator */) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n                wordType = 1 /* WordType.Regular */;\n            }\n            else if (chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                if (wordType === 1 /* WordType.Regular */) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n                wordType = 2 /* WordType.Separator */;\n            }\n            else if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                if (wordType !== 0 /* WordType.None */) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n            }\n        }\n        if (wordType !== 0 /* WordType.None */) {\n            return this._createWord(lineContent, wordType, 1 /* WordCharacterClass.Whitespace */, 0, this._findEndOfWord(lineContent, wordSeparators, wordType, 0));\n        }\n        return null;\n    }\n    static _findEndOfWord(lineContent, wordSeparators, wordType, startIndex) {\n        const nextIntlWord = wordSeparators.findNextIntlWordAtOrAfterOffset(lineContent, startIndex);\n        const len = lineContent.length;\n        for (let chIndex = startIndex; chIndex < len; chIndex++) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (nextIntlWord && chIndex === nextIntlWord.index + nextIntlWord.segment.length) {\n                return chIndex;\n            }\n            if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                return chIndex;\n            }\n            if (wordType === 1 /* WordType.Regular */ && chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                return chIndex;\n            }\n            if (wordType === 2 /* WordType.Separator */ && chClass === 0 /* WordCharacterClass.Regular */) {\n                return chIndex;\n            }\n        }\n        return len;\n    }\n    static _findNextWordOnLine(wordSeparators, model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        return this._doFindNextWordOnLine(lineContent, wordSeparators, position);\n    }\n    static _doFindNextWordOnLine(lineContent, wordSeparators, position) {\n        let wordType = 0 /* WordType.None */;\n        const len = lineContent.length;\n        const nextIntlWord = wordSeparators.findNextIntlWordAtOrAfterOffset(lineContent, position.column - 1);\n        for (let chIndex = position.column - 1; chIndex < len; chIndex++) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (nextIntlWord && chIndex === nextIntlWord.index) {\n                return this._createIntlWord(nextIntlWord, chClass);\n            }\n            if (chClass === 0 /* WordCharacterClass.Regular */) {\n                if (wordType === 2 /* WordType.Separator */) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n                wordType = 1 /* WordType.Regular */;\n            }\n            else if (chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                if (wordType === 1 /* WordType.Regular */) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n                wordType = 2 /* WordType.Separator */;\n            }\n            else if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                if (wordType !== 0 /* WordType.None */) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n            }\n        }\n        if (wordType !== 0 /* WordType.None */) {\n            return this._createWord(lineContent, wordType, 1 /* WordCharacterClass.Whitespace */, this._findStartOfWord(lineContent, wordSeparators, wordType, len - 1), len);\n        }\n        return null;\n    }\n    static _findStartOfWord(lineContent, wordSeparators, wordType, startIndex) {\n        const previousIntlWord = wordSeparators.findPrevIntlWordBeforeOrAtOffset(lineContent, startIndex);\n        for (let chIndex = startIndex; chIndex >= 0; chIndex--) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (previousIntlWord && chIndex === previousIntlWord.index) {\n                return chIndex;\n            }\n            if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                return chIndex + 1;\n            }\n            if (wordType === 1 /* WordType.Regular */ && chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                return chIndex + 1;\n            }\n            if (wordType === 2 /* WordType.Separator */ && chClass === 0 /* WordCharacterClass.Regular */) {\n                return chIndex + 1;\n            }\n        }\n        return 0;\n    }\n    static moveWordLeft(wordSeparators, model, position, wordNavigationType) {\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        if (column === 1) {\n            if (lineNumber > 1) {\n                lineNumber = lineNumber - 1;\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        let prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n        if (wordNavigationType === 0 /* WordNavigationType.WordStart */) {\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n        if (wordNavigationType === 1 /* WordNavigationType.WordStartFast */) {\n            if (prevWordOnLine\n                && prevWordOnLine.wordType === 2 /* WordType.Separator */\n                && prevWordOnLine.end - prevWordOnLine.start === 1\n                && prevWordOnLine.nextCharClass === 0 /* WordCharacterClass.Regular */) {\n                // Skip over a word made up of one single separator and followed by a regular character\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n        if (wordNavigationType === 3 /* WordNavigationType.WordAccessibility */) {\n            while (prevWordOnLine\n                && prevWordOnLine.wordType === 2 /* WordType.Separator */) {\n                // Skip over words made up of only separators\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n        // We are stopping at the ending of words\n        if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n            prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n        }\n        return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.end + 1 : 1);\n    }\n    static _moveWordPartLeft(model, position) {\n        const lineNumber = position.lineNumber;\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (position.column === 1) {\n            return (lineNumber > 1 ? new Position(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)) : position);\n        }\n        const lineContent = model.getLineContent(lineNumber);\n        for (let column = position.column - 1; column > 1; column--) {\n            const left = lineContent.charCodeAt(column - 2);\n            const right = lineContent.charCodeAt(column - 1);\n            if (left === 95 /* CharCode.Underline */ && right !== 95 /* CharCode.Underline */) {\n                // snake_case_variables\n                return new Position(lineNumber, column);\n            }\n            if (left === 45 /* CharCode.Dash */ && right !== 45 /* CharCode.Dash */) {\n                // kebab-case-variables\n                return new Position(lineNumber, column);\n            }\n            if ((strings.isLowerAsciiLetter(left) || strings.isAsciiDigit(left)) && strings.isUpperAsciiLetter(right)) {\n                // camelCaseVariables\n                return new Position(lineNumber, column);\n            }\n            if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n                // thisIsACamelCaseWithOneLetterWords\n                if (column + 1 < maxColumn) {\n                    const rightRight = lineContent.charCodeAt(column);\n                    if (strings.isLowerAsciiLetter(rightRight) || strings.isAsciiDigit(rightRight)) {\n                        return new Position(lineNumber, column);\n                    }\n                }\n            }\n        }\n        return new Position(lineNumber, 1);\n    }\n    static moveWordRight(wordSeparators, model, position, wordNavigationType) {\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        let movedDown = false;\n        if (column === model.getLineMaxColumn(lineNumber)) {\n            if (lineNumber < model.getLineCount()) {\n                movedDown = true;\n                lineNumber = lineNumber + 1;\n                column = 1;\n            }\n        }\n        let nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n        if (wordNavigationType === 2 /* WordNavigationType.WordEnd */) {\n            if (nextWordOnLine && nextWordOnLine.wordType === 2 /* WordType.Separator */) {\n                if (nextWordOnLine.end - nextWordOnLine.start === 1 && nextWordOnLine.nextCharClass === 0 /* WordCharacterClass.Regular */) {\n                    // Skip over a word made up of one single separator and followed by a regular character\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n                }\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.end + 1;\n            }\n            else {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        else if (wordNavigationType === 3 /* WordNavigationType.WordAccessibility */) {\n            if (movedDown) {\n                // If we move to the next line, pretend that the cursor is right before the first character.\n                // This is needed when the first word starts right at the first character - and in order not to miss it,\n                // we need to start before.\n                column = 0;\n            }\n            while (nextWordOnLine\n                && (nextWordOnLine.wordType === 2 /* WordType.Separator */\n                    || nextWordOnLine.start + 1 <= column)) {\n                // Skip over a word made up of one single separator\n                // Also skip over word if it begins before current cursor position to ascertain we're moving forward at least 1 character.\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n            }\n            else {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        else {\n            if (nextWordOnLine && !movedDown && column >= nextWordOnLine.start + 1) {\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n            }\n            else {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        return new Position(lineNumber, column);\n    }\n    static _moveWordPartRight(model, position) {\n        const lineNumber = position.lineNumber;\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (position.column === maxColumn) {\n            return (lineNumber < model.getLineCount() ? new Position(lineNumber + 1, 1) : position);\n        }\n        const lineContent = model.getLineContent(lineNumber);\n        for (let column = position.column + 1; column < maxColumn; column++) {\n            const left = lineContent.charCodeAt(column - 2);\n            const right = lineContent.charCodeAt(column - 1);\n            if (left !== 95 /* CharCode.Underline */ && right === 95 /* CharCode.Underline */) {\n                // snake_case_variables\n                return new Position(lineNumber, column);\n            }\n            if (left !== 45 /* CharCode.Dash */ && right === 45 /* CharCode.Dash */) {\n                // kebab-case-variables\n                return new Position(lineNumber, column);\n            }\n            if ((strings.isLowerAsciiLetter(left) || strings.isAsciiDigit(left)) && strings.isUpperAsciiLetter(right)) {\n                // camelCaseVariables\n                return new Position(lineNumber, column);\n            }\n            if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n                // thisIsACamelCaseWithOneLetterWords\n                if (column + 1 < maxColumn) {\n                    const rightRight = lineContent.charCodeAt(column);\n                    if (strings.isLowerAsciiLetter(rightRight) || strings.isAsciiDigit(rightRight)) {\n                        return new Position(lineNumber, column);\n                    }\n                }\n            }\n        }\n        return new Position(lineNumber, maxColumn);\n    }\n    static _deleteWordLeftWhitespace(model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const startIndex = position.column - 2;\n        const lastNonWhitespace = strings.lastNonWhitespaceIndex(lineContent, startIndex);\n        if (lastNonWhitespace + 1 < startIndex) {\n            return new Range(position.lineNumber, lastNonWhitespace + 2, position.lineNumber, position.column);\n        }\n        return null;\n    }\n    static deleteWordLeft(ctx, wordNavigationType) {\n        const wordSeparators = ctx.wordSeparators;\n        const model = ctx.model;\n        const selection = ctx.selection;\n        const whitespaceHeuristics = ctx.whitespaceHeuristics;\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        if (DeleteOperations.isAutoClosingPairDelete(ctx.autoClosingDelete, ctx.autoClosingBrackets, ctx.autoClosingQuotes, ctx.autoClosingPairs.autoClosingPairsOpenByEnd, ctx.model, [ctx.selection], ctx.autoClosedCharacters)) {\n            const position = ctx.selection.getPosition();\n            return new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);\n        }\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        if (lineNumber === 1 && column === 1) {\n            // Ignore deleting at beginning of file\n            return null;\n        }\n        if (whitespaceHeuristics) {\n            const r = this._deleteWordLeftWhitespace(model, position);\n            if (r) {\n                return r;\n            }\n        }\n        let prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        if (wordNavigationType === 0 /* WordNavigationType.WordStart */) {\n            if (prevWordOnLine) {\n                column = prevWordOnLine.start + 1;\n            }\n            else {\n                if (column > 1) {\n                    column = 1;\n                }\n                else {\n                    lineNumber--;\n                    column = model.getLineMaxColumn(lineNumber);\n                }\n            }\n        }\n        else {\n            if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            if (prevWordOnLine) {\n                column = prevWordOnLine.end + 1;\n            }\n            else {\n                if (column > 1) {\n                    column = 1;\n                }\n                else {\n                    lineNumber--;\n                    column = model.getLineMaxColumn(lineNumber);\n                }\n            }\n        }\n        return new Range(lineNumber, column, position.lineNumber, position.column);\n    }\n    static deleteInsideWord(wordSeparators, model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\n        const r = this._deleteInsideWordWhitespace(model, position);\n        if (r) {\n            return r;\n        }\n        return this._deleteInsideWordDetermineDeleteRange(wordSeparators, model, position);\n    }\n    static _charAtIsWhitespace(str, index) {\n        const charCode = str.charCodeAt(index);\n        return (charCode === 32 /* CharCode.Space */ || charCode === 9 /* CharCode.Tab */);\n    }\n    static _deleteInsideWordWhitespace(model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const lineContentLength = lineContent.length;\n        if (lineContentLength === 0) {\n            // empty line\n            return null;\n        }\n        let leftIndex = Math.max(position.column - 2, 0);\n        if (!this._charAtIsWhitespace(lineContent, leftIndex)) {\n            // touches a non-whitespace character to the left\n            return null;\n        }\n        let rightIndex = Math.min(position.column - 1, lineContentLength - 1);\n        if (!this._charAtIsWhitespace(lineContent, rightIndex)) {\n            // touches a non-whitespace character to the right\n            return null;\n        }\n        // walk over whitespace to the left\n        while (leftIndex > 0 && this._charAtIsWhitespace(lineContent, leftIndex - 1)) {\n            leftIndex--;\n        }\n        // walk over whitespace to the right\n        while (rightIndex + 1 < lineContentLength && this._charAtIsWhitespace(lineContent, rightIndex + 1)) {\n            rightIndex++;\n        }\n        return new Range(position.lineNumber, leftIndex + 1, position.lineNumber, rightIndex + 2);\n    }\n    static _deleteInsideWordDetermineDeleteRange(wordSeparators, model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const lineLength = lineContent.length;\n        if (lineLength === 0) {\n            // empty line\n            if (position.lineNumber > 1) {\n                return new Range(position.lineNumber - 1, model.getLineMaxColumn(position.lineNumber - 1), position.lineNumber, 1);\n            }\n            else {\n                if (position.lineNumber < model.getLineCount()) {\n                    return new Range(position.lineNumber, 1, position.lineNumber + 1, 1);\n                }\n                else {\n                    // empty model\n                    return new Range(position.lineNumber, 1, position.lineNumber, 1);\n                }\n            }\n        }\n        const touchesWord = (word) => {\n            return (word.start + 1 <= position.column && position.column <= word.end + 1);\n        };\n        const createRangeWithPosition = (startColumn, endColumn) => {\n            startColumn = Math.min(startColumn, position.column);\n            endColumn = Math.max(endColumn, position.column);\n            return new Range(position.lineNumber, startColumn, position.lineNumber, endColumn);\n        };\n        const deleteWordAndAdjacentWhitespace = (word) => {\n            let startColumn = word.start + 1;\n            let endColumn = word.end + 1;\n            let expandedToTheRight = false;\n            while (endColumn - 1 < lineLength && this._charAtIsWhitespace(lineContent, endColumn - 1)) {\n                expandedToTheRight = true;\n                endColumn++;\n            }\n            if (!expandedToTheRight) {\n                while (startColumn > 1 && this._charAtIsWhitespace(lineContent, startColumn - 2)) {\n                    startColumn--;\n                }\n            }\n            return createRangeWithPosition(startColumn, endColumn);\n        };\n        const prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        if (prevWordOnLine && touchesWord(prevWordOnLine)) {\n            return deleteWordAndAdjacentWhitespace(prevWordOnLine);\n        }\n        const nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (nextWordOnLine && touchesWord(nextWordOnLine)) {\n            return deleteWordAndAdjacentWhitespace(nextWordOnLine);\n        }\n        if (prevWordOnLine && nextWordOnLine) {\n            return createRangeWithPosition(prevWordOnLine.end + 1, nextWordOnLine.start + 1);\n        }\n        if (prevWordOnLine) {\n            return createRangeWithPosition(prevWordOnLine.start + 1, prevWordOnLine.end + 1);\n        }\n        if (nextWordOnLine) {\n            return createRangeWithPosition(nextWordOnLine.start + 1, nextWordOnLine.end + 1);\n        }\n        return createRangeWithPosition(1, lineLength + 1);\n    }\n    static _deleteWordPartLeft(model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const pos = selection.getPosition();\n        const toPosition = WordOperations._moveWordPartLeft(model, pos);\n        return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n    }\n    static _findFirstNonWhitespaceChar(str, startIndex) {\n        const len = str.length;\n        for (let chIndex = startIndex; chIndex < len; chIndex++) {\n            const ch = str.charAt(chIndex);\n            if (ch !== ' ' && ch !== '\\t') {\n                return chIndex;\n            }\n        }\n        return len;\n    }\n    static _deleteWordRightWhitespace(model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const startIndex = position.column - 1;\n        const firstNonWhitespace = this._findFirstNonWhitespaceChar(lineContent, startIndex);\n        if (startIndex + 1 < firstNonWhitespace) {\n            // bingo\n            return new Range(position.lineNumber, position.column, position.lineNumber, firstNonWhitespace + 1);\n        }\n        return null;\n    }\n    static deleteWordRight(ctx, wordNavigationType) {\n        const wordSeparators = ctx.wordSeparators;\n        const model = ctx.model;\n        const selection = ctx.selection;\n        const whitespaceHeuristics = ctx.whitespaceHeuristics;\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        const lineCount = model.getLineCount();\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (lineNumber === lineCount && column === maxColumn) {\n            // Ignore deleting at end of file\n            return null;\n        }\n        if (whitespaceHeuristics) {\n            const r = this._deleteWordRightWhitespace(model, position);\n            if (r) {\n                return r;\n            }\n        }\n        let nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (wordNavigationType === 2 /* WordNavigationType.WordEnd */) {\n            if (nextWordOnLine) {\n                column = nextWordOnLine.end + 1;\n            }\n            else {\n                if (column < maxColumn || lineNumber === lineCount) {\n                    column = maxColumn;\n                }\n                else {\n                    lineNumber++;\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n                    if (nextWordOnLine) {\n                        column = nextWordOnLine.start + 1;\n                    }\n                    else {\n                        column = model.getLineMaxColumn(lineNumber);\n                    }\n                }\n            }\n        }\n        else {\n            if (nextWordOnLine && column >= nextWordOnLine.start + 1) {\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n            }\n            else {\n                if (column < maxColumn || lineNumber === lineCount) {\n                    column = maxColumn;\n                }\n                else {\n                    lineNumber++;\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n                    if (nextWordOnLine) {\n                        column = nextWordOnLine.start + 1;\n                    }\n                    else {\n                        column = model.getLineMaxColumn(lineNumber);\n                    }\n                }\n            }\n        }\n        return new Range(lineNumber, column, position.lineNumber, position.column);\n    }\n    static _deleteWordPartRight(model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const pos = selection.getPosition();\n        const toPosition = WordOperations._moveWordPartRight(model, pos);\n        return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n    }\n    static _createWordAtPosition(model, lineNumber, word) {\n        const range = new Range(lineNumber, word.start + 1, lineNumber, word.end + 1);\n        return {\n            word: model.getValueInRange(range),\n            startColumn: range.startColumn,\n            endColumn: range.endColumn\n        };\n    }\n    static getWordAtPosition(model, _wordSeparators, _intlSegmenterLocales, position) {\n        const wordSeparators = getMapForWordSeparators(_wordSeparators, _intlSegmenterLocales);\n        const prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        if (prevWord && prevWord.wordType === 1 /* WordType.Regular */ && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n            return WordOperations._createWordAtPosition(model, position.lineNumber, prevWord);\n        }\n        const nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (nextWord && nextWord.wordType === 1 /* WordType.Regular */ && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n            return WordOperations._createWordAtPosition(model, position.lineNumber, nextWord);\n        }\n        return null;\n    }\n    static word(config, model, cursor, inSelectionMode, position) {\n        const wordSeparators = getMapForWordSeparators(config.wordSeparators, config.wordSegmenterLocales);\n        const prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        const nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (!inSelectionMode) {\n            // Entering word selection for the first time\n            let startColumn;\n            let endColumn;\n            if (prevWord && prevWord.wordType === 1 /* WordType.Regular */ && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n                // isTouchingPrevWord\n                startColumn = prevWord.start + 1;\n                endColumn = prevWord.end + 1;\n            }\n            else if (nextWord && nextWord.wordType === 1 /* WordType.Regular */ && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n                // isTouchingNextWord\n                startColumn = nextWord.start + 1;\n                endColumn = nextWord.end + 1;\n            }\n            else {\n                if (prevWord) {\n                    startColumn = prevWord.end + 1;\n                }\n                else {\n                    startColumn = 1;\n                }\n                if (nextWord) {\n                    endColumn = nextWord.start + 1;\n                }\n                else {\n                    endColumn = model.getLineMaxColumn(position.lineNumber);\n                }\n            }\n            return new SingleCursorState(new Range(position.lineNumber, startColumn, position.lineNumber, endColumn), 1 /* SelectionStartKind.Word */, 0, new Position(position.lineNumber, endColumn), 0);\n        }\n        let startColumn;\n        let endColumn;\n        if (prevWord && prevWord.wordType === 1 /* WordType.Regular */ && prevWord.start < position.column - 1 && position.column - 1 < prevWord.end) {\n            // isInsidePrevWord\n            startColumn = prevWord.start + 1;\n            endColumn = prevWord.end + 1;\n        }\n        else if (nextWord && nextWord.wordType === 1 /* WordType.Regular */ && nextWord.start < position.column - 1 && position.column - 1 < nextWord.end) {\n            // isInsideNextWord\n            startColumn = nextWord.start + 1;\n            endColumn = nextWord.end + 1;\n        }\n        else {\n            startColumn = position.column;\n            endColumn = position.column;\n        }\n        const lineNumber = position.lineNumber;\n        let column;\n        if (cursor.selectionStart.containsPosition(position)) {\n            column = cursor.selectionStart.endColumn;\n        }\n        else if (position.isBeforeOrEqual(cursor.selectionStart.getStartPosition())) {\n            column = startColumn;\n            const possiblePosition = new Position(lineNumber, column);\n            if (cursor.selectionStart.containsPosition(possiblePosition)) {\n                column = cursor.selectionStart.endColumn;\n            }\n        }\n        else {\n            column = endColumn;\n            const possiblePosition = new Position(lineNumber, column);\n            if (cursor.selectionStart.containsPosition(possiblePosition)) {\n                column = cursor.selectionStart.startColumn;\n            }\n        }\n        return cursor.move(true, lineNumber, column, 0);\n    }\n}\nexport class WordPartOperations extends WordOperations {\n    static deleteWordPartLeft(ctx) {\n        const candidates = enforceDefined([\n            WordOperations.deleteWordLeft(ctx, 0 /* WordNavigationType.WordStart */),\n            WordOperations.deleteWordLeft(ctx, 2 /* WordNavigationType.WordEnd */),\n            WordOperations._deleteWordPartLeft(ctx.model, ctx.selection)\n        ]);\n        candidates.sort(Range.compareRangesUsingEnds);\n        return candidates[2];\n    }\n    static deleteWordPartRight(ctx) {\n        const candidates = enforceDefined([\n            WordOperations.deleteWordRight(ctx, 0 /* WordNavigationType.WordStart */),\n            WordOperations.deleteWordRight(ctx, 2 /* WordNavigationType.WordEnd */),\n            WordOperations._deleteWordPartRight(ctx.model, ctx.selection)\n        ]);\n        candidates.sort(Range.compareRangesUsingStarts);\n        return candidates[0];\n    }\n    static moveWordPartLeft(wordSeparators, model, position) {\n        const candidates = enforceDefined([\n            WordOperations.moveWordLeft(wordSeparators, model, position, 0 /* WordNavigationType.WordStart */),\n            WordOperations.moveWordLeft(wordSeparators, model, position, 2 /* WordNavigationType.WordEnd */),\n            WordOperations._moveWordPartLeft(model, position)\n        ]);\n        candidates.sort(Position.compare);\n        return candidates[2];\n    }\n    static moveWordPartRight(wordSeparators, model, position) {\n        const candidates = enforceDefined([\n            WordOperations.moveWordRight(wordSeparators, model, position, 0 /* WordNavigationType.WordStart */),\n            WordOperations.moveWordRight(wordSeparators, model, position, 2 /* WordNavigationType.WordEnd */),\n            WordOperations._moveWordPartRight(model, position)\n        ]);\n        candidates.sort(Position.compare);\n        return candidates[0];\n    }\n}\nfunction enforceDefined(arr) {\n    return arr.filter(el => Boolean(el));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}