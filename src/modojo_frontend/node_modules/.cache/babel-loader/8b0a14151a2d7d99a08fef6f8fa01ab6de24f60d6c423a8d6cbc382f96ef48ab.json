{"ast":null,"code":"import { decode, encode } from './utils/base32';\nimport { getCrc32 } from './utils/getCrc';\nimport { sha224 } from './utils/sha224';\nexport const JSON_KEY_PRINCIPAL = '__principal__';\nconst SELF_AUTHENTICATING_SUFFIX = 2;\nconst ANONYMOUS_SUFFIX = 4;\nconst MANAGEMENT_CANISTER_PRINCIPAL_HEX_STR = 'aaaaa-aa';\nconst fromHexString = hexString => {\n  var _a;\n  return new Uint8Array(((_a = hexString.match(/.{1,2}/g)) !== null && _a !== void 0 ? _a : []).map(byte => parseInt(byte, 16)));\n};\nconst toHexString = bytes => bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\nexport class Principal {\n  constructor(_arr) {\n    this._arr = _arr;\n    this._isPrincipal = true;\n  }\n  static anonymous() {\n    return new this(new Uint8Array([ANONYMOUS_SUFFIX]));\n  }\n  /**\n   * Utility method, returning the principal representing the management canister, decoded from the hex string `'aaaaa-aa'`\n   * @returns {Principal} principal of the management canister\n   */\n  static managementCanister() {\n    return this.fromHex(MANAGEMENT_CANISTER_PRINCIPAL_HEX_STR);\n  }\n  static selfAuthenticating(publicKey) {\n    const sha = sha224(publicKey);\n    return new this(new Uint8Array([...sha, SELF_AUTHENTICATING_SUFFIX]));\n  }\n  static from(other) {\n    if (typeof other === 'string') {\n      return Principal.fromText(other);\n    } else if (Object.getPrototypeOf(other) === Uint8Array.prototype) {\n      return new Principal(other);\n    } else if (typeof other === 'object' && other !== null && other._isPrincipal === true) {\n      return new Principal(other._arr);\n    }\n    throw new Error(`Impossible to convert ${JSON.stringify(other)} to Principal.`);\n  }\n  static fromHex(hex) {\n    return new this(fromHexString(hex));\n  }\n  static fromText(text) {\n    let maybePrincipal = text;\n    // If formatted as JSON string, parse it first\n    if (text.includes(JSON_KEY_PRINCIPAL)) {\n      const obj = JSON.parse(text);\n      if (JSON_KEY_PRINCIPAL in obj) {\n        maybePrincipal = obj[JSON_KEY_PRINCIPAL];\n      }\n    }\n    const canisterIdNoDash = maybePrincipal.toLowerCase().replace(/-/g, '');\n    let arr = decode(canisterIdNoDash);\n    arr = arr.slice(4, arr.length);\n    const principal = new this(arr);\n    if (principal.toText() !== maybePrincipal) {\n      throw new Error(`Principal \"${principal.toText()}\" does not have a valid checksum (original value \"${maybePrincipal}\" may not be a valid Principal ID).`);\n    }\n    return principal;\n  }\n  static fromUint8Array(arr) {\n    return new this(arr);\n  }\n  isAnonymous() {\n    return this._arr.byteLength === 1 && this._arr[0] === ANONYMOUS_SUFFIX;\n  }\n  toUint8Array() {\n    return this._arr;\n  }\n  toHex() {\n    return toHexString(this._arr).toUpperCase();\n  }\n  toText() {\n    const checksumArrayBuf = new ArrayBuffer(4);\n    const view = new DataView(checksumArrayBuf);\n    view.setUint32(0, getCrc32(this._arr));\n    const checksum = new Uint8Array(checksumArrayBuf);\n    const bytes = Uint8Array.from(this._arr);\n    const array = new Uint8Array([...checksum, ...bytes]);\n    const result = encode(array);\n    const matches = result.match(/.{1,5}/g);\n    if (!matches) {\n      // This should only happen if there's no character, which is unreachable.\n      throw new Error();\n    }\n    return matches.join('-');\n  }\n  toString() {\n    return this.toText();\n  }\n  /**\n   * Serializes to JSON\n   * @returns {JsonnablePrincipal} a JSON object with a single key, {@link JSON_KEY_PRINCIPAL}, whose value is the principal as a string\n   */\n  toJSON() {\n    return {\n      [JSON_KEY_PRINCIPAL]: this.toText()\n    };\n  }\n  /**\n   * Utility method taking a Principal to compare against. Used for determining canister ranges in certificate verification\n   * @param {Principal} other - a {@link Principal} to compare\n   * @returns {'lt' | 'eq' | 'gt'} `'lt' | 'eq' | 'gt'` a string, representing less than, equal to, or greater than\n   */\n  compareTo(other) {\n    for (let i = 0; i < Math.min(this._arr.length, other._arr.length); i++) {\n      if (this._arr[i] < other._arr[i]) return 'lt';else if (this._arr[i] > other._arr[i]) return 'gt';\n    }\n    // Here, at least one principal is a prefix of the other principal (they could be the same)\n    if (this._arr.length < other._arr.length) return 'lt';\n    if (this._arr.length > other._arr.length) return 'gt';\n    return 'eq';\n  }\n  /**\n   * Utility method checking whether a provided Principal is less than or equal to the current one using the {@link Principal.compareTo} method\n   * @param other a {@link Principal} to compare\n   * @returns {boolean} boolean\n   */\n  ltEq(other) {\n    const cmp = this.compareTo(other);\n    return cmp == 'lt' || cmp == 'eq';\n  }\n  /**\n   * Utility method checking whether a provided Principal is greater than or equal to the current one using the {@link Principal.compareTo} method\n   * @param other a {@link Principal} to compare\n   * @returns {boolean} boolean\n   */\n  gtEq(other) {\n    const cmp = this.compareTo(other);\n    return cmp == 'gt' || cmp == 'eq';\n  }\n}","map":{"version":3,"names":["decode","encode","getCrc32","sha224","JSON_KEY_PRINCIPAL","SELF_AUTHENTICATING_SUFFIX","ANONYMOUS_SUFFIX","MANAGEMENT_CANISTER_PRINCIPAL_HEX_STR","fromHexString","hexString","_a","Uint8Array","match","map","byte","parseInt","toHexString","bytes","reduce","str","toString","padStart","Principal","constructor","_arr","_isPrincipal","anonymous","managementCanister","fromHex","selfAuthenticating","publicKey","sha","from","other","fromText","Object","getPrototypeOf","prototype","Error","JSON","stringify","hex","text","maybePrincipal","includes","obj","parse","canisterIdNoDash","toLowerCase","replace","arr","slice","length","principal","toText","fromUint8Array","isAnonymous","byteLength","toUint8Array","toHex","toUpperCase","checksumArrayBuf","ArrayBuffer","view","DataView","setUint32","checksum","array","result","matches","join","toJSON","compareTo","i","Math","min","ltEq","cmp","gtEq"],"sources":["/home/arslan/modojo/node_modules/@dfinity/principal/src/index.ts"],"sourcesContent":["import { decode, encode } from './utils/base32';\nimport { getCrc32 } from './utils/getCrc';\nimport { sha224 } from './utils/sha224';\n\nexport const JSON_KEY_PRINCIPAL = '__principal__';\nconst SELF_AUTHENTICATING_SUFFIX = 2;\nconst ANONYMOUS_SUFFIX = 4;\n\nconst MANAGEMENT_CANISTER_PRINCIPAL_HEX_STR = 'aaaaa-aa';\n\nconst fromHexString = (hexString: string) =>\n  new Uint8Array((hexString.match(/.{1,2}/g) ?? []).map(byte => parseInt(byte, 16)));\n\nconst toHexString = (bytes: Uint8Array) =>\n  bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n\nexport type JsonnablePrincipal = {\n  [JSON_KEY_PRINCIPAL]: string;\n};\n\nexport class Principal {\n  public static anonymous(): Principal {\n    return new this(new Uint8Array([ANONYMOUS_SUFFIX]));\n  }\n\n  /**\n   * Utility method, returning the principal representing the management canister, decoded from the hex string `'aaaaa-aa'`\n   * @returns {Principal} principal of the management canister\n   */\n  public static managementCanister(): Principal {\n    return this.fromHex(MANAGEMENT_CANISTER_PRINCIPAL_HEX_STR);\n  }\n\n  public static selfAuthenticating(publicKey: Uint8Array): Principal {\n    const sha = sha224(publicKey);\n    return new this(new Uint8Array([...sha, SELF_AUTHENTICATING_SUFFIX]));\n  }\n\n  public static from(other: unknown): Principal {\n    if (typeof other === 'string') {\n      return Principal.fromText(other);\n    } else if (Object.getPrototypeOf(other) === Uint8Array.prototype) {\n      return new Principal(other as Uint8Array);\n    } else if (\n      typeof other === 'object' &&\n      other !== null &&\n      (other as Principal)._isPrincipal === true\n    ) {\n      return new Principal((other as Principal)._arr);\n    }\n\n    throw new Error(`Impossible to convert ${JSON.stringify(other)} to Principal.`);\n  }\n\n  public static fromHex(hex: string): Principal {\n    return new this(fromHexString(hex));\n  }\n\n  public static fromText(text: string): Principal {\n    let maybePrincipal = text;\n    // If formatted as JSON string, parse it first\n    if (text.includes(JSON_KEY_PRINCIPAL)) {\n      const obj = JSON.parse(text);\n      if (JSON_KEY_PRINCIPAL in obj) {\n        maybePrincipal = obj[JSON_KEY_PRINCIPAL];\n      }\n    }\n\n    const canisterIdNoDash = maybePrincipal.toLowerCase().replace(/-/g, '');\n\n    let arr = decode(canisterIdNoDash);\n    arr = arr.slice(4, arr.length);\n\n    const principal = new this(arr);\n    if (principal.toText() !== maybePrincipal) {\n      throw new Error(\n        `Principal \"${principal.toText()}\" does not have a valid checksum (original value \"${maybePrincipal}\" may not be a valid Principal ID).`,\n      );\n    }\n\n    return principal;\n  }\n\n  public static fromUint8Array(arr: Uint8Array): Principal {\n    return new this(arr);\n  }\n\n  public readonly _isPrincipal = true;\n\n  protected constructor(private _arr: Uint8Array) {}\n\n  public isAnonymous(): boolean {\n    return this._arr.byteLength === 1 && this._arr[0] === ANONYMOUS_SUFFIX;\n  }\n\n  public toUint8Array(): Uint8Array {\n    return this._arr;\n  }\n\n  public toHex(): string {\n    return toHexString(this._arr).toUpperCase();\n  }\n\n  public toText(): string {\n    const checksumArrayBuf = new ArrayBuffer(4);\n    const view = new DataView(checksumArrayBuf);\n    view.setUint32(0, getCrc32(this._arr));\n    const checksum = new Uint8Array(checksumArrayBuf);\n\n    const bytes = Uint8Array.from(this._arr);\n    const array = new Uint8Array([...checksum, ...bytes]);\n\n    const result = encode(array);\n    const matches = result.match(/.{1,5}/g);\n    if (!matches) {\n      // This should only happen if there's no character, which is unreachable.\n      throw new Error();\n    }\n    return matches.join('-');\n  }\n\n  public toString(): string {\n    return this.toText();\n  }\n\n  /**\n   * Serializes to JSON\n   * @returns {JsonnablePrincipal} a JSON object with a single key, {@link JSON_KEY_PRINCIPAL}, whose value is the principal as a string\n   */\n  public toJSON(): JsonnablePrincipal {\n    return { [JSON_KEY_PRINCIPAL]: this.toText() };\n  }\n\n  /**\n   * Utility method taking a Principal to compare against. Used for determining canister ranges in certificate verification\n   * @param {Principal} other - a {@link Principal} to compare\n   * @returns {'lt' | 'eq' | 'gt'} `'lt' | 'eq' | 'gt'` a string, representing less than, equal to, or greater than\n   */\n  public compareTo(other: Principal): 'lt' | 'eq' | 'gt' {\n    for (let i = 0; i < Math.min(this._arr.length, other._arr.length); i++) {\n      if (this._arr[i] < other._arr[i]) return 'lt';\n      else if (this._arr[i] > other._arr[i]) return 'gt';\n    }\n    // Here, at least one principal is a prefix of the other principal (they could be the same)\n    if (this._arr.length < other._arr.length) return 'lt';\n    if (this._arr.length > other._arr.length) return 'gt';\n    return 'eq';\n  }\n\n  /**\n   * Utility method checking whether a provided Principal is less than or equal to the current one using the {@link Principal.compareTo} method\n   * @param other a {@link Principal} to compare\n   * @returns {boolean} boolean\n   */\n  public ltEq(other: Principal): boolean {\n    const cmp = this.compareTo(other);\n    return cmp == 'lt' || cmp == 'eq';\n  }\n\n  /**\n   * Utility method checking whether a provided Principal is greater than or equal to the current one using the {@link Principal.compareTo} method\n   * @param other a {@link Principal} to compare\n   * @returns {boolean} boolean\n   */\n  public gtEq(other: Principal): boolean {\n    const cmp = this.compareTo(other);\n    return cmp == 'gt' || cmp == 'eq';\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}