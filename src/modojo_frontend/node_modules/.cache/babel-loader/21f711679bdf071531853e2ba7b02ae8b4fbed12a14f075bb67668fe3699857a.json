{"ast":null,"code":"import { RequestStatusResponseStatus } from '../agent';\nimport { Certificate, lookupResultToBuffer } from '../certificate';\nimport { toHex } from '../utils/buffer';\nimport * as _strategy from './strategy';\nexport { _strategy as strategy };\nimport { defaultStrategy } from './strategy';\nexport { defaultStrategy } from './strategy';\n/**\n * Polls the IC to check the status of the given request then\n * returns the response bytes once the request has been processed.\n * @param agent The agent to use to poll read_state.\n * @param canisterId The effective canister ID.\n * @param requestId The Request ID to poll status for.\n * @param strategy A polling strategy.\n * @param request Request for the readState call.\n * @param blsVerify - optional replacement function that verifies the BLS signature of a certificate.\n */\nexport async function pollForResponse(agent, canisterId, requestId) {\n  let strategy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : defaultStrategy();\n  let\n  // eslint-disable-next-line\n  request = arguments.length > 4 ? arguments[4] : undefined;\n  let blsVerify = arguments.length > 5 ? arguments[5] : undefined;\n  var _a;\n  const path = [new TextEncoder().encode('request_status'), requestId];\n  const currentRequest = request !== null && request !== void 0 ? request : await ((_a = agent.createReadStateRequest) === null || _a === void 0 ? void 0 : _a.call(agent, {\n    paths: [path]\n  }));\n  const state = await agent.readState(canisterId, {\n    paths: [path]\n  }, undefined, currentRequest);\n  if (agent.rootKey == null) throw new Error('Agent root key not initialized before polling');\n  const cert = await Certificate.create({\n    certificate: state.certificate,\n    rootKey: agent.rootKey,\n    canisterId: canisterId,\n    blsVerify\n  });\n  const maybeBuf = lookupResultToBuffer(cert.lookup([...path, new TextEncoder().encode('status')]));\n  let status;\n  if (typeof maybeBuf === 'undefined') {\n    // Missing requestId means we need to wait\n    status = RequestStatusResponseStatus.Unknown;\n  } else {\n    status = new TextDecoder().decode(maybeBuf);\n  }\n  switch (status) {\n    case RequestStatusResponseStatus.Replied:\n      {\n        return {\n          reply: lookupResultToBuffer(cert.lookup([...path, 'reply'])),\n          certificate: cert\n        };\n      }\n    case RequestStatusResponseStatus.Received:\n    case RequestStatusResponseStatus.Unknown:\n    case RequestStatusResponseStatus.Processing:\n      // Execute the polling strategy, then retry.\n      await strategy(canisterId, requestId, status);\n      return pollForResponse(agent, canisterId, requestId, strategy, currentRequest, blsVerify);\n    case RequestStatusResponseStatus.Rejected:\n      {\n        const rejectCode = new Uint8Array(lookupResultToBuffer(cert.lookup([...path, 'reject_code'])))[0];\n        const rejectMessage = new TextDecoder().decode(lookupResultToBuffer(cert.lookup([...path, 'reject_message'])));\n        throw new Error(`Call was rejected:\\n` + `  Request ID: ${toHex(requestId)}\\n` + `  Reject code: ${rejectCode}\\n` + `  Reject text: ${rejectMessage}\\n`);\n      }\n    case RequestStatusResponseStatus.Done:\n      // This is _technically_ not an error, but we still didn't see the `Replied` status so\n      // we don't know the result and cannot decode it.\n      throw new Error(`Call was marked as done but we never saw the reply:\\n` + `  Request ID: ${toHex(requestId)}\\n`);\n  }\n  throw new Error('unreachable');\n}","map":{"version":3,"names":["RequestStatusResponseStatus","Certificate","lookupResultToBuffer","toHex","_strategy","strategy","defaultStrategy","pollForResponse","agent","canisterId","requestId","arguments","length","undefined","request","blsVerify","path","TextEncoder","encode","currentRequest","_a","createReadStateRequest","call","paths","state","readState","rootKey","Error","cert","create","certificate","maybeBuf","lookup","status","Unknown","TextDecoder","decode","Replied","reply","Received","Processing","Rejected","rejectCode","Uint8Array","rejectMessage","Done"],"sources":["/home/arslan/modojo/node_modules/@dfinity/agent/src/polling/index.ts"],"sourcesContent":["import { Principal } from '@dfinity/principal';\nimport { Agent, RequestStatusResponseStatus } from '../agent';\nimport { Certificate, CreateCertificateOptions, lookupResultToBuffer } from '../certificate';\nimport { RequestId } from '../request_id';\nimport { toHex } from '../utils/buffer';\n\nexport * as strategy from './strategy';\nimport { defaultStrategy } from './strategy';\nexport { defaultStrategy } from './strategy';\nexport type PollStrategy = (\n  canisterId: Principal,\n  requestId: RequestId,\n  status: RequestStatusResponseStatus,\n) => Promise<void>;\nexport type PollStrategyFactory = () => PollStrategy;\n\n/**\n * Polls the IC to check the status of the given request then\n * returns the response bytes once the request has been processed.\n * @param agent The agent to use to poll read_state.\n * @param canisterId The effective canister ID.\n * @param requestId The Request ID to poll status for.\n * @param strategy A polling strategy.\n * @param request Request for the readState call.\n * @param blsVerify - optional replacement function that verifies the BLS signature of a certificate.\n */\nexport async function pollForResponse(\n  agent: Agent,\n  canisterId: Principal,\n  requestId: RequestId,\n  strategy: PollStrategy = defaultStrategy(),\n  // eslint-disable-next-line\n  request?: any,\n  blsVerify?: CreateCertificateOptions['blsVerify'],\n): Promise<{\n  certificate: Certificate;\n  reply: ArrayBuffer;\n}> {\n  const path = [new TextEncoder().encode('request_status'), requestId];\n  const currentRequest = request ?? (await agent.createReadStateRequest?.({ paths: [path] }));\n  const state = await agent.readState(canisterId, { paths: [path] }, undefined, currentRequest);\n  if (agent.rootKey == null) throw new Error('Agent root key not initialized before polling');\n  const cert = await Certificate.create({\n    certificate: state.certificate,\n    rootKey: agent.rootKey,\n    canisterId: canisterId,\n    blsVerify,\n  });\n\n  const maybeBuf = lookupResultToBuffer(cert.lookup([...path, new TextEncoder().encode('status')]));\n  let status;\n  if (typeof maybeBuf === 'undefined') {\n    // Missing requestId means we need to wait\n    status = RequestStatusResponseStatus.Unknown;\n  } else {\n    status = new TextDecoder().decode(maybeBuf);\n  }\n\n  switch (status) {\n    case RequestStatusResponseStatus.Replied: {\n      return {\n        reply: lookupResultToBuffer(cert.lookup([...path, 'reply']))!,\n        certificate: cert,\n      };\n    }\n\n    case RequestStatusResponseStatus.Received:\n    case RequestStatusResponseStatus.Unknown:\n    case RequestStatusResponseStatus.Processing:\n      // Execute the polling strategy, then retry.\n      await strategy(canisterId, requestId, status);\n      return pollForResponse(agent, canisterId, requestId, strategy, currentRequest, blsVerify);\n\n    case RequestStatusResponseStatus.Rejected: {\n      const rejectCode = new Uint8Array(\n        lookupResultToBuffer(cert.lookup([...path, 'reject_code']))!,\n      )[0];\n      const rejectMessage = new TextDecoder().decode(\n        lookupResultToBuffer(cert.lookup([...path, 'reject_message']))!,\n      );\n      throw new Error(\n        `Call was rejected:\\n` +\n          `  Request ID: ${toHex(requestId)}\\n` +\n          `  Reject code: ${rejectCode}\\n` +\n          `  Reject text: ${rejectMessage}\\n`,\n      );\n    }\n\n    case RequestStatusResponseStatus.Done:\n      // This is _technically_ not an error, but we still didn't see the `Replied` status so\n      // we don't know the result and cannot decode it.\n      throw new Error(\n        `Call was marked as done but we never saw the reply:\\n` +\n          `  Request ID: ${toHex(requestId)}\\n`,\n      );\n  }\n  throw new Error('unreachable');\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}