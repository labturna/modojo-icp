{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './minimap.css';\nimport * as dom from '../../../../base/browser/dom.js';\nimport { createFastDomNode } from '../../../../base/browser/fastDomNode.js';\nimport { GlobalPointerMoveMonitor } from '../../../../base/browser/globalPointerMoveMonitor.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport * as platform from '../../../../base/common/platform.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { RenderedLinesCollection } from '../../view/viewLayer.js';\nimport { PartFingerprints, ViewPart } from '../../view/viewPart.js';\nimport { MINIMAP_GUTTER_WIDTH, EditorLayoutInfoComputer } from '../../../common/config/editorOptions.js';\nimport { Range } from '../../../common/core/range.js';\nimport { RGBA8 } from '../../../common/core/rgba.js';\nimport { MinimapTokensColorTracker } from '../../../common/viewModel/minimapTokensColorTracker.js';\nimport { ViewModelDecoration } from '../../../common/viewModel.js';\nimport { minimapSelection, minimapBackground, minimapForegroundOpacity, editorForeground } from '../../../../platform/theme/common/colorRegistry.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { EventType, Gesture } from '../../../../base/browser/touch.js';\nimport { MinimapCharRendererFactory } from './minimapCharRendererFactory.js';\nimport { createSingleCallFunction } from '../../../../base/common/functional.js';\nimport { LRUCache } from '../../../../base/common/map.js';\nimport { DEFAULT_FONT_FAMILY } from '../../../../base/browser/fonts.js';\n/**\n * The orthogonal distance to the slider at which dragging \"resets\". This implements \"snapping\"\n */\nconst POINTER_DRAG_RESET_DISTANCE = 140;\nconst GUTTER_DECORATION_WIDTH = 2;\nclass MinimapOptions {\n  constructor(configuration, theme, tokensColorTracker) {\n    const options = configuration.options;\n    const pixelRatio = options.get(143 /* EditorOption.pixelRatio */);\n    const layoutInfo = options.get(145 /* EditorOption.layoutInfo */);\n    const minimapLayout = layoutInfo.minimap;\n    const fontInfo = options.get(50 /* EditorOption.fontInfo */);\n    const minimapOpts = options.get(73 /* EditorOption.minimap */);\n    this.renderMinimap = minimapLayout.renderMinimap;\n    this.size = minimapOpts.size;\n    this.minimapHeightIsEditorHeight = minimapLayout.minimapHeightIsEditorHeight;\n    this.scrollBeyondLastLine = options.get(105 /* EditorOption.scrollBeyondLastLine */);\n    this.paddingTop = options.get(84 /* EditorOption.padding */).top;\n    this.paddingBottom = options.get(84 /* EditorOption.padding */).bottom;\n    this.showSlider = minimapOpts.showSlider;\n    this.autohide = minimapOpts.autohide;\n    this.pixelRatio = pixelRatio;\n    this.typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\n    this.lineHeight = options.get(67 /* EditorOption.lineHeight */);\n    this.minimapLeft = minimapLayout.minimapLeft;\n    this.minimapWidth = minimapLayout.minimapWidth;\n    this.minimapHeight = layoutInfo.height;\n    this.canvasInnerWidth = minimapLayout.minimapCanvasInnerWidth;\n    this.canvasInnerHeight = minimapLayout.minimapCanvasInnerHeight;\n    this.canvasOuterWidth = minimapLayout.minimapCanvasOuterWidth;\n    this.canvasOuterHeight = minimapLayout.minimapCanvasOuterHeight;\n    this.isSampling = minimapLayout.minimapIsSampling;\n    this.editorHeight = layoutInfo.height;\n    this.fontScale = minimapLayout.minimapScale;\n    this.minimapLineHeight = minimapLayout.minimapLineHeight;\n    this.minimapCharWidth = 1 /* Constants.BASE_CHAR_WIDTH */ * this.fontScale;\n    this.sectionHeaderFontFamily = DEFAULT_FONT_FAMILY;\n    this.sectionHeaderFontSize = minimapOpts.sectionHeaderFontSize * pixelRatio;\n    this.sectionHeaderLetterSpacing = minimapOpts.sectionHeaderLetterSpacing; // intentionally not multiplying by pixelRatio\n    this.sectionHeaderFontColor = MinimapOptions._getSectionHeaderColor(theme, tokensColorTracker.getColor(1 /* ColorId.DefaultForeground */));\n    this.charRenderer = createSingleCallFunction(() => MinimapCharRendererFactory.create(this.fontScale, fontInfo.fontFamily));\n    this.defaultBackgroundColor = tokensColorTracker.getColor(2 /* ColorId.DefaultBackground */);\n    this.backgroundColor = MinimapOptions._getMinimapBackground(theme, this.defaultBackgroundColor);\n    this.foregroundAlpha = MinimapOptions._getMinimapForegroundOpacity(theme);\n  }\n  static _getMinimapBackground(theme, defaultBackgroundColor) {\n    const themeColor = theme.getColor(minimapBackground);\n    if (themeColor) {\n      return new RGBA8(themeColor.rgba.r, themeColor.rgba.g, themeColor.rgba.b, Math.round(255 * themeColor.rgba.a));\n    }\n    return defaultBackgroundColor;\n  }\n  static _getMinimapForegroundOpacity(theme) {\n    const themeColor = theme.getColor(minimapForegroundOpacity);\n    if (themeColor) {\n      return RGBA8._clamp(Math.round(255 * themeColor.rgba.a));\n    }\n    return 255;\n  }\n  static _getSectionHeaderColor(theme, defaultForegroundColor) {\n    const themeColor = theme.getColor(editorForeground);\n    if (themeColor) {\n      return new RGBA8(themeColor.rgba.r, themeColor.rgba.g, themeColor.rgba.b, Math.round(255 * themeColor.rgba.a));\n    }\n    return defaultForegroundColor;\n  }\n  equals(other) {\n    return this.renderMinimap === other.renderMinimap && this.size === other.size && this.minimapHeightIsEditorHeight === other.minimapHeightIsEditorHeight && this.scrollBeyondLastLine === other.scrollBeyondLastLine && this.paddingTop === other.paddingTop && this.paddingBottom === other.paddingBottom && this.showSlider === other.showSlider && this.autohide === other.autohide && this.pixelRatio === other.pixelRatio && this.typicalHalfwidthCharacterWidth === other.typicalHalfwidthCharacterWidth && this.lineHeight === other.lineHeight && this.minimapLeft === other.minimapLeft && this.minimapWidth === other.minimapWidth && this.minimapHeight === other.minimapHeight && this.canvasInnerWidth === other.canvasInnerWidth && this.canvasInnerHeight === other.canvasInnerHeight && this.canvasOuterWidth === other.canvasOuterWidth && this.canvasOuterHeight === other.canvasOuterHeight && this.isSampling === other.isSampling && this.editorHeight === other.editorHeight && this.fontScale === other.fontScale && this.minimapLineHeight === other.minimapLineHeight && this.minimapCharWidth === other.minimapCharWidth && this.sectionHeaderFontSize === other.sectionHeaderFontSize && this.sectionHeaderLetterSpacing === other.sectionHeaderLetterSpacing && this.defaultBackgroundColor && this.defaultBackgroundColor.equals(other.defaultBackgroundColor) && this.backgroundColor && this.backgroundColor.equals(other.backgroundColor) && this.foregroundAlpha === other.foregroundAlpha;\n  }\n}\nclass MinimapLayout {\n  constructor(\n  /**\n   * The given editor scrollTop (input).\n   */\n  scrollTop,\n  /**\n   * The given editor scrollHeight (input).\n   */\n  scrollHeight, sliderNeeded, _computedSliderRatio,\n  /**\n   * slider dom node top (in CSS px)\n   */\n  sliderTop,\n  /**\n   * slider dom node height (in CSS px)\n   */\n  sliderHeight,\n  /**\n   * empty lines to reserve at the top of the minimap.\n   */\n  topPaddingLineCount,\n  /**\n   * minimap render start line number.\n   */\n  startLineNumber,\n  /**\n   * minimap render end line number.\n   */\n  endLineNumber) {\n    this.scrollTop = scrollTop;\n    this.scrollHeight = scrollHeight;\n    this.sliderNeeded = sliderNeeded;\n    this._computedSliderRatio = _computedSliderRatio;\n    this.sliderTop = sliderTop;\n    this.sliderHeight = sliderHeight;\n    this.topPaddingLineCount = topPaddingLineCount;\n    this.startLineNumber = startLineNumber;\n    this.endLineNumber = endLineNumber;\n  }\n  /**\n   * Compute a desired `scrollPosition` such that the slider moves by `delta`.\n   */\n  getDesiredScrollTopFromDelta(delta) {\n    return Math.round(this.scrollTop + delta / this._computedSliderRatio);\n  }\n  getDesiredScrollTopFromTouchLocation(pageY) {\n    return Math.round((pageY - this.sliderHeight / 2) / this._computedSliderRatio);\n  }\n  /**\n   * Intersect a line range with `this.startLineNumber` and `this.endLineNumber`.\n   */\n  intersectWithViewport(range) {\n    const startLineNumber = Math.max(this.startLineNumber, range.startLineNumber);\n    const endLineNumber = Math.min(this.endLineNumber, range.endLineNumber);\n    if (startLineNumber > endLineNumber) {\n      // entirely outside minimap's viewport\n      return null;\n    }\n    return [startLineNumber, endLineNumber];\n  }\n  /**\n   * Get the inner minimap y coordinate for a line number.\n   */\n  getYForLineNumber(lineNumber, minimapLineHeight) {\n    return +(lineNumber - this.startLineNumber + this.topPaddingLineCount) * minimapLineHeight;\n  }\n  static create(options, viewportStartLineNumber, viewportEndLineNumber, viewportStartLineNumberVerticalOffset, viewportHeight, viewportContainsWhitespaceGaps, lineCount, realLineCount, scrollTop, scrollHeight, previousLayout) {\n    const pixelRatio = options.pixelRatio;\n    const minimapLineHeight = options.minimapLineHeight;\n    const minimapLinesFitting = Math.floor(options.canvasInnerHeight / minimapLineHeight);\n    const lineHeight = options.lineHeight;\n    if (options.minimapHeightIsEditorHeight) {\n      let logicalScrollHeight = realLineCount * options.lineHeight + options.paddingTop + options.paddingBottom;\n      if (options.scrollBeyondLastLine) {\n        logicalScrollHeight += Math.max(0, viewportHeight - options.lineHeight - options.paddingBottom);\n      }\n      const sliderHeight = Math.max(1, Math.floor(viewportHeight * viewportHeight / logicalScrollHeight));\n      const maxMinimapSliderTop = Math.max(0, options.minimapHeight - sliderHeight);\n      // The slider can move from 0 to `maxMinimapSliderTop`\n      // in the same way `scrollTop` can move from 0 to `scrollHeight` - `viewportHeight`.\n      const computedSliderRatio = maxMinimapSliderTop / (scrollHeight - viewportHeight);\n      const sliderTop = scrollTop * computedSliderRatio;\n      const sliderNeeded = maxMinimapSliderTop > 0;\n      const maxLinesFitting = Math.floor(options.canvasInnerHeight / options.minimapLineHeight);\n      const topPaddingLineCount = Math.floor(options.paddingTop / options.lineHeight);\n      return new MinimapLayout(scrollTop, scrollHeight, sliderNeeded, computedSliderRatio, sliderTop, sliderHeight, topPaddingLineCount, 1, Math.min(lineCount, maxLinesFitting));\n    }\n    // The visible line count in a viewport can change due to a number of reasons:\n    //  a) with the same viewport width, different scroll positions can result in partial lines being visible:\n    //    e.g. for a line height of 20, and a viewport height of 600\n    //          * scrollTop = 0  => visible lines are [1, 30]\n    //          * scrollTop = 10 => visible lines are [1, 31] (with lines 1 and 31 partially visible)\n    //          * scrollTop = 20 => visible lines are [2, 31]\n    //  b) whitespace gaps might make their way in the viewport (which results in a decrease in the visible line count)\n    //  c) we could be in the scroll beyond last line case (which also results in a decrease in the visible line count, down to possibly only one line being visible)\n    // We must first establish a desirable slider height.\n    let sliderHeight;\n    if (viewportContainsWhitespaceGaps && viewportEndLineNumber !== lineCount) {\n      // case b) from above: there are whitespace gaps in the viewport.\n      // In this case, the height of the slider directly reflects the visible line count.\n      const viewportLineCount = viewportEndLineNumber - viewportStartLineNumber + 1;\n      sliderHeight = Math.floor(viewportLineCount * minimapLineHeight / pixelRatio);\n    } else {\n      // The slider has a stable height\n      const expectedViewportLineCount = viewportHeight / lineHeight;\n      sliderHeight = Math.floor(expectedViewportLineCount * minimapLineHeight / pixelRatio);\n    }\n    const extraLinesAtTheTop = Math.floor(options.paddingTop / lineHeight);\n    let extraLinesAtTheBottom = Math.floor(options.paddingBottom / lineHeight);\n    if (options.scrollBeyondLastLine) {\n      const expectedViewportLineCount = viewportHeight / lineHeight;\n      extraLinesAtTheBottom = Math.max(extraLinesAtTheBottom, expectedViewportLineCount - 1);\n    }\n    let maxMinimapSliderTop;\n    if (extraLinesAtTheBottom > 0) {\n      const expectedViewportLineCount = viewportHeight / lineHeight;\n      // The minimap slider, when dragged all the way down, will contain the last line at its top\n      maxMinimapSliderTop = (extraLinesAtTheTop + lineCount + extraLinesAtTheBottom - expectedViewportLineCount - 1) * minimapLineHeight / pixelRatio;\n    } else {\n      // The minimap slider, when dragged all the way down, will contain the last line at its bottom\n      maxMinimapSliderTop = Math.max(0, (extraLinesAtTheTop + lineCount) * minimapLineHeight / pixelRatio - sliderHeight);\n    }\n    maxMinimapSliderTop = Math.min(options.minimapHeight - sliderHeight, maxMinimapSliderTop);\n    // The slider can move from 0 to `maxMinimapSliderTop`\n    // in the same way `scrollTop` can move from 0 to `scrollHeight` - `viewportHeight`.\n    const computedSliderRatio = maxMinimapSliderTop / (scrollHeight - viewportHeight);\n    const sliderTop = scrollTop * computedSliderRatio;\n    if (minimapLinesFitting >= extraLinesAtTheTop + lineCount + extraLinesAtTheBottom) {\n      // All lines fit in the minimap\n      const sliderNeeded = maxMinimapSliderTop > 0;\n      return new MinimapLayout(scrollTop, scrollHeight, sliderNeeded, computedSliderRatio, sliderTop, sliderHeight, extraLinesAtTheTop, 1, lineCount);\n    } else {\n      let consideringStartLineNumber;\n      if (viewportStartLineNumber > 1) {\n        consideringStartLineNumber = viewportStartLineNumber + extraLinesAtTheTop;\n      } else {\n        consideringStartLineNumber = Math.max(1, scrollTop / lineHeight);\n      }\n      let topPaddingLineCount;\n      let startLineNumber = Math.max(1, Math.floor(consideringStartLineNumber - sliderTop * pixelRatio / minimapLineHeight));\n      if (startLineNumber < extraLinesAtTheTop) {\n        topPaddingLineCount = extraLinesAtTheTop - startLineNumber + 1;\n        startLineNumber = 1;\n      } else {\n        topPaddingLineCount = 0;\n        startLineNumber = Math.max(1, startLineNumber - extraLinesAtTheTop);\n      }\n      // Avoid flickering caused by a partial viewport start line\n      // by being consistent w.r.t. the previous layout decision\n      if (previousLayout && previousLayout.scrollHeight === scrollHeight) {\n        if (previousLayout.scrollTop > scrollTop) {\n          // Scrolling up => never increase `startLineNumber`\n          startLineNumber = Math.min(startLineNumber, previousLayout.startLineNumber);\n          topPaddingLineCount = Math.max(topPaddingLineCount, previousLayout.topPaddingLineCount);\n        }\n        if (previousLayout.scrollTop < scrollTop) {\n          // Scrolling down => never decrease `startLineNumber`\n          startLineNumber = Math.max(startLineNumber, previousLayout.startLineNumber);\n          topPaddingLineCount = Math.min(topPaddingLineCount, previousLayout.topPaddingLineCount);\n        }\n      }\n      const endLineNumber = Math.min(lineCount, startLineNumber - topPaddingLineCount + minimapLinesFitting - 1);\n      const partialLine = (scrollTop - viewportStartLineNumberVerticalOffset) / lineHeight;\n      let sliderTopAligned;\n      if (scrollTop >= options.paddingTop) {\n        sliderTopAligned = (viewportStartLineNumber - startLineNumber + topPaddingLineCount + partialLine) * minimapLineHeight / pixelRatio;\n      } else {\n        sliderTopAligned = scrollTop / options.paddingTop * (topPaddingLineCount + partialLine) * minimapLineHeight / pixelRatio;\n      }\n      return new MinimapLayout(scrollTop, scrollHeight, true, computedSliderRatio, sliderTopAligned, sliderHeight, topPaddingLineCount, startLineNumber, endLineNumber);\n    }\n  }\n}\nclass MinimapLine {\n  constructor(dy) {\n    this.dy = dy;\n  }\n  onContentChanged() {\n    this.dy = -1;\n  }\n  onTokensChanged() {\n    this.dy = -1;\n  }\n}\nMinimapLine.INVALID = new MinimapLine(-1);\nclass RenderData {\n  constructor(renderedLayout, imageData, lines) {\n    this.renderedLayout = renderedLayout;\n    this._imageData = imageData;\n    this._renderedLines = new RenderedLinesCollection(() => MinimapLine.INVALID);\n    this._renderedLines._set(renderedLayout.startLineNumber, lines);\n  }\n  /**\n   * Check if the current RenderData matches accurately the new desired layout and no painting is needed.\n   */\n  linesEquals(layout) {\n    if (!this.scrollEquals(layout)) {\n      return false;\n    }\n    const tmp = this._renderedLines._get();\n    const lines = tmp.lines;\n    for (let i = 0, len = lines.length; i < len; i++) {\n      if (lines[i].dy === -1) {\n        // This line is invalid\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Check if the current RenderData matches the new layout's scroll position\n   */\n  scrollEquals(layout) {\n    return this.renderedLayout.startLineNumber === layout.startLineNumber && this.renderedLayout.endLineNumber === layout.endLineNumber;\n  }\n  _get() {\n    const tmp = this._renderedLines._get();\n    return {\n      imageData: this._imageData,\n      rendLineNumberStart: tmp.rendLineNumberStart,\n      lines: tmp.lines\n    };\n  }\n  onLinesChanged(changeFromLineNumber, changeCount) {\n    return this._renderedLines.onLinesChanged(changeFromLineNumber, changeCount);\n  }\n  onLinesDeleted(deleteFromLineNumber, deleteToLineNumber) {\n    this._renderedLines.onLinesDeleted(deleteFromLineNumber, deleteToLineNumber);\n  }\n  onLinesInserted(insertFromLineNumber, insertToLineNumber) {\n    this._renderedLines.onLinesInserted(insertFromLineNumber, insertToLineNumber);\n  }\n  onTokensChanged(ranges) {\n    return this._renderedLines.onTokensChanged(ranges);\n  }\n}\n/**\n * Some sort of double buffering.\n *\n * Keeps two buffers around that will be rotated for painting.\n * Always gives a buffer that is filled with the background color.\n */\nclass MinimapBuffers {\n  constructor(ctx, WIDTH, HEIGHT, background) {\n    this._backgroundFillData = MinimapBuffers._createBackgroundFillData(WIDTH, HEIGHT, background);\n    this._buffers = [ctx.createImageData(WIDTH, HEIGHT), ctx.createImageData(WIDTH, HEIGHT)];\n    this._lastUsedBuffer = 0;\n  }\n  getBuffer() {\n    // rotate buffers\n    this._lastUsedBuffer = 1 - this._lastUsedBuffer;\n    const result = this._buffers[this._lastUsedBuffer];\n    // fill with background color\n    result.data.set(this._backgroundFillData);\n    return result;\n  }\n  static _createBackgroundFillData(WIDTH, HEIGHT, background) {\n    const backgroundR = background.r;\n    const backgroundG = background.g;\n    const backgroundB = background.b;\n    const backgroundA = background.a;\n    const result = new Uint8ClampedArray(WIDTH * HEIGHT * 4);\n    let offset = 0;\n    for (let i = 0; i < HEIGHT; i++) {\n      for (let j = 0; j < WIDTH; j++) {\n        result[offset] = backgroundR;\n        result[offset + 1] = backgroundG;\n        result[offset + 2] = backgroundB;\n        result[offset + 3] = backgroundA;\n        offset += 4;\n      }\n    }\n    return result;\n  }\n}\nclass MinimapSamplingState {\n  static compute(options, viewLineCount, oldSamplingState) {\n    if (options.renderMinimap === 0 /* RenderMinimap.None */ || !options.isSampling) {\n      return [null, []];\n    }\n    // ratio is intentionally not part of the layout to avoid the layout changing all the time\n    // so we need to recompute it again...\n    const {\n      minimapLineCount\n    } = EditorLayoutInfoComputer.computeContainedMinimapLineCount({\n      viewLineCount: viewLineCount,\n      scrollBeyondLastLine: options.scrollBeyondLastLine,\n      paddingTop: options.paddingTop,\n      paddingBottom: options.paddingBottom,\n      height: options.editorHeight,\n      lineHeight: options.lineHeight,\n      pixelRatio: options.pixelRatio\n    });\n    const ratio = viewLineCount / minimapLineCount;\n    const halfRatio = ratio / 2;\n    if (!oldSamplingState || oldSamplingState.minimapLines.length === 0) {\n      const result = [];\n      result[0] = 1;\n      if (minimapLineCount > 1) {\n        for (let i = 0, lastIndex = minimapLineCount - 1; i < lastIndex; i++) {\n          result[i] = Math.round(i * ratio + halfRatio);\n        }\n        result[minimapLineCount - 1] = viewLineCount;\n      }\n      return [new MinimapSamplingState(ratio, result), []];\n    }\n    const oldMinimapLines = oldSamplingState.minimapLines;\n    const oldLength = oldMinimapLines.length;\n    const result = [];\n    let oldIndex = 0;\n    let oldDeltaLineCount = 0;\n    let minViewLineNumber = 1;\n    const MAX_EVENT_COUNT = 10; // generate at most 10 events, if there are more than 10 changes, just flush all previous data\n    let events = [];\n    let lastEvent = null;\n    for (let i = 0; i < minimapLineCount; i++) {\n      const fromViewLineNumber = Math.max(minViewLineNumber, Math.round(i * ratio));\n      const toViewLineNumber = Math.max(fromViewLineNumber, Math.round((i + 1) * ratio));\n      while (oldIndex < oldLength && oldMinimapLines[oldIndex] < fromViewLineNumber) {\n        if (events.length < MAX_EVENT_COUNT) {\n          const oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\n          if (lastEvent && lastEvent.type === 'deleted' && lastEvent._oldIndex === oldIndex - 1) {\n            lastEvent.deleteToLineNumber++;\n          } else {\n            lastEvent = {\n              type: 'deleted',\n              _oldIndex: oldIndex,\n              deleteFromLineNumber: oldMinimapLineNumber,\n              deleteToLineNumber: oldMinimapLineNumber\n            };\n            events.push(lastEvent);\n          }\n          oldDeltaLineCount--;\n        }\n        oldIndex++;\n      }\n      let selectedViewLineNumber;\n      if (oldIndex < oldLength && oldMinimapLines[oldIndex] <= toViewLineNumber) {\n        // reuse the old sampled line\n        selectedViewLineNumber = oldMinimapLines[oldIndex];\n        oldIndex++;\n      } else {\n        if (i === 0) {\n          selectedViewLineNumber = 1;\n        } else if (i + 1 === minimapLineCount) {\n          selectedViewLineNumber = viewLineCount;\n        } else {\n          selectedViewLineNumber = Math.round(i * ratio + halfRatio);\n        }\n        if (events.length < MAX_EVENT_COUNT) {\n          const oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\n          if (lastEvent && lastEvent.type === 'inserted' && lastEvent._i === i - 1) {\n            lastEvent.insertToLineNumber++;\n          } else {\n            lastEvent = {\n              type: 'inserted',\n              _i: i,\n              insertFromLineNumber: oldMinimapLineNumber,\n              insertToLineNumber: oldMinimapLineNumber\n            };\n            events.push(lastEvent);\n          }\n          oldDeltaLineCount++;\n        }\n      }\n      result[i] = selectedViewLineNumber;\n      minViewLineNumber = selectedViewLineNumber;\n    }\n    if (events.length < MAX_EVENT_COUNT) {\n      while (oldIndex < oldLength) {\n        const oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\n        if (lastEvent && lastEvent.type === 'deleted' && lastEvent._oldIndex === oldIndex - 1) {\n          lastEvent.deleteToLineNumber++;\n        } else {\n          lastEvent = {\n            type: 'deleted',\n            _oldIndex: oldIndex,\n            deleteFromLineNumber: oldMinimapLineNumber,\n            deleteToLineNumber: oldMinimapLineNumber\n          };\n          events.push(lastEvent);\n        }\n        oldDeltaLineCount--;\n        oldIndex++;\n      }\n    } else {\n      // too many events, just give up\n      events = [{\n        type: 'flush'\n      }];\n    }\n    return [new MinimapSamplingState(ratio, result), events];\n  }\n  constructor(samplingRatio, minimapLines // a map of 0-based minimap line indexes to 1-based view line numbers\n  ) {\n    this.samplingRatio = samplingRatio;\n    this.minimapLines = minimapLines;\n  }\n  modelLineToMinimapLine(lineNumber) {\n    return Math.min(this.minimapLines.length, Math.max(1, Math.round(lineNumber / this.samplingRatio)));\n  }\n  /**\n   * Will return null if the model line ranges are not intersecting with a sampled model line.\n   */\n  modelLineRangeToMinimapLineRange(fromLineNumber, toLineNumber) {\n    let fromLineIndex = this.modelLineToMinimapLine(fromLineNumber) - 1;\n    while (fromLineIndex > 0 && this.minimapLines[fromLineIndex - 1] >= fromLineNumber) {\n      fromLineIndex--;\n    }\n    let toLineIndex = this.modelLineToMinimapLine(toLineNumber) - 1;\n    while (toLineIndex + 1 < this.minimapLines.length && this.minimapLines[toLineIndex + 1] <= toLineNumber) {\n      toLineIndex++;\n    }\n    if (fromLineIndex === toLineIndex) {\n      const sampledLineNumber = this.minimapLines[fromLineIndex];\n      if (sampledLineNumber < fromLineNumber || sampledLineNumber > toLineNumber) {\n        // This line is not part of the sampled lines ==> nothing to do\n        return null;\n      }\n    }\n    return [fromLineIndex + 1, toLineIndex + 1];\n  }\n  /**\n   * Will always return a range, even if it is not intersecting with a sampled model line.\n   */\n  decorationLineRangeToMinimapLineRange(startLineNumber, endLineNumber) {\n    let minimapLineStart = this.modelLineToMinimapLine(startLineNumber);\n    let minimapLineEnd = this.modelLineToMinimapLine(endLineNumber);\n    if (startLineNumber !== endLineNumber && minimapLineEnd === minimapLineStart) {\n      if (minimapLineEnd === this.minimapLines.length) {\n        if (minimapLineStart > 1) {\n          minimapLineStart--;\n        }\n      } else {\n        minimapLineEnd++;\n      }\n    }\n    return [minimapLineStart, minimapLineEnd];\n  }\n  onLinesDeleted(e) {\n    // have the mapping be sticky\n    const deletedLineCount = e.toLineNumber - e.fromLineNumber + 1;\n    let changeStartIndex = this.minimapLines.length;\n    let changeEndIndex = 0;\n    for (let i = this.minimapLines.length - 1; i >= 0; i--) {\n      if (this.minimapLines[i] < e.fromLineNumber) {\n        break;\n      }\n      if (this.minimapLines[i] <= e.toLineNumber) {\n        // this line got deleted => move to previous available\n        this.minimapLines[i] = Math.max(1, e.fromLineNumber - 1);\n        changeStartIndex = Math.min(changeStartIndex, i);\n        changeEndIndex = Math.max(changeEndIndex, i);\n      } else {\n        this.minimapLines[i] -= deletedLineCount;\n      }\n    }\n    return [changeStartIndex, changeEndIndex];\n  }\n  onLinesInserted(e) {\n    // have the mapping be sticky\n    const insertedLineCount = e.toLineNumber - e.fromLineNumber + 1;\n    for (let i = this.minimapLines.length - 1; i >= 0; i--) {\n      if (this.minimapLines[i] < e.fromLineNumber) {\n        break;\n      }\n      this.minimapLines[i] += insertedLineCount;\n    }\n  }\n}\nexport class Minimap extends ViewPart {\n  constructor(context) {\n    super(context);\n    this._sectionHeaderCache = new LRUCache(10, 1.5);\n    this.tokensColorTracker = MinimapTokensColorTracker.getInstance();\n    this._selections = [];\n    this._minimapSelections = null;\n    this.options = new MinimapOptions(this._context.configuration, this._context.theme, this.tokensColorTracker);\n    const [samplingState] = MinimapSamplingState.compute(this.options, this._context.viewModel.getLineCount(), null);\n    this._samplingState = samplingState;\n    this._shouldCheckSampling = false;\n    this._actual = new InnerMinimap(context.theme, this);\n  }\n  dispose() {\n    this._actual.dispose();\n    super.dispose();\n  }\n  getDomNode() {\n    return this._actual.getDomNode();\n  }\n  _onOptionsMaybeChanged() {\n    const opts = new MinimapOptions(this._context.configuration, this._context.theme, this.tokensColorTracker);\n    if (this.options.equals(opts)) {\n      return false;\n    }\n    this.options = opts;\n    this._recreateLineSampling();\n    this._actual.onDidChangeOptions();\n    return true;\n  }\n  // ---- begin view event handlers\n  onConfigurationChanged(e) {\n    return this._onOptionsMaybeChanged();\n  }\n  onCursorStateChanged(e) {\n    this._selections = e.selections;\n    this._minimapSelections = null;\n    return this._actual.onSelectionChanged();\n  }\n  onDecorationsChanged(e) {\n    if (e.affectsMinimap) {\n      return this._actual.onDecorationsChanged();\n    }\n    return false;\n  }\n  onFlushed(e) {\n    if (this._samplingState) {\n      this._shouldCheckSampling = true;\n    }\n    return this._actual.onFlushed();\n  }\n  onLinesChanged(e) {\n    if (this._samplingState) {\n      const minimapLineRange = this._samplingState.modelLineRangeToMinimapLineRange(e.fromLineNumber, e.fromLineNumber + e.count - 1);\n      if (minimapLineRange) {\n        return this._actual.onLinesChanged(minimapLineRange[0], minimapLineRange[1] - minimapLineRange[0] + 1);\n      } else {\n        return false;\n      }\n    } else {\n      return this._actual.onLinesChanged(e.fromLineNumber, e.count);\n    }\n  }\n  onLinesDeleted(e) {\n    if (this._samplingState) {\n      const [changeStartIndex, changeEndIndex] = this._samplingState.onLinesDeleted(e);\n      if (changeStartIndex <= changeEndIndex) {\n        this._actual.onLinesChanged(changeStartIndex + 1, changeEndIndex - changeStartIndex + 1);\n      }\n      this._shouldCheckSampling = true;\n      return true;\n    } else {\n      return this._actual.onLinesDeleted(e.fromLineNumber, e.toLineNumber);\n    }\n  }\n  onLinesInserted(e) {\n    if (this._samplingState) {\n      this._samplingState.onLinesInserted(e);\n      this._shouldCheckSampling = true;\n      return true;\n    } else {\n      return this._actual.onLinesInserted(e.fromLineNumber, e.toLineNumber);\n    }\n  }\n  onScrollChanged(e) {\n    return this._actual.onScrollChanged();\n  }\n  onThemeChanged(e) {\n    this._actual.onThemeChanged();\n    this._onOptionsMaybeChanged();\n    return true;\n  }\n  onTokensChanged(e) {\n    if (this._samplingState) {\n      const ranges = [];\n      for (const range of e.ranges) {\n        const minimapLineRange = this._samplingState.modelLineRangeToMinimapLineRange(range.fromLineNumber, range.toLineNumber);\n        if (minimapLineRange) {\n          ranges.push({\n            fromLineNumber: minimapLineRange[0],\n            toLineNumber: minimapLineRange[1]\n          });\n        }\n      }\n      if (ranges.length) {\n        return this._actual.onTokensChanged(ranges);\n      } else {\n        return false;\n      }\n    } else {\n      return this._actual.onTokensChanged(e.ranges);\n    }\n  }\n  onTokensColorsChanged(e) {\n    this._onOptionsMaybeChanged();\n    return this._actual.onTokensColorsChanged();\n  }\n  onZonesChanged(e) {\n    return this._actual.onZonesChanged();\n  }\n  // --- end event handlers\n  prepareRender(ctx) {\n    if (this._shouldCheckSampling) {\n      this._shouldCheckSampling = false;\n      this._recreateLineSampling();\n    }\n  }\n  render(ctx) {\n    let viewportStartLineNumber = ctx.visibleRange.startLineNumber;\n    let viewportEndLineNumber = ctx.visibleRange.endLineNumber;\n    if (this._samplingState) {\n      viewportStartLineNumber = this._samplingState.modelLineToMinimapLine(viewportStartLineNumber);\n      viewportEndLineNumber = this._samplingState.modelLineToMinimapLine(viewportEndLineNumber);\n    }\n    const minimapCtx = {\n      viewportContainsWhitespaceGaps: ctx.viewportData.whitespaceViewportData.length > 0,\n      scrollWidth: ctx.scrollWidth,\n      scrollHeight: ctx.scrollHeight,\n      viewportStartLineNumber: viewportStartLineNumber,\n      viewportEndLineNumber: viewportEndLineNumber,\n      viewportStartLineNumberVerticalOffset: ctx.getVerticalOffsetForLineNumber(viewportStartLineNumber),\n      scrollTop: ctx.scrollTop,\n      scrollLeft: ctx.scrollLeft,\n      viewportWidth: ctx.viewportWidth,\n      viewportHeight: ctx.viewportHeight\n    };\n    this._actual.render(minimapCtx);\n  }\n  //#region IMinimapModel\n  _recreateLineSampling() {\n    this._minimapSelections = null;\n    const wasSampling = Boolean(this._samplingState);\n    const [samplingState, events] = MinimapSamplingState.compute(this.options, this._context.viewModel.getLineCount(), this._samplingState);\n    this._samplingState = samplingState;\n    if (wasSampling && this._samplingState) {\n      // was sampling, is sampling\n      for (const event of events) {\n        switch (event.type) {\n          case 'deleted':\n            this._actual.onLinesDeleted(event.deleteFromLineNumber, event.deleteToLineNumber);\n            break;\n          case 'inserted':\n            this._actual.onLinesInserted(event.insertFromLineNumber, event.insertToLineNumber);\n            break;\n          case 'flush':\n            this._actual.onFlushed();\n            break;\n        }\n      }\n    }\n  }\n  getLineCount() {\n    if (this._samplingState) {\n      return this._samplingState.minimapLines.length;\n    }\n    return this._context.viewModel.getLineCount();\n  }\n  getRealLineCount() {\n    return this._context.viewModel.getLineCount();\n  }\n  getLineContent(lineNumber) {\n    if (this._samplingState) {\n      return this._context.viewModel.getLineContent(this._samplingState.minimapLines[lineNumber - 1]);\n    }\n    return this._context.viewModel.getLineContent(lineNumber);\n  }\n  getLineMaxColumn(lineNumber) {\n    if (this._samplingState) {\n      return this._context.viewModel.getLineMaxColumn(this._samplingState.minimapLines[lineNumber - 1]);\n    }\n    return this._context.viewModel.getLineMaxColumn(lineNumber);\n  }\n  getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed) {\n    if (this._samplingState) {\n      const result = [];\n      for (let lineIndex = 0, lineCount = endLineNumber - startLineNumber + 1; lineIndex < lineCount; lineIndex++) {\n        if (needed[lineIndex]) {\n          result[lineIndex] = this._context.viewModel.getViewLineData(this._samplingState.minimapLines[startLineNumber + lineIndex - 1]);\n        } else {\n          result[lineIndex] = null;\n        }\n      }\n      return result;\n    }\n    return this._context.viewModel.getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed).data;\n  }\n  getSelections() {\n    if (this._minimapSelections === null) {\n      if (this._samplingState) {\n        this._minimapSelections = [];\n        for (const selection of this._selections) {\n          const [minimapLineStart, minimapLineEnd] = this._samplingState.decorationLineRangeToMinimapLineRange(selection.startLineNumber, selection.endLineNumber);\n          this._minimapSelections.push(new Selection(minimapLineStart, selection.startColumn, minimapLineEnd, selection.endColumn));\n        }\n      } else {\n        this._minimapSelections = this._selections;\n      }\n    }\n    return this._minimapSelections;\n  }\n  getMinimapDecorationsInViewport(startLineNumber, endLineNumber) {\n    const decorations = this._getMinimapDecorationsInViewport(startLineNumber, endLineNumber).filter(decoration => {\n      var _a;\n      return !((_a = decoration.options.minimap) === null || _a === void 0 ? void 0 : _a.sectionHeaderStyle);\n    });\n    if (this._samplingState) {\n      const result = [];\n      for (const decoration of decorations) {\n        if (!decoration.options.minimap) {\n          continue;\n        }\n        const range = decoration.range;\n        const minimapStartLineNumber = this._samplingState.modelLineToMinimapLine(range.startLineNumber);\n        const minimapEndLineNumber = this._samplingState.modelLineToMinimapLine(range.endLineNumber);\n        result.push(new ViewModelDecoration(new Range(minimapStartLineNumber, range.startColumn, minimapEndLineNumber, range.endColumn), decoration.options));\n      }\n      return result;\n    }\n    return decorations;\n  }\n  getSectionHeaderDecorationsInViewport(startLineNumber, endLineNumber) {\n    const minimapLineHeight = this.options.minimapLineHeight;\n    const sectionHeaderFontSize = this.options.sectionHeaderFontSize;\n    const headerHeightInMinimapLines = sectionHeaderFontSize / minimapLineHeight;\n    startLineNumber = Math.floor(Math.max(1, startLineNumber - headerHeightInMinimapLines));\n    return this._getMinimapDecorationsInViewport(startLineNumber, endLineNumber).filter(decoration => {\n      var _a;\n      return !!((_a = decoration.options.minimap) === null || _a === void 0 ? void 0 : _a.sectionHeaderStyle);\n    });\n  }\n  _getMinimapDecorationsInViewport(startLineNumber, endLineNumber) {\n    let visibleRange;\n    if (this._samplingState) {\n      const modelStartLineNumber = this._samplingState.minimapLines[startLineNumber - 1];\n      const modelEndLineNumber = this._samplingState.minimapLines[endLineNumber - 1];\n      visibleRange = new Range(modelStartLineNumber, 1, modelEndLineNumber, this._context.viewModel.getLineMaxColumn(modelEndLineNumber));\n    } else {\n      visibleRange = new Range(startLineNumber, 1, endLineNumber, this._context.viewModel.getLineMaxColumn(endLineNumber));\n    }\n    return this._context.viewModel.getMinimapDecorationsInRange(visibleRange);\n  }\n  getSectionHeaderText(decoration, fitWidth) {\n    var _a;\n    const headerText = (_a = decoration.options.minimap) === null || _a === void 0 ? void 0 : _a.sectionHeaderText;\n    if (!headerText) {\n      return null;\n    }\n    const cachedText = this._sectionHeaderCache.get(headerText);\n    if (cachedText) {\n      return cachedText;\n    }\n    const fittedText = fitWidth(headerText);\n    this._sectionHeaderCache.set(headerText, fittedText);\n    return fittedText;\n  }\n  getOptions() {\n    return this._context.viewModel.model.getOptions();\n  }\n  revealLineNumber(lineNumber) {\n    if (this._samplingState) {\n      lineNumber = this._samplingState.minimapLines[lineNumber - 1];\n    }\n    this._context.viewModel.revealRange('mouse', false, new Range(lineNumber, 1, lineNumber, 1), 1 /* viewEvents.VerticalRevealType.Center */, 0 /* ScrollType.Smooth */);\n  }\n  setScrollTop(scrollTop) {\n    this._context.viewModel.viewLayout.setScrollPosition({\n      scrollTop: scrollTop\n    }, 1 /* ScrollType.Immediate */);\n  }\n}\nclass InnerMinimap extends Disposable {\n  constructor(theme, model) {\n    super();\n    this._renderDecorations = false;\n    this._gestureInProgress = false;\n    this._theme = theme;\n    this._model = model;\n    this._lastRenderData = null;\n    this._buffers = null;\n    this._selectionColor = this._theme.getColor(minimapSelection);\n    this._domNode = createFastDomNode(document.createElement('div'));\n    PartFingerprints.write(this._domNode, 9 /* PartFingerprint.Minimap */);\n    this._domNode.setClassName(this._getMinimapDomNodeClassName());\n    this._domNode.setPosition('absolute');\n    this._domNode.setAttribute('role', 'presentation');\n    this._domNode.setAttribute('aria-hidden', 'true');\n    this._shadow = createFastDomNode(document.createElement('div'));\n    this._shadow.setClassName('minimap-shadow-hidden');\n    this._domNode.appendChild(this._shadow);\n    this._canvas = createFastDomNode(document.createElement('canvas'));\n    this._canvas.setPosition('absolute');\n    this._canvas.setLeft(0);\n    this._domNode.appendChild(this._canvas);\n    this._decorationsCanvas = createFastDomNode(document.createElement('canvas'));\n    this._decorationsCanvas.setPosition('absolute');\n    this._decorationsCanvas.setClassName('minimap-decorations-layer');\n    this._decorationsCanvas.setLeft(0);\n    this._domNode.appendChild(this._decorationsCanvas);\n    this._slider = createFastDomNode(document.createElement('div'));\n    this._slider.setPosition('absolute');\n    this._slider.setClassName('minimap-slider');\n    this._slider.setLayerHinting(true);\n    this._slider.setContain('strict');\n    this._domNode.appendChild(this._slider);\n    this._sliderHorizontal = createFastDomNode(document.createElement('div'));\n    this._sliderHorizontal.setPosition('absolute');\n    this._sliderHorizontal.setClassName('minimap-slider-horizontal');\n    this._slider.appendChild(this._sliderHorizontal);\n    this._applyLayout();\n    this._pointerDownListener = dom.addStandardDisposableListener(this._domNode.domNode, dom.EventType.POINTER_DOWN, e => {\n      e.preventDefault();\n      const renderMinimap = this._model.options.renderMinimap;\n      if (renderMinimap === 0 /* RenderMinimap.None */) {\n        return;\n      }\n      if (!this._lastRenderData) {\n        return;\n      }\n      if (this._model.options.size !== 'proportional') {\n        if (e.button === 0 && this._lastRenderData) {\n          // pretend the click occurred in the center of the slider\n          const position = dom.getDomNodePagePosition(this._slider.domNode);\n          const initialPosY = position.top + position.height / 2;\n          this._startSliderDragging(e, initialPosY, this._lastRenderData.renderedLayout);\n        }\n        return;\n      }\n      const minimapLineHeight = this._model.options.minimapLineHeight;\n      const internalOffsetY = this._model.options.canvasInnerHeight / this._model.options.canvasOuterHeight * e.offsetY;\n      const lineIndex = Math.floor(internalOffsetY / minimapLineHeight);\n      let lineNumber = lineIndex + this._lastRenderData.renderedLayout.startLineNumber - this._lastRenderData.renderedLayout.topPaddingLineCount;\n      lineNumber = Math.min(lineNumber, this._model.getLineCount());\n      this._model.revealLineNumber(lineNumber);\n    });\n    this._sliderPointerMoveMonitor = new GlobalPointerMoveMonitor();\n    this._sliderPointerDownListener = dom.addStandardDisposableListener(this._slider.domNode, dom.EventType.POINTER_DOWN, e => {\n      e.preventDefault();\n      e.stopPropagation();\n      if (e.button === 0 && this._lastRenderData) {\n        this._startSliderDragging(e, e.pageY, this._lastRenderData.renderedLayout);\n      }\n    });\n    this._gestureDisposable = Gesture.addTarget(this._domNode.domNode);\n    this._sliderTouchStartListener = dom.addDisposableListener(this._domNode.domNode, EventType.Start, e => {\n      e.preventDefault();\n      e.stopPropagation();\n      if (this._lastRenderData) {\n        this._slider.toggleClassName('active', true);\n        this._gestureInProgress = true;\n        this.scrollDueToTouchEvent(e);\n      }\n    }, {\n      passive: false\n    });\n    this._sliderTouchMoveListener = dom.addDisposableListener(this._domNode.domNode, EventType.Change, e => {\n      e.preventDefault();\n      e.stopPropagation();\n      if (this._lastRenderData && this._gestureInProgress) {\n        this.scrollDueToTouchEvent(e);\n      }\n    }, {\n      passive: false\n    });\n    this._sliderTouchEndListener = dom.addStandardDisposableListener(this._domNode.domNode, EventType.End, e => {\n      e.preventDefault();\n      e.stopPropagation();\n      this._gestureInProgress = false;\n      this._slider.toggleClassName('active', false);\n    });\n  }\n  _startSliderDragging(e, initialPosY, initialSliderState) {\n    if (!e.target || !(e.target instanceof Element)) {\n      return;\n    }\n    const initialPosX = e.pageX;\n    this._slider.toggleClassName('active', true);\n    const handlePointerMove = (posy, posx) => {\n      const minimapPosition = dom.getDomNodePagePosition(this._domNode.domNode);\n      const pointerOrthogonalDelta = Math.min(Math.abs(posx - initialPosX), Math.abs(posx - minimapPosition.left), Math.abs(posx - minimapPosition.left - minimapPosition.width));\n      if (platform.isWindows && pointerOrthogonalDelta > POINTER_DRAG_RESET_DISTANCE) {\n        // The pointer has wondered away from the scrollbar => reset dragging\n        this._model.setScrollTop(initialSliderState.scrollTop);\n        return;\n      }\n      const pointerDelta = posy - initialPosY;\n      this._model.setScrollTop(initialSliderState.getDesiredScrollTopFromDelta(pointerDelta));\n    };\n    if (e.pageY !== initialPosY) {\n      handlePointerMove(e.pageY, initialPosX);\n    }\n    this._sliderPointerMoveMonitor.startMonitoring(e.target, e.pointerId, e.buttons, pointerMoveData => handlePointerMove(pointerMoveData.pageY, pointerMoveData.pageX), () => {\n      this._slider.toggleClassName('active', false);\n    });\n  }\n  scrollDueToTouchEvent(touch) {\n    const startY = this._domNode.domNode.getBoundingClientRect().top;\n    const scrollTop = this._lastRenderData.renderedLayout.getDesiredScrollTopFromTouchLocation(touch.pageY - startY);\n    this._model.setScrollTop(scrollTop);\n  }\n  dispose() {\n    this._pointerDownListener.dispose();\n    this._sliderPointerMoveMonitor.dispose();\n    this._sliderPointerDownListener.dispose();\n    this._gestureDisposable.dispose();\n    this._sliderTouchStartListener.dispose();\n    this._sliderTouchMoveListener.dispose();\n    this._sliderTouchEndListener.dispose();\n    super.dispose();\n  }\n  _getMinimapDomNodeClassName() {\n    const class_ = ['minimap'];\n    if (this._model.options.showSlider === 'always') {\n      class_.push('slider-always');\n    } else {\n      class_.push('slider-mouseover');\n    }\n    if (this._model.options.autohide) {\n      class_.push('autohide');\n    }\n    return class_.join(' ');\n  }\n  getDomNode() {\n    return this._domNode;\n  }\n  _applyLayout() {\n    this._domNode.setLeft(this._model.options.minimapLeft);\n    this._domNode.setWidth(this._model.options.minimapWidth);\n    this._domNode.setHeight(this._model.options.minimapHeight);\n    this._shadow.setHeight(this._model.options.minimapHeight);\n    this._canvas.setWidth(this._model.options.canvasOuterWidth);\n    this._canvas.setHeight(this._model.options.canvasOuterHeight);\n    this._canvas.domNode.width = this._model.options.canvasInnerWidth;\n    this._canvas.domNode.height = this._model.options.canvasInnerHeight;\n    this._decorationsCanvas.setWidth(this._model.options.canvasOuterWidth);\n    this._decorationsCanvas.setHeight(this._model.options.canvasOuterHeight);\n    this._decorationsCanvas.domNode.width = this._model.options.canvasInnerWidth;\n    this._decorationsCanvas.domNode.height = this._model.options.canvasInnerHeight;\n    this._slider.setWidth(this._model.options.minimapWidth);\n  }\n  _getBuffer() {\n    if (!this._buffers) {\n      if (this._model.options.canvasInnerWidth > 0 && this._model.options.canvasInnerHeight > 0) {\n        this._buffers = new MinimapBuffers(this._canvas.domNode.getContext('2d'), this._model.options.canvasInnerWidth, this._model.options.canvasInnerHeight, this._model.options.backgroundColor);\n      }\n    }\n    return this._buffers ? this._buffers.getBuffer() : null;\n  }\n  // ---- begin view event handlers\n  onDidChangeOptions() {\n    this._lastRenderData = null;\n    this._buffers = null;\n    this._applyLayout();\n    this._domNode.setClassName(this._getMinimapDomNodeClassName());\n  }\n  onSelectionChanged() {\n    this._renderDecorations = true;\n    return true;\n  }\n  onDecorationsChanged() {\n    this._renderDecorations = true;\n    return true;\n  }\n  onFlushed() {\n    this._lastRenderData = null;\n    return true;\n  }\n  onLinesChanged(changeFromLineNumber, changeCount) {\n    if (this._lastRenderData) {\n      return this._lastRenderData.onLinesChanged(changeFromLineNumber, changeCount);\n    }\n    return false;\n  }\n  onLinesDeleted(deleteFromLineNumber, deleteToLineNumber) {\n    var _a;\n    (_a = this._lastRenderData) === null || _a === void 0 ? void 0 : _a.onLinesDeleted(deleteFromLineNumber, deleteToLineNumber);\n    return true;\n  }\n  onLinesInserted(insertFromLineNumber, insertToLineNumber) {\n    var _a;\n    (_a = this._lastRenderData) === null || _a === void 0 ? void 0 : _a.onLinesInserted(insertFromLineNumber, insertToLineNumber);\n    return true;\n  }\n  onScrollChanged() {\n    this._renderDecorations = true;\n    return true;\n  }\n  onThemeChanged() {\n    this._selectionColor = this._theme.getColor(minimapSelection);\n    this._renderDecorations = true;\n    return true;\n  }\n  onTokensChanged(ranges) {\n    if (this._lastRenderData) {\n      return this._lastRenderData.onTokensChanged(ranges);\n    }\n    return false;\n  }\n  onTokensColorsChanged() {\n    this._lastRenderData = null;\n    this._buffers = null;\n    return true;\n  }\n  onZonesChanged() {\n    this._lastRenderData = null;\n    return true;\n  }\n  // --- end event handlers\n  render(renderingCtx) {\n    const renderMinimap = this._model.options.renderMinimap;\n    if (renderMinimap === 0 /* RenderMinimap.None */) {\n      this._shadow.setClassName('minimap-shadow-hidden');\n      this._sliderHorizontal.setWidth(0);\n      this._sliderHorizontal.setHeight(0);\n      return;\n    }\n    if (renderingCtx.scrollLeft + renderingCtx.viewportWidth >= renderingCtx.scrollWidth) {\n      this._shadow.setClassName('minimap-shadow-hidden');\n    } else {\n      this._shadow.setClassName('minimap-shadow-visible');\n    }\n    const layout = MinimapLayout.create(this._model.options, renderingCtx.viewportStartLineNumber, renderingCtx.viewportEndLineNumber, renderingCtx.viewportStartLineNumberVerticalOffset, renderingCtx.viewportHeight, renderingCtx.viewportContainsWhitespaceGaps, this._model.getLineCount(), this._model.getRealLineCount(), renderingCtx.scrollTop, renderingCtx.scrollHeight, this._lastRenderData ? this._lastRenderData.renderedLayout : null);\n    this._slider.setDisplay(layout.sliderNeeded ? 'block' : 'none');\n    this._slider.setTop(layout.sliderTop);\n    this._slider.setHeight(layout.sliderHeight);\n    // Compute horizontal slider coordinates\n    this._sliderHorizontal.setLeft(0);\n    this._sliderHorizontal.setWidth(this._model.options.minimapWidth);\n    this._sliderHorizontal.setTop(0);\n    this._sliderHorizontal.setHeight(layout.sliderHeight);\n    this.renderDecorations(layout);\n    this._lastRenderData = this.renderLines(layout);\n  }\n  renderDecorations(layout) {\n    if (this._renderDecorations) {\n      this._renderDecorations = false;\n      const selections = this._model.getSelections();\n      selections.sort(Range.compareRangesUsingStarts);\n      const decorations = this._model.getMinimapDecorationsInViewport(layout.startLineNumber, layout.endLineNumber);\n      decorations.sort((a, b) => (a.options.zIndex || 0) - (b.options.zIndex || 0));\n      const {\n        canvasInnerWidth,\n        canvasInnerHeight\n      } = this._model.options;\n      const minimapLineHeight = this._model.options.minimapLineHeight;\n      const minimapCharWidth = this._model.options.minimapCharWidth;\n      const tabSize = this._model.getOptions().tabSize;\n      const canvasContext = this._decorationsCanvas.domNode.getContext('2d');\n      canvasContext.clearRect(0, 0, canvasInnerWidth, canvasInnerHeight);\n      // We first need to render line highlights and then render decorations on top of those.\n      // But we need to pick a single color for each line, and use that as a line highlight.\n      // This needs to be the color of the decoration with the highest `zIndex`, but priority\n      // is given to the selection.\n      const highlightedLines = new ContiguousLineMap(layout.startLineNumber, layout.endLineNumber, false);\n      this._renderSelectionLineHighlights(canvasContext, selections, highlightedLines, layout, minimapLineHeight);\n      this._renderDecorationsLineHighlights(canvasContext, decorations, highlightedLines, layout, minimapLineHeight);\n      const lineOffsetMap = new ContiguousLineMap(layout.startLineNumber, layout.endLineNumber, null);\n      this._renderSelectionsHighlights(canvasContext, selections, lineOffsetMap, layout, minimapLineHeight, tabSize, minimapCharWidth, canvasInnerWidth);\n      this._renderDecorationsHighlights(canvasContext, decorations, lineOffsetMap, layout, minimapLineHeight, tabSize, minimapCharWidth, canvasInnerWidth);\n      this._renderSectionHeaders(layout);\n    }\n  }\n  _renderSelectionLineHighlights(canvasContext, selections, highlightedLines, layout, minimapLineHeight) {\n    if (!this._selectionColor || this._selectionColor.isTransparent()) {\n      return;\n    }\n    canvasContext.fillStyle = this._selectionColor.transparent(0.5).toString();\n    let y1 = 0;\n    let y2 = 0;\n    for (const selection of selections) {\n      const intersection = layout.intersectWithViewport(selection);\n      if (!intersection) {\n        // entirely outside minimap's viewport\n        continue;\n      }\n      const [startLineNumber, endLineNumber] = intersection;\n      for (let line = startLineNumber; line <= endLineNumber; line++) {\n        highlightedLines.set(line, true);\n      }\n      const yy1 = layout.getYForLineNumber(startLineNumber, minimapLineHeight);\n      const yy2 = layout.getYForLineNumber(endLineNumber, minimapLineHeight);\n      if (y2 >= yy1) {\n        // merge into previous\n        y2 = yy2;\n      } else {\n        if (y2 > y1) {\n          // flush\n          canvasContext.fillRect(MINIMAP_GUTTER_WIDTH, y1, canvasContext.canvas.width, y2 - y1);\n        }\n        y1 = yy1;\n        y2 = yy2;\n      }\n    }\n    if (y2 > y1) {\n      // flush\n      canvasContext.fillRect(MINIMAP_GUTTER_WIDTH, y1, canvasContext.canvas.width, y2 - y1);\n    }\n  }\n  _renderDecorationsLineHighlights(canvasContext, decorations, highlightedLines, layout, minimapLineHeight) {\n    const highlightColors = new Map();\n    // Loop backwards to hit first decorations with higher `zIndex`\n    for (let i = decorations.length - 1; i >= 0; i--) {\n      const decoration = decorations[i];\n      const minimapOptions = decoration.options.minimap;\n      if (!minimapOptions || minimapOptions.position !== 1 /* MinimapPosition.Inline */) {\n        continue;\n      }\n      const intersection = layout.intersectWithViewport(decoration.range);\n      if (!intersection) {\n        // entirely outside minimap's viewport\n        continue;\n      }\n      const [startLineNumber, endLineNumber] = intersection;\n      const decorationColor = minimapOptions.getColor(this._theme.value);\n      if (!decorationColor || decorationColor.isTransparent()) {\n        continue;\n      }\n      let highlightColor = highlightColors.get(decorationColor.toString());\n      if (!highlightColor) {\n        highlightColor = decorationColor.transparent(0.5).toString();\n        highlightColors.set(decorationColor.toString(), highlightColor);\n      }\n      canvasContext.fillStyle = highlightColor;\n      for (let line = startLineNumber; line <= endLineNumber; line++) {\n        if (highlightedLines.has(line)) {\n          continue;\n        }\n        highlightedLines.set(line, true);\n        const y = layout.getYForLineNumber(startLineNumber, minimapLineHeight);\n        canvasContext.fillRect(MINIMAP_GUTTER_WIDTH, y, canvasContext.canvas.width, minimapLineHeight);\n      }\n    }\n  }\n  _renderSelectionsHighlights(canvasContext, selections, lineOffsetMap, layout, lineHeight, tabSize, characterWidth, canvasInnerWidth) {\n    if (!this._selectionColor || this._selectionColor.isTransparent()) {\n      return;\n    }\n    for (const selection of selections) {\n      const intersection = layout.intersectWithViewport(selection);\n      if (!intersection) {\n        // entirely outside minimap's viewport\n        continue;\n      }\n      const [startLineNumber, endLineNumber] = intersection;\n      for (let line = startLineNumber; line <= endLineNumber; line++) {\n        this.renderDecorationOnLine(canvasContext, lineOffsetMap, selection, this._selectionColor, layout, line, lineHeight, lineHeight, tabSize, characterWidth, canvasInnerWidth);\n      }\n    }\n  }\n  _renderDecorationsHighlights(canvasContext, decorations, lineOffsetMap, layout, minimapLineHeight, tabSize, characterWidth, canvasInnerWidth) {\n    // Loop forwards to hit first decorations with lower `zIndex`\n    for (const decoration of decorations) {\n      const minimapOptions = decoration.options.minimap;\n      if (!minimapOptions) {\n        continue;\n      }\n      const intersection = layout.intersectWithViewport(decoration.range);\n      if (!intersection) {\n        // entirely outside minimap's viewport\n        continue;\n      }\n      const [startLineNumber, endLineNumber] = intersection;\n      const decorationColor = minimapOptions.getColor(this._theme.value);\n      if (!decorationColor || decorationColor.isTransparent()) {\n        continue;\n      }\n      for (let line = startLineNumber; line <= endLineNumber; line++) {\n        switch (minimapOptions.position) {\n          case 1 /* MinimapPosition.Inline */:\n            this.renderDecorationOnLine(canvasContext, lineOffsetMap, decoration.range, decorationColor, layout, line, minimapLineHeight, minimapLineHeight, tabSize, characterWidth, canvasInnerWidth);\n            continue;\n          case 2 /* MinimapPosition.Gutter */:\n            {\n              const y = layout.getYForLineNumber(line, minimapLineHeight);\n              const x = 2;\n              this.renderDecoration(canvasContext, decorationColor, x, y, GUTTER_DECORATION_WIDTH, minimapLineHeight);\n              continue;\n            }\n        }\n      }\n    }\n  }\n  renderDecorationOnLine(canvasContext, lineOffsetMap, decorationRange, decorationColor, layout, lineNumber, height, minimapLineHeight, tabSize, charWidth, canvasInnerWidth) {\n    const y = layout.getYForLineNumber(lineNumber, minimapLineHeight);\n    // Skip rendering the line if it's vertically outside our viewport\n    if (y + height < 0 || y > this._model.options.canvasInnerHeight) {\n      return;\n    }\n    const {\n      startLineNumber,\n      endLineNumber\n    } = decorationRange;\n    const startColumn = startLineNumber === lineNumber ? decorationRange.startColumn : 1;\n    const endColumn = endLineNumber === lineNumber ? decorationRange.endColumn : this._model.getLineMaxColumn(lineNumber);\n    const x1 = this.getXOffsetForPosition(lineOffsetMap, lineNumber, startColumn, tabSize, charWidth, canvasInnerWidth);\n    const x2 = this.getXOffsetForPosition(lineOffsetMap, lineNumber, endColumn, tabSize, charWidth, canvasInnerWidth);\n    this.renderDecoration(canvasContext, decorationColor, x1, y, x2 - x1, height);\n  }\n  getXOffsetForPosition(lineOffsetMap, lineNumber, column, tabSize, charWidth, canvasInnerWidth) {\n    if (column === 1) {\n      return MINIMAP_GUTTER_WIDTH;\n    }\n    const minimumXOffset = (column - 1) * charWidth;\n    if (minimumXOffset >= canvasInnerWidth) {\n      // there is no need to look at actual characters,\n      // as this column is certainly after the minimap width\n      return canvasInnerWidth;\n    }\n    // Cache line offset data so that it is only read once per line\n    let lineIndexToXOffset = lineOffsetMap.get(lineNumber);\n    if (!lineIndexToXOffset) {\n      const lineData = this._model.getLineContent(lineNumber);\n      lineIndexToXOffset = [MINIMAP_GUTTER_WIDTH];\n      let prevx = MINIMAP_GUTTER_WIDTH;\n      for (let i = 1; i < lineData.length + 1; i++) {\n        const charCode = lineData.charCodeAt(i - 1);\n        const dx = charCode === 9 /* CharCode.Tab */ ? tabSize * charWidth : strings.isFullWidthCharacter(charCode) ? 2 * charWidth : charWidth;\n        const x = prevx + dx;\n        if (x >= canvasInnerWidth) {\n          // no need to keep on going, as we've hit the canvas width\n          lineIndexToXOffset[i] = canvasInnerWidth;\n          break;\n        }\n        lineIndexToXOffset[i] = x;\n        prevx = x;\n      }\n      lineOffsetMap.set(lineNumber, lineIndexToXOffset);\n    }\n    if (column - 1 < lineIndexToXOffset.length) {\n      return lineIndexToXOffset[column - 1];\n    }\n    // goes over the canvas width\n    return canvasInnerWidth;\n  }\n  renderDecoration(canvasContext, decorationColor, x, y, width, height) {\n    canvasContext.fillStyle = decorationColor && decorationColor.toString() || '';\n    canvasContext.fillRect(x, y, width, height);\n  }\n  _renderSectionHeaders(layout) {\n    var _a;\n    const minimapLineHeight = this._model.options.minimapLineHeight;\n    const sectionHeaderFontSize = this._model.options.sectionHeaderFontSize;\n    const sectionHeaderLetterSpacing = this._model.options.sectionHeaderLetterSpacing;\n    const backgroundFillHeight = sectionHeaderFontSize * 1.5;\n    const {\n      canvasInnerWidth\n    } = this._model.options;\n    const backgroundColor = this._model.options.backgroundColor;\n    const backgroundFill = `rgb(${backgroundColor.r} ${backgroundColor.g} ${backgroundColor.b} / .7)`;\n    const foregroundColor = this._model.options.sectionHeaderFontColor;\n    const foregroundFill = `rgb(${foregroundColor.r} ${foregroundColor.g} ${foregroundColor.b})`;\n    const separatorStroke = foregroundFill;\n    const canvasContext = this._decorationsCanvas.domNode.getContext('2d');\n    canvasContext.letterSpacing = sectionHeaderLetterSpacing + 'px';\n    canvasContext.font = '500 ' + sectionHeaderFontSize + 'px ' + this._model.options.sectionHeaderFontFamily;\n    canvasContext.strokeStyle = separatorStroke;\n    canvasContext.lineWidth = 0.2;\n    const decorations = this._model.getSectionHeaderDecorationsInViewport(layout.startLineNumber, layout.endLineNumber);\n    decorations.sort((a, b) => a.range.startLineNumber - b.range.startLineNumber);\n    const fitWidth = InnerMinimap._fitSectionHeader.bind(null, canvasContext, canvasInnerWidth - MINIMAP_GUTTER_WIDTH);\n    for (const decoration of decorations) {\n      const y = layout.getYForLineNumber(decoration.range.startLineNumber, minimapLineHeight) + sectionHeaderFontSize;\n      const backgroundFillY = y - sectionHeaderFontSize;\n      const separatorY = backgroundFillY + 2;\n      const headerText = this._model.getSectionHeaderText(decoration, fitWidth);\n      InnerMinimap._renderSectionLabel(canvasContext, headerText, ((_a = decoration.options.minimap) === null || _a === void 0 ? void 0 : _a.sectionHeaderStyle) === 2 /* MinimapSectionHeaderStyle.Underlined */, backgroundFill, foregroundFill, canvasInnerWidth, backgroundFillY, backgroundFillHeight, y, separatorY);\n    }\n  }\n  static _fitSectionHeader(target, maxWidth, headerText) {\n    if (!headerText) {\n      return headerText;\n    }\n    const ellipsis = '…';\n    const width = target.measureText(headerText).width;\n    const ellipsisWidth = target.measureText(ellipsis).width;\n    if (width <= maxWidth || width <= ellipsisWidth) {\n      return headerText;\n    }\n    const len = headerText.length;\n    const averageCharWidth = width / headerText.length;\n    const maxCharCount = Math.floor((maxWidth - ellipsisWidth) / averageCharWidth) - 1;\n    // Find a halfway point that isn't after whitespace\n    let halfCharCount = Math.ceil(maxCharCount / 2);\n    while (halfCharCount > 0 && /\\s/.test(headerText[halfCharCount - 1])) {\n      --halfCharCount;\n    }\n    // Split with ellipsis\n    return headerText.substring(0, halfCharCount) + ellipsis + headerText.substring(len - (maxCharCount - halfCharCount));\n  }\n  static _renderSectionLabel(target, headerText, hasSeparatorLine, backgroundFill, foregroundFill, minimapWidth, backgroundFillY, backgroundFillHeight, textY, separatorY) {\n    if (headerText) {\n      target.fillStyle = backgroundFill;\n      target.fillRect(0, backgroundFillY, minimapWidth, backgroundFillHeight);\n      target.fillStyle = foregroundFill;\n      target.fillText(headerText, MINIMAP_GUTTER_WIDTH, textY);\n    }\n    if (hasSeparatorLine) {\n      target.beginPath();\n      target.moveTo(0, separatorY);\n      target.lineTo(minimapWidth, separatorY);\n      target.closePath();\n      target.stroke();\n    }\n  }\n  renderLines(layout) {\n    const startLineNumber = layout.startLineNumber;\n    const endLineNumber = layout.endLineNumber;\n    const minimapLineHeight = this._model.options.minimapLineHeight;\n    // Check if nothing changed w.r.t. lines from last frame\n    if (this._lastRenderData && this._lastRenderData.linesEquals(layout)) {\n      const _lastData = this._lastRenderData._get();\n      // Nice!! Nothing changed from last frame\n      return new RenderData(layout, _lastData.imageData, _lastData.lines);\n    }\n    // Oh well!! We need to repaint some lines...\n    const imageData = this._getBuffer();\n    if (!imageData) {\n      // 0 width or 0 height canvas, nothing to do\n      return null;\n    }\n    // Render untouched lines by using last rendered data.\n    const [_dirtyY1, _dirtyY2, needed] = InnerMinimap._renderUntouchedLines(imageData, layout.topPaddingLineCount, startLineNumber, endLineNumber, minimapLineHeight, this._lastRenderData);\n    // Fetch rendering info from view model for rest of lines that need rendering.\n    const lineInfo = this._model.getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed);\n    const tabSize = this._model.getOptions().tabSize;\n    const defaultBackground = this._model.options.defaultBackgroundColor;\n    const background = this._model.options.backgroundColor;\n    const foregroundAlpha = this._model.options.foregroundAlpha;\n    const tokensColorTracker = this._model.tokensColorTracker;\n    const useLighterFont = tokensColorTracker.backgroundIsLight();\n    const renderMinimap = this._model.options.renderMinimap;\n    const charRenderer = this._model.options.charRenderer();\n    const fontScale = this._model.options.fontScale;\n    const minimapCharWidth = this._model.options.minimapCharWidth;\n    const baseCharHeight = renderMinimap === 1 /* RenderMinimap.Text */ ? 2 /* Constants.BASE_CHAR_HEIGHT */ : 2 /* Constants.BASE_CHAR_HEIGHT */ + 1;\n    const renderMinimapLineHeight = baseCharHeight * fontScale;\n    const innerLinePadding = minimapLineHeight > renderMinimapLineHeight ? Math.floor((minimapLineHeight - renderMinimapLineHeight) / 2) : 0;\n    // Render the rest of lines\n    const backgroundA = background.a / 255;\n    const renderBackground = new RGBA8(Math.round((background.r - defaultBackground.r) * backgroundA + defaultBackground.r), Math.round((background.g - defaultBackground.g) * backgroundA + defaultBackground.g), Math.round((background.b - defaultBackground.b) * backgroundA + defaultBackground.b), 255);\n    let dy = layout.topPaddingLineCount * minimapLineHeight;\n    const renderedLines = [];\n    for (let lineIndex = 0, lineCount = endLineNumber - startLineNumber + 1; lineIndex < lineCount; lineIndex++) {\n      if (needed[lineIndex]) {\n        InnerMinimap._renderLine(imageData, renderBackground, background.a, useLighterFont, renderMinimap, minimapCharWidth, tokensColorTracker, foregroundAlpha, charRenderer, dy, innerLinePadding, tabSize, lineInfo[lineIndex], fontScale, minimapLineHeight);\n      }\n      renderedLines[lineIndex] = new MinimapLine(dy);\n      dy += minimapLineHeight;\n    }\n    const dirtyY1 = _dirtyY1 === -1 ? 0 : _dirtyY1;\n    const dirtyY2 = _dirtyY2 === -1 ? imageData.height : _dirtyY2;\n    const dirtyHeight = dirtyY2 - dirtyY1;\n    // Finally, paint to the canvas\n    const ctx = this._canvas.domNode.getContext('2d');\n    ctx.putImageData(imageData, 0, 0, 0, dirtyY1, imageData.width, dirtyHeight);\n    // Save rendered data for reuse on next frame if possible\n    return new RenderData(layout, imageData, renderedLines);\n  }\n  static _renderUntouchedLines(target, topPaddingLineCount, startLineNumber, endLineNumber, minimapLineHeight, lastRenderData) {\n    const needed = [];\n    if (!lastRenderData) {\n      for (let i = 0, len = endLineNumber - startLineNumber + 1; i < len; i++) {\n        needed[i] = true;\n      }\n      return [-1, -1, needed];\n    }\n    const _lastData = lastRenderData._get();\n    const lastTargetData = _lastData.imageData.data;\n    const lastStartLineNumber = _lastData.rendLineNumberStart;\n    const lastLines = _lastData.lines;\n    const lastLinesLength = lastLines.length;\n    const WIDTH = target.width;\n    const targetData = target.data;\n    const maxDestPixel = (endLineNumber - startLineNumber + 1) * minimapLineHeight * WIDTH * 4;\n    let dirtyPixel1 = -1; // the pixel offset up to which all the data is equal to the prev frame\n    let dirtyPixel2 = -1; // the pixel offset after which all the data is equal to the prev frame\n    let copySourceStart = -1;\n    let copySourceEnd = -1;\n    let copyDestStart = -1;\n    let copyDestEnd = -1;\n    let dest_dy = topPaddingLineCount * minimapLineHeight;\n    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n      const lineIndex = lineNumber - startLineNumber;\n      const lastLineIndex = lineNumber - lastStartLineNumber;\n      const source_dy = lastLineIndex >= 0 && lastLineIndex < lastLinesLength ? lastLines[lastLineIndex].dy : -1;\n      if (source_dy === -1) {\n        needed[lineIndex] = true;\n        dest_dy += minimapLineHeight;\n        continue;\n      }\n      const sourceStart = source_dy * WIDTH * 4;\n      const sourceEnd = (source_dy + minimapLineHeight) * WIDTH * 4;\n      const destStart = dest_dy * WIDTH * 4;\n      const destEnd = (dest_dy + minimapLineHeight) * WIDTH * 4;\n      if (copySourceEnd === sourceStart && copyDestEnd === destStart) {\n        // contiguous zone => extend copy request\n        copySourceEnd = sourceEnd;\n        copyDestEnd = destEnd;\n      } else {\n        if (copySourceStart !== -1) {\n          // flush existing copy request\n          targetData.set(lastTargetData.subarray(copySourceStart, copySourceEnd), copyDestStart);\n          if (dirtyPixel1 === -1 && copySourceStart === 0 && copySourceStart === copyDestStart) {\n            dirtyPixel1 = copySourceEnd;\n          }\n          if (dirtyPixel2 === -1 && copySourceEnd === maxDestPixel && copySourceStart === copyDestStart) {\n            dirtyPixel2 = copySourceStart;\n          }\n        }\n        copySourceStart = sourceStart;\n        copySourceEnd = sourceEnd;\n        copyDestStart = destStart;\n        copyDestEnd = destEnd;\n      }\n      needed[lineIndex] = false;\n      dest_dy += minimapLineHeight;\n    }\n    if (copySourceStart !== -1) {\n      // flush existing copy request\n      targetData.set(lastTargetData.subarray(copySourceStart, copySourceEnd), copyDestStart);\n      if (dirtyPixel1 === -1 && copySourceStart === 0 && copySourceStart === copyDestStart) {\n        dirtyPixel1 = copySourceEnd;\n      }\n      if (dirtyPixel2 === -1 && copySourceEnd === maxDestPixel && copySourceStart === copyDestStart) {\n        dirtyPixel2 = copySourceStart;\n      }\n    }\n    const dirtyY1 = dirtyPixel1 === -1 ? -1 : dirtyPixel1 / (WIDTH * 4);\n    const dirtyY2 = dirtyPixel2 === -1 ? -1 : dirtyPixel2 / (WIDTH * 4);\n    return [dirtyY1, dirtyY2, needed];\n  }\n  static _renderLine(target, backgroundColor, backgroundAlpha, useLighterFont, renderMinimap, charWidth, colorTracker, foregroundAlpha, minimapCharRenderer, dy, innerLinePadding, tabSize, lineData, fontScale, minimapLineHeight) {\n    const content = lineData.content;\n    const tokens = lineData.tokens;\n    const maxDx = target.width - charWidth;\n    const force1pxHeight = minimapLineHeight === 1;\n    let dx = MINIMAP_GUTTER_WIDTH;\n    let charIndex = 0;\n    let tabsCharDelta = 0;\n    for (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n      const tokenEndIndex = tokens.getEndOffset(tokenIndex);\n      const tokenColorId = tokens.getForeground(tokenIndex);\n      const tokenColor = colorTracker.getColor(tokenColorId);\n      for (; charIndex < tokenEndIndex; charIndex++) {\n        if (dx > maxDx) {\n          // hit edge of minimap\n          return;\n        }\n        const charCode = content.charCodeAt(charIndex);\n        if (charCode === 9 /* CharCode.Tab */) {\n          const insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;\n          tabsCharDelta += insertSpacesCount - 1;\n          // No need to render anything since tab is invisible\n          dx += insertSpacesCount * charWidth;\n        } else if (charCode === 32 /* CharCode.Space */) {\n          // No need to render anything since space is invisible\n          dx += charWidth;\n        } else {\n          // Render twice for a full width character\n          const count = strings.isFullWidthCharacter(charCode) ? 2 : 1;\n          for (let i = 0; i < count; i++) {\n            if (renderMinimap === 2 /* RenderMinimap.Blocks */) {\n              minimapCharRenderer.blockRenderChar(target, dx, dy + innerLinePadding, tokenColor, foregroundAlpha, backgroundColor, backgroundAlpha, force1pxHeight);\n            } else {\n              // RenderMinimap.Text\n              minimapCharRenderer.renderChar(target, dx, dy + innerLinePadding, charCode, tokenColor, foregroundAlpha, backgroundColor, backgroundAlpha, fontScale, useLighterFont, force1pxHeight);\n            }\n            dx += charWidth;\n            if (dx > maxDx) {\n              // hit edge of minimap\n              return;\n            }\n          }\n        }\n      }\n    }\n  }\n}\nclass ContiguousLineMap {\n  constructor(startLineNumber, endLineNumber, defaultValue) {\n    this._startLineNumber = startLineNumber;\n    this._endLineNumber = endLineNumber;\n    this._defaultValue = defaultValue;\n    this._values = [];\n    for (let i = 0, count = this._endLineNumber - this._startLineNumber + 1; i < count; i++) {\n      this._values[i] = defaultValue;\n    }\n  }\n  has(lineNumber) {\n    return this.get(lineNumber) !== this._defaultValue;\n  }\n  set(lineNumber, value) {\n    if (lineNumber < this._startLineNumber || lineNumber > this._endLineNumber) {\n      return;\n    }\n    this._values[lineNumber - this._startLineNumber] = value;\n  }\n  get(lineNumber) {\n    if (lineNumber < this._startLineNumber || lineNumber > this._endLineNumber) {\n      return this._defaultValue;\n    }\n    return this._values[lineNumber - this._startLineNumber];\n  }\n}","map":{"version":3,"names":["dom","createFastDomNode","GlobalPointerMoveMonitor","Disposable","platform","strings","RenderedLinesCollection","PartFingerprints","ViewPart","MINIMAP_GUTTER_WIDTH","EditorLayoutInfoComputer","Range","RGBA8","MinimapTokensColorTracker","ViewModelDecoration","minimapSelection","minimapBackground","minimapForegroundOpacity","editorForeground","Selection","EventType","Gesture","MinimapCharRendererFactory","createSingleCallFunction","LRUCache","DEFAULT_FONT_FAMILY","POINTER_DRAG_RESET_DISTANCE","GUTTER_DECORATION_WIDTH","MinimapOptions","constructor","configuration","theme","tokensColorTracker","options","pixelRatio","get","layoutInfo","minimapLayout","minimap","fontInfo","minimapOpts","renderMinimap","size","minimapHeightIsEditorHeight","scrollBeyondLastLine","paddingTop","top","paddingBottom","bottom","showSlider","autohide","typicalHalfwidthCharacterWidth","lineHeight","minimapLeft","minimapWidth","minimapHeight","height","canvasInnerWidth","minimapCanvasInnerWidth","canvasInnerHeight","minimapCanvasInnerHeight","canvasOuterWidth","minimapCanvasOuterWidth","canvasOuterHeight","minimapCanvasOuterHeight","isSampling","minimapIsSampling","editorHeight","fontScale","minimapScale","minimapLineHeight","minimapCharWidth","sectionHeaderFontFamily","sectionHeaderFontSize","sectionHeaderLetterSpacing","sectionHeaderFontColor","_getSectionHeaderColor","getColor","charRenderer","create","fontFamily","defaultBackgroundColor","backgroundColor","_getMinimapBackground","foregroundAlpha","_getMinimapForegroundOpacity","themeColor","rgba","r","g","b","Math","round","a","_clamp","defaultForegroundColor","equals","other","MinimapLayout","scrollTop","scrollHeight","sliderNeeded","_computedSliderRatio","sliderTop","sliderHeight","topPaddingLineCount","startLineNumber","endLineNumber","getDesiredScrollTopFromDelta","delta","getDesiredScrollTopFromTouchLocation","pageY","intersectWithViewport","range","max","min","getYForLineNumber","lineNumber","viewportStartLineNumber","viewportEndLineNumber","viewportStartLineNumberVerticalOffset","viewportHeight","viewportContainsWhitespaceGaps","lineCount","realLineCount","previousLayout","minimapLinesFitting","floor","logicalScrollHeight","maxMinimapSliderTop","computedSliderRatio","maxLinesFitting","viewportLineCount","expectedViewportLineCount","extraLinesAtTheTop","extraLinesAtTheBottom","consideringStartLineNumber","partialLine","sliderTopAligned","MinimapLine","dy","onContentChanged","onTokensChanged","INVALID","RenderData","renderedLayout","imageData","lines","_imageData","_renderedLines","_set","linesEquals","layout","scrollEquals","tmp","_get","i","len","length","rendLineNumberStart","onLinesChanged","changeFromLineNumber","changeCount","onLinesDeleted","deleteFromLineNumber","deleteToLineNumber","onLinesInserted","insertFromLineNumber","insertToLineNumber","ranges","MinimapBuffers","ctx","WIDTH","HEIGHT","background","_backgroundFillData","_createBackgroundFillData","_buffers","createImageData","_lastUsedBuffer","getBuffer","result","data","set","backgroundR","backgroundG","backgroundB","backgroundA","Uint8ClampedArray","offset","j","MinimapSamplingState","compute","viewLineCount","oldSamplingState","minimapLineCount","computeContainedMinimapLineCount","ratio","halfRatio","minimapLines","lastIndex","oldMinimapLines","oldLength","oldIndex","oldDeltaLineCount","minViewLineNumber","MAX_EVENT_COUNT","events","lastEvent","fromViewLineNumber","toViewLineNumber","oldMinimapLineNumber","type","_oldIndex","push","selectedViewLineNumber","_i","samplingRatio","modelLineToMinimapLine","modelLineRangeToMinimapLineRange","fromLineNumber","toLineNumber","fromLineIndex","toLineIndex","sampledLineNumber","decorationLineRangeToMinimapLineRange","minimapLineStart","minimapLineEnd","e","deletedLineCount","changeStartIndex","changeEndIndex","insertedLineCount","Minimap","context","_sectionHeaderCache","getInstance","_selections","_minimapSelections","_context","samplingState","viewModel","getLineCount","_samplingState","_shouldCheckSampling","_actual","InnerMinimap","dispose","getDomNode","_onOptionsMaybeChanged","opts","_recreateLineSampling","onDidChangeOptions","onConfigurationChanged","onCursorStateChanged","selections","onSelectionChanged","onDecorationsChanged","affectsMinimap","onFlushed","minimapLineRange","count","onScrollChanged","onThemeChanged","onTokensColorsChanged","onZonesChanged","prepareRender","render","visibleRange","minimapCtx","viewportData","whitespaceViewportData","scrollWidth","getVerticalOffsetForLineNumber","scrollLeft","viewportWidth","wasSampling","Boolean","event","getRealLineCount","getLineContent","getLineMaxColumn","getMinimapLinesRenderingData","needed","lineIndex","getViewLineData","getSelections","selection","startColumn","endColumn","getMinimapDecorationsInViewport","decorations","_getMinimapDecorationsInViewport","filter","decoration","_a","sectionHeaderStyle","minimapStartLineNumber","minimapEndLineNumber","getSectionHeaderDecorationsInViewport","headerHeightInMinimapLines","modelStartLineNumber","modelEndLineNumber","getMinimapDecorationsInRange","getSectionHeaderText","fitWidth","headerText","sectionHeaderText","cachedText","fittedText","getOptions","model","revealLineNumber","revealRange","setScrollTop","viewLayout","setScrollPosition","_renderDecorations","_gestureInProgress","_theme","_model","_lastRenderData","_selectionColor","_domNode","document","createElement","write","setClassName","_getMinimapDomNodeClassName","setPosition","setAttribute","_shadow","appendChild","_canvas","setLeft","_decorationsCanvas","_slider","setLayerHinting","setContain","_sliderHorizontal","_applyLayout","_pointerDownListener","addStandardDisposableListener","domNode","POINTER_DOWN","preventDefault","button","position","getDomNodePagePosition","initialPosY","_startSliderDragging","internalOffsetY","offsetY","_sliderPointerMoveMonitor","_sliderPointerDownListener","stopPropagation","_gestureDisposable","addTarget","_sliderTouchStartListener","addDisposableListener","Start","toggleClassName","scrollDueToTouchEvent","passive","_sliderTouchMoveListener","Change","_sliderTouchEndListener","End","initialSliderState","target","Element","initialPosX","pageX","handlePointerMove","posy","posx","minimapPosition","pointerOrthogonalDelta","abs","left","width","isWindows","pointerDelta","startMonitoring","pointerId","buttons","pointerMoveData","touch","startY","getBoundingClientRect","class_","join","setWidth","setHeight","_getBuffer","getContext","renderingCtx","setDisplay","setTop","renderDecorations","renderLines","sort","compareRangesUsingStarts","zIndex","tabSize","canvasContext","clearRect","highlightedLines","ContiguousLineMap","_renderSelectionLineHighlights","_renderDecorationsLineHighlights","lineOffsetMap","_renderSelectionsHighlights","_renderDecorationsHighlights","_renderSectionHeaders","isTransparent","fillStyle","transparent","toString","y1","y2","intersection","line","yy1","yy2","fillRect","canvas","highlightColors","Map","minimapOptions","decorationColor","value","highlightColor","has","y","characterWidth","renderDecorationOnLine","x","renderDecoration","decorationRange","charWidth","x1","getXOffsetForPosition","x2","column","minimumXOffset","lineIndexToXOffset","lineData","prevx","charCode","charCodeAt","dx","isFullWidthCharacter","backgroundFillHeight","backgroundFill","foregroundColor","foregroundFill","separatorStroke","letterSpacing","font","strokeStyle","lineWidth","_fitSectionHeader","bind","backgroundFillY","separatorY","_renderSectionLabel","maxWidth","ellipsis","measureText","ellipsisWidth","averageCharWidth","maxCharCount","halfCharCount","ceil","test","substring","hasSeparatorLine","textY","fillText","beginPath","moveTo","lineTo","closePath","stroke","_lastData","_dirtyY1","_dirtyY2","_renderUntouchedLines","lineInfo","defaultBackground","useLighterFont","backgroundIsLight","baseCharHeight","renderMinimapLineHeight","innerLinePadding","renderBackground","renderedLines","_renderLine","dirtyY1","dirtyY2","dirtyHeight","putImageData","lastRenderData","lastTargetData","lastStartLineNumber","lastLines","lastLinesLength","targetData","maxDestPixel","dirtyPixel1","dirtyPixel2","copySourceStart","copySourceEnd","copyDestStart","copyDestEnd","dest_dy","lastLineIndex","source_dy","sourceStart","sourceEnd","destStart","destEnd","subarray","backgroundAlpha","colorTracker","minimapCharRenderer","content","tokens","maxDx","force1pxHeight","charIndex","tabsCharDelta","tokenIndex","tokensLen","getCount","tokenEndIndex","getEndOffset","tokenColorId","getForeground","tokenColor","insertSpacesCount","blockRenderChar","renderChar","defaultValue","_startLineNumber","_endLineNumber","_defaultValue","_values"],"sources":["/home/arslan/modojo/node_modules/monaco-editor/esm/vs/editor/browser/viewParts/minimap/minimap.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './minimap.css';\nimport * as dom from '../../../../base/browser/dom.js';\nimport { createFastDomNode } from '../../../../base/browser/fastDomNode.js';\nimport { GlobalPointerMoveMonitor } from '../../../../base/browser/globalPointerMoveMonitor.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport * as platform from '../../../../base/common/platform.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { RenderedLinesCollection } from '../../view/viewLayer.js';\nimport { PartFingerprints, ViewPart } from '../../view/viewPart.js';\nimport { MINIMAP_GUTTER_WIDTH, EditorLayoutInfoComputer } from '../../../common/config/editorOptions.js';\nimport { Range } from '../../../common/core/range.js';\nimport { RGBA8 } from '../../../common/core/rgba.js';\nimport { MinimapTokensColorTracker } from '../../../common/viewModel/minimapTokensColorTracker.js';\nimport { ViewModelDecoration } from '../../../common/viewModel.js';\nimport { minimapSelection, minimapBackground, minimapForegroundOpacity, editorForeground } from '../../../../platform/theme/common/colorRegistry.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { EventType, Gesture } from '../../../../base/browser/touch.js';\nimport { MinimapCharRendererFactory } from './minimapCharRendererFactory.js';\nimport { createSingleCallFunction } from '../../../../base/common/functional.js';\nimport { LRUCache } from '../../../../base/common/map.js';\nimport { DEFAULT_FONT_FAMILY } from '../../../../base/browser/fonts.js';\n/**\n * The orthogonal distance to the slider at which dragging \"resets\". This implements \"snapping\"\n */\nconst POINTER_DRAG_RESET_DISTANCE = 140;\nconst GUTTER_DECORATION_WIDTH = 2;\nclass MinimapOptions {\n    constructor(configuration, theme, tokensColorTracker) {\n        const options = configuration.options;\n        const pixelRatio = options.get(143 /* EditorOption.pixelRatio */);\n        const layoutInfo = options.get(145 /* EditorOption.layoutInfo */);\n        const minimapLayout = layoutInfo.minimap;\n        const fontInfo = options.get(50 /* EditorOption.fontInfo */);\n        const minimapOpts = options.get(73 /* EditorOption.minimap */);\n        this.renderMinimap = minimapLayout.renderMinimap;\n        this.size = minimapOpts.size;\n        this.minimapHeightIsEditorHeight = minimapLayout.minimapHeightIsEditorHeight;\n        this.scrollBeyondLastLine = options.get(105 /* EditorOption.scrollBeyondLastLine */);\n        this.paddingTop = options.get(84 /* EditorOption.padding */).top;\n        this.paddingBottom = options.get(84 /* EditorOption.padding */).bottom;\n        this.showSlider = minimapOpts.showSlider;\n        this.autohide = minimapOpts.autohide;\n        this.pixelRatio = pixelRatio;\n        this.typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\n        this.lineHeight = options.get(67 /* EditorOption.lineHeight */);\n        this.minimapLeft = minimapLayout.minimapLeft;\n        this.minimapWidth = minimapLayout.minimapWidth;\n        this.minimapHeight = layoutInfo.height;\n        this.canvasInnerWidth = minimapLayout.minimapCanvasInnerWidth;\n        this.canvasInnerHeight = minimapLayout.minimapCanvasInnerHeight;\n        this.canvasOuterWidth = minimapLayout.minimapCanvasOuterWidth;\n        this.canvasOuterHeight = minimapLayout.minimapCanvasOuterHeight;\n        this.isSampling = minimapLayout.minimapIsSampling;\n        this.editorHeight = layoutInfo.height;\n        this.fontScale = minimapLayout.minimapScale;\n        this.minimapLineHeight = minimapLayout.minimapLineHeight;\n        this.minimapCharWidth = 1 /* Constants.BASE_CHAR_WIDTH */ * this.fontScale;\n        this.sectionHeaderFontFamily = DEFAULT_FONT_FAMILY;\n        this.sectionHeaderFontSize = minimapOpts.sectionHeaderFontSize * pixelRatio;\n        this.sectionHeaderLetterSpacing = minimapOpts.sectionHeaderLetterSpacing; // intentionally not multiplying by pixelRatio\n        this.sectionHeaderFontColor = MinimapOptions._getSectionHeaderColor(theme, tokensColorTracker.getColor(1 /* ColorId.DefaultForeground */));\n        this.charRenderer = createSingleCallFunction(() => MinimapCharRendererFactory.create(this.fontScale, fontInfo.fontFamily));\n        this.defaultBackgroundColor = tokensColorTracker.getColor(2 /* ColorId.DefaultBackground */);\n        this.backgroundColor = MinimapOptions._getMinimapBackground(theme, this.defaultBackgroundColor);\n        this.foregroundAlpha = MinimapOptions._getMinimapForegroundOpacity(theme);\n    }\n    static _getMinimapBackground(theme, defaultBackgroundColor) {\n        const themeColor = theme.getColor(minimapBackground);\n        if (themeColor) {\n            return new RGBA8(themeColor.rgba.r, themeColor.rgba.g, themeColor.rgba.b, Math.round(255 * themeColor.rgba.a));\n        }\n        return defaultBackgroundColor;\n    }\n    static _getMinimapForegroundOpacity(theme) {\n        const themeColor = theme.getColor(minimapForegroundOpacity);\n        if (themeColor) {\n            return RGBA8._clamp(Math.round(255 * themeColor.rgba.a));\n        }\n        return 255;\n    }\n    static _getSectionHeaderColor(theme, defaultForegroundColor) {\n        const themeColor = theme.getColor(editorForeground);\n        if (themeColor) {\n            return new RGBA8(themeColor.rgba.r, themeColor.rgba.g, themeColor.rgba.b, Math.round(255 * themeColor.rgba.a));\n        }\n        return defaultForegroundColor;\n    }\n    equals(other) {\n        return (this.renderMinimap === other.renderMinimap\n            && this.size === other.size\n            && this.minimapHeightIsEditorHeight === other.minimapHeightIsEditorHeight\n            && this.scrollBeyondLastLine === other.scrollBeyondLastLine\n            && this.paddingTop === other.paddingTop\n            && this.paddingBottom === other.paddingBottom\n            && this.showSlider === other.showSlider\n            && this.autohide === other.autohide\n            && this.pixelRatio === other.pixelRatio\n            && this.typicalHalfwidthCharacterWidth === other.typicalHalfwidthCharacterWidth\n            && this.lineHeight === other.lineHeight\n            && this.minimapLeft === other.minimapLeft\n            && this.minimapWidth === other.minimapWidth\n            && this.minimapHeight === other.minimapHeight\n            && this.canvasInnerWidth === other.canvasInnerWidth\n            && this.canvasInnerHeight === other.canvasInnerHeight\n            && this.canvasOuterWidth === other.canvasOuterWidth\n            && this.canvasOuterHeight === other.canvasOuterHeight\n            && this.isSampling === other.isSampling\n            && this.editorHeight === other.editorHeight\n            && this.fontScale === other.fontScale\n            && this.minimapLineHeight === other.minimapLineHeight\n            && this.minimapCharWidth === other.minimapCharWidth\n            && this.sectionHeaderFontSize === other.sectionHeaderFontSize\n            && this.sectionHeaderLetterSpacing === other.sectionHeaderLetterSpacing\n            && this.defaultBackgroundColor && this.defaultBackgroundColor.equals(other.defaultBackgroundColor)\n            && this.backgroundColor && this.backgroundColor.equals(other.backgroundColor)\n            && this.foregroundAlpha === other.foregroundAlpha);\n    }\n}\nclass MinimapLayout {\n    constructor(\n    /**\n     * The given editor scrollTop (input).\n     */\n    scrollTop, \n    /**\n     * The given editor scrollHeight (input).\n     */\n    scrollHeight, sliderNeeded, _computedSliderRatio, \n    /**\n     * slider dom node top (in CSS px)\n     */\n    sliderTop, \n    /**\n     * slider dom node height (in CSS px)\n     */\n    sliderHeight, \n    /**\n     * empty lines to reserve at the top of the minimap.\n     */\n    topPaddingLineCount, \n    /**\n     * minimap render start line number.\n     */\n    startLineNumber, \n    /**\n     * minimap render end line number.\n     */\n    endLineNumber) {\n        this.scrollTop = scrollTop;\n        this.scrollHeight = scrollHeight;\n        this.sliderNeeded = sliderNeeded;\n        this._computedSliderRatio = _computedSliderRatio;\n        this.sliderTop = sliderTop;\n        this.sliderHeight = sliderHeight;\n        this.topPaddingLineCount = topPaddingLineCount;\n        this.startLineNumber = startLineNumber;\n        this.endLineNumber = endLineNumber;\n    }\n    /**\n     * Compute a desired `scrollPosition` such that the slider moves by `delta`.\n     */\n    getDesiredScrollTopFromDelta(delta) {\n        return Math.round(this.scrollTop + delta / this._computedSliderRatio);\n    }\n    getDesiredScrollTopFromTouchLocation(pageY) {\n        return Math.round((pageY - this.sliderHeight / 2) / this._computedSliderRatio);\n    }\n    /**\n     * Intersect a line range with `this.startLineNumber` and `this.endLineNumber`.\n     */\n    intersectWithViewport(range) {\n        const startLineNumber = Math.max(this.startLineNumber, range.startLineNumber);\n        const endLineNumber = Math.min(this.endLineNumber, range.endLineNumber);\n        if (startLineNumber > endLineNumber) {\n            // entirely outside minimap's viewport\n            return null;\n        }\n        return [startLineNumber, endLineNumber];\n    }\n    /**\n     * Get the inner minimap y coordinate for a line number.\n     */\n    getYForLineNumber(lineNumber, minimapLineHeight) {\n        return +(lineNumber - this.startLineNumber + this.topPaddingLineCount) * minimapLineHeight;\n    }\n    static create(options, viewportStartLineNumber, viewportEndLineNumber, viewportStartLineNumberVerticalOffset, viewportHeight, viewportContainsWhitespaceGaps, lineCount, realLineCount, scrollTop, scrollHeight, previousLayout) {\n        const pixelRatio = options.pixelRatio;\n        const minimapLineHeight = options.minimapLineHeight;\n        const minimapLinesFitting = Math.floor(options.canvasInnerHeight / minimapLineHeight);\n        const lineHeight = options.lineHeight;\n        if (options.minimapHeightIsEditorHeight) {\n            let logicalScrollHeight = (realLineCount * options.lineHeight\n                + options.paddingTop\n                + options.paddingBottom);\n            if (options.scrollBeyondLastLine) {\n                logicalScrollHeight += Math.max(0, viewportHeight - options.lineHeight - options.paddingBottom);\n            }\n            const sliderHeight = Math.max(1, Math.floor(viewportHeight * viewportHeight / logicalScrollHeight));\n            const maxMinimapSliderTop = Math.max(0, options.minimapHeight - sliderHeight);\n            // The slider can move from 0 to `maxMinimapSliderTop`\n            // in the same way `scrollTop` can move from 0 to `scrollHeight` - `viewportHeight`.\n            const computedSliderRatio = (maxMinimapSliderTop) / (scrollHeight - viewportHeight);\n            const sliderTop = (scrollTop * computedSliderRatio);\n            const sliderNeeded = (maxMinimapSliderTop > 0);\n            const maxLinesFitting = Math.floor(options.canvasInnerHeight / options.minimapLineHeight);\n            const topPaddingLineCount = Math.floor(options.paddingTop / options.lineHeight);\n            return new MinimapLayout(scrollTop, scrollHeight, sliderNeeded, computedSliderRatio, sliderTop, sliderHeight, topPaddingLineCount, 1, Math.min(lineCount, maxLinesFitting));\n        }\n        // The visible line count in a viewport can change due to a number of reasons:\n        //  a) with the same viewport width, different scroll positions can result in partial lines being visible:\n        //    e.g. for a line height of 20, and a viewport height of 600\n        //          * scrollTop = 0  => visible lines are [1, 30]\n        //          * scrollTop = 10 => visible lines are [1, 31] (with lines 1 and 31 partially visible)\n        //          * scrollTop = 20 => visible lines are [2, 31]\n        //  b) whitespace gaps might make their way in the viewport (which results in a decrease in the visible line count)\n        //  c) we could be in the scroll beyond last line case (which also results in a decrease in the visible line count, down to possibly only one line being visible)\n        // We must first establish a desirable slider height.\n        let sliderHeight;\n        if (viewportContainsWhitespaceGaps && viewportEndLineNumber !== lineCount) {\n            // case b) from above: there are whitespace gaps in the viewport.\n            // In this case, the height of the slider directly reflects the visible line count.\n            const viewportLineCount = viewportEndLineNumber - viewportStartLineNumber + 1;\n            sliderHeight = Math.floor(viewportLineCount * minimapLineHeight / pixelRatio);\n        }\n        else {\n            // The slider has a stable height\n            const expectedViewportLineCount = viewportHeight / lineHeight;\n            sliderHeight = Math.floor(expectedViewportLineCount * minimapLineHeight / pixelRatio);\n        }\n        const extraLinesAtTheTop = Math.floor(options.paddingTop / lineHeight);\n        let extraLinesAtTheBottom = Math.floor(options.paddingBottom / lineHeight);\n        if (options.scrollBeyondLastLine) {\n            const expectedViewportLineCount = viewportHeight / lineHeight;\n            extraLinesAtTheBottom = Math.max(extraLinesAtTheBottom, expectedViewportLineCount - 1);\n        }\n        let maxMinimapSliderTop;\n        if (extraLinesAtTheBottom > 0) {\n            const expectedViewportLineCount = viewportHeight / lineHeight;\n            // The minimap slider, when dragged all the way down, will contain the last line at its top\n            maxMinimapSliderTop = (extraLinesAtTheTop + lineCount + extraLinesAtTheBottom - expectedViewportLineCount - 1) * minimapLineHeight / pixelRatio;\n        }\n        else {\n            // The minimap slider, when dragged all the way down, will contain the last line at its bottom\n            maxMinimapSliderTop = Math.max(0, (extraLinesAtTheTop + lineCount) * minimapLineHeight / pixelRatio - sliderHeight);\n        }\n        maxMinimapSliderTop = Math.min(options.minimapHeight - sliderHeight, maxMinimapSliderTop);\n        // The slider can move from 0 to `maxMinimapSliderTop`\n        // in the same way `scrollTop` can move from 0 to `scrollHeight` - `viewportHeight`.\n        const computedSliderRatio = (maxMinimapSliderTop) / (scrollHeight - viewportHeight);\n        const sliderTop = (scrollTop * computedSliderRatio);\n        if (minimapLinesFitting >= extraLinesAtTheTop + lineCount + extraLinesAtTheBottom) {\n            // All lines fit in the minimap\n            const sliderNeeded = (maxMinimapSliderTop > 0);\n            return new MinimapLayout(scrollTop, scrollHeight, sliderNeeded, computedSliderRatio, sliderTop, sliderHeight, extraLinesAtTheTop, 1, lineCount);\n        }\n        else {\n            let consideringStartLineNumber;\n            if (viewportStartLineNumber > 1) {\n                consideringStartLineNumber = viewportStartLineNumber + extraLinesAtTheTop;\n            }\n            else {\n                consideringStartLineNumber = Math.max(1, scrollTop / lineHeight);\n            }\n            let topPaddingLineCount;\n            let startLineNumber = Math.max(1, Math.floor(consideringStartLineNumber - sliderTop * pixelRatio / minimapLineHeight));\n            if (startLineNumber < extraLinesAtTheTop) {\n                topPaddingLineCount = extraLinesAtTheTop - startLineNumber + 1;\n                startLineNumber = 1;\n            }\n            else {\n                topPaddingLineCount = 0;\n                startLineNumber = Math.max(1, startLineNumber - extraLinesAtTheTop);\n            }\n            // Avoid flickering caused by a partial viewport start line\n            // by being consistent w.r.t. the previous layout decision\n            if (previousLayout && previousLayout.scrollHeight === scrollHeight) {\n                if (previousLayout.scrollTop > scrollTop) {\n                    // Scrolling up => never increase `startLineNumber`\n                    startLineNumber = Math.min(startLineNumber, previousLayout.startLineNumber);\n                    topPaddingLineCount = Math.max(topPaddingLineCount, previousLayout.topPaddingLineCount);\n                }\n                if (previousLayout.scrollTop < scrollTop) {\n                    // Scrolling down => never decrease `startLineNumber`\n                    startLineNumber = Math.max(startLineNumber, previousLayout.startLineNumber);\n                    topPaddingLineCount = Math.min(topPaddingLineCount, previousLayout.topPaddingLineCount);\n                }\n            }\n            const endLineNumber = Math.min(lineCount, startLineNumber - topPaddingLineCount + minimapLinesFitting - 1);\n            const partialLine = (scrollTop - viewportStartLineNumberVerticalOffset) / lineHeight;\n            let sliderTopAligned;\n            if (scrollTop >= options.paddingTop) {\n                sliderTopAligned = (viewportStartLineNumber - startLineNumber + topPaddingLineCount + partialLine) * minimapLineHeight / pixelRatio;\n            }\n            else {\n                sliderTopAligned = (scrollTop / options.paddingTop) * (topPaddingLineCount + partialLine) * minimapLineHeight / pixelRatio;\n            }\n            return new MinimapLayout(scrollTop, scrollHeight, true, computedSliderRatio, sliderTopAligned, sliderHeight, topPaddingLineCount, startLineNumber, endLineNumber);\n        }\n    }\n}\nclass MinimapLine {\n    constructor(dy) {\n        this.dy = dy;\n    }\n    onContentChanged() {\n        this.dy = -1;\n    }\n    onTokensChanged() {\n        this.dy = -1;\n    }\n}\nMinimapLine.INVALID = new MinimapLine(-1);\nclass RenderData {\n    constructor(renderedLayout, imageData, lines) {\n        this.renderedLayout = renderedLayout;\n        this._imageData = imageData;\n        this._renderedLines = new RenderedLinesCollection(() => MinimapLine.INVALID);\n        this._renderedLines._set(renderedLayout.startLineNumber, lines);\n    }\n    /**\n     * Check if the current RenderData matches accurately the new desired layout and no painting is needed.\n     */\n    linesEquals(layout) {\n        if (!this.scrollEquals(layout)) {\n            return false;\n        }\n        const tmp = this._renderedLines._get();\n        const lines = tmp.lines;\n        for (let i = 0, len = lines.length; i < len; i++) {\n            if (lines[i].dy === -1) {\n                // This line is invalid\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Check if the current RenderData matches the new layout's scroll position\n     */\n    scrollEquals(layout) {\n        return this.renderedLayout.startLineNumber === layout.startLineNumber\n            && this.renderedLayout.endLineNumber === layout.endLineNumber;\n    }\n    _get() {\n        const tmp = this._renderedLines._get();\n        return {\n            imageData: this._imageData,\n            rendLineNumberStart: tmp.rendLineNumberStart,\n            lines: tmp.lines\n        };\n    }\n    onLinesChanged(changeFromLineNumber, changeCount) {\n        return this._renderedLines.onLinesChanged(changeFromLineNumber, changeCount);\n    }\n    onLinesDeleted(deleteFromLineNumber, deleteToLineNumber) {\n        this._renderedLines.onLinesDeleted(deleteFromLineNumber, deleteToLineNumber);\n    }\n    onLinesInserted(insertFromLineNumber, insertToLineNumber) {\n        this._renderedLines.onLinesInserted(insertFromLineNumber, insertToLineNumber);\n    }\n    onTokensChanged(ranges) {\n        return this._renderedLines.onTokensChanged(ranges);\n    }\n}\n/**\n * Some sort of double buffering.\n *\n * Keeps two buffers around that will be rotated for painting.\n * Always gives a buffer that is filled with the background color.\n */\nclass MinimapBuffers {\n    constructor(ctx, WIDTH, HEIGHT, background) {\n        this._backgroundFillData = MinimapBuffers._createBackgroundFillData(WIDTH, HEIGHT, background);\n        this._buffers = [\n            ctx.createImageData(WIDTH, HEIGHT),\n            ctx.createImageData(WIDTH, HEIGHT)\n        ];\n        this._lastUsedBuffer = 0;\n    }\n    getBuffer() {\n        // rotate buffers\n        this._lastUsedBuffer = 1 - this._lastUsedBuffer;\n        const result = this._buffers[this._lastUsedBuffer];\n        // fill with background color\n        result.data.set(this._backgroundFillData);\n        return result;\n    }\n    static _createBackgroundFillData(WIDTH, HEIGHT, background) {\n        const backgroundR = background.r;\n        const backgroundG = background.g;\n        const backgroundB = background.b;\n        const backgroundA = background.a;\n        const result = new Uint8ClampedArray(WIDTH * HEIGHT * 4);\n        let offset = 0;\n        for (let i = 0; i < HEIGHT; i++) {\n            for (let j = 0; j < WIDTH; j++) {\n                result[offset] = backgroundR;\n                result[offset + 1] = backgroundG;\n                result[offset + 2] = backgroundB;\n                result[offset + 3] = backgroundA;\n                offset += 4;\n            }\n        }\n        return result;\n    }\n}\nclass MinimapSamplingState {\n    static compute(options, viewLineCount, oldSamplingState) {\n        if (options.renderMinimap === 0 /* RenderMinimap.None */ || !options.isSampling) {\n            return [null, []];\n        }\n        // ratio is intentionally not part of the layout to avoid the layout changing all the time\n        // so we need to recompute it again...\n        const { minimapLineCount } = EditorLayoutInfoComputer.computeContainedMinimapLineCount({\n            viewLineCount: viewLineCount,\n            scrollBeyondLastLine: options.scrollBeyondLastLine,\n            paddingTop: options.paddingTop,\n            paddingBottom: options.paddingBottom,\n            height: options.editorHeight,\n            lineHeight: options.lineHeight,\n            pixelRatio: options.pixelRatio\n        });\n        const ratio = viewLineCount / minimapLineCount;\n        const halfRatio = ratio / 2;\n        if (!oldSamplingState || oldSamplingState.minimapLines.length === 0) {\n            const result = [];\n            result[0] = 1;\n            if (minimapLineCount > 1) {\n                for (let i = 0, lastIndex = minimapLineCount - 1; i < lastIndex; i++) {\n                    result[i] = Math.round(i * ratio + halfRatio);\n                }\n                result[minimapLineCount - 1] = viewLineCount;\n            }\n            return [new MinimapSamplingState(ratio, result), []];\n        }\n        const oldMinimapLines = oldSamplingState.minimapLines;\n        const oldLength = oldMinimapLines.length;\n        const result = [];\n        let oldIndex = 0;\n        let oldDeltaLineCount = 0;\n        let minViewLineNumber = 1;\n        const MAX_EVENT_COUNT = 10; // generate at most 10 events, if there are more than 10 changes, just flush all previous data\n        let events = [];\n        let lastEvent = null;\n        for (let i = 0; i < minimapLineCount; i++) {\n            const fromViewLineNumber = Math.max(minViewLineNumber, Math.round(i * ratio));\n            const toViewLineNumber = Math.max(fromViewLineNumber, Math.round((i + 1) * ratio));\n            while (oldIndex < oldLength && oldMinimapLines[oldIndex] < fromViewLineNumber) {\n                if (events.length < MAX_EVENT_COUNT) {\n                    const oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\n                    if (lastEvent && lastEvent.type === 'deleted' && lastEvent._oldIndex === oldIndex - 1) {\n                        lastEvent.deleteToLineNumber++;\n                    }\n                    else {\n                        lastEvent = { type: 'deleted', _oldIndex: oldIndex, deleteFromLineNumber: oldMinimapLineNumber, deleteToLineNumber: oldMinimapLineNumber };\n                        events.push(lastEvent);\n                    }\n                    oldDeltaLineCount--;\n                }\n                oldIndex++;\n            }\n            let selectedViewLineNumber;\n            if (oldIndex < oldLength && oldMinimapLines[oldIndex] <= toViewLineNumber) {\n                // reuse the old sampled line\n                selectedViewLineNumber = oldMinimapLines[oldIndex];\n                oldIndex++;\n            }\n            else {\n                if (i === 0) {\n                    selectedViewLineNumber = 1;\n                }\n                else if (i + 1 === minimapLineCount) {\n                    selectedViewLineNumber = viewLineCount;\n                }\n                else {\n                    selectedViewLineNumber = Math.round(i * ratio + halfRatio);\n                }\n                if (events.length < MAX_EVENT_COUNT) {\n                    const oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\n                    if (lastEvent && lastEvent.type === 'inserted' && lastEvent._i === i - 1) {\n                        lastEvent.insertToLineNumber++;\n                    }\n                    else {\n                        lastEvent = { type: 'inserted', _i: i, insertFromLineNumber: oldMinimapLineNumber, insertToLineNumber: oldMinimapLineNumber };\n                        events.push(lastEvent);\n                    }\n                    oldDeltaLineCount++;\n                }\n            }\n            result[i] = selectedViewLineNumber;\n            minViewLineNumber = selectedViewLineNumber;\n        }\n        if (events.length < MAX_EVENT_COUNT) {\n            while (oldIndex < oldLength) {\n                const oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\n                if (lastEvent && lastEvent.type === 'deleted' && lastEvent._oldIndex === oldIndex - 1) {\n                    lastEvent.deleteToLineNumber++;\n                }\n                else {\n                    lastEvent = { type: 'deleted', _oldIndex: oldIndex, deleteFromLineNumber: oldMinimapLineNumber, deleteToLineNumber: oldMinimapLineNumber };\n                    events.push(lastEvent);\n                }\n                oldDeltaLineCount--;\n                oldIndex++;\n            }\n        }\n        else {\n            // too many events, just give up\n            events = [{ type: 'flush' }];\n        }\n        return [new MinimapSamplingState(ratio, result), events];\n    }\n    constructor(samplingRatio, minimapLines // a map of 0-based minimap line indexes to 1-based view line numbers\n    ) {\n        this.samplingRatio = samplingRatio;\n        this.minimapLines = minimapLines;\n    }\n    modelLineToMinimapLine(lineNumber) {\n        return Math.min(this.minimapLines.length, Math.max(1, Math.round(lineNumber / this.samplingRatio)));\n    }\n    /**\n     * Will return null if the model line ranges are not intersecting with a sampled model line.\n     */\n    modelLineRangeToMinimapLineRange(fromLineNumber, toLineNumber) {\n        let fromLineIndex = this.modelLineToMinimapLine(fromLineNumber) - 1;\n        while (fromLineIndex > 0 && this.minimapLines[fromLineIndex - 1] >= fromLineNumber) {\n            fromLineIndex--;\n        }\n        let toLineIndex = this.modelLineToMinimapLine(toLineNumber) - 1;\n        while (toLineIndex + 1 < this.minimapLines.length && this.minimapLines[toLineIndex + 1] <= toLineNumber) {\n            toLineIndex++;\n        }\n        if (fromLineIndex === toLineIndex) {\n            const sampledLineNumber = this.minimapLines[fromLineIndex];\n            if (sampledLineNumber < fromLineNumber || sampledLineNumber > toLineNumber) {\n                // This line is not part of the sampled lines ==> nothing to do\n                return null;\n            }\n        }\n        return [fromLineIndex + 1, toLineIndex + 1];\n    }\n    /**\n     * Will always return a range, even if it is not intersecting with a sampled model line.\n     */\n    decorationLineRangeToMinimapLineRange(startLineNumber, endLineNumber) {\n        let minimapLineStart = this.modelLineToMinimapLine(startLineNumber);\n        let minimapLineEnd = this.modelLineToMinimapLine(endLineNumber);\n        if (startLineNumber !== endLineNumber && minimapLineEnd === minimapLineStart) {\n            if (minimapLineEnd === this.minimapLines.length) {\n                if (minimapLineStart > 1) {\n                    minimapLineStart--;\n                }\n            }\n            else {\n                minimapLineEnd++;\n            }\n        }\n        return [minimapLineStart, minimapLineEnd];\n    }\n    onLinesDeleted(e) {\n        // have the mapping be sticky\n        const deletedLineCount = e.toLineNumber - e.fromLineNumber + 1;\n        let changeStartIndex = this.minimapLines.length;\n        let changeEndIndex = 0;\n        for (let i = this.minimapLines.length - 1; i >= 0; i--) {\n            if (this.minimapLines[i] < e.fromLineNumber) {\n                break;\n            }\n            if (this.minimapLines[i] <= e.toLineNumber) {\n                // this line got deleted => move to previous available\n                this.minimapLines[i] = Math.max(1, e.fromLineNumber - 1);\n                changeStartIndex = Math.min(changeStartIndex, i);\n                changeEndIndex = Math.max(changeEndIndex, i);\n            }\n            else {\n                this.minimapLines[i] -= deletedLineCount;\n            }\n        }\n        return [changeStartIndex, changeEndIndex];\n    }\n    onLinesInserted(e) {\n        // have the mapping be sticky\n        const insertedLineCount = e.toLineNumber - e.fromLineNumber + 1;\n        for (let i = this.minimapLines.length - 1; i >= 0; i--) {\n            if (this.minimapLines[i] < e.fromLineNumber) {\n                break;\n            }\n            this.minimapLines[i] += insertedLineCount;\n        }\n    }\n}\nexport class Minimap extends ViewPart {\n    constructor(context) {\n        super(context);\n        this._sectionHeaderCache = new LRUCache(10, 1.5);\n        this.tokensColorTracker = MinimapTokensColorTracker.getInstance();\n        this._selections = [];\n        this._minimapSelections = null;\n        this.options = new MinimapOptions(this._context.configuration, this._context.theme, this.tokensColorTracker);\n        const [samplingState,] = MinimapSamplingState.compute(this.options, this._context.viewModel.getLineCount(), null);\n        this._samplingState = samplingState;\n        this._shouldCheckSampling = false;\n        this._actual = new InnerMinimap(context.theme, this);\n    }\n    dispose() {\n        this._actual.dispose();\n        super.dispose();\n    }\n    getDomNode() {\n        return this._actual.getDomNode();\n    }\n    _onOptionsMaybeChanged() {\n        const opts = new MinimapOptions(this._context.configuration, this._context.theme, this.tokensColorTracker);\n        if (this.options.equals(opts)) {\n            return false;\n        }\n        this.options = opts;\n        this._recreateLineSampling();\n        this._actual.onDidChangeOptions();\n        return true;\n    }\n    // ---- begin view event handlers\n    onConfigurationChanged(e) {\n        return this._onOptionsMaybeChanged();\n    }\n    onCursorStateChanged(e) {\n        this._selections = e.selections;\n        this._minimapSelections = null;\n        return this._actual.onSelectionChanged();\n    }\n    onDecorationsChanged(e) {\n        if (e.affectsMinimap) {\n            return this._actual.onDecorationsChanged();\n        }\n        return false;\n    }\n    onFlushed(e) {\n        if (this._samplingState) {\n            this._shouldCheckSampling = true;\n        }\n        return this._actual.onFlushed();\n    }\n    onLinesChanged(e) {\n        if (this._samplingState) {\n            const minimapLineRange = this._samplingState.modelLineRangeToMinimapLineRange(e.fromLineNumber, e.fromLineNumber + e.count - 1);\n            if (minimapLineRange) {\n                return this._actual.onLinesChanged(minimapLineRange[0], minimapLineRange[1] - minimapLineRange[0] + 1);\n            }\n            else {\n                return false;\n            }\n        }\n        else {\n            return this._actual.onLinesChanged(e.fromLineNumber, e.count);\n        }\n    }\n    onLinesDeleted(e) {\n        if (this._samplingState) {\n            const [changeStartIndex, changeEndIndex] = this._samplingState.onLinesDeleted(e);\n            if (changeStartIndex <= changeEndIndex) {\n                this._actual.onLinesChanged(changeStartIndex + 1, changeEndIndex - changeStartIndex + 1);\n            }\n            this._shouldCheckSampling = true;\n            return true;\n        }\n        else {\n            return this._actual.onLinesDeleted(e.fromLineNumber, e.toLineNumber);\n        }\n    }\n    onLinesInserted(e) {\n        if (this._samplingState) {\n            this._samplingState.onLinesInserted(e);\n            this._shouldCheckSampling = true;\n            return true;\n        }\n        else {\n            return this._actual.onLinesInserted(e.fromLineNumber, e.toLineNumber);\n        }\n    }\n    onScrollChanged(e) {\n        return this._actual.onScrollChanged();\n    }\n    onThemeChanged(e) {\n        this._actual.onThemeChanged();\n        this._onOptionsMaybeChanged();\n        return true;\n    }\n    onTokensChanged(e) {\n        if (this._samplingState) {\n            const ranges = [];\n            for (const range of e.ranges) {\n                const minimapLineRange = this._samplingState.modelLineRangeToMinimapLineRange(range.fromLineNumber, range.toLineNumber);\n                if (minimapLineRange) {\n                    ranges.push({ fromLineNumber: minimapLineRange[0], toLineNumber: minimapLineRange[1] });\n                }\n            }\n            if (ranges.length) {\n                return this._actual.onTokensChanged(ranges);\n            }\n            else {\n                return false;\n            }\n        }\n        else {\n            return this._actual.onTokensChanged(e.ranges);\n        }\n    }\n    onTokensColorsChanged(e) {\n        this._onOptionsMaybeChanged();\n        return this._actual.onTokensColorsChanged();\n    }\n    onZonesChanged(e) {\n        return this._actual.onZonesChanged();\n    }\n    // --- end event handlers\n    prepareRender(ctx) {\n        if (this._shouldCheckSampling) {\n            this._shouldCheckSampling = false;\n            this._recreateLineSampling();\n        }\n    }\n    render(ctx) {\n        let viewportStartLineNumber = ctx.visibleRange.startLineNumber;\n        let viewportEndLineNumber = ctx.visibleRange.endLineNumber;\n        if (this._samplingState) {\n            viewportStartLineNumber = this._samplingState.modelLineToMinimapLine(viewportStartLineNumber);\n            viewportEndLineNumber = this._samplingState.modelLineToMinimapLine(viewportEndLineNumber);\n        }\n        const minimapCtx = {\n            viewportContainsWhitespaceGaps: (ctx.viewportData.whitespaceViewportData.length > 0),\n            scrollWidth: ctx.scrollWidth,\n            scrollHeight: ctx.scrollHeight,\n            viewportStartLineNumber: viewportStartLineNumber,\n            viewportEndLineNumber: viewportEndLineNumber,\n            viewportStartLineNumberVerticalOffset: ctx.getVerticalOffsetForLineNumber(viewportStartLineNumber),\n            scrollTop: ctx.scrollTop,\n            scrollLeft: ctx.scrollLeft,\n            viewportWidth: ctx.viewportWidth,\n            viewportHeight: ctx.viewportHeight,\n        };\n        this._actual.render(minimapCtx);\n    }\n    //#region IMinimapModel\n    _recreateLineSampling() {\n        this._minimapSelections = null;\n        const wasSampling = Boolean(this._samplingState);\n        const [samplingState, events] = MinimapSamplingState.compute(this.options, this._context.viewModel.getLineCount(), this._samplingState);\n        this._samplingState = samplingState;\n        if (wasSampling && this._samplingState) {\n            // was sampling, is sampling\n            for (const event of events) {\n                switch (event.type) {\n                    case 'deleted':\n                        this._actual.onLinesDeleted(event.deleteFromLineNumber, event.deleteToLineNumber);\n                        break;\n                    case 'inserted':\n                        this._actual.onLinesInserted(event.insertFromLineNumber, event.insertToLineNumber);\n                        break;\n                    case 'flush':\n                        this._actual.onFlushed();\n                        break;\n                }\n            }\n        }\n    }\n    getLineCount() {\n        if (this._samplingState) {\n            return this._samplingState.minimapLines.length;\n        }\n        return this._context.viewModel.getLineCount();\n    }\n    getRealLineCount() {\n        return this._context.viewModel.getLineCount();\n    }\n    getLineContent(lineNumber) {\n        if (this._samplingState) {\n            return this._context.viewModel.getLineContent(this._samplingState.minimapLines[lineNumber - 1]);\n        }\n        return this._context.viewModel.getLineContent(lineNumber);\n    }\n    getLineMaxColumn(lineNumber) {\n        if (this._samplingState) {\n            return this._context.viewModel.getLineMaxColumn(this._samplingState.minimapLines[lineNumber - 1]);\n        }\n        return this._context.viewModel.getLineMaxColumn(lineNumber);\n    }\n    getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed) {\n        if (this._samplingState) {\n            const result = [];\n            for (let lineIndex = 0, lineCount = endLineNumber - startLineNumber + 1; lineIndex < lineCount; lineIndex++) {\n                if (needed[lineIndex]) {\n                    result[lineIndex] = this._context.viewModel.getViewLineData(this._samplingState.minimapLines[startLineNumber + lineIndex - 1]);\n                }\n                else {\n                    result[lineIndex] = null;\n                }\n            }\n            return result;\n        }\n        return this._context.viewModel.getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed).data;\n    }\n    getSelections() {\n        if (this._minimapSelections === null) {\n            if (this._samplingState) {\n                this._minimapSelections = [];\n                for (const selection of this._selections) {\n                    const [minimapLineStart, minimapLineEnd] = this._samplingState.decorationLineRangeToMinimapLineRange(selection.startLineNumber, selection.endLineNumber);\n                    this._minimapSelections.push(new Selection(minimapLineStart, selection.startColumn, minimapLineEnd, selection.endColumn));\n                }\n            }\n            else {\n                this._minimapSelections = this._selections;\n            }\n        }\n        return this._minimapSelections;\n    }\n    getMinimapDecorationsInViewport(startLineNumber, endLineNumber) {\n        const decorations = this._getMinimapDecorationsInViewport(startLineNumber, endLineNumber)\n            .filter(decoration => { var _a; return !((_a = decoration.options.minimap) === null || _a === void 0 ? void 0 : _a.sectionHeaderStyle); });\n        if (this._samplingState) {\n            const result = [];\n            for (const decoration of decorations) {\n                if (!decoration.options.minimap) {\n                    continue;\n                }\n                const range = decoration.range;\n                const minimapStartLineNumber = this._samplingState.modelLineToMinimapLine(range.startLineNumber);\n                const minimapEndLineNumber = this._samplingState.modelLineToMinimapLine(range.endLineNumber);\n                result.push(new ViewModelDecoration(new Range(minimapStartLineNumber, range.startColumn, minimapEndLineNumber, range.endColumn), decoration.options));\n            }\n            return result;\n        }\n        return decorations;\n    }\n    getSectionHeaderDecorationsInViewport(startLineNumber, endLineNumber) {\n        const minimapLineHeight = this.options.minimapLineHeight;\n        const sectionHeaderFontSize = this.options.sectionHeaderFontSize;\n        const headerHeightInMinimapLines = sectionHeaderFontSize / minimapLineHeight;\n        startLineNumber = Math.floor(Math.max(1, startLineNumber - headerHeightInMinimapLines));\n        return this._getMinimapDecorationsInViewport(startLineNumber, endLineNumber)\n            .filter(decoration => { var _a; return !!((_a = decoration.options.minimap) === null || _a === void 0 ? void 0 : _a.sectionHeaderStyle); });\n    }\n    _getMinimapDecorationsInViewport(startLineNumber, endLineNumber) {\n        let visibleRange;\n        if (this._samplingState) {\n            const modelStartLineNumber = this._samplingState.minimapLines[startLineNumber - 1];\n            const modelEndLineNumber = this._samplingState.minimapLines[endLineNumber - 1];\n            visibleRange = new Range(modelStartLineNumber, 1, modelEndLineNumber, this._context.viewModel.getLineMaxColumn(modelEndLineNumber));\n        }\n        else {\n            visibleRange = new Range(startLineNumber, 1, endLineNumber, this._context.viewModel.getLineMaxColumn(endLineNumber));\n        }\n        return this._context.viewModel.getMinimapDecorationsInRange(visibleRange);\n    }\n    getSectionHeaderText(decoration, fitWidth) {\n        var _a;\n        const headerText = (_a = decoration.options.minimap) === null || _a === void 0 ? void 0 : _a.sectionHeaderText;\n        if (!headerText) {\n            return null;\n        }\n        const cachedText = this._sectionHeaderCache.get(headerText);\n        if (cachedText) {\n            return cachedText;\n        }\n        const fittedText = fitWidth(headerText);\n        this._sectionHeaderCache.set(headerText, fittedText);\n        return fittedText;\n    }\n    getOptions() {\n        return this._context.viewModel.model.getOptions();\n    }\n    revealLineNumber(lineNumber) {\n        if (this._samplingState) {\n            lineNumber = this._samplingState.minimapLines[lineNumber - 1];\n        }\n        this._context.viewModel.revealRange('mouse', false, new Range(lineNumber, 1, lineNumber, 1), 1 /* viewEvents.VerticalRevealType.Center */, 0 /* ScrollType.Smooth */);\n    }\n    setScrollTop(scrollTop) {\n        this._context.viewModel.viewLayout.setScrollPosition({\n            scrollTop: scrollTop\n        }, 1 /* ScrollType.Immediate */);\n    }\n}\nclass InnerMinimap extends Disposable {\n    constructor(theme, model) {\n        super();\n        this._renderDecorations = false;\n        this._gestureInProgress = false;\n        this._theme = theme;\n        this._model = model;\n        this._lastRenderData = null;\n        this._buffers = null;\n        this._selectionColor = this._theme.getColor(minimapSelection);\n        this._domNode = createFastDomNode(document.createElement('div'));\n        PartFingerprints.write(this._domNode, 9 /* PartFingerprint.Minimap */);\n        this._domNode.setClassName(this._getMinimapDomNodeClassName());\n        this._domNode.setPosition('absolute');\n        this._domNode.setAttribute('role', 'presentation');\n        this._domNode.setAttribute('aria-hidden', 'true');\n        this._shadow = createFastDomNode(document.createElement('div'));\n        this._shadow.setClassName('minimap-shadow-hidden');\n        this._domNode.appendChild(this._shadow);\n        this._canvas = createFastDomNode(document.createElement('canvas'));\n        this._canvas.setPosition('absolute');\n        this._canvas.setLeft(0);\n        this._domNode.appendChild(this._canvas);\n        this._decorationsCanvas = createFastDomNode(document.createElement('canvas'));\n        this._decorationsCanvas.setPosition('absolute');\n        this._decorationsCanvas.setClassName('minimap-decorations-layer');\n        this._decorationsCanvas.setLeft(0);\n        this._domNode.appendChild(this._decorationsCanvas);\n        this._slider = createFastDomNode(document.createElement('div'));\n        this._slider.setPosition('absolute');\n        this._slider.setClassName('minimap-slider');\n        this._slider.setLayerHinting(true);\n        this._slider.setContain('strict');\n        this._domNode.appendChild(this._slider);\n        this._sliderHorizontal = createFastDomNode(document.createElement('div'));\n        this._sliderHorizontal.setPosition('absolute');\n        this._sliderHorizontal.setClassName('minimap-slider-horizontal');\n        this._slider.appendChild(this._sliderHorizontal);\n        this._applyLayout();\n        this._pointerDownListener = dom.addStandardDisposableListener(this._domNode.domNode, dom.EventType.POINTER_DOWN, (e) => {\n            e.preventDefault();\n            const renderMinimap = this._model.options.renderMinimap;\n            if (renderMinimap === 0 /* RenderMinimap.None */) {\n                return;\n            }\n            if (!this._lastRenderData) {\n                return;\n            }\n            if (this._model.options.size !== 'proportional') {\n                if (e.button === 0 && this._lastRenderData) {\n                    // pretend the click occurred in the center of the slider\n                    const position = dom.getDomNodePagePosition(this._slider.domNode);\n                    const initialPosY = position.top + position.height / 2;\n                    this._startSliderDragging(e, initialPosY, this._lastRenderData.renderedLayout);\n                }\n                return;\n            }\n            const minimapLineHeight = this._model.options.minimapLineHeight;\n            const internalOffsetY = (this._model.options.canvasInnerHeight / this._model.options.canvasOuterHeight) * e.offsetY;\n            const lineIndex = Math.floor(internalOffsetY / minimapLineHeight);\n            let lineNumber = lineIndex + this._lastRenderData.renderedLayout.startLineNumber - this._lastRenderData.renderedLayout.topPaddingLineCount;\n            lineNumber = Math.min(lineNumber, this._model.getLineCount());\n            this._model.revealLineNumber(lineNumber);\n        });\n        this._sliderPointerMoveMonitor = new GlobalPointerMoveMonitor();\n        this._sliderPointerDownListener = dom.addStandardDisposableListener(this._slider.domNode, dom.EventType.POINTER_DOWN, (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            if (e.button === 0 && this._lastRenderData) {\n                this._startSliderDragging(e, e.pageY, this._lastRenderData.renderedLayout);\n            }\n        });\n        this._gestureDisposable = Gesture.addTarget(this._domNode.domNode);\n        this._sliderTouchStartListener = dom.addDisposableListener(this._domNode.domNode, EventType.Start, (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            if (this._lastRenderData) {\n                this._slider.toggleClassName('active', true);\n                this._gestureInProgress = true;\n                this.scrollDueToTouchEvent(e);\n            }\n        }, { passive: false });\n        this._sliderTouchMoveListener = dom.addDisposableListener(this._domNode.domNode, EventType.Change, (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            if (this._lastRenderData && this._gestureInProgress) {\n                this.scrollDueToTouchEvent(e);\n            }\n        }, { passive: false });\n        this._sliderTouchEndListener = dom.addStandardDisposableListener(this._domNode.domNode, EventType.End, (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            this._gestureInProgress = false;\n            this._slider.toggleClassName('active', false);\n        });\n    }\n    _startSliderDragging(e, initialPosY, initialSliderState) {\n        if (!e.target || !(e.target instanceof Element)) {\n            return;\n        }\n        const initialPosX = e.pageX;\n        this._slider.toggleClassName('active', true);\n        const handlePointerMove = (posy, posx) => {\n            const minimapPosition = dom.getDomNodePagePosition(this._domNode.domNode);\n            const pointerOrthogonalDelta = Math.min(Math.abs(posx - initialPosX), Math.abs(posx - minimapPosition.left), Math.abs(posx - minimapPosition.left - minimapPosition.width));\n            if (platform.isWindows && pointerOrthogonalDelta > POINTER_DRAG_RESET_DISTANCE) {\n                // The pointer has wondered away from the scrollbar => reset dragging\n                this._model.setScrollTop(initialSliderState.scrollTop);\n                return;\n            }\n            const pointerDelta = posy - initialPosY;\n            this._model.setScrollTop(initialSliderState.getDesiredScrollTopFromDelta(pointerDelta));\n        };\n        if (e.pageY !== initialPosY) {\n            handlePointerMove(e.pageY, initialPosX);\n        }\n        this._sliderPointerMoveMonitor.startMonitoring(e.target, e.pointerId, e.buttons, pointerMoveData => handlePointerMove(pointerMoveData.pageY, pointerMoveData.pageX), () => {\n            this._slider.toggleClassName('active', false);\n        });\n    }\n    scrollDueToTouchEvent(touch) {\n        const startY = this._domNode.domNode.getBoundingClientRect().top;\n        const scrollTop = this._lastRenderData.renderedLayout.getDesiredScrollTopFromTouchLocation(touch.pageY - startY);\n        this._model.setScrollTop(scrollTop);\n    }\n    dispose() {\n        this._pointerDownListener.dispose();\n        this._sliderPointerMoveMonitor.dispose();\n        this._sliderPointerDownListener.dispose();\n        this._gestureDisposable.dispose();\n        this._sliderTouchStartListener.dispose();\n        this._sliderTouchMoveListener.dispose();\n        this._sliderTouchEndListener.dispose();\n        super.dispose();\n    }\n    _getMinimapDomNodeClassName() {\n        const class_ = ['minimap'];\n        if (this._model.options.showSlider === 'always') {\n            class_.push('slider-always');\n        }\n        else {\n            class_.push('slider-mouseover');\n        }\n        if (this._model.options.autohide) {\n            class_.push('autohide');\n        }\n        return class_.join(' ');\n    }\n    getDomNode() {\n        return this._domNode;\n    }\n    _applyLayout() {\n        this._domNode.setLeft(this._model.options.minimapLeft);\n        this._domNode.setWidth(this._model.options.minimapWidth);\n        this._domNode.setHeight(this._model.options.minimapHeight);\n        this._shadow.setHeight(this._model.options.minimapHeight);\n        this._canvas.setWidth(this._model.options.canvasOuterWidth);\n        this._canvas.setHeight(this._model.options.canvasOuterHeight);\n        this._canvas.domNode.width = this._model.options.canvasInnerWidth;\n        this._canvas.domNode.height = this._model.options.canvasInnerHeight;\n        this._decorationsCanvas.setWidth(this._model.options.canvasOuterWidth);\n        this._decorationsCanvas.setHeight(this._model.options.canvasOuterHeight);\n        this._decorationsCanvas.domNode.width = this._model.options.canvasInnerWidth;\n        this._decorationsCanvas.domNode.height = this._model.options.canvasInnerHeight;\n        this._slider.setWidth(this._model.options.minimapWidth);\n    }\n    _getBuffer() {\n        if (!this._buffers) {\n            if (this._model.options.canvasInnerWidth > 0 && this._model.options.canvasInnerHeight > 0) {\n                this._buffers = new MinimapBuffers(this._canvas.domNode.getContext('2d'), this._model.options.canvasInnerWidth, this._model.options.canvasInnerHeight, this._model.options.backgroundColor);\n            }\n        }\n        return this._buffers ? this._buffers.getBuffer() : null;\n    }\n    // ---- begin view event handlers\n    onDidChangeOptions() {\n        this._lastRenderData = null;\n        this._buffers = null;\n        this._applyLayout();\n        this._domNode.setClassName(this._getMinimapDomNodeClassName());\n    }\n    onSelectionChanged() {\n        this._renderDecorations = true;\n        return true;\n    }\n    onDecorationsChanged() {\n        this._renderDecorations = true;\n        return true;\n    }\n    onFlushed() {\n        this._lastRenderData = null;\n        return true;\n    }\n    onLinesChanged(changeFromLineNumber, changeCount) {\n        if (this._lastRenderData) {\n            return this._lastRenderData.onLinesChanged(changeFromLineNumber, changeCount);\n        }\n        return false;\n    }\n    onLinesDeleted(deleteFromLineNumber, deleteToLineNumber) {\n        var _a;\n        (_a = this._lastRenderData) === null || _a === void 0 ? void 0 : _a.onLinesDeleted(deleteFromLineNumber, deleteToLineNumber);\n        return true;\n    }\n    onLinesInserted(insertFromLineNumber, insertToLineNumber) {\n        var _a;\n        (_a = this._lastRenderData) === null || _a === void 0 ? void 0 : _a.onLinesInserted(insertFromLineNumber, insertToLineNumber);\n        return true;\n    }\n    onScrollChanged() {\n        this._renderDecorations = true;\n        return true;\n    }\n    onThemeChanged() {\n        this._selectionColor = this._theme.getColor(minimapSelection);\n        this._renderDecorations = true;\n        return true;\n    }\n    onTokensChanged(ranges) {\n        if (this._lastRenderData) {\n            return this._lastRenderData.onTokensChanged(ranges);\n        }\n        return false;\n    }\n    onTokensColorsChanged() {\n        this._lastRenderData = null;\n        this._buffers = null;\n        return true;\n    }\n    onZonesChanged() {\n        this._lastRenderData = null;\n        return true;\n    }\n    // --- end event handlers\n    render(renderingCtx) {\n        const renderMinimap = this._model.options.renderMinimap;\n        if (renderMinimap === 0 /* RenderMinimap.None */) {\n            this._shadow.setClassName('minimap-shadow-hidden');\n            this._sliderHorizontal.setWidth(0);\n            this._sliderHorizontal.setHeight(0);\n            return;\n        }\n        if (renderingCtx.scrollLeft + renderingCtx.viewportWidth >= renderingCtx.scrollWidth) {\n            this._shadow.setClassName('minimap-shadow-hidden');\n        }\n        else {\n            this._shadow.setClassName('minimap-shadow-visible');\n        }\n        const layout = MinimapLayout.create(this._model.options, renderingCtx.viewportStartLineNumber, renderingCtx.viewportEndLineNumber, renderingCtx.viewportStartLineNumberVerticalOffset, renderingCtx.viewportHeight, renderingCtx.viewportContainsWhitespaceGaps, this._model.getLineCount(), this._model.getRealLineCount(), renderingCtx.scrollTop, renderingCtx.scrollHeight, this._lastRenderData ? this._lastRenderData.renderedLayout : null);\n        this._slider.setDisplay(layout.sliderNeeded ? 'block' : 'none');\n        this._slider.setTop(layout.sliderTop);\n        this._slider.setHeight(layout.sliderHeight);\n        // Compute horizontal slider coordinates\n        this._sliderHorizontal.setLeft(0);\n        this._sliderHorizontal.setWidth(this._model.options.minimapWidth);\n        this._sliderHorizontal.setTop(0);\n        this._sliderHorizontal.setHeight(layout.sliderHeight);\n        this.renderDecorations(layout);\n        this._lastRenderData = this.renderLines(layout);\n    }\n    renderDecorations(layout) {\n        if (this._renderDecorations) {\n            this._renderDecorations = false;\n            const selections = this._model.getSelections();\n            selections.sort(Range.compareRangesUsingStarts);\n            const decorations = this._model.getMinimapDecorationsInViewport(layout.startLineNumber, layout.endLineNumber);\n            decorations.sort((a, b) => (a.options.zIndex || 0) - (b.options.zIndex || 0));\n            const { canvasInnerWidth, canvasInnerHeight } = this._model.options;\n            const minimapLineHeight = this._model.options.minimapLineHeight;\n            const minimapCharWidth = this._model.options.minimapCharWidth;\n            const tabSize = this._model.getOptions().tabSize;\n            const canvasContext = this._decorationsCanvas.domNode.getContext('2d');\n            canvasContext.clearRect(0, 0, canvasInnerWidth, canvasInnerHeight);\n            // We first need to render line highlights and then render decorations on top of those.\n            // But we need to pick a single color for each line, and use that as a line highlight.\n            // This needs to be the color of the decoration with the highest `zIndex`, but priority\n            // is given to the selection.\n            const highlightedLines = new ContiguousLineMap(layout.startLineNumber, layout.endLineNumber, false);\n            this._renderSelectionLineHighlights(canvasContext, selections, highlightedLines, layout, minimapLineHeight);\n            this._renderDecorationsLineHighlights(canvasContext, decorations, highlightedLines, layout, minimapLineHeight);\n            const lineOffsetMap = new ContiguousLineMap(layout.startLineNumber, layout.endLineNumber, null);\n            this._renderSelectionsHighlights(canvasContext, selections, lineOffsetMap, layout, minimapLineHeight, tabSize, minimapCharWidth, canvasInnerWidth);\n            this._renderDecorationsHighlights(canvasContext, decorations, lineOffsetMap, layout, minimapLineHeight, tabSize, minimapCharWidth, canvasInnerWidth);\n            this._renderSectionHeaders(layout);\n        }\n    }\n    _renderSelectionLineHighlights(canvasContext, selections, highlightedLines, layout, minimapLineHeight) {\n        if (!this._selectionColor || this._selectionColor.isTransparent()) {\n            return;\n        }\n        canvasContext.fillStyle = this._selectionColor.transparent(0.5).toString();\n        let y1 = 0;\n        let y2 = 0;\n        for (const selection of selections) {\n            const intersection = layout.intersectWithViewport(selection);\n            if (!intersection) {\n                // entirely outside minimap's viewport\n                continue;\n            }\n            const [startLineNumber, endLineNumber] = intersection;\n            for (let line = startLineNumber; line <= endLineNumber; line++) {\n                highlightedLines.set(line, true);\n            }\n            const yy1 = layout.getYForLineNumber(startLineNumber, minimapLineHeight);\n            const yy2 = layout.getYForLineNumber(endLineNumber, minimapLineHeight);\n            if (y2 >= yy1) {\n                // merge into previous\n                y2 = yy2;\n            }\n            else {\n                if (y2 > y1) {\n                    // flush\n                    canvasContext.fillRect(MINIMAP_GUTTER_WIDTH, y1, canvasContext.canvas.width, y2 - y1);\n                }\n                y1 = yy1;\n                y2 = yy2;\n            }\n        }\n        if (y2 > y1) {\n            // flush\n            canvasContext.fillRect(MINIMAP_GUTTER_WIDTH, y1, canvasContext.canvas.width, y2 - y1);\n        }\n    }\n    _renderDecorationsLineHighlights(canvasContext, decorations, highlightedLines, layout, minimapLineHeight) {\n        const highlightColors = new Map();\n        // Loop backwards to hit first decorations with higher `zIndex`\n        for (let i = decorations.length - 1; i >= 0; i--) {\n            const decoration = decorations[i];\n            const minimapOptions = decoration.options.minimap;\n            if (!minimapOptions || minimapOptions.position !== 1 /* MinimapPosition.Inline */) {\n                continue;\n            }\n            const intersection = layout.intersectWithViewport(decoration.range);\n            if (!intersection) {\n                // entirely outside minimap's viewport\n                continue;\n            }\n            const [startLineNumber, endLineNumber] = intersection;\n            const decorationColor = minimapOptions.getColor(this._theme.value);\n            if (!decorationColor || decorationColor.isTransparent()) {\n                continue;\n            }\n            let highlightColor = highlightColors.get(decorationColor.toString());\n            if (!highlightColor) {\n                highlightColor = decorationColor.transparent(0.5).toString();\n                highlightColors.set(decorationColor.toString(), highlightColor);\n            }\n            canvasContext.fillStyle = highlightColor;\n            for (let line = startLineNumber; line <= endLineNumber; line++) {\n                if (highlightedLines.has(line)) {\n                    continue;\n                }\n                highlightedLines.set(line, true);\n                const y = layout.getYForLineNumber(startLineNumber, minimapLineHeight);\n                canvasContext.fillRect(MINIMAP_GUTTER_WIDTH, y, canvasContext.canvas.width, minimapLineHeight);\n            }\n        }\n    }\n    _renderSelectionsHighlights(canvasContext, selections, lineOffsetMap, layout, lineHeight, tabSize, characterWidth, canvasInnerWidth) {\n        if (!this._selectionColor || this._selectionColor.isTransparent()) {\n            return;\n        }\n        for (const selection of selections) {\n            const intersection = layout.intersectWithViewport(selection);\n            if (!intersection) {\n                // entirely outside minimap's viewport\n                continue;\n            }\n            const [startLineNumber, endLineNumber] = intersection;\n            for (let line = startLineNumber; line <= endLineNumber; line++) {\n                this.renderDecorationOnLine(canvasContext, lineOffsetMap, selection, this._selectionColor, layout, line, lineHeight, lineHeight, tabSize, characterWidth, canvasInnerWidth);\n            }\n        }\n    }\n    _renderDecorationsHighlights(canvasContext, decorations, lineOffsetMap, layout, minimapLineHeight, tabSize, characterWidth, canvasInnerWidth) {\n        // Loop forwards to hit first decorations with lower `zIndex`\n        for (const decoration of decorations) {\n            const minimapOptions = decoration.options.minimap;\n            if (!minimapOptions) {\n                continue;\n            }\n            const intersection = layout.intersectWithViewport(decoration.range);\n            if (!intersection) {\n                // entirely outside minimap's viewport\n                continue;\n            }\n            const [startLineNumber, endLineNumber] = intersection;\n            const decorationColor = minimapOptions.getColor(this._theme.value);\n            if (!decorationColor || decorationColor.isTransparent()) {\n                continue;\n            }\n            for (let line = startLineNumber; line <= endLineNumber; line++) {\n                switch (minimapOptions.position) {\n                    case 1 /* MinimapPosition.Inline */:\n                        this.renderDecorationOnLine(canvasContext, lineOffsetMap, decoration.range, decorationColor, layout, line, minimapLineHeight, minimapLineHeight, tabSize, characterWidth, canvasInnerWidth);\n                        continue;\n                    case 2 /* MinimapPosition.Gutter */: {\n                        const y = layout.getYForLineNumber(line, minimapLineHeight);\n                        const x = 2;\n                        this.renderDecoration(canvasContext, decorationColor, x, y, GUTTER_DECORATION_WIDTH, minimapLineHeight);\n                        continue;\n                    }\n                }\n            }\n        }\n    }\n    renderDecorationOnLine(canvasContext, lineOffsetMap, decorationRange, decorationColor, layout, lineNumber, height, minimapLineHeight, tabSize, charWidth, canvasInnerWidth) {\n        const y = layout.getYForLineNumber(lineNumber, minimapLineHeight);\n        // Skip rendering the line if it's vertically outside our viewport\n        if (y + height < 0 || y > this._model.options.canvasInnerHeight) {\n            return;\n        }\n        const { startLineNumber, endLineNumber } = decorationRange;\n        const startColumn = (startLineNumber === lineNumber ? decorationRange.startColumn : 1);\n        const endColumn = (endLineNumber === lineNumber ? decorationRange.endColumn : this._model.getLineMaxColumn(lineNumber));\n        const x1 = this.getXOffsetForPosition(lineOffsetMap, lineNumber, startColumn, tabSize, charWidth, canvasInnerWidth);\n        const x2 = this.getXOffsetForPosition(lineOffsetMap, lineNumber, endColumn, tabSize, charWidth, canvasInnerWidth);\n        this.renderDecoration(canvasContext, decorationColor, x1, y, x2 - x1, height);\n    }\n    getXOffsetForPosition(lineOffsetMap, lineNumber, column, tabSize, charWidth, canvasInnerWidth) {\n        if (column === 1) {\n            return MINIMAP_GUTTER_WIDTH;\n        }\n        const minimumXOffset = (column - 1) * charWidth;\n        if (minimumXOffset >= canvasInnerWidth) {\n            // there is no need to look at actual characters,\n            // as this column is certainly after the minimap width\n            return canvasInnerWidth;\n        }\n        // Cache line offset data so that it is only read once per line\n        let lineIndexToXOffset = lineOffsetMap.get(lineNumber);\n        if (!lineIndexToXOffset) {\n            const lineData = this._model.getLineContent(lineNumber);\n            lineIndexToXOffset = [MINIMAP_GUTTER_WIDTH];\n            let prevx = MINIMAP_GUTTER_WIDTH;\n            for (let i = 1; i < lineData.length + 1; i++) {\n                const charCode = lineData.charCodeAt(i - 1);\n                const dx = charCode === 9 /* CharCode.Tab */\n                    ? tabSize * charWidth\n                    : strings.isFullWidthCharacter(charCode)\n                        ? 2 * charWidth\n                        : charWidth;\n                const x = prevx + dx;\n                if (x >= canvasInnerWidth) {\n                    // no need to keep on going, as we've hit the canvas width\n                    lineIndexToXOffset[i] = canvasInnerWidth;\n                    break;\n                }\n                lineIndexToXOffset[i] = x;\n                prevx = x;\n            }\n            lineOffsetMap.set(lineNumber, lineIndexToXOffset);\n        }\n        if (column - 1 < lineIndexToXOffset.length) {\n            return lineIndexToXOffset[column - 1];\n        }\n        // goes over the canvas width\n        return canvasInnerWidth;\n    }\n    renderDecoration(canvasContext, decorationColor, x, y, width, height) {\n        canvasContext.fillStyle = decorationColor && decorationColor.toString() || '';\n        canvasContext.fillRect(x, y, width, height);\n    }\n    _renderSectionHeaders(layout) {\n        var _a;\n        const minimapLineHeight = this._model.options.minimapLineHeight;\n        const sectionHeaderFontSize = this._model.options.sectionHeaderFontSize;\n        const sectionHeaderLetterSpacing = this._model.options.sectionHeaderLetterSpacing;\n        const backgroundFillHeight = sectionHeaderFontSize * 1.5;\n        const { canvasInnerWidth } = this._model.options;\n        const backgroundColor = this._model.options.backgroundColor;\n        const backgroundFill = `rgb(${backgroundColor.r} ${backgroundColor.g} ${backgroundColor.b} / .7)`;\n        const foregroundColor = this._model.options.sectionHeaderFontColor;\n        const foregroundFill = `rgb(${foregroundColor.r} ${foregroundColor.g} ${foregroundColor.b})`;\n        const separatorStroke = foregroundFill;\n        const canvasContext = this._decorationsCanvas.domNode.getContext('2d');\n        canvasContext.letterSpacing = sectionHeaderLetterSpacing + 'px';\n        canvasContext.font = '500 ' + sectionHeaderFontSize + 'px ' + this._model.options.sectionHeaderFontFamily;\n        canvasContext.strokeStyle = separatorStroke;\n        canvasContext.lineWidth = 0.2;\n        const decorations = this._model.getSectionHeaderDecorationsInViewport(layout.startLineNumber, layout.endLineNumber);\n        decorations.sort((a, b) => a.range.startLineNumber - b.range.startLineNumber);\n        const fitWidth = InnerMinimap._fitSectionHeader.bind(null, canvasContext, canvasInnerWidth - MINIMAP_GUTTER_WIDTH);\n        for (const decoration of decorations) {\n            const y = layout.getYForLineNumber(decoration.range.startLineNumber, minimapLineHeight) + sectionHeaderFontSize;\n            const backgroundFillY = y - sectionHeaderFontSize;\n            const separatorY = backgroundFillY + 2;\n            const headerText = this._model.getSectionHeaderText(decoration, fitWidth);\n            InnerMinimap._renderSectionLabel(canvasContext, headerText, ((_a = decoration.options.minimap) === null || _a === void 0 ? void 0 : _a.sectionHeaderStyle) === 2 /* MinimapSectionHeaderStyle.Underlined */, backgroundFill, foregroundFill, canvasInnerWidth, backgroundFillY, backgroundFillHeight, y, separatorY);\n        }\n    }\n    static _fitSectionHeader(target, maxWidth, headerText) {\n        if (!headerText) {\n            return headerText;\n        }\n        const ellipsis = '…';\n        const width = target.measureText(headerText).width;\n        const ellipsisWidth = target.measureText(ellipsis).width;\n        if (width <= maxWidth || width <= ellipsisWidth) {\n            return headerText;\n        }\n        const len = headerText.length;\n        const averageCharWidth = width / headerText.length;\n        const maxCharCount = Math.floor((maxWidth - ellipsisWidth) / averageCharWidth) - 1;\n        // Find a halfway point that isn't after whitespace\n        let halfCharCount = Math.ceil(maxCharCount / 2);\n        while (halfCharCount > 0 && /\\s/.test(headerText[halfCharCount - 1])) {\n            --halfCharCount;\n        }\n        // Split with ellipsis\n        return headerText.substring(0, halfCharCount)\n            + ellipsis + headerText.substring(len - (maxCharCount - halfCharCount));\n    }\n    static _renderSectionLabel(target, headerText, hasSeparatorLine, backgroundFill, foregroundFill, minimapWidth, backgroundFillY, backgroundFillHeight, textY, separatorY) {\n        if (headerText) {\n            target.fillStyle = backgroundFill;\n            target.fillRect(0, backgroundFillY, minimapWidth, backgroundFillHeight);\n            target.fillStyle = foregroundFill;\n            target.fillText(headerText, MINIMAP_GUTTER_WIDTH, textY);\n        }\n        if (hasSeparatorLine) {\n            target.beginPath();\n            target.moveTo(0, separatorY);\n            target.lineTo(minimapWidth, separatorY);\n            target.closePath();\n            target.stroke();\n        }\n    }\n    renderLines(layout) {\n        const startLineNumber = layout.startLineNumber;\n        const endLineNumber = layout.endLineNumber;\n        const minimapLineHeight = this._model.options.minimapLineHeight;\n        // Check if nothing changed w.r.t. lines from last frame\n        if (this._lastRenderData && this._lastRenderData.linesEquals(layout)) {\n            const _lastData = this._lastRenderData._get();\n            // Nice!! Nothing changed from last frame\n            return new RenderData(layout, _lastData.imageData, _lastData.lines);\n        }\n        // Oh well!! We need to repaint some lines...\n        const imageData = this._getBuffer();\n        if (!imageData) {\n            // 0 width or 0 height canvas, nothing to do\n            return null;\n        }\n        // Render untouched lines by using last rendered data.\n        const [_dirtyY1, _dirtyY2, needed] = InnerMinimap._renderUntouchedLines(imageData, layout.topPaddingLineCount, startLineNumber, endLineNumber, minimapLineHeight, this._lastRenderData);\n        // Fetch rendering info from view model for rest of lines that need rendering.\n        const lineInfo = this._model.getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed);\n        const tabSize = this._model.getOptions().tabSize;\n        const defaultBackground = this._model.options.defaultBackgroundColor;\n        const background = this._model.options.backgroundColor;\n        const foregroundAlpha = this._model.options.foregroundAlpha;\n        const tokensColorTracker = this._model.tokensColorTracker;\n        const useLighterFont = tokensColorTracker.backgroundIsLight();\n        const renderMinimap = this._model.options.renderMinimap;\n        const charRenderer = this._model.options.charRenderer();\n        const fontScale = this._model.options.fontScale;\n        const minimapCharWidth = this._model.options.minimapCharWidth;\n        const baseCharHeight = (renderMinimap === 1 /* RenderMinimap.Text */ ? 2 /* Constants.BASE_CHAR_HEIGHT */ : 2 /* Constants.BASE_CHAR_HEIGHT */ + 1);\n        const renderMinimapLineHeight = baseCharHeight * fontScale;\n        const innerLinePadding = (minimapLineHeight > renderMinimapLineHeight ? Math.floor((minimapLineHeight - renderMinimapLineHeight) / 2) : 0);\n        // Render the rest of lines\n        const backgroundA = background.a / 255;\n        const renderBackground = new RGBA8(Math.round((background.r - defaultBackground.r) * backgroundA + defaultBackground.r), Math.round((background.g - defaultBackground.g) * backgroundA + defaultBackground.g), Math.round((background.b - defaultBackground.b) * backgroundA + defaultBackground.b), 255);\n        let dy = layout.topPaddingLineCount * minimapLineHeight;\n        const renderedLines = [];\n        for (let lineIndex = 0, lineCount = endLineNumber - startLineNumber + 1; lineIndex < lineCount; lineIndex++) {\n            if (needed[lineIndex]) {\n                InnerMinimap._renderLine(imageData, renderBackground, background.a, useLighterFont, renderMinimap, minimapCharWidth, tokensColorTracker, foregroundAlpha, charRenderer, dy, innerLinePadding, tabSize, lineInfo[lineIndex], fontScale, minimapLineHeight);\n            }\n            renderedLines[lineIndex] = new MinimapLine(dy);\n            dy += minimapLineHeight;\n        }\n        const dirtyY1 = (_dirtyY1 === -1 ? 0 : _dirtyY1);\n        const dirtyY2 = (_dirtyY2 === -1 ? imageData.height : _dirtyY2);\n        const dirtyHeight = dirtyY2 - dirtyY1;\n        // Finally, paint to the canvas\n        const ctx = this._canvas.domNode.getContext('2d');\n        ctx.putImageData(imageData, 0, 0, 0, dirtyY1, imageData.width, dirtyHeight);\n        // Save rendered data for reuse on next frame if possible\n        return new RenderData(layout, imageData, renderedLines);\n    }\n    static _renderUntouchedLines(target, topPaddingLineCount, startLineNumber, endLineNumber, minimapLineHeight, lastRenderData) {\n        const needed = [];\n        if (!lastRenderData) {\n            for (let i = 0, len = endLineNumber - startLineNumber + 1; i < len; i++) {\n                needed[i] = true;\n            }\n            return [-1, -1, needed];\n        }\n        const _lastData = lastRenderData._get();\n        const lastTargetData = _lastData.imageData.data;\n        const lastStartLineNumber = _lastData.rendLineNumberStart;\n        const lastLines = _lastData.lines;\n        const lastLinesLength = lastLines.length;\n        const WIDTH = target.width;\n        const targetData = target.data;\n        const maxDestPixel = (endLineNumber - startLineNumber + 1) * minimapLineHeight * WIDTH * 4;\n        let dirtyPixel1 = -1; // the pixel offset up to which all the data is equal to the prev frame\n        let dirtyPixel2 = -1; // the pixel offset after which all the data is equal to the prev frame\n        let copySourceStart = -1;\n        let copySourceEnd = -1;\n        let copyDestStart = -1;\n        let copyDestEnd = -1;\n        let dest_dy = topPaddingLineCount * minimapLineHeight;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const lineIndex = lineNumber - startLineNumber;\n            const lastLineIndex = lineNumber - lastStartLineNumber;\n            const source_dy = (lastLineIndex >= 0 && lastLineIndex < lastLinesLength ? lastLines[lastLineIndex].dy : -1);\n            if (source_dy === -1) {\n                needed[lineIndex] = true;\n                dest_dy += minimapLineHeight;\n                continue;\n            }\n            const sourceStart = source_dy * WIDTH * 4;\n            const sourceEnd = (source_dy + minimapLineHeight) * WIDTH * 4;\n            const destStart = dest_dy * WIDTH * 4;\n            const destEnd = (dest_dy + minimapLineHeight) * WIDTH * 4;\n            if (copySourceEnd === sourceStart && copyDestEnd === destStart) {\n                // contiguous zone => extend copy request\n                copySourceEnd = sourceEnd;\n                copyDestEnd = destEnd;\n            }\n            else {\n                if (copySourceStart !== -1) {\n                    // flush existing copy request\n                    targetData.set(lastTargetData.subarray(copySourceStart, copySourceEnd), copyDestStart);\n                    if (dirtyPixel1 === -1 && copySourceStart === 0 && copySourceStart === copyDestStart) {\n                        dirtyPixel1 = copySourceEnd;\n                    }\n                    if (dirtyPixel2 === -1 && copySourceEnd === maxDestPixel && copySourceStart === copyDestStart) {\n                        dirtyPixel2 = copySourceStart;\n                    }\n                }\n                copySourceStart = sourceStart;\n                copySourceEnd = sourceEnd;\n                copyDestStart = destStart;\n                copyDestEnd = destEnd;\n            }\n            needed[lineIndex] = false;\n            dest_dy += minimapLineHeight;\n        }\n        if (copySourceStart !== -1) {\n            // flush existing copy request\n            targetData.set(lastTargetData.subarray(copySourceStart, copySourceEnd), copyDestStart);\n            if (dirtyPixel1 === -1 && copySourceStart === 0 && copySourceStart === copyDestStart) {\n                dirtyPixel1 = copySourceEnd;\n            }\n            if (dirtyPixel2 === -1 && copySourceEnd === maxDestPixel && copySourceStart === copyDestStart) {\n                dirtyPixel2 = copySourceStart;\n            }\n        }\n        const dirtyY1 = (dirtyPixel1 === -1 ? -1 : dirtyPixel1 / (WIDTH * 4));\n        const dirtyY2 = (dirtyPixel2 === -1 ? -1 : dirtyPixel2 / (WIDTH * 4));\n        return [dirtyY1, dirtyY2, needed];\n    }\n    static _renderLine(target, backgroundColor, backgroundAlpha, useLighterFont, renderMinimap, charWidth, colorTracker, foregroundAlpha, minimapCharRenderer, dy, innerLinePadding, tabSize, lineData, fontScale, minimapLineHeight) {\n        const content = lineData.content;\n        const tokens = lineData.tokens;\n        const maxDx = target.width - charWidth;\n        const force1pxHeight = (minimapLineHeight === 1);\n        let dx = MINIMAP_GUTTER_WIDTH;\n        let charIndex = 0;\n        let tabsCharDelta = 0;\n        for (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n            const tokenEndIndex = tokens.getEndOffset(tokenIndex);\n            const tokenColorId = tokens.getForeground(tokenIndex);\n            const tokenColor = colorTracker.getColor(tokenColorId);\n            for (; charIndex < tokenEndIndex; charIndex++) {\n                if (dx > maxDx) {\n                    // hit edge of minimap\n                    return;\n                }\n                const charCode = content.charCodeAt(charIndex);\n                if (charCode === 9 /* CharCode.Tab */) {\n                    const insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;\n                    tabsCharDelta += insertSpacesCount - 1;\n                    // No need to render anything since tab is invisible\n                    dx += insertSpacesCount * charWidth;\n                }\n                else if (charCode === 32 /* CharCode.Space */) {\n                    // No need to render anything since space is invisible\n                    dx += charWidth;\n                }\n                else {\n                    // Render twice for a full width character\n                    const count = strings.isFullWidthCharacter(charCode) ? 2 : 1;\n                    for (let i = 0; i < count; i++) {\n                        if (renderMinimap === 2 /* RenderMinimap.Blocks */) {\n                            minimapCharRenderer.blockRenderChar(target, dx, dy + innerLinePadding, tokenColor, foregroundAlpha, backgroundColor, backgroundAlpha, force1pxHeight);\n                        }\n                        else { // RenderMinimap.Text\n                            minimapCharRenderer.renderChar(target, dx, dy + innerLinePadding, charCode, tokenColor, foregroundAlpha, backgroundColor, backgroundAlpha, fontScale, useLighterFont, force1pxHeight);\n                        }\n                        dx += charWidth;\n                        if (dx > maxDx) {\n                            // hit edge of minimap\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\nclass ContiguousLineMap {\n    constructor(startLineNumber, endLineNumber, defaultValue) {\n        this._startLineNumber = startLineNumber;\n        this._endLineNumber = endLineNumber;\n        this._defaultValue = defaultValue;\n        this._values = [];\n        for (let i = 0, count = this._endLineNumber - this._startLineNumber + 1; i < count; i++) {\n            this._values[i] = defaultValue;\n        }\n    }\n    has(lineNumber) {\n        return (this.get(lineNumber) !== this._defaultValue);\n    }\n    set(lineNumber, value) {\n        if (lineNumber < this._startLineNumber || lineNumber > this._endLineNumber) {\n            return;\n        }\n        this._values[lineNumber - this._startLineNumber] = value;\n    }\n    get(lineNumber) {\n        if (lineNumber < this._startLineNumber || lineNumber > this._endLineNumber) {\n            return this._defaultValue;\n        }\n        return this._values[lineNumber - this._startLineNumber];\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}