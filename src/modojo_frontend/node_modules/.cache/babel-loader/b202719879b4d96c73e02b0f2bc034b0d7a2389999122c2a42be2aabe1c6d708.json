{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Event } from '../event.js';\nimport { DisposableStore, toDisposable } from '../lifecycle.js';\nimport { BaseObservable, ConvenientObservable, _setKeepObserved, _setRecomputeInitiallyAndOnChange, subtransaction, transaction } from './base.js';\nimport { DebugNameData, getFunctionName } from './debugName.js';\nimport { derived, derivedOpts } from './derived.js';\nimport { getLogger } from './logging.js';\n/**\n * Represents an efficient observable whose value never changes.\n */\nexport function constObservable(value) {\n  return new ConstObservable(value);\n}\nclass ConstObservable extends ConvenientObservable {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n  get debugName() {\n    return this.toString();\n  }\n  get() {\n    return this.value;\n  }\n  addObserver(observer) {\n    // NO OP\n  }\n  removeObserver(observer) {\n    // NO OP\n  }\n  toString() {\n    return `Const: ${this.value}`;\n  }\n}\nexport function observableFromEvent(event, getValue) {\n  return new FromEventObservable(event, getValue);\n}\nexport class FromEventObservable extends BaseObservable {\n  constructor(event, _getValue) {\n    super();\n    this.event = event;\n    this._getValue = _getValue;\n    this.hasValue = false;\n    this.handleEvent = args => {\n      var _a;\n      const newValue = this._getValue(args);\n      const oldValue = this.value;\n      const didChange = !this.hasValue || oldValue !== newValue;\n      let didRunTransaction = false;\n      if (didChange) {\n        this.value = newValue;\n        if (this.hasValue) {\n          didRunTransaction = true;\n          subtransaction(FromEventObservable.globalTransaction, tx => {\n            var _a;\n            (_a = getLogger()) === null || _a === void 0 ? void 0 : _a.handleFromEventObservableTriggered(this, {\n              oldValue,\n              newValue,\n              change: undefined,\n              didChange,\n              hadValue: this.hasValue\n            });\n            for (const o of this.observers) {\n              tx.updateObserver(o, this);\n              o.handleChange(this, undefined);\n            }\n          }, () => {\n            const name = this.getDebugName();\n            return 'Event fired' + (name ? `: ${name}` : '');\n          });\n        }\n        this.hasValue = true;\n      }\n      if (!didRunTransaction) {\n        (_a = getLogger()) === null || _a === void 0 ? void 0 : _a.handleFromEventObservableTriggered(this, {\n          oldValue,\n          newValue,\n          change: undefined,\n          didChange,\n          hadValue: this.hasValue\n        });\n      }\n    };\n  }\n  getDebugName() {\n    return getFunctionName(this._getValue);\n  }\n  get debugName() {\n    const name = this.getDebugName();\n    return 'From Event' + (name ? `: ${name}` : '');\n  }\n  onFirstObserverAdded() {\n    this.subscription = this.event(this.handleEvent);\n  }\n  onLastObserverRemoved() {\n    this.subscription.dispose();\n    this.subscription = undefined;\n    this.hasValue = false;\n    this.value = undefined;\n  }\n  get() {\n    if (this.subscription) {\n      if (!this.hasValue) {\n        this.handleEvent(undefined);\n      }\n      return this.value;\n    } else {\n      // no cache, as there are no subscribers to keep it updated\n      const value = this._getValue(undefined);\n      return value;\n    }\n  }\n}\n(function (observableFromEvent) {\n  observableFromEvent.Observer = FromEventObservable;\n  function batchEventsGlobally(tx, fn) {\n    let didSet = false;\n    if (FromEventObservable.globalTransaction === undefined) {\n      FromEventObservable.globalTransaction = tx;\n      didSet = true;\n    }\n    try {\n      fn();\n    } finally {\n      if (didSet) {\n        FromEventObservable.globalTransaction = undefined;\n      }\n    }\n  }\n  observableFromEvent.batchEventsGlobally = batchEventsGlobally;\n})(observableFromEvent || (observableFromEvent = {}));\nexport function observableSignalFromEvent(debugName, event) {\n  return new FromEventObservableSignal(debugName, event);\n}\nclass FromEventObservableSignal extends BaseObservable {\n  constructor(debugName, event) {\n    super();\n    this.debugName = debugName;\n    this.event = event;\n    this.handleEvent = () => {\n      transaction(tx => {\n        for (const o of this.observers) {\n          tx.updateObserver(o, this);\n          o.handleChange(this, undefined);\n        }\n      }, () => this.debugName);\n    };\n  }\n  onFirstObserverAdded() {\n    this.subscription = this.event(this.handleEvent);\n  }\n  onLastObserverRemoved() {\n    this.subscription.dispose();\n    this.subscription = undefined;\n  }\n  get() {\n    // NO OP\n  }\n}\nexport function observableSignal(debugNameOrOwner) {\n  if (typeof debugNameOrOwner === 'string') {\n    return new ObservableSignal(debugNameOrOwner);\n  } else {\n    return new ObservableSignal(undefined, debugNameOrOwner);\n  }\n}\nclass ObservableSignal extends BaseObservable {\n  get debugName() {\n    var _a;\n    return (_a = new DebugNameData(this._owner, this._debugName, undefined).getDebugName(this)) !== null && _a !== void 0 ? _a : 'Observable Signal';\n  }\n  constructor(_debugName, _owner) {\n    super();\n    this._debugName = _debugName;\n    this._owner = _owner;\n  }\n  trigger(tx, change) {\n    if (!tx) {\n      transaction(tx => {\n        this.trigger(tx, change);\n      }, () => `Trigger signal ${this.debugName}`);\n      return;\n    }\n    for (const o of this.observers) {\n      tx.updateObserver(o, this);\n      o.handleChange(this, change);\n    }\n  }\n  get() {\n    // NO OP\n  }\n}\n/**\n * This makes sure the observable is being observed and keeps its cache alive.\n */\nexport function keepObserved(observable) {\n  const o = new KeepAliveObserver(false, undefined);\n  observable.addObserver(o);\n  return toDisposable(() => {\n    observable.removeObserver(o);\n  });\n}\n_setKeepObserved(keepObserved);\n/**\n * This converts the given observable into an autorun.\n */\nexport function recomputeInitiallyAndOnChange(observable, handleValue) {\n  const o = new KeepAliveObserver(true, handleValue);\n  observable.addObserver(o);\n  if (handleValue) {\n    handleValue(observable.get());\n  } else {\n    observable.reportChanges();\n  }\n  return toDisposable(() => {\n    observable.removeObserver(o);\n  });\n}\n_setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange);\nexport class KeepAliveObserver {\n  constructor(_forceRecompute, _handleValue) {\n    this._forceRecompute = _forceRecompute;\n    this._handleValue = _handleValue;\n    this._counter = 0;\n  }\n  beginUpdate(observable) {\n    this._counter++;\n  }\n  endUpdate(observable) {\n    this._counter--;\n    if (this._counter === 0 && this._forceRecompute) {\n      if (this._handleValue) {\n        this._handleValue(observable.get());\n      } else {\n        observable.reportChanges();\n      }\n    }\n  }\n  handlePossibleChange(observable) {\n    // NO OP\n  }\n  handleChange(observable, change) {\n    // NO OP\n  }\n}\nexport function derivedObservableWithCache(owner, computeFn) {\n  let lastValue = undefined;\n  const observable = derived(owner, reader => {\n    lastValue = computeFn(reader, lastValue);\n    return lastValue;\n  });\n  return observable;\n}\nexport function derivedObservableWithWritableCache(owner, computeFn) {\n  let lastValue = undefined;\n  const onChange = observableSignal('derivedObservableWithWritableCache');\n  const observable = derived(owner, reader => {\n    onChange.read(reader);\n    lastValue = computeFn(reader, lastValue);\n    return lastValue;\n  });\n  return Object.assign(observable, {\n    clearCache: tx => {\n      lastValue = undefined;\n      onChange.trigger(tx);\n    },\n    setCache: (newValue, tx) => {\n      lastValue = newValue;\n      onChange.trigger(tx);\n    }\n  });\n}\n/**\n * When the items array changes, referential equal items are not mapped again.\n */\nexport function mapObservableArrayCached(owner, items, map, keySelector) {\n  let m = new ArrayMap(map, keySelector);\n  const self = derivedOpts({\n    debugReferenceFn: map,\n    owner,\n    onLastObserverRemoved: () => {\n      m.dispose();\n      m = new ArrayMap(map);\n    }\n  }, reader => {\n    m.setItems(items.read(reader));\n    return m.getItems();\n  });\n  return self;\n}\nclass ArrayMap {\n  constructor(_map, _keySelector) {\n    this._map = _map;\n    this._keySelector = _keySelector;\n    this._cache = new Map();\n    this._items = [];\n  }\n  dispose() {\n    this._cache.forEach(entry => entry.store.dispose());\n    this._cache.clear();\n  }\n  setItems(items) {\n    const newItems = [];\n    const itemsToRemove = new Set(this._cache.keys());\n    for (const item of items) {\n      const key = this._keySelector ? this._keySelector(item) : item;\n      let entry = this._cache.get(key);\n      if (!entry) {\n        const store = new DisposableStore();\n        const out = this._map(item, store);\n        entry = {\n          out,\n          store\n        };\n        this._cache.set(key, entry);\n      } else {\n        itemsToRemove.delete(key);\n      }\n      newItems.push(entry.out);\n    }\n    for (const item of itemsToRemove) {\n      const entry = this._cache.get(item);\n      entry.store.dispose();\n      this._cache.delete(item);\n    }\n    this._items = newItems;\n  }\n  getItems() {\n    return this._items;\n  }\n}\nexport class ValueWithChangeEventFromObservable {\n  constructor(observable) {\n    this.observable = observable;\n  }\n  get onDidChange() {\n    return Event.fromObservableLight(this.observable);\n  }\n  get value() {\n    return this.observable.get();\n  }\n}\nexport function observableFromValueWithChangeEvent(_owner, value) {\n  if (value instanceof ValueWithChangeEventFromObservable) {\n    return value.observable;\n  }\n  return observableFromEvent(value.onDidChange, () => value.value);\n}","map":{"version":3,"names":["Event","DisposableStore","toDisposable","BaseObservable","ConvenientObservable","_setKeepObserved","_setRecomputeInitiallyAndOnChange","subtransaction","transaction","DebugNameData","getFunctionName","derived","derivedOpts","getLogger","constObservable","value","ConstObservable","constructor","debugName","toString","get","addObserver","observer","removeObserver","observableFromEvent","event","getValue","FromEventObservable","_getValue","hasValue","handleEvent","args","_a","newValue","oldValue","didChange","didRunTransaction","globalTransaction","tx","handleFromEventObservableTriggered","change","undefined","hadValue","o","observers","updateObserver","handleChange","name","getDebugName","onFirstObserverAdded","subscription","onLastObserverRemoved","dispose","Observer","batchEventsGlobally","fn","didSet","observableSignalFromEvent","FromEventObservableSignal","observableSignal","debugNameOrOwner","ObservableSignal","_owner","_debugName","trigger","keepObserved","observable","KeepAliveObserver","recomputeInitiallyAndOnChange","handleValue","reportChanges","_forceRecompute","_handleValue","_counter","beginUpdate","endUpdate","handlePossibleChange","derivedObservableWithCache","owner","computeFn","lastValue","reader","derivedObservableWithWritableCache","onChange","read","Object","assign","clearCache","setCache","mapObservableArrayCached","items","map","keySelector","m","ArrayMap","self","debugReferenceFn","setItems","getItems","_map","_keySelector","_cache","Map","_items","forEach","entry","store","clear","newItems","itemsToRemove","Set","keys","item","key","out","set","delete","push","ValueWithChangeEventFromObservable","onDidChange","fromObservableLight","observableFromValueWithChangeEvent"],"sources":["/home/arslan/modojo/node_modules/monaco-editor/esm/vs/base/common/observableInternal/utils.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Event } from '../event.js';\nimport { DisposableStore, toDisposable } from '../lifecycle.js';\nimport { BaseObservable, ConvenientObservable, _setKeepObserved, _setRecomputeInitiallyAndOnChange, subtransaction, transaction } from './base.js';\nimport { DebugNameData, getFunctionName } from './debugName.js';\nimport { derived, derivedOpts } from './derived.js';\nimport { getLogger } from './logging.js';\n/**\n * Represents an efficient observable whose value never changes.\n */\nexport function constObservable(value) {\n    return new ConstObservable(value);\n}\nclass ConstObservable extends ConvenientObservable {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n    get debugName() {\n        return this.toString();\n    }\n    get() {\n        return this.value;\n    }\n    addObserver(observer) {\n        // NO OP\n    }\n    removeObserver(observer) {\n        // NO OP\n    }\n    toString() {\n        return `Const: ${this.value}`;\n    }\n}\nexport function observableFromEvent(event, getValue) {\n    return new FromEventObservable(event, getValue);\n}\nexport class FromEventObservable extends BaseObservable {\n    constructor(event, _getValue) {\n        super();\n        this.event = event;\n        this._getValue = _getValue;\n        this.hasValue = false;\n        this.handleEvent = (args) => {\n            var _a;\n            const newValue = this._getValue(args);\n            const oldValue = this.value;\n            const didChange = !this.hasValue || oldValue !== newValue;\n            let didRunTransaction = false;\n            if (didChange) {\n                this.value = newValue;\n                if (this.hasValue) {\n                    didRunTransaction = true;\n                    subtransaction(FromEventObservable.globalTransaction, (tx) => {\n                        var _a;\n                        (_a = getLogger()) === null || _a === void 0 ? void 0 : _a.handleFromEventObservableTriggered(this, { oldValue, newValue, change: undefined, didChange, hadValue: this.hasValue });\n                        for (const o of this.observers) {\n                            tx.updateObserver(o, this);\n                            o.handleChange(this, undefined);\n                        }\n                    }, () => {\n                        const name = this.getDebugName();\n                        return 'Event fired' + (name ? `: ${name}` : '');\n                    });\n                }\n                this.hasValue = true;\n            }\n            if (!didRunTransaction) {\n                (_a = getLogger()) === null || _a === void 0 ? void 0 : _a.handleFromEventObservableTriggered(this, { oldValue, newValue, change: undefined, didChange, hadValue: this.hasValue });\n            }\n        };\n    }\n    getDebugName() {\n        return getFunctionName(this._getValue);\n    }\n    get debugName() {\n        const name = this.getDebugName();\n        return 'From Event' + (name ? `: ${name}` : '');\n    }\n    onFirstObserverAdded() {\n        this.subscription = this.event(this.handleEvent);\n    }\n    onLastObserverRemoved() {\n        this.subscription.dispose();\n        this.subscription = undefined;\n        this.hasValue = false;\n        this.value = undefined;\n    }\n    get() {\n        if (this.subscription) {\n            if (!this.hasValue) {\n                this.handleEvent(undefined);\n            }\n            return this.value;\n        }\n        else {\n            // no cache, as there are no subscribers to keep it updated\n            const value = this._getValue(undefined);\n            return value;\n        }\n    }\n}\n(function (observableFromEvent) {\n    observableFromEvent.Observer = FromEventObservable;\n    function batchEventsGlobally(tx, fn) {\n        let didSet = false;\n        if (FromEventObservable.globalTransaction === undefined) {\n            FromEventObservable.globalTransaction = tx;\n            didSet = true;\n        }\n        try {\n            fn();\n        }\n        finally {\n            if (didSet) {\n                FromEventObservable.globalTransaction = undefined;\n            }\n        }\n    }\n    observableFromEvent.batchEventsGlobally = batchEventsGlobally;\n})(observableFromEvent || (observableFromEvent = {}));\nexport function observableSignalFromEvent(debugName, event) {\n    return new FromEventObservableSignal(debugName, event);\n}\nclass FromEventObservableSignal extends BaseObservable {\n    constructor(debugName, event) {\n        super();\n        this.debugName = debugName;\n        this.event = event;\n        this.handleEvent = () => {\n            transaction((tx) => {\n                for (const o of this.observers) {\n                    tx.updateObserver(o, this);\n                    o.handleChange(this, undefined);\n                }\n            }, () => this.debugName);\n        };\n    }\n    onFirstObserverAdded() {\n        this.subscription = this.event(this.handleEvent);\n    }\n    onLastObserverRemoved() {\n        this.subscription.dispose();\n        this.subscription = undefined;\n    }\n    get() {\n        // NO OP\n    }\n}\nexport function observableSignal(debugNameOrOwner) {\n    if (typeof debugNameOrOwner === 'string') {\n        return new ObservableSignal(debugNameOrOwner);\n    }\n    else {\n        return new ObservableSignal(undefined, debugNameOrOwner);\n    }\n}\nclass ObservableSignal extends BaseObservable {\n    get debugName() {\n        var _a;\n        return (_a = new DebugNameData(this._owner, this._debugName, undefined).getDebugName(this)) !== null && _a !== void 0 ? _a : 'Observable Signal';\n    }\n    constructor(_debugName, _owner) {\n        super();\n        this._debugName = _debugName;\n        this._owner = _owner;\n    }\n    trigger(tx, change) {\n        if (!tx) {\n            transaction(tx => {\n                this.trigger(tx, change);\n            }, () => `Trigger signal ${this.debugName}`);\n            return;\n        }\n        for (const o of this.observers) {\n            tx.updateObserver(o, this);\n            o.handleChange(this, change);\n        }\n    }\n    get() {\n        // NO OP\n    }\n}\n/**\n * This makes sure the observable is being observed and keeps its cache alive.\n */\nexport function keepObserved(observable) {\n    const o = new KeepAliveObserver(false, undefined);\n    observable.addObserver(o);\n    return toDisposable(() => {\n        observable.removeObserver(o);\n    });\n}\n_setKeepObserved(keepObserved);\n/**\n * This converts the given observable into an autorun.\n */\nexport function recomputeInitiallyAndOnChange(observable, handleValue) {\n    const o = new KeepAliveObserver(true, handleValue);\n    observable.addObserver(o);\n    if (handleValue) {\n        handleValue(observable.get());\n    }\n    else {\n        observable.reportChanges();\n    }\n    return toDisposable(() => {\n        observable.removeObserver(o);\n    });\n}\n_setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange);\nexport class KeepAliveObserver {\n    constructor(_forceRecompute, _handleValue) {\n        this._forceRecompute = _forceRecompute;\n        this._handleValue = _handleValue;\n        this._counter = 0;\n    }\n    beginUpdate(observable) {\n        this._counter++;\n    }\n    endUpdate(observable) {\n        this._counter--;\n        if (this._counter === 0 && this._forceRecompute) {\n            if (this._handleValue) {\n                this._handleValue(observable.get());\n            }\n            else {\n                observable.reportChanges();\n            }\n        }\n    }\n    handlePossibleChange(observable) {\n        // NO OP\n    }\n    handleChange(observable, change) {\n        // NO OP\n    }\n}\nexport function derivedObservableWithCache(owner, computeFn) {\n    let lastValue = undefined;\n    const observable = derived(owner, reader => {\n        lastValue = computeFn(reader, lastValue);\n        return lastValue;\n    });\n    return observable;\n}\nexport function derivedObservableWithWritableCache(owner, computeFn) {\n    let lastValue = undefined;\n    const onChange = observableSignal('derivedObservableWithWritableCache');\n    const observable = derived(owner, reader => {\n        onChange.read(reader);\n        lastValue = computeFn(reader, lastValue);\n        return lastValue;\n    });\n    return Object.assign(observable, {\n        clearCache: (tx) => {\n            lastValue = undefined;\n            onChange.trigger(tx);\n        },\n        setCache: (newValue, tx) => {\n            lastValue = newValue;\n            onChange.trigger(tx);\n        }\n    });\n}\n/**\n * When the items array changes, referential equal items are not mapped again.\n */\nexport function mapObservableArrayCached(owner, items, map, keySelector) {\n    let m = new ArrayMap(map, keySelector);\n    const self = derivedOpts({\n        debugReferenceFn: map,\n        owner,\n        onLastObserverRemoved: () => {\n            m.dispose();\n            m = new ArrayMap(map);\n        }\n    }, (reader) => {\n        m.setItems(items.read(reader));\n        return m.getItems();\n    });\n    return self;\n}\nclass ArrayMap {\n    constructor(_map, _keySelector) {\n        this._map = _map;\n        this._keySelector = _keySelector;\n        this._cache = new Map();\n        this._items = [];\n    }\n    dispose() {\n        this._cache.forEach(entry => entry.store.dispose());\n        this._cache.clear();\n    }\n    setItems(items) {\n        const newItems = [];\n        const itemsToRemove = new Set(this._cache.keys());\n        for (const item of items) {\n            const key = this._keySelector ? this._keySelector(item) : item;\n            let entry = this._cache.get(key);\n            if (!entry) {\n                const store = new DisposableStore();\n                const out = this._map(item, store);\n                entry = { out, store };\n                this._cache.set(key, entry);\n            }\n            else {\n                itemsToRemove.delete(key);\n            }\n            newItems.push(entry.out);\n        }\n        for (const item of itemsToRemove) {\n            const entry = this._cache.get(item);\n            entry.store.dispose();\n            this._cache.delete(item);\n        }\n        this._items = newItems;\n    }\n    getItems() {\n        return this._items;\n    }\n}\nexport class ValueWithChangeEventFromObservable {\n    constructor(observable) {\n        this.observable = observable;\n    }\n    get onDidChange() {\n        return Event.fromObservableLight(this.observable);\n    }\n    get value() {\n        return this.observable.get();\n    }\n}\nexport function observableFromValueWithChangeEvent(_owner, value) {\n    if (value instanceof ValueWithChangeEventFromObservable) {\n        return value.observable;\n    }\n    return observableFromEvent(value.onDidChange, () => value.value);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}