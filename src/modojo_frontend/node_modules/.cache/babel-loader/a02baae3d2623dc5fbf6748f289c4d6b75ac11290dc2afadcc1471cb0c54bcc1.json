{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { Range } from '../../core/range.js';\nimport { ApplyEditsResult } from '../../model.js';\nimport { PieceTreeBase } from './pieceTreeBase.js';\nimport { countEOL } from '../../core/eolCounter.js';\nimport { TextChange } from '../../core/textChange.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nexport class PieceTreeTextBuffer extends Disposable {\n  constructor(chunks, BOM, eol, containsRTL, containsUnusualLineTerminators, isBasicASCII, eolNormalized) {\n    super();\n    this._onDidChangeContent = this._register(new Emitter());\n    this._BOM = BOM;\n    this._mightContainNonBasicASCII = !isBasicASCII;\n    this._mightContainRTL = containsRTL;\n    this._mightContainUnusualLineTerminators = containsUnusualLineTerminators;\n    this._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);\n  }\n  mightContainRTL() {\n    return this._mightContainRTL;\n  }\n  mightContainUnusualLineTerminators() {\n    return this._mightContainUnusualLineTerminators;\n  }\n  resetMightContainUnusualLineTerminators() {\n    this._mightContainUnusualLineTerminators = false;\n  }\n  mightContainNonBasicASCII() {\n    return this._mightContainNonBasicASCII;\n  }\n  getBOM() {\n    return this._BOM;\n  }\n  getEOL() {\n    return this._pieceTree.getEOL();\n  }\n  createSnapshot(preserveBOM) {\n    return this._pieceTree.createSnapshot(preserveBOM ? this._BOM : '');\n  }\n  getOffsetAt(lineNumber, column) {\n    return this._pieceTree.getOffsetAt(lineNumber, column);\n  }\n  getPositionAt(offset) {\n    return this._pieceTree.getPositionAt(offset);\n  }\n  getRangeAt(start, length) {\n    const end = start + length;\n    const startPosition = this.getPositionAt(start);\n    const endPosition = this.getPositionAt(end);\n    return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n  }\n  getValueInRange(range) {\n    let eol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    if (range.isEmpty()) {\n      return '';\n    }\n    const lineEnding = this._getEndOfLine(eol);\n    return this._pieceTree.getValueInRange(range, lineEnding);\n  }\n  getValueLengthInRange(range) {\n    let eol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    if (range.isEmpty()) {\n      return 0;\n    }\n    if (range.startLineNumber === range.endLineNumber) {\n      return range.endColumn - range.startColumn;\n    }\n    const startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);\n    const endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);\n    // offsets use the text EOL, so we need to compensate for length differences\n    // if the requested EOL doesn't match the text EOL\n    let eolOffsetCompensation = 0;\n    const desiredEOL = this._getEndOfLine(eol);\n    const actualEOL = this.getEOL();\n    if (desiredEOL.length !== actualEOL.length) {\n      const delta = desiredEOL.length - actualEOL.length;\n      const eolCount = range.endLineNumber - range.startLineNumber;\n      eolOffsetCompensation = delta * eolCount;\n    }\n    return endOffset - startOffset + eolOffsetCompensation;\n  }\n  getCharacterCountInRange(range) {\n    let eol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    if (this._mightContainNonBasicASCII) {\n      // we must count by iterating\n      let result = 0;\n      const fromLineNumber = range.startLineNumber;\n      const toLineNumber = range.endLineNumber;\n      for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n        const lineContent = this.getLineContent(lineNumber);\n        const fromOffset = lineNumber === fromLineNumber ? range.startColumn - 1 : 0;\n        const toOffset = lineNumber === toLineNumber ? range.endColumn - 1 : lineContent.length;\n        for (let offset = fromOffset; offset < toOffset; offset++) {\n          if (strings.isHighSurrogate(lineContent.charCodeAt(offset))) {\n            result = result + 1;\n            offset = offset + 1;\n          } else {\n            result = result + 1;\n          }\n        }\n      }\n      result += this._getEndOfLine(eol).length * (toLineNumber - fromLineNumber);\n      return result;\n    }\n    return this.getValueLengthInRange(range, eol);\n  }\n  getLength() {\n    return this._pieceTree.getLength();\n  }\n  getLineCount() {\n    return this._pieceTree.getLineCount();\n  }\n  getLinesContent() {\n    return this._pieceTree.getLinesContent();\n  }\n  getLineContent(lineNumber) {\n    return this._pieceTree.getLineContent(lineNumber);\n  }\n  getLineCharCode(lineNumber, index) {\n    return this._pieceTree.getLineCharCode(lineNumber, index);\n  }\n  getLineLength(lineNumber) {\n    return this._pieceTree.getLineLength(lineNumber);\n  }\n  getLineFirstNonWhitespaceColumn(lineNumber) {\n    const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n    if (result === -1) {\n      return 0;\n    }\n    return result + 1;\n  }\n  getLineLastNonWhitespaceColumn(lineNumber) {\n    const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n    if (result === -1) {\n      return 0;\n    }\n    return result + 2;\n  }\n  _getEndOfLine(eol) {\n    switch (eol) {\n      case 1 /* EndOfLinePreference.LF */:\n        return '\\n';\n      case 2 /* EndOfLinePreference.CRLF */:\n        return '\\r\\n';\n      case 0 /* EndOfLinePreference.TextDefined */:\n        return this.getEOL();\n      default:\n        throw new Error('Unknown EOL preference');\n    }\n  }\n  setEOL(newEOL) {\n    this._pieceTree.setEOL(newEOL);\n  }\n  applyEdits(rawOperations, recordTrimAutoWhitespace, computeUndoEdits) {\n    let mightContainRTL = this._mightContainRTL;\n    let mightContainUnusualLineTerminators = this._mightContainUnusualLineTerminators;\n    let mightContainNonBasicASCII = this._mightContainNonBasicASCII;\n    let canReduceOperations = true;\n    let operations = [];\n    for (let i = 0; i < rawOperations.length; i++) {\n      const op = rawOperations[i];\n      if (canReduceOperations && op._isTracked) {\n        canReduceOperations = false;\n      }\n      const validatedRange = op.range;\n      if (op.text) {\n        let textMightContainNonBasicASCII = true;\n        if (!mightContainNonBasicASCII) {\n          textMightContainNonBasicASCII = !strings.isBasicASCII(op.text);\n          mightContainNonBasicASCII = textMightContainNonBasicASCII;\n        }\n        if (!mightContainRTL && textMightContainNonBasicASCII) {\n          // check if the new inserted text contains RTL\n          mightContainRTL = strings.containsRTL(op.text);\n        }\n        if (!mightContainUnusualLineTerminators && textMightContainNonBasicASCII) {\n          // check if the new inserted text contains unusual line terminators\n          mightContainUnusualLineTerminators = strings.containsUnusualLineTerminators(op.text);\n        }\n      }\n      let validText = '';\n      let eolCount = 0;\n      let firstLineLength = 0;\n      let lastLineLength = 0;\n      if (op.text) {\n        let strEOL;\n        [eolCount, firstLineLength, lastLineLength, strEOL] = countEOL(op.text);\n        const bufferEOL = this.getEOL();\n        const expectedStrEOL = bufferEOL === '\\r\\n' ? 2 /* StringEOL.CRLF */ : 1 /* StringEOL.LF */;\n        if (strEOL === 0 /* StringEOL.Unknown */ || strEOL === expectedStrEOL) {\n          validText = op.text;\n        } else {\n          validText = op.text.replace(/\\r\\n|\\r|\\n/g, bufferEOL);\n        }\n      }\n      operations[i] = {\n        sortIndex: i,\n        identifier: op.identifier || null,\n        range: validatedRange,\n        rangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),\n        rangeLength: this.getValueLengthInRange(validatedRange),\n        text: validText,\n        eolCount: eolCount,\n        firstLineLength: firstLineLength,\n        lastLineLength: lastLineLength,\n        forceMoveMarkers: Boolean(op.forceMoveMarkers),\n        isAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false\n      };\n    }\n    // Sort operations ascending\n    operations.sort(PieceTreeTextBuffer._sortOpsAscending);\n    let hasTouchingRanges = false;\n    for (let i = 0, count = operations.length - 1; i < count; i++) {\n      const rangeEnd = operations[i].range.getEndPosition();\n      const nextRangeStart = operations[i + 1].range.getStartPosition();\n      if (nextRangeStart.isBeforeOrEqual(rangeEnd)) {\n        if (nextRangeStart.isBefore(rangeEnd)) {\n          // overlapping ranges\n          throw new Error('Overlapping ranges are not allowed!');\n        }\n        hasTouchingRanges = true;\n      }\n    }\n    if (canReduceOperations) {\n      operations = this._reduceOperations(operations);\n    }\n    // Delta encode operations\n    const reverseRanges = computeUndoEdits || recordTrimAutoWhitespace ? PieceTreeTextBuffer._getInverseEditRanges(operations) : [];\n    const newTrimAutoWhitespaceCandidates = [];\n    if (recordTrimAutoWhitespace) {\n      for (let i = 0; i < operations.length; i++) {\n        const op = operations[i];\n        const reverseRange = reverseRanges[i];\n        if (op.isAutoWhitespaceEdit && op.range.isEmpty()) {\n          // Record already the future line numbers that might be auto whitespace removal candidates on next edit\n          for (let lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {\n            let currentLineContent = '';\n            if (lineNumber === reverseRange.startLineNumber) {\n              currentLineContent = this.getLineContent(op.range.startLineNumber);\n              if (strings.firstNonWhitespaceIndex(currentLineContent) !== -1) {\n                continue;\n              }\n            }\n            newTrimAutoWhitespaceCandidates.push({\n              lineNumber: lineNumber,\n              oldContent: currentLineContent\n            });\n          }\n        }\n      }\n    }\n    let reverseOperations = null;\n    if (computeUndoEdits) {\n      let reverseRangeDeltaOffset = 0;\n      reverseOperations = [];\n      for (let i = 0; i < operations.length; i++) {\n        const op = operations[i];\n        const reverseRange = reverseRanges[i];\n        const bufferText = this.getValueInRange(op.range);\n        const reverseRangeOffset = op.rangeOffset + reverseRangeDeltaOffset;\n        reverseRangeDeltaOffset += op.text.length - bufferText.length;\n        reverseOperations[i] = {\n          sortIndex: op.sortIndex,\n          identifier: op.identifier,\n          range: reverseRange,\n          text: bufferText,\n          textChange: new TextChange(op.rangeOffset, bufferText, reverseRangeOffset, op.text)\n        };\n      }\n      // Can only sort reverse operations when the order is not significant\n      if (!hasTouchingRanges) {\n        reverseOperations.sort((a, b) => a.sortIndex - b.sortIndex);\n      }\n    }\n    this._mightContainRTL = mightContainRTL;\n    this._mightContainUnusualLineTerminators = mightContainUnusualLineTerminators;\n    this._mightContainNonBasicASCII = mightContainNonBasicASCII;\n    const contentChanges = this._doApplyEdits(operations);\n    let trimAutoWhitespaceLineNumbers = null;\n    if (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {\n      // sort line numbers auto whitespace removal candidates for next edit descending\n      newTrimAutoWhitespaceCandidates.sort((a, b) => b.lineNumber - a.lineNumber);\n      trimAutoWhitespaceLineNumbers = [];\n      for (let i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {\n        const lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;\n        if (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {\n          // Do not have the same line number twice\n          continue;\n        }\n        const prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;\n        const lineContent = this.getLineContent(lineNumber);\n        if (lineContent.length === 0 || lineContent === prevContent || strings.firstNonWhitespaceIndex(lineContent) !== -1) {\n          continue;\n        }\n        trimAutoWhitespaceLineNumbers.push(lineNumber);\n      }\n    }\n    this._onDidChangeContent.fire();\n    return new ApplyEditsResult(reverseOperations, contentChanges, trimAutoWhitespaceLineNumbers);\n  }\n  /**\n   * Transform operations such that they represent the same logic edit,\n   * but that they also do not cause OOM crashes.\n   */\n  _reduceOperations(operations) {\n    if (operations.length < 1000) {\n      // We know from empirical testing that a thousand edits work fine regardless of their shape.\n      return operations;\n    }\n    // At one point, due to how events are emitted and how each operation is handled,\n    // some operations can trigger a high amount of temporary string allocations,\n    // that will immediately get edited again.\n    // e.g. a formatter inserting ridiculous ammounts of \\n on a model with a single line\n    // Therefore, the strategy is to collapse all the operations into a huge single edit operation\n    return [this._toSingleEditOperation(operations)];\n  }\n  _toSingleEditOperation(operations) {\n    let forceMoveMarkers = false;\n    const firstEditRange = operations[0].range;\n    const lastEditRange = operations[operations.length - 1].range;\n    const entireEditRange = new Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn);\n    let lastEndLineNumber = firstEditRange.startLineNumber;\n    let lastEndColumn = firstEditRange.startColumn;\n    const result = [];\n    for (let i = 0, len = operations.length; i < len; i++) {\n      const operation = operations[i];\n      const range = operation.range;\n      forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;\n      // (1) -- Push old text\n      result.push(this.getValueInRange(new Range(lastEndLineNumber, lastEndColumn, range.startLineNumber, range.startColumn)));\n      // (2) -- Push new text\n      if (operation.text.length > 0) {\n        result.push(operation.text);\n      }\n      lastEndLineNumber = range.endLineNumber;\n      lastEndColumn = range.endColumn;\n    }\n    const text = result.join('');\n    const [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n    return {\n      sortIndex: 0,\n      identifier: operations[0].identifier,\n      range: entireEditRange,\n      rangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),\n      rangeLength: this.getValueLengthInRange(entireEditRange, 0 /* EndOfLinePreference.TextDefined */),\n      text: text,\n      eolCount: eolCount,\n      firstLineLength: firstLineLength,\n      lastLineLength: lastLineLength,\n      forceMoveMarkers: forceMoveMarkers,\n      isAutoWhitespaceEdit: false\n    };\n  }\n  _doApplyEdits(operations) {\n    operations.sort(PieceTreeTextBuffer._sortOpsDescending);\n    const contentChanges = [];\n    // operations are from bottom to top\n    for (let i = 0; i < operations.length; i++) {\n      const op = operations[i];\n      const startLineNumber = op.range.startLineNumber;\n      const startColumn = op.range.startColumn;\n      const endLineNumber = op.range.endLineNumber;\n      const endColumn = op.range.endColumn;\n      if (startLineNumber === endLineNumber && startColumn === endColumn && op.text.length === 0) {\n        // no-op\n        continue;\n      }\n      if (op.text) {\n        // replacement\n        this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n        this._pieceTree.insert(op.rangeOffset, op.text, true);\n      } else {\n        // deletion\n        this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n      }\n      const contentChangeRange = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n      contentChanges.push({\n        range: contentChangeRange,\n        rangeLength: op.rangeLength,\n        text: op.text,\n        rangeOffset: op.rangeOffset,\n        forceMoveMarkers: op.forceMoveMarkers\n      });\n    }\n    return contentChanges;\n  }\n  findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n    return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n  }\n  /**\n   * Assumes `operations` are validated and sorted ascending\n   */\n  static _getInverseEditRanges(operations) {\n    const result = [];\n    let prevOpEndLineNumber = 0;\n    let prevOpEndColumn = 0;\n    let prevOp = null;\n    for (let i = 0, len = operations.length; i < len; i++) {\n      const op = operations[i];\n      let startLineNumber;\n      let startColumn;\n      if (prevOp) {\n        if (prevOp.range.endLineNumber === op.range.startLineNumber) {\n          startLineNumber = prevOpEndLineNumber;\n          startColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);\n        } else {\n          startLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);\n          startColumn = op.range.startColumn;\n        }\n      } else {\n        startLineNumber = op.range.startLineNumber;\n        startColumn = op.range.startColumn;\n      }\n      let resultRange;\n      if (op.text.length > 0) {\n        // the operation inserts something\n        const lineCount = op.eolCount + 1;\n        if (lineCount === 1) {\n          // single line insert\n          resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + op.firstLineLength);\n        } else {\n          // multi line insert\n          resultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, op.lastLineLength + 1);\n        }\n      } else {\n        // There is nothing to insert\n        resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);\n      }\n      prevOpEndLineNumber = resultRange.endLineNumber;\n      prevOpEndColumn = resultRange.endColumn;\n      result.push(resultRange);\n      prevOp = op;\n    }\n    return result;\n  }\n  static _sortOpsAscending(a, b) {\n    const r = Range.compareRangesUsingEnds(a.range, b.range);\n    if (r === 0) {\n      return a.sortIndex - b.sortIndex;\n    }\n    return r;\n  }\n  static _sortOpsDescending(a, b) {\n    const r = Range.compareRangesUsingEnds(a.range, b.range);\n    if (r === 0) {\n      return b.sortIndex - a.sortIndex;\n    }\n    return -r;\n  }\n}","map":{"version":3,"names":["Emitter","strings","Range","ApplyEditsResult","PieceTreeBase","countEOL","TextChange","Disposable","PieceTreeTextBuffer","constructor","chunks","BOM","eol","containsRTL","containsUnusualLineTerminators","isBasicASCII","eolNormalized","_onDidChangeContent","_register","_BOM","_mightContainNonBasicASCII","_mightContainRTL","_mightContainUnusualLineTerminators","_pieceTree","mightContainRTL","mightContainUnusualLineTerminators","resetMightContainUnusualLineTerminators","mightContainNonBasicASCII","getBOM","getEOL","createSnapshot","preserveBOM","getOffsetAt","lineNumber","column","getPositionAt","offset","getRangeAt","start","length","end","startPosition","endPosition","getValueInRange","range","arguments","undefined","isEmpty","lineEnding","_getEndOfLine","getValueLengthInRange","startLineNumber","endLineNumber","endColumn","startColumn","startOffset","endOffset","eolOffsetCompensation","desiredEOL","actualEOL","delta","eolCount","getCharacterCountInRange","result","fromLineNumber","toLineNumber","lineContent","getLineContent","fromOffset","toOffset","isHighSurrogate","charCodeAt","getLength","getLineCount","getLinesContent","getLineCharCode","index","getLineLength","getLineFirstNonWhitespaceColumn","firstNonWhitespaceIndex","getLineLastNonWhitespaceColumn","lastNonWhitespaceIndex","Error","setEOL","newEOL","applyEdits","rawOperations","recordTrimAutoWhitespace","computeUndoEdits","canReduceOperations","operations","i","op","_isTracked","validatedRange","text","textMightContainNonBasicASCII","validText","firstLineLength","lastLineLength","strEOL","bufferEOL","expectedStrEOL","replace","sortIndex","identifier","rangeOffset","rangeLength","forceMoveMarkers","Boolean","isAutoWhitespaceEdit","sort","_sortOpsAscending","hasTouchingRanges","count","rangeEnd","getEndPosition","nextRangeStart","getStartPosition","isBeforeOrEqual","isBefore","_reduceOperations","reverseRanges","_getInverseEditRanges","newTrimAutoWhitespaceCandidates","reverseRange","currentLineContent","push","oldContent","reverseOperations","reverseRangeDeltaOffset","bufferText","reverseRangeOffset","textChange","a","b","contentChanges","_doApplyEdits","trimAutoWhitespaceLineNumbers","len","prevContent","fire","_toSingleEditOperation","firstEditRange","lastEditRange","entireEditRange","lastEndLineNumber","lastEndColumn","operation","join","_sortOpsDescending","delete","insert","contentChangeRange","findMatchesLineByLine","searchRange","searchData","captureMatches","limitResultCount","prevOpEndLineNumber","prevOpEndColumn","prevOp","resultRange","lineCount","r","compareRangesUsingEnds"],"sources":["/home/arslan/modojo/node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { Range } from '../../core/range.js';\nimport { ApplyEditsResult } from '../../model.js';\nimport { PieceTreeBase } from './pieceTreeBase.js';\nimport { countEOL } from '../../core/eolCounter.js';\nimport { TextChange } from '../../core/textChange.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nexport class PieceTreeTextBuffer extends Disposable {\n    constructor(chunks, BOM, eol, containsRTL, containsUnusualLineTerminators, isBasicASCII, eolNormalized) {\n        super();\n        this._onDidChangeContent = this._register(new Emitter());\n        this._BOM = BOM;\n        this._mightContainNonBasicASCII = !isBasicASCII;\n        this._mightContainRTL = containsRTL;\n        this._mightContainUnusualLineTerminators = containsUnusualLineTerminators;\n        this._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);\n    }\n    mightContainRTL() {\n        return this._mightContainRTL;\n    }\n    mightContainUnusualLineTerminators() {\n        return this._mightContainUnusualLineTerminators;\n    }\n    resetMightContainUnusualLineTerminators() {\n        this._mightContainUnusualLineTerminators = false;\n    }\n    mightContainNonBasicASCII() {\n        return this._mightContainNonBasicASCII;\n    }\n    getBOM() {\n        return this._BOM;\n    }\n    getEOL() {\n        return this._pieceTree.getEOL();\n    }\n    createSnapshot(preserveBOM) {\n        return this._pieceTree.createSnapshot(preserveBOM ? this._BOM : '');\n    }\n    getOffsetAt(lineNumber, column) {\n        return this._pieceTree.getOffsetAt(lineNumber, column);\n    }\n    getPositionAt(offset) {\n        return this._pieceTree.getPositionAt(offset);\n    }\n    getRangeAt(start, length) {\n        const end = start + length;\n        const startPosition = this.getPositionAt(start);\n        const endPosition = this.getPositionAt(end);\n        return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n    }\n    getValueInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (range.isEmpty()) {\n            return '';\n        }\n        const lineEnding = this._getEndOfLine(eol);\n        return this._pieceTree.getValueInRange(range, lineEnding);\n    }\n    getValueLengthInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (range.isEmpty()) {\n            return 0;\n        }\n        if (range.startLineNumber === range.endLineNumber) {\n            return (range.endColumn - range.startColumn);\n        }\n        const startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);\n        // offsets use the text EOL, so we need to compensate for length differences\n        // if the requested EOL doesn't match the text EOL\n        let eolOffsetCompensation = 0;\n        const desiredEOL = this._getEndOfLine(eol);\n        const actualEOL = this.getEOL();\n        if (desiredEOL.length !== actualEOL.length) {\n            const delta = desiredEOL.length - actualEOL.length;\n            const eolCount = range.endLineNumber - range.startLineNumber;\n            eolOffsetCompensation = delta * eolCount;\n        }\n        return endOffset - startOffset + eolOffsetCompensation;\n    }\n    getCharacterCountInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (this._mightContainNonBasicASCII) {\n            // we must count by iterating\n            let result = 0;\n            const fromLineNumber = range.startLineNumber;\n            const toLineNumber = range.endLineNumber;\n            for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n                const lineContent = this.getLineContent(lineNumber);\n                const fromOffset = (lineNumber === fromLineNumber ? range.startColumn - 1 : 0);\n                const toOffset = (lineNumber === toLineNumber ? range.endColumn - 1 : lineContent.length);\n                for (let offset = fromOffset; offset < toOffset; offset++) {\n                    if (strings.isHighSurrogate(lineContent.charCodeAt(offset))) {\n                        result = result + 1;\n                        offset = offset + 1;\n                    }\n                    else {\n                        result = result + 1;\n                    }\n                }\n            }\n            result += this._getEndOfLine(eol).length * (toLineNumber - fromLineNumber);\n            return result;\n        }\n        return this.getValueLengthInRange(range, eol);\n    }\n    getLength() {\n        return this._pieceTree.getLength();\n    }\n    getLineCount() {\n        return this._pieceTree.getLineCount();\n    }\n    getLinesContent() {\n        return this._pieceTree.getLinesContent();\n    }\n    getLineContent(lineNumber) {\n        return this._pieceTree.getLineContent(lineNumber);\n    }\n    getLineCharCode(lineNumber, index) {\n        return this._pieceTree.getLineCharCode(lineNumber, index);\n    }\n    getLineLength(lineNumber) {\n        return this._pieceTree.getLineLength(lineNumber);\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 1;\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 2;\n    }\n    _getEndOfLine(eol) {\n        switch (eol) {\n            case 1 /* EndOfLinePreference.LF */:\n                return '\\n';\n            case 2 /* EndOfLinePreference.CRLF */:\n                return '\\r\\n';\n            case 0 /* EndOfLinePreference.TextDefined */:\n                return this.getEOL();\n            default:\n                throw new Error('Unknown EOL preference');\n        }\n    }\n    setEOL(newEOL) {\n        this._pieceTree.setEOL(newEOL);\n    }\n    applyEdits(rawOperations, recordTrimAutoWhitespace, computeUndoEdits) {\n        let mightContainRTL = this._mightContainRTL;\n        let mightContainUnusualLineTerminators = this._mightContainUnusualLineTerminators;\n        let mightContainNonBasicASCII = this._mightContainNonBasicASCII;\n        let canReduceOperations = true;\n        let operations = [];\n        for (let i = 0; i < rawOperations.length; i++) {\n            const op = rawOperations[i];\n            if (canReduceOperations && op._isTracked) {\n                canReduceOperations = false;\n            }\n            const validatedRange = op.range;\n            if (op.text) {\n                let textMightContainNonBasicASCII = true;\n                if (!mightContainNonBasicASCII) {\n                    textMightContainNonBasicASCII = !strings.isBasicASCII(op.text);\n                    mightContainNonBasicASCII = textMightContainNonBasicASCII;\n                }\n                if (!mightContainRTL && textMightContainNonBasicASCII) {\n                    // check if the new inserted text contains RTL\n                    mightContainRTL = strings.containsRTL(op.text);\n                }\n                if (!mightContainUnusualLineTerminators && textMightContainNonBasicASCII) {\n                    // check if the new inserted text contains unusual line terminators\n                    mightContainUnusualLineTerminators = strings.containsUnusualLineTerminators(op.text);\n                }\n            }\n            let validText = '';\n            let eolCount = 0;\n            let firstLineLength = 0;\n            let lastLineLength = 0;\n            if (op.text) {\n                let strEOL;\n                [eolCount, firstLineLength, lastLineLength, strEOL] = countEOL(op.text);\n                const bufferEOL = this.getEOL();\n                const expectedStrEOL = (bufferEOL === '\\r\\n' ? 2 /* StringEOL.CRLF */ : 1 /* StringEOL.LF */);\n                if (strEOL === 0 /* StringEOL.Unknown */ || strEOL === expectedStrEOL) {\n                    validText = op.text;\n                }\n                else {\n                    validText = op.text.replace(/\\r\\n|\\r|\\n/g, bufferEOL);\n                }\n            }\n            operations[i] = {\n                sortIndex: i,\n                identifier: op.identifier || null,\n                range: validatedRange,\n                rangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),\n                rangeLength: this.getValueLengthInRange(validatedRange),\n                text: validText,\n                eolCount: eolCount,\n                firstLineLength: firstLineLength,\n                lastLineLength: lastLineLength,\n                forceMoveMarkers: Boolean(op.forceMoveMarkers),\n                isAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false\n            };\n        }\n        // Sort operations ascending\n        operations.sort(PieceTreeTextBuffer._sortOpsAscending);\n        let hasTouchingRanges = false;\n        for (let i = 0, count = operations.length - 1; i < count; i++) {\n            const rangeEnd = operations[i].range.getEndPosition();\n            const nextRangeStart = operations[i + 1].range.getStartPosition();\n            if (nextRangeStart.isBeforeOrEqual(rangeEnd)) {\n                if (nextRangeStart.isBefore(rangeEnd)) {\n                    // overlapping ranges\n                    throw new Error('Overlapping ranges are not allowed!');\n                }\n                hasTouchingRanges = true;\n            }\n        }\n        if (canReduceOperations) {\n            operations = this._reduceOperations(operations);\n        }\n        // Delta encode operations\n        const reverseRanges = (computeUndoEdits || recordTrimAutoWhitespace ? PieceTreeTextBuffer._getInverseEditRanges(operations) : []);\n        const newTrimAutoWhitespaceCandidates = [];\n        if (recordTrimAutoWhitespace) {\n            for (let i = 0; i < operations.length; i++) {\n                const op = operations[i];\n                const reverseRange = reverseRanges[i];\n                if (op.isAutoWhitespaceEdit && op.range.isEmpty()) {\n                    // Record already the future line numbers that might be auto whitespace removal candidates on next edit\n                    for (let lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {\n                        let currentLineContent = '';\n                        if (lineNumber === reverseRange.startLineNumber) {\n                            currentLineContent = this.getLineContent(op.range.startLineNumber);\n                            if (strings.firstNonWhitespaceIndex(currentLineContent) !== -1) {\n                                continue;\n                            }\n                        }\n                        newTrimAutoWhitespaceCandidates.push({ lineNumber: lineNumber, oldContent: currentLineContent });\n                    }\n                }\n            }\n        }\n        let reverseOperations = null;\n        if (computeUndoEdits) {\n            let reverseRangeDeltaOffset = 0;\n            reverseOperations = [];\n            for (let i = 0; i < operations.length; i++) {\n                const op = operations[i];\n                const reverseRange = reverseRanges[i];\n                const bufferText = this.getValueInRange(op.range);\n                const reverseRangeOffset = op.rangeOffset + reverseRangeDeltaOffset;\n                reverseRangeDeltaOffset += (op.text.length - bufferText.length);\n                reverseOperations[i] = {\n                    sortIndex: op.sortIndex,\n                    identifier: op.identifier,\n                    range: reverseRange,\n                    text: bufferText,\n                    textChange: new TextChange(op.rangeOffset, bufferText, reverseRangeOffset, op.text)\n                };\n            }\n            // Can only sort reverse operations when the order is not significant\n            if (!hasTouchingRanges) {\n                reverseOperations.sort((a, b) => a.sortIndex - b.sortIndex);\n            }\n        }\n        this._mightContainRTL = mightContainRTL;\n        this._mightContainUnusualLineTerminators = mightContainUnusualLineTerminators;\n        this._mightContainNonBasicASCII = mightContainNonBasicASCII;\n        const contentChanges = this._doApplyEdits(operations);\n        let trimAutoWhitespaceLineNumbers = null;\n        if (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {\n            // sort line numbers auto whitespace removal candidates for next edit descending\n            newTrimAutoWhitespaceCandidates.sort((a, b) => b.lineNumber - a.lineNumber);\n            trimAutoWhitespaceLineNumbers = [];\n            for (let i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {\n                const lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;\n                if (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {\n                    // Do not have the same line number twice\n                    continue;\n                }\n                const prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;\n                const lineContent = this.getLineContent(lineNumber);\n                if (lineContent.length === 0 || lineContent === prevContent || strings.firstNonWhitespaceIndex(lineContent) !== -1) {\n                    continue;\n                }\n                trimAutoWhitespaceLineNumbers.push(lineNumber);\n            }\n        }\n        this._onDidChangeContent.fire();\n        return new ApplyEditsResult(reverseOperations, contentChanges, trimAutoWhitespaceLineNumbers);\n    }\n    /**\n     * Transform operations such that they represent the same logic edit,\n     * but that they also do not cause OOM crashes.\n     */\n    _reduceOperations(operations) {\n        if (operations.length < 1000) {\n            // We know from empirical testing that a thousand edits work fine regardless of their shape.\n            return operations;\n        }\n        // At one point, due to how events are emitted and how each operation is handled,\n        // some operations can trigger a high amount of temporary string allocations,\n        // that will immediately get edited again.\n        // e.g. a formatter inserting ridiculous ammounts of \\n on a model with a single line\n        // Therefore, the strategy is to collapse all the operations into a huge single edit operation\n        return [this._toSingleEditOperation(operations)];\n    }\n    _toSingleEditOperation(operations) {\n        let forceMoveMarkers = false;\n        const firstEditRange = operations[0].range;\n        const lastEditRange = operations[operations.length - 1].range;\n        const entireEditRange = new Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn);\n        let lastEndLineNumber = firstEditRange.startLineNumber;\n        let lastEndColumn = firstEditRange.startColumn;\n        const result = [];\n        for (let i = 0, len = operations.length; i < len; i++) {\n            const operation = operations[i];\n            const range = operation.range;\n            forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;\n            // (1) -- Push old text\n            result.push(this.getValueInRange(new Range(lastEndLineNumber, lastEndColumn, range.startLineNumber, range.startColumn)));\n            // (2) -- Push new text\n            if (operation.text.length > 0) {\n                result.push(operation.text);\n            }\n            lastEndLineNumber = range.endLineNumber;\n            lastEndColumn = range.endColumn;\n        }\n        const text = result.join('');\n        const [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n        return {\n            sortIndex: 0,\n            identifier: operations[0].identifier,\n            range: entireEditRange,\n            rangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),\n            rangeLength: this.getValueLengthInRange(entireEditRange, 0 /* EndOfLinePreference.TextDefined */),\n            text: text,\n            eolCount: eolCount,\n            firstLineLength: firstLineLength,\n            lastLineLength: lastLineLength,\n            forceMoveMarkers: forceMoveMarkers,\n            isAutoWhitespaceEdit: false\n        };\n    }\n    _doApplyEdits(operations) {\n        operations.sort(PieceTreeTextBuffer._sortOpsDescending);\n        const contentChanges = [];\n        // operations are from bottom to top\n        for (let i = 0; i < operations.length; i++) {\n            const op = operations[i];\n            const startLineNumber = op.range.startLineNumber;\n            const startColumn = op.range.startColumn;\n            const endLineNumber = op.range.endLineNumber;\n            const endColumn = op.range.endColumn;\n            if (startLineNumber === endLineNumber && startColumn === endColumn && op.text.length === 0) {\n                // no-op\n                continue;\n            }\n            if (op.text) {\n                // replacement\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n                this._pieceTree.insert(op.rangeOffset, op.text, true);\n            }\n            else {\n                // deletion\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n            }\n            const contentChangeRange = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            contentChanges.push({\n                range: contentChangeRange,\n                rangeLength: op.rangeLength,\n                text: op.text,\n                rangeOffset: op.rangeOffset,\n                forceMoveMarkers: op.forceMoveMarkers\n            });\n        }\n        return contentChanges;\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n    /**\n     * Assumes `operations` are validated and sorted ascending\n     */\n    static _getInverseEditRanges(operations) {\n        const result = [];\n        let prevOpEndLineNumber = 0;\n        let prevOpEndColumn = 0;\n        let prevOp = null;\n        for (let i = 0, len = operations.length; i < len; i++) {\n            const op = operations[i];\n            let startLineNumber;\n            let startColumn;\n            if (prevOp) {\n                if (prevOp.range.endLineNumber === op.range.startLineNumber) {\n                    startLineNumber = prevOpEndLineNumber;\n                    startColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);\n                }\n                else {\n                    startLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);\n                    startColumn = op.range.startColumn;\n                }\n            }\n            else {\n                startLineNumber = op.range.startLineNumber;\n                startColumn = op.range.startColumn;\n            }\n            let resultRange;\n            if (op.text.length > 0) {\n                // the operation inserts something\n                const lineCount = op.eolCount + 1;\n                if (lineCount === 1) {\n                    // single line insert\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + op.firstLineLength);\n                }\n                else {\n                    // multi line insert\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, op.lastLineLength + 1);\n                }\n            }\n            else {\n                // There is nothing to insert\n                resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);\n            }\n            prevOpEndLineNumber = resultRange.endLineNumber;\n            prevOpEndColumn = resultRange.endColumn;\n            result.push(resultRange);\n            prevOp = op;\n        }\n        return result;\n    }\n    static _sortOpsAscending(a, b) {\n        const r = Range.compareRangesUsingEnds(a.range, b.range);\n        if (r === 0) {\n            return a.sortIndex - b.sortIndex;\n        }\n        return r;\n    }\n    static _sortOpsDescending(a, b) {\n        const r = Range.compareRangesUsingEnds(a.range, b.range);\n        if (r === 0) {\n            return b.sortIndex - a.sortIndex;\n        }\n        return -r;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}