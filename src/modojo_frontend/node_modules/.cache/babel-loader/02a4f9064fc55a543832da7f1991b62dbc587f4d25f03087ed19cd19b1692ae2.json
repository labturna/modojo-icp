{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveLib = exports.resolveMain = void 0;\n// function getOne<T>(values: T[]): T | undefined {\n//     if (values.length) {\n//         return values[0];\n//     }\n// }\nfunction resolveEntryPoint(mo, directory, expected) {\n  directory = directory || '';\n  if (directory && !directory.endsWith('/')) {\n    directory += '/';\n  }\n  const moFiles = mo.list(directory).filter(f => /\\.mo$/i.test(f));\n  if (moFiles.length === 1) {\n    return moFiles[0];\n  } else if (moFiles.length === 0) {\n    throw new Error('Could not find any Motoko files in the top-level directory');\n  }\n  const expectedFiles = moFiles.filter(f => f.toLowerCase() === expected.toLowerCase());\n  if (expectedFiles.length === 1) {\n    return expectedFiles[0];\n  } else if (expectedFiles.length > 1) {\n    throw new Error(`Found ${expectedFiles.length} entry point files with different capitalization`);\n  }\n  throw new Error(`Found ${moFiles.length} possible entry points. Please rename one of these files to '${expected}'`);\n  // TODO: evaluate whether we want to choose an entry point by parsing files\n  // const parsedFiles = moFiles.map((f) => {\n  //     try {\n  //         return mo.parseMotoko(mo.read(directory + f));\n  //     } catch (err) {\n  //         throw new Error(`Parse error in ${f}`);\n  //     }\n  // });\n  // console.log(parsedFiles);\n  // return getOne(parsedFiles.filter());\n}\nfunction resolveMain(mo, directory) {\n  return resolveEntryPoint(mo, directory, 'Main.mo');\n}\nexports.resolveMain = resolveMain;\nfunction resolveLib(mo, directory) {\n  return resolveEntryPoint(mo, directory, 'Lib.mo');\n}\nexports.resolveLib = resolveLib;","map":{"version":3,"names":["resolveEntryPoint","mo","directory","expected","endsWith","moFiles","list","filter","f","test","length","Error","expectedFiles","toLowerCase","resolveMain","exports","resolveLib"],"sources":["/home/arslan/modojo/node_modules/motoko/src/utils/resolveEntryPoint.ts"],"sourcesContent":["import { Motoko } from '..';\n\n// function getOne<T>(values: T[]): T | undefined {\n//     if (values.length) {\n//         return values[0];\n//     }\n// }\n\nfunction resolveEntryPoint(\n    mo: Motoko,\n    directory: string,\n    expected: string,\n): string {\n    directory = directory || '';\n    if (directory && !directory.endsWith('/')) {\n        directory += '/';\n    }\n\n    const moFiles = mo.list(directory).filter((f) => /\\.mo$/i.test(f));\n    if (moFiles.length === 1) {\n        return moFiles[0];\n    } else if (moFiles.length === 0) {\n        throw new Error(\n            'Could not find any Motoko files in the top-level directory',\n        );\n    }\n\n    const expectedFiles = moFiles.filter(\n        (f) => f.toLowerCase() === expected.toLowerCase(),\n    );\n    if (expectedFiles.length === 1) {\n        return expectedFiles[0];\n    } else if (expectedFiles.length > 1) {\n        throw new Error(\n            `Found ${expectedFiles.length} entry point files with different capitalization`,\n        );\n    }\n\n    throw new Error(\n        `Found ${moFiles.length} possible entry points. Please rename one of these files to '${expected}'`,\n    );\n\n    // TODO: evaluate whether we want to choose an entry point by parsing files\n\n    // const parsedFiles = moFiles.map((f) => {\n    //     try {\n    //         return mo.parseMotoko(mo.read(directory + f));\n    //     } catch (err) {\n    //         throw new Error(`Parse error in ${f}`);\n    //     }\n    // });\n\n    // console.log(parsedFiles);\n\n    // return getOne(parsedFiles.filter());\n}\n\nexport function resolveMain(mo: Motoko, directory: string): string {\n    return resolveEntryPoint(mo, directory, 'Main.mo');\n}\n\nexport function resolveLib(mo: Motoko, directory: string): string {\n    return resolveEntryPoint(mo, directory, 'Lib.mo');\n}\n"],"mappings":";;;;;;AAEA;AACA;AACA;AACA;AACA;AAEA,SAASA,iBAAiBA,CACtBC,EAAU,EACVC,SAAiB,EACjBC,QAAgB;EAEhBD,SAAS,GAAGA,SAAS,IAAI,EAAE;EAC3B,IAAIA,SAAS,IAAI,CAACA,SAAS,CAACE,QAAQ,CAAC,GAAG,CAAC,EAAE;IACvCF,SAAS,IAAI,GAAG;;EAGpB,MAAMG,OAAO,GAAGJ,EAAE,CAACK,IAAI,CAACJ,SAAS,CAAC,CAACK,MAAM,CAAEC,CAAC,IAAK,QAAQ,CAACC,IAAI,CAACD,CAAC,CAAC,CAAC;EAClE,IAAIH,OAAO,CAACK,MAAM,KAAK,CAAC,EAAE;IACtB,OAAOL,OAAO,CAAC,CAAC,CAAC;GACpB,MAAM,IAAIA,OAAO,CAACK,MAAM,KAAK,CAAC,EAAE;IAC7B,MAAM,IAAIC,KAAK,CACX,4DAA4D,CAC/D;;EAGL,MAAMC,aAAa,GAAGP,OAAO,CAACE,MAAM,CAC/BC,CAAC,IAAKA,CAAC,CAACK,WAAW,EAAE,KAAKV,QAAQ,CAACU,WAAW,EAAE,CACpD;EACD,IAAID,aAAa,CAACF,MAAM,KAAK,CAAC,EAAE;IAC5B,OAAOE,aAAa,CAAC,CAAC,CAAC;GAC1B,MAAM,IAAIA,aAAa,CAACF,MAAM,GAAG,CAAC,EAAE;IACjC,MAAM,IAAIC,KAAK,CACX,SAASC,aAAa,CAACF,MAAM,kDAAkD,CAClF;;EAGL,MAAM,IAAIC,KAAK,CACX,SAASN,OAAO,CAACK,MAAM,gEAAgEP,QAAQ,GAAG,CACrG;EAED;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EAEA;EAEA;AACJ;AAEA,SAAgBW,WAAWA,CAACb,EAAU,EAAEC,SAAiB;EACrD,OAAOF,iBAAiB,CAACC,EAAE,EAAEC,SAAS,EAAE,SAAS,CAAC;AACtD;AAFAa,OAAA,CAAAD,WAAA,GAAAA,WAAA;AAIA,SAAgBE,UAAUA,CAACf,EAAU,EAAEC,SAAiB;EACpD,OAAOF,iBAAiB,CAACC,EAAE,EAAEC,SAAS,EAAE,QAAQ,CAAC;AACrD;AAFAa,OAAA,CAAAC,UAAA,GAAAA,UAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}