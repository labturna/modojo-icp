{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { onUnexpectedExternalError } from '../../../../base/common/errors.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { IModelService } from '../../../common/services/model.js';\nimport { CommandsRegistry, ICommandService } from '../../../../platform/commands/common/commands.js';\nimport { assertType } from '../../../../base/common/types.js';\nimport { encodeSemanticTokensDto } from '../../../common/services/semanticTokensDto.js';\nimport { Range } from '../../../common/core/range.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nexport function isSemanticTokens(v) {\n  return v && !!v.data;\n}\nexport function isSemanticTokensEdits(v) {\n  return v && Array.isArray(v.edits);\n}\nexport class DocumentSemanticTokensResult {\n  constructor(provider, tokens, error) {\n    this.provider = provider;\n    this.tokens = tokens;\n    this.error = error;\n  }\n}\nexport function hasDocumentSemanticTokensProvider(registry, model) {\n  return registry.has(model);\n}\nfunction getDocumentSemanticTokensProviders(registry, model) {\n  const groups = registry.orderedGroups(model);\n  return groups.length > 0 ? groups[0] : [];\n}\nexport async function getDocumentSemanticTokens(registry, model, lastProvider, lastResultId, token) {\n  const providers = getDocumentSemanticTokensProviders(registry, model);\n  // Get tokens from all providers at the same time.\n  const results = await Promise.all(providers.map(async provider => {\n    let result;\n    let error = null;\n    try {\n      result = await provider.provideDocumentSemanticTokens(model, provider === lastProvider ? lastResultId : null, token);\n    } catch (err) {\n      error = err;\n      result = null;\n    }\n    if (!result || !isSemanticTokens(result) && !isSemanticTokensEdits(result)) {\n      result = null;\n    }\n    return new DocumentSemanticTokensResult(provider, result, error);\n  }));\n  // Try to return the first result with actual tokens or\n  // the first result which threw an error (!!)\n  for (const result of results) {\n    if (result.error) {\n      throw result.error;\n    }\n    if (result.tokens) {\n      return result;\n    }\n  }\n  // Return the first result, even if it doesn't have tokens\n  if (results.length > 0) {\n    return results[0];\n  }\n  return null;\n}\nfunction _getDocumentSemanticTokensProviderHighestGroup(registry, model) {\n  const result = registry.orderedGroups(model);\n  return result.length > 0 ? result[0] : null;\n}\nclass DocumentRangeSemanticTokensResult {\n  constructor(provider, tokens) {\n    this.provider = provider;\n    this.tokens = tokens;\n  }\n}\nexport function hasDocumentRangeSemanticTokensProvider(providers, model) {\n  return providers.has(model);\n}\nfunction getDocumentRangeSemanticTokensProviders(providers, model) {\n  const groups = providers.orderedGroups(model);\n  return groups.length > 0 ? groups[0] : [];\n}\nexport async function getDocumentRangeSemanticTokens(registry, model, range, token) {\n  const providers = getDocumentRangeSemanticTokensProviders(registry, model);\n  // Get tokens from all providers at the same time.\n  const results = await Promise.all(providers.map(async provider => {\n    let result;\n    try {\n      result = await provider.provideDocumentRangeSemanticTokens(model, range, token);\n    } catch (err) {\n      onUnexpectedExternalError(err);\n      result = null;\n    }\n    if (!result || !isSemanticTokens(result)) {\n      result = null;\n    }\n    return new DocumentRangeSemanticTokensResult(provider, result);\n  }));\n  // Try to return the first result with actual tokens\n  for (const result of results) {\n    if (result.tokens) {\n      return result;\n    }\n  }\n  // Return the first result, even if it doesn't have tokens\n  if (results.length > 0) {\n    return results[0];\n  }\n  return null;\n}\nCommandsRegistry.registerCommand('_provideDocumentSemanticTokensLegend', async function (accessor) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n  const [uri] = args;\n  assertType(uri instanceof URI);\n  const model = accessor.get(IModelService).getModel(uri);\n  if (!model) {\n    return undefined;\n  }\n  const {\n    documentSemanticTokensProvider\n  } = accessor.get(ILanguageFeaturesService);\n  const providers = _getDocumentSemanticTokensProviderHighestGroup(documentSemanticTokensProvider, model);\n  if (!providers) {\n    // there is no provider => fall back to a document range semantic tokens provider\n    return accessor.get(ICommandService).executeCommand('_provideDocumentRangeSemanticTokensLegend', uri);\n  }\n  return providers[0].getLegend();\n});\nCommandsRegistry.registerCommand('_provideDocumentSemanticTokens', async function (accessor) {\n  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    args[_key2 - 1] = arguments[_key2];\n  }\n  const [uri] = args;\n  assertType(uri instanceof URI);\n  const model = accessor.get(IModelService).getModel(uri);\n  if (!model) {\n    return undefined;\n  }\n  const {\n    documentSemanticTokensProvider\n  } = accessor.get(ILanguageFeaturesService);\n  if (!hasDocumentSemanticTokensProvider(documentSemanticTokensProvider, model)) {\n    // there is no provider => fall back to a document range semantic tokens provider\n    return accessor.get(ICommandService).executeCommand('_provideDocumentRangeSemanticTokens', uri, model.getFullModelRange());\n  }\n  const r = await getDocumentSemanticTokens(documentSemanticTokensProvider, model, null, null, CancellationToken.None);\n  if (!r) {\n    return undefined;\n  }\n  const {\n    provider,\n    tokens\n  } = r;\n  if (!tokens || !isSemanticTokens(tokens)) {\n    return undefined;\n  }\n  const buff = encodeSemanticTokensDto({\n    id: 0,\n    type: 'full',\n    data: tokens.data\n  });\n  if (tokens.resultId) {\n    provider.releaseDocumentSemanticTokens(tokens.resultId);\n  }\n  return buff;\n});\nCommandsRegistry.registerCommand('_provideDocumentRangeSemanticTokensLegend', async function (accessor) {\n  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    args[_key3 - 1] = arguments[_key3];\n  }\n  const [uri, range] = args;\n  assertType(uri instanceof URI);\n  const model = accessor.get(IModelService).getModel(uri);\n  if (!model) {\n    return undefined;\n  }\n  const {\n    documentRangeSemanticTokensProvider\n  } = accessor.get(ILanguageFeaturesService);\n  const providers = getDocumentRangeSemanticTokensProviders(documentRangeSemanticTokensProvider, model);\n  if (providers.length === 0) {\n    // no providers\n    return undefined;\n  }\n  if (providers.length === 1) {\n    // straight forward case, just a single provider\n    return providers[0].getLegend();\n  }\n  if (!range || !Range.isIRange(range)) {\n    // if no range is provided, we cannot support multiple providers\n    // as we cannot fall back to the one which would give results\n    // => return the first legend for backwards compatibility and print a warning\n    console.warn(`provideDocumentRangeSemanticTokensLegend might be out-of-sync with provideDocumentRangeSemanticTokens unless a range argument is passed in`);\n    return providers[0].getLegend();\n  }\n  const result = await getDocumentRangeSemanticTokens(documentRangeSemanticTokensProvider, model, Range.lift(range), CancellationToken.None);\n  if (!result) {\n    return undefined;\n  }\n  return result.provider.getLegend();\n});\nCommandsRegistry.registerCommand('_provideDocumentRangeSemanticTokens', async function (accessor) {\n  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    args[_key4 - 1] = arguments[_key4];\n  }\n  const [uri, range] = args;\n  assertType(uri instanceof URI);\n  assertType(Range.isIRange(range));\n  const model = accessor.get(IModelService).getModel(uri);\n  if (!model) {\n    return undefined;\n  }\n  const {\n    documentRangeSemanticTokensProvider\n  } = accessor.get(ILanguageFeaturesService);\n  const result = await getDocumentRangeSemanticTokens(documentRangeSemanticTokensProvider, model, Range.lift(range), CancellationToken.None);\n  if (!result || !result.tokens) {\n    // there is no provider or it didn't return tokens\n    return undefined;\n  }\n  return encodeSemanticTokensDto({\n    id: 0,\n    type: 'full',\n    data: result.tokens.data\n  });\n});","map":{"version":3,"names":["CancellationToken","onUnexpectedExternalError","URI","IModelService","CommandsRegistry","ICommandService","assertType","encodeSemanticTokensDto","Range","ILanguageFeaturesService","isSemanticTokens","v","data","isSemanticTokensEdits","Array","isArray","edits","DocumentSemanticTokensResult","constructor","provider","tokens","error","hasDocumentSemanticTokensProvider","registry","model","has","getDocumentSemanticTokensProviders","groups","orderedGroups","length","getDocumentSemanticTokens","lastProvider","lastResultId","token","providers","results","Promise","all","map","result","provideDocumentSemanticTokens","err","_getDocumentSemanticTokensProviderHighestGroup","DocumentRangeSemanticTokensResult","hasDocumentRangeSemanticTokensProvider","getDocumentRangeSemanticTokensProviders","getDocumentRangeSemanticTokens","range","provideDocumentRangeSemanticTokens","registerCommand","accessor","_len","arguments","args","_key","uri","get","getModel","undefined","documentSemanticTokensProvider","executeCommand","getLegend","_len2","_key2","getFullModelRange","r","None","buff","id","type","resultId","releaseDocumentSemanticTokens","_len3","_key3","documentRangeSemanticTokensProvider","isIRange","console","warn","lift","_len4","_key4"],"sources":["/home/arslan/modojo/node_modules/monaco-editor/esm/vs/editor/contrib/semanticTokens/common/getSemanticTokens.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { onUnexpectedExternalError } from '../../../../base/common/errors.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { IModelService } from '../../../common/services/model.js';\nimport { CommandsRegistry, ICommandService } from '../../../../platform/commands/common/commands.js';\nimport { assertType } from '../../../../base/common/types.js';\nimport { encodeSemanticTokensDto } from '../../../common/services/semanticTokensDto.js';\nimport { Range } from '../../../common/core/range.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nexport function isSemanticTokens(v) {\n    return v && !!(v.data);\n}\nexport function isSemanticTokensEdits(v) {\n    return v && Array.isArray(v.edits);\n}\nexport class DocumentSemanticTokensResult {\n    constructor(provider, tokens, error) {\n        this.provider = provider;\n        this.tokens = tokens;\n        this.error = error;\n    }\n}\nexport function hasDocumentSemanticTokensProvider(registry, model) {\n    return registry.has(model);\n}\nfunction getDocumentSemanticTokensProviders(registry, model) {\n    const groups = registry.orderedGroups(model);\n    return (groups.length > 0 ? groups[0] : []);\n}\nexport async function getDocumentSemanticTokens(registry, model, lastProvider, lastResultId, token) {\n    const providers = getDocumentSemanticTokensProviders(registry, model);\n    // Get tokens from all providers at the same time.\n    const results = await Promise.all(providers.map(async (provider) => {\n        let result;\n        let error = null;\n        try {\n            result = await provider.provideDocumentSemanticTokens(model, (provider === lastProvider ? lastResultId : null), token);\n        }\n        catch (err) {\n            error = err;\n            result = null;\n        }\n        if (!result || (!isSemanticTokens(result) && !isSemanticTokensEdits(result))) {\n            result = null;\n        }\n        return new DocumentSemanticTokensResult(provider, result, error);\n    }));\n    // Try to return the first result with actual tokens or\n    // the first result which threw an error (!!)\n    for (const result of results) {\n        if (result.error) {\n            throw result.error;\n        }\n        if (result.tokens) {\n            return result;\n        }\n    }\n    // Return the first result, even if it doesn't have tokens\n    if (results.length > 0) {\n        return results[0];\n    }\n    return null;\n}\nfunction _getDocumentSemanticTokensProviderHighestGroup(registry, model) {\n    const result = registry.orderedGroups(model);\n    return (result.length > 0 ? result[0] : null);\n}\nclass DocumentRangeSemanticTokensResult {\n    constructor(provider, tokens) {\n        this.provider = provider;\n        this.tokens = tokens;\n    }\n}\nexport function hasDocumentRangeSemanticTokensProvider(providers, model) {\n    return providers.has(model);\n}\nfunction getDocumentRangeSemanticTokensProviders(providers, model) {\n    const groups = providers.orderedGroups(model);\n    return (groups.length > 0 ? groups[0] : []);\n}\nexport async function getDocumentRangeSemanticTokens(registry, model, range, token) {\n    const providers = getDocumentRangeSemanticTokensProviders(registry, model);\n    // Get tokens from all providers at the same time.\n    const results = await Promise.all(providers.map(async (provider) => {\n        let result;\n        try {\n            result = await provider.provideDocumentRangeSemanticTokens(model, range, token);\n        }\n        catch (err) {\n            onUnexpectedExternalError(err);\n            result = null;\n        }\n        if (!result || !isSemanticTokens(result)) {\n            result = null;\n        }\n        return new DocumentRangeSemanticTokensResult(provider, result);\n    }));\n    // Try to return the first result with actual tokens\n    for (const result of results) {\n        if (result.tokens) {\n            return result;\n        }\n    }\n    // Return the first result, even if it doesn't have tokens\n    if (results.length > 0) {\n        return results[0];\n    }\n    return null;\n}\nCommandsRegistry.registerCommand('_provideDocumentSemanticTokensLegend', async (accessor, ...args) => {\n    const [uri] = args;\n    assertType(uri instanceof URI);\n    const model = accessor.get(IModelService).getModel(uri);\n    if (!model) {\n        return undefined;\n    }\n    const { documentSemanticTokensProvider } = accessor.get(ILanguageFeaturesService);\n    const providers = _getDocumentSemanticTokensProviderHighestGroup(documentSemanticTokensProvider, model);\n    if (!providers) {\n        // there is no provider => fall back to a document range semantic tokens provider\n        return accessor.get(ICommandService).executeCommand('_provideDocumentRangeSemanticTokensLegend', uri);\n    }\n    return providers[0].getLegend();\n});\nCommandsRegistry.registerCommand('_provideDocumentSemanticTokens', async (accessor, ...args) => {\n    const [uri] = args;\n    assertType(uri instanceof URI);\n    const model = accessor.get(IModelService).getModel(uri);\n    if (!model) {\n        return undefined;\n    }\n    const { documentSemanticTokensProvider } = accessor.get(ILanguageFeaturesService);\n    if (!hasDocumentSemanticTokensProvider(documentSemanticTokensProvider, model)) {\n        // there is no provider => fall back to a document range semantic tokens provider\n        return accessor.get(ICommandService).executeCommand('_provideDocumentRangeSemanticTokens', uri, model.getFullModelRange());\n    }\n    const r = await getDocumentSemanticTokens(documentSemanticTokensProvider, model, null, null, CancellationToken.None);\n    if (!r) {\n        return undefined;\n    }\n    const { provider, tokens } = r;\n    if (!tokens || !isSemanticTokens(tokens)) {\n        return undefined;\n    }\n    const buff = encodeSemanticTokensDto({\n        id: 0,\n        type: 'full',\n        data: tokens.data\n    });\n    if (tokens.resultId) {\n        provider.releaseDocumentSemanticTokens(tokens.resultId);\n    }\n    return buff;\n});\nCommandsRegistry.registerCommand('_provideDocumentRangeSemanticTokensLegend', async (accessor, ...args) => {\n    const [uri, range] = args;\n    assertType(uri instanceof URI);\n    const model = accessor.get(IModelService).getModel(uri);\n    if (!model) {\n        return undefined;\n    }\n    const { documentRangeSemanticTokensProvider } = accessor.get(ILanguageFeaturesService);\n    const providers = getDocumentRangeSemanticTokensProviders(documentRangeSemanticTokensProvider, model);\n    if (providers.length === 0) {\n        // no providers\n        return undefined;\n    }\n    if (providers.length === 1) {\n        // straight forward case, just a single provider\n        return providers[0].getLegend();\n    }\n    if (!range || !Range.isIRange(range)) {\n        // if no range is provided, we cannot support multiple providers\n        // as we cannot fall back to the one which would give results\n        // => return the first legend for backwards compatibility and print a warning\n        console.warn(`provideDocumentRangeSemanticTokensLegend might be out-of-sync with provideDocumentRangeSemanticTokens unless a range argument is passed in`);\n        return providers[0].getLegend();\n    }\n    const result = await getDocumentRangeSemanticTokens(documentRangeSemanticTokensProvider, model, Range.lift(range), CancellationToken.None);\n    if (!result) {\n        return undefined;\n    }\n    return result.provider.getLegend();\n});\nCommandsRegistry.registerCommand('_provideDocumentRangeSemanticTokens', async (accessor, ...args) => {\n    const [uri, range] = args;\n    assertType(uri instanceof URI);\n    assertType(Range.isIRange(range));\n    const model = accessor.get(IModelService).getModel(uri);\n    if (!model) {\n        return undefined;\n    }\n    const { documentRangeSemanticTokensProvider } = accessor.get(ILanguageFeaturesService);\n    const result = await getDocumentRangeSemanticTokens(documentRangeSemanticTokensProvider, model, Range.lift(range), CancellationToken.None);\n    if (!result || !result.tokens) {\n        // there is no provider or it didn't return tokens\n        return undefined;\n    }\n    return encodeSemanticTokensDto({\n        id: 0,\n        type: 'full',\n        data: result.tokens.data\n    });\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}