{"ast":null,"code":"import { bufEquals } from './utils/buffer';\nexport const encodeLenBytes = len => {\n  if (len <= 0x7f) {\n    return 1;\n  } else if (len <= 0xff) {\n    return 2;\n  } else if (len <= 0xffff) {\n    return 3;\n  } else if (len <= 0xffffff) {\n    return 4;\n  } else {\n    throw new Error('Length too long (> 4 bytes)');\n  }\n};\nexport const encodeLen = (buf, offset, len) => {\n  if (len <= 0x7f) {\n    buf[offset] = len;\n    return 1;\n  } else if (len <= 0xff) {\n    buf[offset] = 0x81;\n    buf[offset + 1] = len;\n    return 2;\n  } else if (len <= 0xffff) {\n    buf[offset] = 0x82;\n    buf[offset + 1] = len >> 8;\n    buf[offset + 2] = len;\n    return 3;\n  } else if (len <= 0xffffff) {\n    buf[offset] = 0x83;\n    buf[offset + 1] = len >> 16;\n    buf[offset + 2] = len >> 8;\n    buf[offset + 3] = len;\n    return 4;\n  } else {\n    throw new Error('Length too long (> 4 bytes)');\n  }\n};\nexport const decodeLenBytes = (buf, offset) => {\n  if (buf[offset] < 0x80) return 1;\n  if (buf[offset] === 0x80) throw new Error('Invalid length 0');\n  if (buf[offset] === 0x81) return 2;\n  if (buf[offset] === 0x82) return 3;\n  if (buf[offset] === 0x83) return 4;\n  throw new Error('Length too long (> 4 bytes)');\n};\nexport const decodeLen = (buf, offset) => {\n  const lenBytes = decodeLenBytes(buf, offset);\n  if (lenBytes === 1) return buf[offset];else if (lenBytes === 2) return buf[offset + 1];else if (lenBytes === 3) return (buf[offset + 1] << 8) + buf[offset + 2];else if (lenBytes === 4) return (buf[offset + 1] << 16) + (buf[offset + 2] << 8) + buf[offset + 3];\n  throw new Error('Length too long (> 4 bytes)');\n};\n/**\n * A DER encoded `SEQUENCE(OID)` for DER-encoded-COSE\n */\nexport const DER_COSE_OID = Uint8Array.from([...[0x30, 0x0c], ...[0x06, 0x0a], ...[0x2b, 0x06, 0x01, 0x04, 0x01, 0x83, 0xb8, 0x43, 0x01, 0x01] // DER encoded COSE\n]);\n/**\n * A DER encoded `SEQUENCE(OID)` for the Ed25519 algorithm\n */\nexport const ED25519_OID = Uint8Array.from([...[0x30, 0x05], ...[0x06, 0x03], ...[0x2b, 0x65, 0x70] // id-Ed25519 OID\n]);\n/**\n * A DER encoded `SEQUENCE(OID)` for secp256k1 with the ECDSA algorithm\n */\nexport const SECP256K1_OID = Uint8Array.from([...[0x30, 0x10], ...[0x06, 0x07], ...[0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01], ...[0x06, 0x05], ...[0x2b, 0x81, 0x04, 0x00, 0x0a] // OID secp256k1\n]);\n/**\n * Wraps the given `payload` in a DER encoding tagged with the given encoded `oid` like so:\n * `SEQUENCE(oid, BITSTRING(payload))`\n *\n * @param payload The payload to encode as the bit string\n * @param oid The DER encoded (and SEQUENCE wrapped!) OID to tag the payload with\n */\nexport function wrapDER(payload, oid) {\n  // The Bit String header needs to include the unused bit count byte in its length\n  const bitStringHeaderLength = 2 + encodeLenBytes(payload.byteLength + 1);\n  const len = oid.byteLength + bitStringHeaderLength + payload.byteLength;\n  let offset = 0;\n  const buf = new Uint8Array(1 + encodeLenBytes(len) + len);\n  // Sequence\n  buf[offset++] = 0x30;\n  // Sequence Length\n  offset += encodeLen(buf, offset, len);\n  // OID\n  buf.set(oid, offset);\n  offset += oid.byteLength;\n  // Bit String Header\n  buf[offset++] = 0x03;\n  offset += encodeLen(buf, offset, payload.byteLength + 1);\n  // 0 padding\n  buf[offset++] = 0x00;\n  buf.set(new Uint8Array(payload), offset);\n  return buf;\n}\n/**\n * Extracts a payload from the given `derEncoded` data, and checks that it was tagged with the given `oid`.\n *\n * `derEncoded = SEQUENCE(oid, BITSTRING(payload))`\n *\n * @param derEncoded The DER encoded and tagged data\n * @param oid The DER encoded (and SEQUENCE wrapped!) expected OID\n * @returns The unwrapped payload\n */\nexport const unwrapDER = (derEncoded, oid) => {\n  let offset = 0;\n  const expect = (n, msg) => {\n    if (buf[offset++] !== n) {\n      throw new Error('Expected: ' + msg);\n    }\n  };\n  const buf = new Uint8Array(derEncoded);\n  expect(0x30, 'sequence');\n  offset += decodeLenBytes(buf, offset);\n  if (!bufEquals(buf.slice(offset, offset + oid.byteLength), oid)) {\n    throw new Error('Not the expected OID.');\n  }\n  offset += oid.byteLength;\n  expect(0x03, 'bit string');\n  const payloadLen = decodeLen(buf, offset) - 1; // Subtracting 1 to account for the 0 padding\n  offset += decodeLenBytes(buf, offset);\n  expect(0x00, '0 padding');\n  const result = buf.slice(offset);\n  if (payloadLen !== result.length) {\n    throw new Error(`DER payload mismatch: Expected length ${payloadLen} actual length ${result.length}`);\n  }\n  return result;\n};","map":{"version":3,"names":["bufEquals","encodeLenBytes","len","Error","encodeLen","buf","offset","decodeLenBytes","decodeLen","lenBytes","DER_COSE_OID","Uint8Array","from","ED25519_OID","SECP256K1_OID","wrapDER","payload","oid","bitStringHeaderLength","byteLength","set","unwrapDER","derEncoded","expect","n","msg","slice","payloadLen","result","length"],"sources":["/home/arslan/modojo/node_modules/@dfinity/agent/src/der.ts"],"sourcesContent":["import { bufEquals } from './utils/buffer';\n\nexport const encodeLenBytes = (len: number): number => {\n  if (len <= 0x7f) {\n    return 1;\n  } else if (len <= 0xff) {\n    return 2;\n  } else if (len <= 0xffff) {\n    return 3;\n  } else if (len <= 0xffffff) {\n    return 4;\n  } else {\n    throw new Error('Length too long (> 4 bytes)');\n  }\n};\n\nexport const encodeLen = (buf: Uint8Array, offset: number, len: number): number => {\n  if (len <= 0x7f) {\n    buf[offset] = len;\n    return 1;\n  } else if (len <= 0xff) {\n    buf[offset] = 0x81;\n    buf[offset + 1] = len;\n    return 2;\n  } else if (len <= 0xffff) {\n    buf[offset] = 0x82;\n    buf[offset + 1] = len >> 8;\n    buf[offset + 2] = len;\n    return 3;\n  } else if (len <= 0xffffff) {\n    buf[offset] = 0x83;\n    buf[offset + 1] = len >> 16;\n    buf[offset + 2] = len >> 8;\n    buf[offset + 3] = len;\n    return 4;\n  } else {\n    throw new Error('Length too long (> 4 bytes)');\n  }\n};\n\nexport const decodeLenBytes = (buf: Uint8Array, offset: number): number => {\n  if (buf[offset] < 0x80) return 1;\n  if (buf[offset] === 0x80) throw new Error('Invalid length 0');\n  if (buf[offset] === 0x81) return 2;\n  if (buf[offset] === 0x82) return 3;\n  if (buf[offset] === 0x83) return 4;\n  throw new Error('Length too long (> 4 bytes)');\n};\n\nexport const decodeLen = (buf: Uint8Array, offset: number): number => {\n  const lenBytes = decodeLenBytes(buf, offset);\n  if (lenBytes === 1) return buf[offset];\n  else if (lenBytes === 2) return buf[offset + 1];\n  else if (lenBytes === 3) return (buf[offset + 1] << 8) + buf[offset + 2];\n  else if (lenBytes === 4)\n    return (buf[offset + 1] << 16) + (buf[offset + 2] << 8) + buf[offset + 3];\n  throw new Error('Length too long (> 4 bytes)');\n};\n\n/**\n * A DER encoded `SEQUENCE(OID)` for DER-encoded-COSE\n */\nexport const DER_COSE_OID = Uint8Array.from([\n  ...[0x30, 0x0c], // SEQUENCE\n  ...[0x06, 0x0a], // OID with 10 bytes\n  ...[0x2b, 0x06, 0x01, 0x04, 0x01, 0x83, 0xb8, 0x43, 0x01, 0x01], // DER encoded COSE\n]);\n\n/**\n * A DER encoded `SEQUENCE(OID)` for the Ed25519 algorithm\n */\nexport const ED25519_OID = Uint8Array.from([\n  ...[0x30, 0x05], // SEQUENCE\n  ...[0x06, 0x03], // OID with 3 bytes\n  ...[0x2b, 0x65, 0x70], // id-Ed25519 OID\n]);\n\n/**\n * A DER encoded `SEQUENCE(OID)` for secp256k1 with the ECDSA algorithm\n */\nexport const SECP256K1_OID = Uint8Array.from([\n  ...[0x30, 0x10], // SEQUENCE\n  ...[0x06, 0x07], // OID with 7 bytes\n  ...[0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01], // OID ECDSA\n  ...[0x06, 0x05], // OID with 5 bytes\n  ...[0x2b, 0x81, 0x04, 0x00, 0x0a], // OID secp256k1\n]);\n\n/**\n * Wraps the given `payload` in a DER encoding tagged with the given encoded `oid` like so:\n * `SEQUENCE(oid, BITSTRING(payload))`\n *\n * @param payload The payload to encode as the bit string\n * @param oid The DER encoded (and SEQUENCE wrapped!) OID to tag the payload with\n */\nexport function wrapDER(payload: ArrayBuffer, oid: Uint8Array): Uint8Array {\n  // The Bit String header needs to include the unused bit count byte in its length\n  const bitStringHeaderLength = 2 + encodeLenBytes(payload.byteLength + 1);\n  const len = oid.byteLength + bitStringHeaderLength + payload.byteLength;\n  let offset = 0;\n  const buf = new Uint8Array(1 + encodeLenBytes(len) + len);\n  // Sequence\n  buf[offset++] = 0x30;\n  // Sequence Length\n  offset += encodeLen(buf, offset, len);\n\n  // OID\n  buf.set(oid, offset);\n  offset += oid.byteLength;\n\n  // Bit String Header\n  buf[offset++] = 0x03;\n  offset += encodeLen(buf, offset, payload.byteLength + 1);\n  // 0 padding\n  buf[offset++] = 0x00;\n  buf.set(new Uint8Array(payload), offset);\n\n  return buf;\n}\n\n/**\n * Extracts a payload from the given `derEncoded` data, and checks that it was tagged with the given `oid`.\n *\n * `derEncoded = SEQUENCE(oid, BITSTRING(payload))`\n *\n * @param derEncoded The DER encoded and tagged data\n * @param oid The DER encoded (and SEQUENCE wrapped!) expected OID\n * @returns The unwrapped payload\n */\nexport const unwrapDER = (derEncoded: ArrayBuffer, oid: Uint8Array): Uint8Array => {\n  let offset = 0;\n  const expect = (n: number, msg: string) => {\n    if (buf[offset++] !== n) {\n      throw new Error('Expected: ' + msg);\n    }\n  };\n\n  const buf = new Uint8Array(derEncoded);\n  expect(0x30, 'sequence');\n  offset += decodeLenBytes(buf, offset);\n\n  if (!bufEquals(buf.slice(offset, offset + oid.byteLength), oid)) {\n    throw new Error('Not the expected OID.');\n  }\n  offset += oid.byteLength;\n\n  expect(0x03, 'bit string');\n  const payloadLen = decodeLen(buf, offset) - 1; // Subtracting 1 to account for the 0 padding\n  offset += decodeLenBytes(buf, offset);\n  expect(0x00, '0 padding');\n  const result = buf.slice(offset);\n  if (payloadLen !== result.length) {\n    throw new Error(\n      `DER payload mismatch: Expected length ${payloadLen} actual length ${result.length}`,\n    );\n  }\n  return result;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}