{"ast":null,"code":"var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _HttpAgent_instances, _HttpAgent_identity, _HttpAgent_fetch, _HttpAgent_fetchOptions, _HttpAgent_callOptions, _HttpAgent_timeDiffMsecs, _HttpAgent_credentials, _HttpAgent_rootKeyFetched, _HttpAgent_retryTimes, _HttpAgent_backoffStrategy, _HttpAgent_waterMark, _HttpAgent_queryPipeline, _HttpAgent_updatePipeline, _HttpAgent_subnetKeys, _HttpAgent_verifyQuerySignatures, _HttpAgent_requestAndRetryQuery, _HttpAgent_requestAndRetry, _HttpAgent_verifyQueryResponse;\nimport { Principal } from '@dfinity/principal';\nimport { AgentError } from '../../errors';\nimport { AnonymousIdentity } from '../../auth';\nimport * as cbor from '../../cbor';\nimport { hashOfMap, requestIdOf } from '../../request_id';\nimport { bufFromBufLike, concat, fromHex } from '../../utils/buffer';\nimport { Expiry, httpHeadersTransform, makeNonceTransform } from './transforms';\nimport { makeNonce, SubmitRequestType } from './types';\nimport { AgentHTTPResponseError } from './errors';\nimport { request } from '../../canisterStatus';\nimport { CertificateVerificationError, LookupStatus, lookup_path } from '../../certificate';\nimport { ed25519 } from '@noble/curves/ed25519';\nimport { ExpirableMap } from '../../utils/expirableMap';\nimport { Ed25519PublicKey } from '../../public_key';\nimport { decodeTime } from '../../utils/leb';\nimport { ObservableLog } from '../../observable';\nimport { ExponentialBackoff } from '../../polling/backoff';\nexport * from './transforms';\nexport { makeNonce } from './types';\nexport var RequestStatusResponseStatus;\n(function (RequestStatusResponseStatus) {\n  RequestStatusResponseStatus[\"Received\"] = \"received\";\n  RequestStatusResponseStatus[\"Processing\"] = \"processing\";\n  RequestStatusResponseStatus[\"Replied\"] = \"replied\";\n  RequestStatusResponseStatus[\"Rejected\"] = \"rejected\";\n  RequestStatusResponseStatus[\"Unknown\"] = \"unknown\";\n  RequestStatusResponseStatus[\"Done\"] = \"done\";\n})(RequestStatusResponseStatus || (RequestStatusResponseStatus = {}));\n// Default delta for ingress expiry is 5 minutes.\nconst DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS = 5 * 60 * 1000;\n// Root public key for the IC, encoded as hex\nexport const IC_ROOT_KEY = '308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100814' + 'c0e6ec71fab583b08bd81373c255c3c371b2e84863c98a4f1e08b74235d14fb5d9c0cd546d968' + '5f913a0c0b2cc5341583bf4b4392e467db96d65b9bb4cb717112f8472e0d5a4d14505ffd7484' + 'b01291091c5f87b98883463f98091a0baaae';\nexport const MANAGEMENT_CANISTER_ID = 'aaaaa-aa';\n// IC0 domain info\nconst IC0_DOMAIN = 'ic0.app';\nconst IC0_SUB_DOMAIN = '.ic0.app';\nconst ICP0_DOMAIN = 'icp0.io';\nconst ICP0_SUB_DOMAIN = '.icp0.io';\nconst ICP_API_DOMAIN = 'icp-api.io';\nconst ICP_API_SUB_DOMAIN = '.icp-api.io';\nclass HttpDefaultFetchError extends AgentError {\n  constructor(message) {\n    super(message);\n    this.message = message;\n  }\n}\nexport class IdentityInvalidError extends AgentError {\n  constructor(message) {\n    super(message);\n    this.message = message;\n  }\n}\nfunction getDefaultFetch() {\n  let defaultFetch;\n  if (typeof window !== 'undefined') {\n    // Browser context\n    if (window.fetch) {\n      defaultFetch = window.fetch.bind(window);\n    } else {\n      throw new HttpDefaultFetchError('Fetch implementation was not available. You appear to be in a browser context, but window.fetch was not present.');\n    }\n  } else if (typeof global !== 'undefined') {\n    // Node context\n    if (global.fetch) {\n      defaultFetch = global.fetch.bind(global);\n    } else {\n      throw new HttpDefaultFetchError('Fetch implementation was not available. You appear to be in a Node.js context, but global.fetch was not available.');\n    }\n  } else if (typeof self !== 'undefined') {\n    if (self.fetch) {\n      defaultFetch = self.fetch.bind(self);\n    }\n  }\n  if (defaultFetch) {\n    return defaultFetch;\n  }\n  throw new HttpDefaultFetchError('Fetch implementation was not available. Please provide fetch to the HttpAgent constructor, or ensure it is available in the window or global context.');\n}\nfunction determineHost(configuredHost) {\n  let host;\n  if (configuredHost !== undefined) {\n    if (!configuredHost.match(/^[a-z]+:/) && typeof window !== 'undefined') {\n      host = new URL(window.location.protocol + '//' + configuredHost);\n    } else {\n      host = new URL(configuredHost);\n    }\n  } else {\n    // Mainnet, local, and remote environments will have the api route available\n    const knownHosts = ['ic0.app', 'icp0.io', '127.0.0.1', 'localhost'];\n    const remoteHosts = ['.github.dev', '.gitpod.io'];\n    const location = typeof window !== 'undefined' ? window.location : undefined;\n    const hostname = location === null || location === void 0 ? void 0 : location.hostname;\n    let knownHost;\n    if (hostname && typeof hostname === 'string') {\n      if (remoteHosts.some(host => hostname.endsWith(host))) {\n        knownHost = hostname;\n      } else {\n        knownHost = knownHosts.find(host => hostname.endsWith(host));\n      }\n    }\n    if (location && knownHost) {\n      // If the user is on a boundary-node provided host, we can use the same host for the agent\n      host = new URL(`${location.protocol}//${knownHost}${location.port ? ':' + location.port : ''}`);\n    } else {\n      host = new URL('https://icp-api.io');\n    }\n  }\n  return host.toString();\n}\n/**\n * A HTTP agent allows users to interact with a client of the internet computer\nusing the available methods. It exposes an API that closely follows the\npublic view of the internet computer, and is not intended to be exposed\ndirectly to the majority of users due to its low-level interface.\n * There is a pipeline to apply transformations to the request before sending\nit to the client. This is to decouple signature, nonce generation and\nother computations so that this class can stay as simple as possible while\nallowing extensions.\n */\nexport class HttpAgent {\n  /**\n   * @param options - Options for the HttpAgent\n   * @deprecated Use `HttpAgent.create` or `HttpAgent.createSync` instead\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var _a;\n    _HttpAgent_instances.add(this);\n    _HttpAgent_identity.set(this, void 0);\n    _HttpAgent_fetch.set(this, void 0);\n    _HttpAgent_fetchOptions.set(this, void 0);\n    _HttpAgent_callOptions.set(this, void 0);\n    _HttpAgent_timeDiffMsecs.set(this, 0);\n    _HttpAgent_credentials.set(this, void 0);\n    _HttpAgent_rootKeyFetched.set(this, false);\n    _HttpAgent_retryTimes.set(this, void 0); // Retry requests N times before erroring by default\n    _HttpAgent_backoffStrategy.set(this, void 0);\n    // Public signature to help with type checking.\n    this._isAgent = true;\n    this.config = {};\n    // The UTC time in milliseconds when the latest request was made\n    _HttpAgent_waterMark.set(this, 0);\n    this.log = new ObservableLog();\n    _HttpAgent_queryPipeline.set(this, []);\n    _HttpAgent_updatePipeline.set(this, []);\n    _HttpAgent_subnetKeys.set(this, new ExpirableMap({\n      expirationTime: 5 * 60 * 1000 // 5 minutes\n    }));\n    _HttpAgent_verifyQuerySignatures.set(this, true);\n    /**\n     * See https://internetcomputer.org/docs/current/references/ic-interface-spec/#http-query for details on validation\n     * @param queryResponse - The response from the query\n     * @param subnetStatus - The subnet status, including all node keys\n     * @returns ApiQueryResponse\n     */\n    _HttpAgent_verifyQueryResponse.set(this, (queryResponse, subnetStatus) => {\n      if (__classPrivateFieldGet(this, _HttpAgent_verifyQuerySignatures, \"f\") === false) {\n        // This should not be called if the user has disabled verification\n        return queryResponse;\n      }\n      if (!subnetStatus) {\n        throw new CertificateVerificationError('Invalid signature from replica signed query: no matching node key found.');\n      }\n      const {\n        status,\n        signatures = [],\n        requestId\n      } = queryResponse;\n      const domainSeparator = new TextEncoder().encode('\\x0Bic-response');\n      for (const sig of signatures) {\n        const {\n          timestamp,\n          identity\n        } = sig;\n        const nodeId = Principal.fromUint8Array(identity).toText();\n        let hash;\n        // Hash is constructed differently depending on the status\n        if (status === 'replied') {\n          const {\n            reply\n          } = queryResponse;\n          hash = hashOfMap({\n            status: status,\n            reply: reply,\n            timestamp: BigInt(timestamp),\n            request_id: requestId\n          });\n        } else if (status === 'rejected') {\n          const {\n            reject_code,\n            reject_message,\n            error_code\n          } = queryResponse;\n          hash = hashOfMap({\n            status: status,\n            reject_code: reject_code,\n            reject_message: reject_message,\n            error_code: error_code,\n            timestamp: BigInt(timestamp),\n            request_id: requestId\n          });\n        } else {\n          throw new Error(`Unknown status: ${status}`);\n        }\n        const separatorWithHash = concat(domainSeparator, new Uint8Array(hash));\n        // FIX: check for match without verifying N times\n        const pubKey = subnetStatus === null || subnetStatus === void 0 ? void 0 : subnetStatus.nodeKeys.get(nodeId);\n        if (!pubKey) {\n          throw new CertificateVerificationError('Invalid signature from replica signed query: no matching node key found.');\n        }\n        const rawKey = Ed25519PublicKey.fromDer(pubKey).rawKey;\n        const valid = ed25519.verify(sig.signature, new Uint8Array(separatorWithHash), new Uint8Array(rawKey));\n        if (valid) return queryResponse;\n        throw new CertificateVerificationError(`Invalid signature from replica ${nodeId} signed query.`);\n      }\n      return queryResponse;\n    });\n    this.config = options;\n    __classPrivateFieldSet(this, _HttpAgent_fetch, options.fetch || getDefaultFetch() || fetch.bind(global), \"f\");\n    __classPrivateFieldSet(this, _HttpAgent_fetchOptions, options.fetchOptions, \"f\");\n    __classPrivateFieldSet(this, _HttpAgent_callOptions, options.callOptions, \"f\");\n    this.rootKey = options.rootKey ? options.rootKey : fromHex(IC_ROOT_KEY);\n    const host = determineHost(options.host);\n    this.host = new URL(host);\n    if (options.verifyQuerySignatures !== undefined) {\n      __classPrivateFieldSet(this, _HttpAgent_verifyQuerySignatures, options.verifyQuerySignatures, \"f\");\n    }\n    // Default is 3\n    __classPrivateFieldSet(this, _HttpAgent_retryTimes, (_a = options.retryTimes) !== null && _a !== void 0 ? _a : 3, \"f\");\n    // Delay strategy for retries. Default is exponential backoff\n    const defaultBackoffFactory = () => new ExponentialBackoff({\n      maxIterations: __classPrivateFieldGet(this, _HttpAgent_retryTimes, \"f\")\n    });\n    __classPrivateFieldSet(this, _HttpAgent_backoffStrategy, options.backoffStrategy || defaultBackoffFactory, \"f\");\n    // Rewrite to avoid redirects\n    if (this.host.hostname.endsWith(IC0_SUB_DOMAIN)) {\n      this.host.hostname = IC0_DOMAIN;\n    } else if (this.host.hostname.endsWith(ICP0_SUB_DOMAIN)) {\n      this.host.hostname = ICP0_DOMAIN;\n    } else if (this.host.hostname.endsWith(ICP_API_SUB_DOMAIN)) {\n      this.host.hostname = ICP_API_DOMAIN;\n    }\n    if (options.credentials) {\n      const {\n        name,\n        password\n      } = options.credentials;\n      __classPrivateFieldSet(this, _HttpAgent_credentials, `${name}${password ? ':' + password : ''}`, \"f\");\n    }\n    __classPrivateFieldSet(this, _HttpAgent_identity, Promise.resolve(options.identity || new AnonymousIdentity()), \"f\");\n    // Add a nonce transform to ensure calls are unique\n    this.addTransform('update', makeNonceTransform(makeNonce));\n    if (options.useQueryNonces) {\n      this.addTransform('query', makeNonceTransform(makeNonce));\n    }\n    if (options.logToConsole) {\n      this.log.subscribe(log => {\n        if (log.level === 'error') {\n          console.error(log.message);\n        } else if (log.level === 'warn') {\n          console.warn(log.message);\n        } else {\n          console.log(log.message);\n        }\n      });\n    }\n  }\n  get waterMark() {\n    return __classPrivateFieldGet(this, _HttpAgent_waterMark, \"f\");\n  }\n  static createSync() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return new this(Object.assign({}, options));\n  }\n  static async create() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      shouldFetchRootKey: false\n    };\n    const agent = HttpAgent.createSync(options);\n    const initPromises = [agent.syncTime()];\n    if (agent.host.toString() !== 'https://icp-api.io' && options.shouldFetchRootKey) {\n      initPromises.push(agent.fetchRootKey());\n    }\n    await Promise.all(initPromises);\n    return agent;\n  }\n  static async from(agent) {\n    var _a;\n    try {\n      if ('config' in agent) {\n        return await HttpAgent.create(agent.config);\n      }\n      return await HttpAgent.create({\n        fetch: agent._fetch,\n        fetchOptions: agent._fetchOptions,\n        callOptions: agent._callOptions,\n        host: agent._host.toString(),\n        identity: (_a = agent._identity) !== null && _a !== void 0 ? _a : undefined\n      });\n    } catch (_b) {\n      throw new AgentError('Failed to create agent from provided agent');\n    }\n  }\n  isLocal() {\n    const hostname = this.host.hostname;\n    return hostname === '127.0.0.1' || hostname.endsWith('127.0.0.1');\n  }\n  addTransform(type, fn) {\n    let priority = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : fn.priority || 0;\n    if (type === 'update') {\n      // Keep the pipeline sorted at all time, by priority.\n      const i = __classPrivateFieldGet(this, _HttpAgent_updatePipeline, \"f\").findIndex(x => (x.priority || 0) < priority);\n      __classPrivateFieldGet(this, _HttpAgent_updatePipeline, \"f\").splice(i >= 0 ? i : __classPrivateFieldGet(this, _HttpAgent_updatePipeline, \"f\").length, 0, Object.assign(fn, {\n        priority\n      }));\n    } else if (type === 'query') {\n      // Keep the pipeline sorted at all time, by priority.\n      const i = __classPrivateFieldGet(this, _HttpAgent_queryPipeline, \"f\").findIndex(x => (x.priority || 0) < priority);\n      __classPrivateFieldGet(this, _HttpAgent_queryPipeline, \"f\").splice(i >= 0 ? i : __classPrivateFieldGet(this, _HttpAgent_queryPipeline, \"f\").length, 0, Object.assign(fn, {\n        priority\n      }));\n    }\n  }\n  async getPrincipal() {\n    if (!__classPrivateFieldGet(this, _HttpAgent_identity, \"f\")) {\n      throw new IdentityInvalidError(\"This identity has expired due this application's security policy. Please refresh your authentication.\");\n    }\n    return (await __classPrivateFieldGet(this, _HttpAgent_identity, \"f\")).getPrincipal();\n  }\n  async call(canisterId, options, identity) {\n    var _a;\n    const callSync = (_a = options.callSync) !== null && _a !== void 0 ? _a : true;\n    const id = await (identity !== undefined ? await identity : await __classPrivateFieldGet(this, _HttpAgent_identity, \"f\"));\n    if (!id) {\n      throw new IdentityInvalidError(\"This identity has expired due this application's security policy. Please refresh your authentication.\");\n    }\n    const canister = Principal.from(canisterId);\n    const ecid = options.effectiveCanisterId ? Principal.from(options.effectiveCanisterId) : canister;\n    const sender = id.getPrincipal() || Principal.anonymous();\n    let ingress_expiry = new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS);\n    // If the value is off by more than 30 seconds, reconcile system time with the network\n    if (Math.abs(__classPrivateFieldGet(this, _HttpAgent_timeDiffMsecs, \"f\")) > 1000 * 30) {\n      ingress_expiry = new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS + __classPrivateFieldGet(this, _HttpAgent_timeDiffMsecs, \"f\"));\n    }\n    const submit = {\n      request_type: SubmitRequestType.Call,\n      canister_id: canister,\n      method_name: options.methodName,\n      arg: options.arg,\n      sender,\n      ingress_expiry\n    };\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let transformedRequest = await this._transform({\n      request: {\n        body: null,\n        method: 'POST',\n        headers: Object.assign({\n          'Content-Type': 'application/cbor'\n        }, __classPrivateFieldGet(this, _HttpAgent_credentials, \"f\") ? {\n          Authorization: 'Basic ' + btoa(__classPrivateFieldGet(this, _HttpAgent_credentials, \"f\"))\n        } : {})\n      },\n      endpoint: \"call\" /* Endpoint.Call */,\n      body: submit\n    });\n    const nonce = transformedRequest.body.nonce ? toNonce(transformedRequest.body.nonce) : undefined;\n    submit.nonce = nonce;\n    function toNonce(buf) {\n      return new Uint8Array(buf);\n    }\n    // Apply transform for identity.\n    transformedRequest = await id.transformRequest(transformedRequest);\n    const body = cbor.encode(transformedRequest.body);\n    const backoff = __classPrivateFieldGet(this, _HttpAgent_backoffStrategy, \"f\").call(this);\n    try {\n      // Attempt v3 sync call\n      const requestSync = () => {\n        this.log.print(`fetching \"/api/v3/canister/${ecid.toText()}/call\" with request:`, transformedRequest);\n        return __classPrivateFieldGet(this, _HttpAgent_fetch, \"f\").call(this, '' + new URL(`/api/v3/canister/${ecid.toText()}/call`, this.host), Object.assign(Object.assign(Object.assign({}, __classPrivateFieldGet(this, _HttpAgent_callOptions, \"f\")), transformedRequest.request), {\n          body\n        }));\n      };\n      const requestAsync = () => {\n        this.log.print(`fetching \"/api/v2/canister/${ecid.toText()}/call\" with request:`, transformedRequest);\n        return __classPrivateFieldGet(this, _HttpAgent_fetch, \"f\").call(this, '' + new URL(`/api/v2/canister/${ecid.toText()}/call`, this.host), Object.assign(Object.assign(Object.assign({}, __classPrivateFieldGet(this, _HttpAgent_callOptions, \"f\")), transformedRequest.request), {\n          body\n        }));\n      };\n      const request = __classPrivateFieldGet(this, _HttpAgent_instances, \"m\", _HttpAgent_requestAndRetry).call(this, {\n        request: callSync ? requestSync : requestAsync,\n        backoff,\n        tries: 0\n      });\n      const [response, requestId] = await Promise.all([request, requestIdOf(submit)]);\n      const responseBuffer = await response.arrayBuffer();\n      const responseBody = response.status === 200 && responseBuffer.byteLength > 0 ? cbor.decode(responseBuffer) : null;\n      // Update the watermark with the latest time from consensus\n      if (responseBody === null || responseBody === void 0 ? void 0 : responseBody.certificate) {\n        const time = await this.parseTimeFromResponse({\n          certificate: responseBody.certificate\n        });\n        __classPrivateFieldSet(this, _HttpAgent_waterMark, time, \"f\");\n      }\n      return {\n        requestId,\n        response: {\n          ok: response.ok,\n          status: response.status,\n          statusText: response.statusText,\n          body: responseBody,\n          headers: httpHeadersTransform(response.headers)\n        },\n        requestDetails: submit\n      };\n    } catch (error) {\n      // If the error is due to the v3 api not being supported, fall back to v2\n      if (error.message.includes('v3 api not supported.')) {\n        this.log.warn('v3 api not supported. Fall back to v2');\n        return this.call(canisterId, Object.assign(Object.assign({}, options), {\n          // disable v3 api\n          callSync: false\n        }), identity);\n      }\n      this.log.error('Error while making call:', error);\n      throw error;\n    }\n  }\n  async query(canisterId, fields, identity) {\n    const backoff = __classPrivateFieldGet(this, _HttpAgent_backoffStrategy, \"f\").call(this);\n    const ecid = fields.effectiveCanisterId ? Principal.from(fields.effectiveCanisterId) : Principal.from(canisterId);\n    this.log.print(`ecid ${ecid.toString()}`);\n    this.log.print(`canisterId ${canisterId.toString()}`);\n    const makeQuery = async () => {\n      const id = await (identity !== undefined ? await identity : await __classPrivateFieldGet(this, _HttpAgent_identity, \"f\"));\n      if (!id) {\n        throw new IdentityInvalidError(\"This identity has expired due this application's security policy. Please refresh your authentication.\");\n      }\n      const canister = Principal.from(canisterId);\n      const sender = (id === null || id === void 0 ? void 0 : id.getPrincipal()) || Principal.anonymous();\n      const request = {\n        request_type: \"query\" /* ReadRequestType.Query */,\n        canister_id: canister,\n        method_name: fields.methodName,\n        arg: fields.arg,\n        sender,\n        ingress_expiry: new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS)\n      };\n      const requestId = await requestIdOf(request);\n      // TODO: remove this any. This can be a Signed or UnSigned request.\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      let transformedRequest = await this._transform({\n        request: {\n          method: 'POST',\n          headers: Object.assign({\n            'Content-Type': 'application/cbor'\n          }, __classPrivateFieldGet(this, _HttpAgent_credentials, \"f\") ? {\n            Authorization: 'Basic ' + btoa(__classPrivateFieldGet(this, _HttpAgent_credentials, \"f\"))\n          } : {})\n        },\n        endpoint: \"read\" /* Endpoint.Query */,\n        body: request\n      });\n      // Apply transform for identity.\n      transformedRequest = await (id === null || id === void 0 ? void 0 : id.transformRequest(transformedRequest));\n      const body = cbor.encode(transformedRequest.body);\n      const args = {\n        canister: canister.toText(),\n        ecid,\n        transformedRequest,\n        body,\n        requestId,\n        backoff,\n        tries: 0\n      };\n      return {\n        requestDetails: request,\n        query: await __classPrivateFieldGet(this, _HttpAgent_instances, \"m\", _HttpAgent_requestAndRetryQuery).call(this, args)\n      };\n    };\n    const getSubnetStatus = async () => {\n      if (!__classPrivateFieldGet(this, _HttpAgent_verifyQuerySignatures, \"f\")) {\n        return undefined;\n      }\n      const subnetStatus = __classPrivateFieldGet(this, _HttpAgent_subnetKeys, \"f\").get(ecid.toString());\n      if (subnetStatus) {\n        return subnetStatus;\n      }\n      await this.fetchSubnetKeys(ecid.toString());\n      return __classPrivateFieldGet(this, _HttpAgent_subnetKeys, \"f\").get(ecid.toString());\n    };\n    // Attempt to make the query i=retryTimes times\n    // Make query and fetch subnet keys in parallel\n    const [queryResult, subnetStatus] = await Promise.all([makeQuery(), getSubnetStatus()]);\n    const {\n      requestDetails,\n      query\n    } = queryResult;\n    const queryWithDetails = Object.assign(Object.assign({}, query), {\n      requestDetails\n    });\n    this.log.print('Query response:', queryWithDetails);\n    // Skip verification if the user has disabled it\n    if (!__classPrivateFieldGet(this, _HttpAgent_verifyQuerySignatures, \"f\")) {\n      return queryWithDetails;\n    }\n    try {\n      return __classPrivateFieldGet(this, _HttpAgent_verifyQueryResponse, \"f\").call(this, queryWithDetails, subnetStatus);\n    } catch (_a) {\n      // In case the node signatures have changed, refresh the subnet keys and try again\n      this.log.warn('Query response verification failed. Retrying with fresh subnet keys.');\n      __classPrivateFieldGet(this, _HttpAgent_subnetKeys, \"f\").delete(canisterId.toString());\n      await this.fetchSubnetKeys(ecid.toString());\n      const updatedSubnetStatus = __classPrivateFieldGet(this, _HttpAgent_subnetKeys, \"f\").get(canisterId.toString());\n      if (!updatedSubnetStatus) {\n        throw new CertificateVerificationError('Invalid signature from replica signed query: no matching node key found.');\n      }\n      return __classPrivateFieldGet(this, _HttpAgent_verifyQueryResponse, \"f\").call(this, queryWithDetails, updatedSubnetStatus);\n    }\n  }\n  async createReadStateRequest(fields, identity) {\n    const id = await (identity !== undefined ? await identity : await __classPrivateFieldGet(this, _HttpAgent_identity, \"f\"));\n    if (!id) {\n      throw new IdentityInvalidError(\"This identity has expired due this application's security policy. Please refresh your authentication.\");\n    }\n    const sender = (id === null || id === void 0 ? void 0 : id.getPrincipal()) || Principal.anonymous();\n    // TODO: remove this any. This can be a Signed or UnSigned request.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const transformedRequest = await this._transform({\n      request: {\n        method: 'POST',\n        headers: Object.assign({\n          'Content-Type': 'application/cbor'\n        }, __classPrivateFieldGet(this, _HttpAgent_credentials, \"f\") ? {\n          Authorization: 'Basic ' + btoa(__classPrivateFieldGet(this, _HttpAgent_credentials, \"f\"))\n        } : {})\n      },\n      endpoint: \"read_state\" /* Endpoint.ReadState */,\n      body: {\n        request_type: \"read_state\" /* ReadRequestType.ReadState */,\n        paths: fields.paths,\n        sender,\n        ingress_expiry: new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS)\n      }\n    });\n    // Apply transform for identity.\n    return id === null || id === void 0 ? void 0 : id.transformRequest(transformedRequest);\n  }\n  async readState(canisterId, fields, identity,\n  // eslint-disable-next-line\n  request) {\n    const canister = typeof canisterId === 'string' ? Principal.fromText(canisterId) : canisterId;\n    const transformedRequest = request !== null && request !== void 0 ? request : await this.createReadStateRequest(fields, identity);\n    const body = cbor.encode(transformedRequest.body);\n    this.log.print(`fetching \"/api/v2/canister/${canister}/read_state\" with request:`, transformedRequest);\n    // TODO - https://dfinity.atlassian.net/browse/SDK-1092\n    const backoff = __classPrivateFieldGet(this, _HttpAgent_backoffStrategy, \"f\").call(this);\n    try {\n      const response = await __classPrivateFieldGet(this, _HttpAgent_instances, \"m\", _HttpAgent_requestAndRetry).call(this, {\n        request: () => __classPrivateFieldGet(this, _HttpAgent_fetch, \"f\").call(this, '' + new URL(`/api/v2/canister/${canister.toString()}/read_state`, this.host), Object.assign(Object.assign(Object.assign({}, __classPrivateFieldGet(this, _HttpAgent_fetchOptions, \"f\")), transformedRequest.request), {\n          body\n        })),\n        backoff,\n        tries: 0\n      });\n      if (!response.ok) {\n        throw new Error(`Server returned an error:\\n` + `  Code: ${response.status} (${response.statusText})\\n` + `  Body: ${await response.text()}\\n`);\n      }\n      const decodedResponse = cbor.decode(await response.arrayBuffer());\n      this.log.print('Read state response:', decodedResponse);\n      const parsedTime = await this.parseTimeFromResponse(decodedResponse);\n      if (parsedTime > 0) {\n        this.log.print('Read state response time:', parsedTime);\n        __classPrivateFieldSet(this, _HttpAgent_waterMark, parsedTime, \"f\");\n      }\n      return decodedResponse;\n    } catch (error) {\n      this.log.error('Caught exception while attempting to read state', error);\n      throw error;\n    }\n  }\n  async parseTimeFromResponse(response) {\n    let tree;\n    if (response.certificate) {\n      const decoded = cbor.decode(response.certificate);\n      if (decoded && 'tree' in decoded) {\n        tree = decoded.tree;\n      } else {\n        throw new Error('Could not decode time from response');\n      }\n      const timeLookup = lookup_path(['time'], tree);\n      if (timeLookup.status !== LookupStatus.Found) {\n        throw new Error('Time was not found in the response or was not in its expected format.');\n      }\n      if (!(timeLookup.value instanceof ArrayBuffer) && !ArrayBuffer.isView(timeLookup)) {\n        throw new Error('Time was not found in the response or was not in its expected format.');\n      }\n      const date = decodeTime(bufFromBufLike(timeLookup.value));\n      this.log.print('Time from response:', date);\n      this.log.print('Time from response in milliseconds:', Number(date));\n      return Number(date);\n    } else {\n      this.log.warn('No certificate found in response');\n    }\n    return 0;\n  }\n  /**\n   * Allows agent to sync its time with the network. Can be called during intialization or mid-lifecycle if the device's clock has drifted away from the network time. This is necessary to set the Expiry for a request\n   * @param {Principal} canisterId - Pass a canister ID if you need to sync the time with a particular replica. Uses the management canister by default\n   */\n  async syncTime(canisterId) {\n    const CanisterStatus = await import('../../canisterStatus');\n    const callTime = Date.now();\n    try {\n      if (!canisterId) {\n        this.log.print('Syncing time with the IC. No canisterId provided, so falling back to ryjl3-tyaaa-aaaaa-aaaba-cai');\n      }\n      const status = await CanisterStatus.request({\n        // Fall back with canisterId of the ICP Ledger\n        canisterId: canisterId !== null && canisterId !== void 0 ? canisterId : Principal.from('ryjl3-tyaaa-aaaaa-aaaba-cai'),\n        agent: this,\n        paths: ['time']\n      });\n      const replicaTime = status.get('time');\n      if (replicaTime) {\n        __classPrivateFieldSet(this, _HttpAgent_timeDiffMsecs, Number(replicaTime) - Number(callTime), \"f\");\n      }\n    } catch (error) {\n      this.log.error('Caught exception while attempting to sync time', error);\n    }\n  }\n  async status() {\n    const headers = __classPrivateFieldGet(this, _HttpAgent_credentials, \"f\") ? {\n      Authorization: 'Basic ' + btoa(__classPrivateFieldGet(this, _HttpAgent_credentials, \"f\"))\n    } : {};\n    this.log.print(`fetching \"/api/v2/status\"`);\n    const backoff = __classPrivateFieldGet(this, _HttpAgent_backoffStrategy, \"f\").call(this);\n    const response = await __classPrivateFieldGet(this, _HttpAgent_instances, \"m\", _HttpAgent_requestAndRetry).call(this, {\n      backoff,\n      request: () => __classPrivateFieldGet(this, _HttpAgent_fetch, \"f\").call(this, '' + new URL(`/api/v2/status`, this.host), Object.assign({\n        headers\n      }, __classPrivateFieldGet(this, _HttpAgent_fetchOptions, \"f\"))),\n      tries: 0\n    });\n    return cbor.decode(await response.arrayBuffer());\n  }\n  async fetchRootKey() {\n    if (!__classPrivateFieldGet(this, _HttpAgent_rootKeyFetched, \"f\")) {\n      const status = await this.status();\n      // Hex-encoded version of the replica root key\n      this.rootKey = status.root_key;\n      __classPrivateFieldSet(this, _HttpAgent_rootKeyFetched, true, \"f\");\n    }\n    return this.rootKey;\n  }\n  invalidateIdentity() {\n    __classPrivateFieldSet(this, _HttpAgent_identity, null, \"f\");\n  }\n  replaceIdentity(identity) {\n    __classPrivateFieldSet(this, _HttpAgent_identity, Promise.resolve(identity), \"f\");\n  }\n  async fetchSubnetKeys(canisterId) {\n    const effectiveCanisterId = Principal.from(canisterId);\n    const response = await request({\n      canisterId: effectiveCanisterId,\n      paths: ['subnet'],\n      agent: this\n    });\n    const subnetResponse = response.get('subnet');\n    if (subnetResponse && typeof subnetResponse === 'object' && 'nodeKeys' in subnetResponse) {\n      __classPrivateFieldGet(this, _HttpAgent_subnetKeys, \"f\").set(effectiveCanisterId.toText(), subnetResponse);\n      return subnetResponse;\n    }\n    // If the subnet status is not returned, return undefined\n    return undefined;\n  }\n  _transform(request) {\n    let p = Promise.resolve(request);\n    if (request.endpoint === \"call\" /* Endpoint.Call */) {\n      for (const fn of __classPrivateFieldGet(this, _HttpAgent_updatePipeline, \"f\")) {\n        p = p.then(r => fn(r).then(r2 => r2 || r));\n      }\n    } else {\n      for (const fn of __classPrivateFieldGet(this, _HttpAgent_queryPipeline, \"f\")) {\n        p = p.then(r => fn(r).then(r2 => r2 || r));\n      }\n    }\n    return p;\n  }\n}\n_HttpAgent_identity = new WeakMap(), _HttpAgent_fetch = new WeakMap(), _HttpAgent_fetchOptions = new WeakMap(), _HttpAgent_callOptions = new WeakMap(), _HttpAgent_timeDiffMsecs = new WeakMap(), _HttpAgent_credentials = new WeakMap(), _HttpAgent_rootKeyFetched = new WeakMap(), _HttpAgent_retryTimes = new WeakMap(), _HttpAgent_backoffStrategy = new WeakMap(), _HttpAgent_waterMark = new WeakMap(), _HttpAgent_queryPipeline = new WeakMap(), _HttpAgent_updatePipeline = new WeakMap(), _HttpAgent_subnetKeys = new WeakMap(), _HttpAgent_verifyQuerySignatures = new WeakMap(), _HttpAgent_verifyQueryResponse = new WeakMap(), _HttpAgent_instances = new WeakSet(), _HttpAgent_requestAndRetryQuery = async function _HttpAgent_requestAndRetryQuery(args) {\n  var _a, _b;\n  const {\n    ecid,\n    transformedRequest,\n    body,\n    requestId,\n    backoff,\n    tries\n  } = args;\n  const delay = tries === 0 ? 0 : backoff.next();\n  this.log.print(`fetching \"/api/v2/canister/${ecid.toString()}/query\" with tries:`, {\n    tries,\n    backoff,\n    delay\n  });\n  // If delay is null, the backoff strategy is exhausted due to a maximum number of retries, duration, or other reason\n  if (delay === null) {\n    throw new AgentError(`Timestamp failed to pass the watermark after retrying the configured ${__classPrivateFieldGet(this, _HttpAgent_retryTimes, \"f\")} times. We cannot guarantee the integrity of the response since it could be a replay attack.`);\n  }\n  if (delay > 0) {\n    await new Promise(resolve => setTimeout(resolve, delay));\n  }\n  let response;\n  // Make the request and retry if it throws an error\n  try {\n    this.log.print(`fetching \"/api/v2/canister/${ecid.toString()}/query\" with request:`, transformedRequest);\n    const fetchResponse = await __classPrivateFieldGet(this, _HttpAgent_fetch, \"f\").call(this, '' + new URL(`/api/v2/canister/${ecid.toString()}/query`, this.host), Object.assign(Object.assign(Object.assign({}, __classPrivateFieldGet(this, _HttpAgent_fetchOptions, \"f\")), transformedRequest.request), {\n      body\n    }));\n    if (fetchResponse.status === 200) {\n      const queryResponse = cbor.decode(await fetchResponse.arrayBuffer());\n      response = Object.assign(Object.assign({}, queryResponse), {\n        httpDetails: {\n          ok: fetchResponse.ok,\n          status: fetchResponse.status,\n          statusText: fetchResponse.statusText,\n          headers: httpHeadersTransform(fetchResponse.headers)\n        },\n        requestId\n      });\n    } else {\n      throw new AgentHTTPResponseError(`Gateway returned an error:\\n` + `  Code: ${fetchResponse.status} (${fetchResponse.statusText})\\n` + `  Body: ${await fetchResponse.text()}\\n`, {\n        ok: fetchResponse.ok,\n        status: fetchResponse.status,\n        statusText: fetchResponse.statusText,\n        headers: httpHeadersTransform(fetchResponse.headers)\n      });\n    }\n  } catch (error) {\n    if (tries < __classPrivateFieldGet(this, _HttpAgent_retryTimes, \"f\")) {\n      this.log.warn(`Caught exception while attempting to make query:\\n` + `  ${error}\\n` + `  Retrying query.`);\n      return await __classPrivateFieldGet(this, _HttpAgent_instances, \"m\", _HttpAgent_requestAndRetryQuery).call(this, Object.assign(Object.assign({}, args), {\n        tries: tries + 1\n      }));\n    }\n    throw error;\n  }\n  const timestamp = (_b = (_a = response.signatures) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.timestamp;\n  // Skip watermark verification if the user has set verifyQuerySignatures to false\n  if (!__classPrivateFieldGet(this, _HttpAgent_verifyQuerySignatures, \"f\")) {\n    return response;\n  }\n  if (!timestamp) {\n    throw new Error('Timestamp not found in query response. This suggests a malformed or malicious response.');\n  }\n  // Convert the timestamp to milliseconds\n  const timeStampInMs = Number(BigInt(timestamp) / BigInt(1000000));\n  this.log.print('watermark and timestamp', {\n    waterMark: this.waterMark,\n    timestamp: timeStampInMs\n  });\n  // If the timestamp is less than the watermark, retry the request up to the retry limit\n  if (Number(this.waterMark) > timeStampInMs) {\n    const error = new AgentError('Timestamp is below the watermark. Retrying query.');\n    this.log.error('Timestamp is below', error, {\n      timestamp,\n      waterMark: this.waterMark\n    });\n    if (tries < __classPrivateFieldGet(this, _HttpAgent_retryTimes, \"f\")) {\n      return await __classPrivateFieldGet(this, _HttpAgent_instances, \"m\", _HttpAgent_requestAndRetryQuery).call(this, Object.assign(Object.assign({}, args), {\n        tries: tries + 1\n      }));\n    }\n    {\n      throw new AgentError(`Timestamp failed to pass the watermark after retrying the configured ${__classPrivateFieldGet(this, _HttpAgent_retryTimes, \"f\")} times. We cannot guarantee the integrity of the response since it could be a replay attack.`);\n    }\n  }\n  return response;\n}, _HttpAgent_requestAndRetry = async function _HttpAgent_requestAndRetry(args) {\n  const {\n    request,\n    backoff,\n    tries\n  } = args;\n  const delay = tries === 0 ? 0 : backoff.next();\n  // If delay is null, the backoff strategy is exhausted due to a maximum number of retries, duration, or other reason\n  if (delay === null) {\n    throw new AgentError(`Timestamp failed to pass the watermark after retrying the configured ${__classPrivateFieldGet(this, _HttpAgent_retryTimes, \"f\")} times. We cannot guarantee the integrity of the response since it could be a replay attack.`);\n  }\n  if (delay > 0) {\n    await new Promise(resolve => setTimeout(resolve, delay));\n  }\n  let response;\n  try {\n    response = await request();\n  } catch (error) {\n    if (__classPrivateFieldGet(this, _HttpAgent_retryTimes, \"f\") > tries) {\n      this.log.warn(`Caught exception while attempting to make request:\\n` + `  ${error}\\n` + `  Retrying request.`);\n      // Delay the request by the configured backoff strategy\n      return await __classPrivateFieldGet(this, _HttpAgent_instances, \"m\", _HttpAgent_requestAndRetry).call(this, {\n        request,\n        backoff,\n        tries: tries + 1\n      });\n    }\n    throw error;\n  }\n  if (response.ok) {\n    return response;\n  }\n  const responseText = await response.clone().text();\n  const errorMessage = `Server returned an error:\\n` + `  Code: ${response.status} (${response.statusText})\\n` + `  Body: ${responseText}\\n`;\n  if (response.status === 404 && response.url.includes('api/v3')) {\n    throw new AgentHTTPResponseError('v3 api not supported. Fall back to v2', {\n      ok: response.ok,\n      status: response.status,\n      statusText: response.statusText,\n      headers: httpHeadersTransform(response.headers)\n    });\n  }\n  if (tries < __classPrivateFieldGet(this, _HttpAgent_retryTimes, \"f\")) {\n    return await __classPrivateFieldGet(this, _HttpAgent_instances, \"m\", _HttpAgent_requestAndRetry).call(this, {\n      request,\n      backoff,\n      tries: tries + 1\n    });\n  }\n  throw new AgentHTTPResponseError(errorMessage, {\n    ok: response.ok,\n    status: response.status,\n    statusText: response.statusText,\n    headers: httpHeadersTransform(response.headers)\n  });\n};","map":{"version":3,"names":["Principal","AgentError","AnonymousIdentity","cbor","hashOfMap","requestIdOf","bufFromBufLike","concat","fromHex","Expiry","httpHeadersTransform","makeNonceTransform","makeNonce","SubmitRequestType","AgentHTTPResponseError","request","CertificateVerificationError","LookupStatus","lookup_path","ed25519","ExpirableMap","Ed25519PublicKey","decodeTime","ObservableLog","ExponentialBackoff","RequestStatusResponseStatus","DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS","IC_ROOT_KEY","MANAGEMENT_CANISTER_ID","IC0_DOMAIN","IC0_SUB_DOMAIN","ICP0_DOMAIN","ICP0_SUB_DOMAIN","ICP_API_DOMAIN","ICP_API_SUB_DOMAIN","HttpDefaultFetchError","constructor","message","IdentityInvalidError","getDefaultFetch","defaultFetch","window","fetch","bind","global","self","determineHost","configuredHost","host","undefined","match","URL","location","protocol","knownHosts","remoteHosts","hostname","knownHost","some","endsWith","find","port","toString","HttpAgent","options","arguments","length","_HttpAgent_identity","set","_HttpAgent_fetch","_HttpAgent_fetchOptions","_HttpAgent_callOptions","_HttpAgent_timeDiffMsecs","_HttpAgent_credentials","_HttpAgent_rootKeyFetched","_HttpAgent_retryTimes","_HttpAgent_backoffStrategy","_isAgent","config","_HttpAgent_waterMark","log","_HttpAgent_queryPipeline","_HttpAgent_updatePipeline","_HttpAgent_subnetKeys","expirationTime","_HttpAgent_verifyQuerySignatures","_HttpAgent_verifyQueryResponse","queryResponse","subnetStatus","__classPrivateFieldGet","status","signatures","requestId","domainSeparator","TextEncoder","encode","sig","timestamp","identity","nodeId","fromUint8Array","toText","hash","reply","BigInt","request_id","reject_code","reject_message","error_code","Error","separatorWithHash","Uint8Array","pubKey","nodeKeys","get","rawKey","fromDer","valid","verify","signature","__classPrivateFieldSet","fetchOptions","callOptions","rootKey","verifyQuerySignatures","_a","retryTimes","defaultBackoffFactory","maxIterations","backoffStrategy","credentials","name","password","Promise","resolve","addTransform","useQueryNonces","logToConsole","subscribe","level","console","error","warn","waterMark","createSync","Object","assign","create","shouldFetchRootKey","agent","initPromises","syncTime","push","fetchRootKey","all","from","_fetch","_fetchOptions","_callOptions","_host","_identity","_b","isLocal","type","fn","priority","i","findIndex","x","splice","getPrincipal","call","canisterId","callSync","id","canister","ecid","effectiveCanisterId","sender","anonymous","ingress_expiry","Math","abs","submit","request_type","Call","canister_id","method_name","methodName","arg","transformedRequest","_transform","body","method","headers","Authorization","btoa","endpoint","nonce","toNonce","buf","transformRequest","backoff","requestSync","print","requestAsync","_HttpAgent_instances","_HttpAgent_requestAndRetry","tries","response","responseBuffer","arrayBuffer","responseBody","byteLength","decode","certificate","time","parseTimeFromResponse","ok","statusText","requestDetails","includes","query","fields","makeQuery","args","_HttpAgent_requestAndRetryQuery","getSubnetStatus","fetchSubnetKeys","queryResult","queryWithDetails","delete","updatedSubnetStatus","createReadStateRequest","paths","readState","fromText","text","decodedResponse","parsedTime","tree","decoded","timeLookup","Found","value","ArrayBuffer","isView","date","Number","CanisterStatus","callTime","Date","now","replicaTime","root_key","invalidateIdentity","replaceIdentity","subnetResponse","p","then","r","r2","delay","next","setTimeout","fetchResponse","httpDetails","timeStampInMs","responseText","clone","errorMessage","url"],"sources":["/home/arslan/modojo/node_modules/@dfinity/agent/src/agent/http/index.ts"],"sourcesContent":["import { JsonObject } from '@dfinity/candid';\nimport { Principal } from '@dfinity/principal';\nimport { AgentError } from '../../errors';\nimport { AnonymousIdentity, Identity } from '../../auth';\nimport * as cbor from '../../cbor';\nimport { RequestId, hashOfMap, requestIdOf } from '../../request_id';\nimport { bufFromBufLike, concat, fromHex } from '../../utils/buffer';\nimport {\n  Agent,\n  ApiQueryResponse,\n  QueryFields,\n  QueryResponse,\n  ReadStateOptions,\n  ReadStateResponse,\n  SubmitResponse,\n} from '../api';\nimport { Expiry, httpHeadersTransform, makeNonceTransform } from './transforms';\nimport {\n  CallRequest,\n  Endpoint,\n  HttpAgentRequest,\n  HttpAgentRequestTransformFn,\n  HttpAgentSubmitRequest,\n  makeNonce,\n  Nonce,\n  QueryRequest,\n  ReadRequestType,\n  SubmitRequestType,\n} from './types';\nimport { AgentHTTPResponseError } from './errors';\nimport { SubnetStatus, request } from '../../canisterStatus';\nimport {\n  CertificateVerificationError,\n  HashTree,\n  LookupStatus,\n  lookup_path,\n} from '../../certificate';\nimport { ed25519 } from '@noble/curves/ed25519';\nimport { ExpirableMap } from '../../utils/expirableMap';\nimport { Ed25519PublicKey } from '../../public_key';\nimport { decodeTime } from '../../utils/leb';\nimport { ObservableLog } from '../../observable';\nimport { BackoffStrategy, BackoffStrategyFactory, ExponentialBackoff } from '../../polling/backoff';\nexport * from './transforms';\nexport { Nonce, makeNonce } from './types';\n\nexport enum RequestStatusResponseStatus {\n  Received = 'received',\n  Processing = 'processing',\n  Replied = 'replied',\n  Rejected = 'rejected',\n  Unknown = 'unknown',\n  Done = 'done',\n}\n\n// Default delta for ingress expiry is 5 minutes.\nconst DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS = 5 * 60 * 1000;\n\n// Root public key for the IC, encoded as hex\nexport const IC_ROOT_KEY =\n  '308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100814' +\n  'c0e6ec71fab583b08bd81373c255c3c371b2e84863c98a4f1e08b74235d14fb5d9c0cd546d968' +\n  '5f913a0c0b2cc5341583bf4b4392e467db96d65b9bb4cb717112f8472e0d5a4d14505ffd7484' +\n  'b01291091c5f87b98883463f98091a0baaae';\n\nexport const MANAGEMENT_CANISTER_ID = 'aaaaa-aa';\n\n// IC0 domain info\nconst IC0_DOMAIN = 'ic0.app';\nconst IC0_SUB_DOMAIN = '.ic0.app';\n\nconst ICP0_DOMAIN = 'icp0.io';\nconst ICP0_SUB_DOMAIN = '.icp0.io';\n\nconst ICP_API_DOMAIN = 'icp-api.io';\nconst ICP_API_SUB_DOMAIN = '.icp-api.io';\n\nclass HttpDefaultFetchError extends AgentError {\n  constructor(public readonly message: string) {\n    super(message);\n  }\n}\nexport class IdentityInvalidError extends AgentError {\n  constructor(public readonly message: string) {\n    super(message);\n  }\n}\n\n// HttpAgent options that can be used at construction.\nexport interface HttpAgentOptions {\n  // A surrogate to the global fetch function. Useful for testing.\n  fetch?: typeof fetch;\n\n  // Additional options to pass along to fetch. Will not override fields that\n  // the agent already needs to set\n  // Should follow the RequestInit interface, but we intentially support non-standard fields\n  fetchOptions?: Record<string, unknown>;\n\n  // Additional options to pass along to fetch for the call API.\n  callOptions?: Record<string, unknown>;\n\n  // The host to use for the client. By default, uses the same host as\n  // the current page.\n  host?: string;\n\n  // The principal used to send messages. This cannot be empty at the request\n  // time (will throw).\n  identity?: Identity | Promise<Identity>;\n\n  credentials?: {\n    name: string;\n    password?: string;\n  };\n  /**\n   * Adds a unique {@link Nonce} with each query.\n   * Enabling will prevent queries from being answered with a cached response.\n   * @example\n   * const agent = new HttpAgent({ useQueryNonces: true });\n   * agent.addTransform(makeNonceTransform(makeNonce);\n   * @default false\n   */\n  useQueryNonces?: boolean;\n  /**\n   * Number of times to retry requests before throwing an error\n   * @default 3\n   */\n  retryTimes?: number;\n  /**\n   * The strategy to use for backoff when retrying requests\n   */\n  backoffStrategy?: BackoffStrategyFactory;\n  /**\n   * Whether the agent should verify signatures signed by node keys on query responses. Increases security, but adds overhead and must make a separate request to cache the node keys for the canister's subnet.\n   * @default true\n   */\n  verifyQuerySignatures?: boolean;\n  /**\n   * Whether to log to the console. Defaults to false.\n   */\n  logToConsole?: boolean;\n\n  /**\n   * Alternate root key to use for verifying certificates. If not provided, the default IC root key will be used.\n   */\n  rootKey?: ArrayBuffer;\n}\n\nfunction getDefaultFetch(): typeof fetch {\n  let defaultFetch;\n\n  if (typeof window !== 'undefined') {\n    // Browser context\n    if (window.fetch) {\n      defaultFetch = window.fetch.bind(window);\n    } else {\n      throw new HttpDefaultFetchError(\n        'Fetch implementation was not available. You appear to be in a browser context, but window.fetch was not present.',\n      );\n    }\n  } else if (typeof global !== 'undefined') {\n    // Node context\n    if (global.fetch) {\n      defaultFetch = global.fetch.bind(global);\n    } else {\n      throw new HttpDefaultFetchError(\n        'Fetch implementation was not available. You appear to be in a Node.js context, but global.fetch was not available.',\n      );\n    }\n  } else if (typeof self !== 'undefined') {\n    if (self.fetch) {\n      defaultFetch = self.fetch.bind(self);\n    }\n  }\n\n  if (defaultFetch) {\n    return defaultFetch;\n  }\n  throw new HttpDefaultFetchError(\n    'Fetch implementation was not available. Please provide fetch to the HttpAgent constructor, or ensure it is available in the window or global context.',\n  );\n}\n\nfunction determineHost(configuredHost: string | undefined): string {\n  let host: URL;\n  if (configuredHost !== undefined) {\n    if (!configuredHost.match(/^[a-z]+:/) && typeof window !== 'undefined') {\n      host = new URL(window.location.protocol + '//' + configuredHost);\n    } else {\n      host = new URL(configuredHost);\n    }\n  } else {\n    // Mainnet, local, and remote environments will have the api route available\n    const knownHosts = ['ic0.app', 'icp0.io', '127.0.0.1', 'localhost'];\n    const remoteHosts = ['.github.dev', '.gitpod.io'];\n    const location = typeof window !== 'undefined' ? window.location : undefined;\n    const hostname = location?.hostname;\n    let knownHost;\n    if (hostname && typeof hostname === 'string') {\n      if (remoteHosts.some(host => hostname.endsWith(host))) {\n        knownHost = hostname;\n      } else {\n        knownHost = knownHosts.find(host => hostname.endsWith(host));\n      }\n    }\n\n    if (location && knownHost) {\n      // If the user is on a boundary-node provided host, we can use the same host for the agent\n      host = new URL(\n        `${location.protocol}//${knownHost}${location.port ? ':' + location.port : ''}`,\n      );\n    } else {\n      host = new URL('https://icp-api.io');\n    }\n  }\n  return host.toString();\n}\n\ninterface V1HttpAgentInterface {\n  _identity: Promise<Identity> | null;\n  readonly _fetch: typeof fetch;\n  readonly _fetchOptions?: Record<string, unknown>;\n  readonly _callOptions?: Record<string, unknown>;\n\n  readonly _host: URL;\n  readonly _credentials: string | undefined;\n  readonly _retryTimes: number; // Retry requests N times before erroring by default\n  _isAgent: true;\n}\n\n/** \n * A HTTP agent allows users to interact with a client of the internet computer\nusing the available methods. It exposes an API that closely follows the\npublic view of the internet computer, and is not intended to be exposed\ndirectly to the majority of users due to its low-level interface.\n * There is a pipeline to apply transformations to the request before sending\nit to the client. This is to decouple signature, nonce generation and\nother computations so that this class can stay as simple as possible while\nallowing extensions.\n */\nexport class HttpAgent implements Agent {\n  public rootKey: ArrayBuffer;\n  #identity: Promise<Identity> | null;\n  readonly #fetch: typeof fetch;\n  readonly #fetchOptions?: Record<string, unknown>;\n  readonly #callOptions?: Record<string, unknown>;\n  #timeDiffMsecs = 0;\n  readonly host: URL;\n  readonly #credentials: string | undefined;\n  #rootKeyFetched = false;\n  readonly #retryTimes; // Retry requests N times before erroring by default\n  #backoffStrategy: BackoffStrategyFactory;\n\n  // Public signature to help with type checking.\n  public readonly _isAgent = true;\n  public config: HttpAgentOptions = {};\n\n  // The UTC time in milliseconds when the latest request was made\n  #waterMark = 0;\n\n  get waterMark(): number {\n    return this.#waterMark;\n  }\n\n  public log: ObservableLog = new ObservableLog();\n\n  #queryPipeline: HttpAgentRequestTransformFn[] = [];\n  #updatePipeline: HttpAgentRequestTransformFn[] = [];\n\n  #subnetKeys: ExpirableMap<string, SubnetStatus> = new ExpirableMap({\n    expirationTime: 5 * 60 * 1000, // 5 minutes\n  });\n  #verifyQuerySignatures = true;\n\n  /**\n   * @param options - Options for the HttpAgent\n   * @deprecated Use `HttpAgent.create` or `HttpAgent.createSync` instead\n   */\n  constructor(options: HttpAgentOptions = {}) {\n    this.config = options;\n    this.#fetch = options.fetch || getDefaultFetch() || fetch.bind(global);\n    this.#fetchOptions = options.fetchOptions;\n    this.#callOptions = options.callOptions;\n    this.rootKey = options.rootKey ? options.rootKey : fromHex(IC_ROOT_KEY);\n\n    const host = determineHost(options.host);\n    this.host = new URL(host);\n\n    if (options.verifyQuerySignatures !== undefined) {\n      this.#verifyQuerySignatures = options.verifyQuerySignatures;\n    }\n    // Default is 3\n    this.#retryTimes = options.retryTimes ?? 3;\n    // Delay strategy for retries. Default is exponential backoff\n    const defaultBackoffFactory = () =>\n      new ExponentialBackoff({\n        maxIterations: this.#retryTimes,\n      });\n    this.#backoffStrategy = options.backoffStrategy || defaultBackoffFactory;\n    // Rewrite to avoid redirects\n    if (this.host.hostname.endsWith(IC0_SUB_DOMAIN)) {\n      this.host.hostname = IC0_DOMAIN;\n    } else if (this.host.hostname.endsWith(ICP0_SUB_DOMAIN)) {\n      this.host.hostname = ICP0_DOMAIN;\n    } else if (this.host.hostname.endsWith(ICP_API_SUB_DOMAIN)) {\n      this.host.hostname = ICP_API_DOMAIN;\n    }\n\n    if (options.credentials) {\n      const { name, password } = options.credentials;\n      this.#credentials = `${name}${password ? ':' + password : ''}`;\n    }\n    this.#identity = Promise.resolve(options.identity || new AnonymousIdentity());\n\n    // Add a nonce transform to ensure calls are unique\n    this.addTransform('update', makeNonceTransform(makeNonce));\n    if (options.useQueryNonces) {\n      this.addTransform('query', makeNonceTransform(makeNonce));\n    }\n    if (options.logToConsole) {\n      this.log.subscribe(log => {\n        if (log.level === 'error') {\n          console.error(log.message);\n        } else if (log.level === 'warn') {\n          console.warn(log.message);\n        } else {\n          console.log(log.message);\n        }\n      });\n    }\n  }\n\n  public static createSync(options: HttpAgentOptions = {}): HttpAgent {\n    return new this({ ...options });\n  }\n\n  public static async create(\n    options: HttpAgentOptions & { shouldFetchRootKey?: boolean } = {\n      shouldFetchRootKey: false,\n    },\n  ): Promise<HttpAgent> {\n    const agent = HttpAgent.createSync(options);\n    const initPromises: Promise<ArrayBuffer | void>[] = [agent.syncTime()];\n    if (agent.host.toString() !== 'https://icp-api.io' && options.shouldFetchRootKey) {\n      initPromises.push(agent.fetchRootKey());\n    }\n    await Promise.all(initPromises);\n    return agent;\n  }\n\n  public static async from(\n    agent: Pick<HttpAgent, 'config'> | V1HttpAgentInterface,\n  ): Promise<HttpAgent> {\n    try {\n      if ('config' in agent) {\n        return await HttpAgent.create(agent.config);\n      }\n      return await HttpAgent.create({\n        fetch: agent._fetch,\n        fetchOptions: agent._fetchOptions,\n        callOptions: agent._callOptions,\n        host: agent._host.toString(),\n        identity: agent._identity ?? undefined,\n      });\n    } catch {\n      throw new AgentError('Failed to create agent from provided agent');\n    }\n  }\n\n  public isLocal(): boolean {\n    const hostname = this.host.hostname;\n    return hostname === '127.0.0.1' || hostname.endsWith('127.0.0.1');\n  }\n\n  public addTransform(\n    type: 'update' | 'query',\n    fn: HttpAgentRequestTransformFn,\n    priority = fn.priority || 0,\n  ): void {\n    if (type === 'update') {\n      // Keep the pipeline sorted at all time, by priority.\n      const i = this.#updatePipeline.findIndex(x => (x.priority || 0) < priority);\n      this.#updatePipeline.splice(\n        i >= 0 ? i : this.#updatePipeline.length,\n        0,\n        Object.assign(fn, { priority }),\n      );\n    } else if (type === 'query') {\n      // Keep the pipeline sorted at all time, by priority.\n      const i = this.#queryPipeline.findIndex(x => (x.priority || 0) < priority);\n      this.#queryPipeline.splice(\n        i >= 0 ? i : this.#queryPipeline.length,\n        0,\n        Object.assign(fn, { priority }),\n      );\n    }\n  }\n\n  public async getPrincipal(): Promise<Principal> {\n    if (!this.#identity) {\n      throw new IdentityInvalidError(\n        \"This identity has expired due this application's security policy. Please refresh your authentication.\",\n      );\n    }\n    return (await this.#identity).getPrincipal();\n  }\n\n  public async call(\n    canisterId: Principal | string,\n    options: {\n      methodName: string;\n      arg: ArrayBuffer;\n      effectiveCanisterId?: Principal | string;\n      callSync?: boolean;\n    },\n    identity?: Identity | Promise<Identity>,\n  ): Promise<SubmitResponse> {\n    const callSync = options.callSync ?? true;\n    const id = await (identity !== undefined ? await identity : await this.#identity);\n    if (!id) {\n      throw new IdentityInvalidError(\n        \"This identity has expired due this application's security policy. Please refresh your authentication.\",\n      );\n    }\n    const canister = Principal.from(canisterId);\n    const ecid = options.effectiveCanisterId\n      ? Principal.from(options.effectiveCanisterId)\n      : canister;\n\n    const sender: Principal = id.getPrincipal() || Principal.anonymous();\n\n    let ingress_expiry = new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS);\n\n    // If the value is off by more than 30 seconds, reconcile system time with the network\n    if (Math.abs(this.#timeDiffMsecs) > 1_000 * 30) {\n      ingress_expiry = new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS + this.#timeDiffMsecs);\n    }\n\n    const submit: CallRequest = {\n      request_type: SubmitRequestType.Call,\n      canister_id: canister,\n      method_name: options.methodName,\n      arg: options.arg,\n      sender,\n      ingress_expiry,\n    };\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let transformedRequest: any = (await this._transform({\n      request: {\n        body: null,\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/cbor',\n          ...(this.#credentials ? { Authorization: 'Basic ' + btoa(this.#credentials) } : {}),\n        },\n      },\n      endpoint: Endpoint.Call,\n      body: submit,\n    })) as HttpAgentSubmitRequest;\n\n    const nonce: Nonce | undefined = transformedRequest.body.nonce\n      ? toNonce(transformedRequest.body.nonce)\n      : undefined;\n\n    submit.nonce = nonce;\n\n    function toNonce(buf: ArrayBuffer): Nonce {\n      return new Uint8Array(buf) as Nonce;\n    }\n\n    // Apply transform for identity.\n    transformedRequest = await id.transformRequest(transformedRequest);\n\n    const body = cbor.encode(transformedRequest.body);\n    const backoff = this.#backoffStrategy();\n    try {\n      // Attempt v3 sync call\n      const requestSync = () => {\n        this.log.print(\n          `fetching \"/api/v3/canister/${ecid.toText()}/call\" with request:`,\n          transformedRequest,\n        );\n        return this.#fetch('' + new URL(`/api/v3/canister/${ecid.toText()}/call`, this.host), {\n          ...this.#callOptions,\n          ...transformedRequest.request,\n          body,\n        });\n      };\n\n      const requestAsync = () => {\n        this.log.print(\n          `fetching \"/api/v2/canister/${ecid.toText()}/call\" with request:`,\n          transformedRequest,\n        );\n        return this.#fetch('' + new URL(`/api/v2/canister/${ecid.toText()}/call`, this.host), {\n          ...this.#callOptions,\n          ...transformedRequest.request,\n          body,\n        });\n      };\n\n\n      const request = this.#requestAndRetry({\n        request: callSync ? requestSync : requestAsync,\n        backoff,\n        tries: 0,\n      });\n\n      const [response, requestId] = await Promise.all([request, requestIdOf(submit)]);\n\n      const responseBuffer = await response.arrayBuffer();\n      const responseBody = (\n        response.status === 200 && responseBuffer.byteLength > 0\n          ? cbor.decode(responseBuffer)\n          : null\n      ) as SubmitResponse['response']['body'];\n\n      // Update the watermark with the latest time from consensus\n      if (responseBody?.certificate) {\n        const time = await this.parseTimeFromResponse({ certificate: responseBody.certificate });\n        this.#waterMark = time;\n      }\n\n      return {\n        requestId,\n        response: {\n          ok: response.ok,\n          status: response.status,\n          statusText: response.statusText,\n          body: responseBody,\n          headers: httpHeadersTransform(response.headers),\n        },\n        requestDetails: submit,\n      };\n    } catch (error) {\n      // If the error is due to the v3 api not being supported, fall back to v2\n      if ((error as AgentError).message.includes('v3 api not supported.')) {\n        this.log.warn('v3 api not supported. Fall back to v2');\n        return this.call(\n          canisterId,\n          {\n            ...options,\n            // disable v3 api\n            callSync: false,\n          },\n          identity,\n        );\n      }\n\n      this.log.error('Error while making call:', error as Error);\n      throw error;\n    }\n  }\n\n  async #requestAndRetryQuery(args: {\n    ecid: Principal;\n    transformedRequest: HttpAgentRequest;\n    body: ArrayBuffer;\n    requestId: RequestId;\n    backoff: BackoffStrategy;\n    tries: number;\n  }): Promise<ApiQueryResponse> {\n    const { ecid, transformedRequest, body, requestId, backoff, tries } = args;\n\n    const delay = tries === 0 ? 0 : backoff.next();\n    this.log.print(`fetching \"/api/v2/canister/${ecid.toString()}/query\" with tries:`, {\n      tries,\n      backoff,\n      delay,\n    });\n\n    // If delay is null, the backoff strategy is exhausted due to a maximum number of retries, duration, or other reason\n    if (delay === null) {\n      throw new AgentError(\n        `Timestamp failed to pass the watermark after retrying the configured ${\n          this.#retryTimes\n        } times. We cannot guarantee the integrity of the response since it could be a replay attack.`,\n      );\n    }\n\n    if (delay > 0) {\n      await new Promise(resolve => setTimeout(resolve, delay));\n    }\n    let response: ApiQueryResponse;\n    // Make the request and retry if it throws an error\n    try {\n      this.log.print(\n        `fetching \"/api/v2/canister/${ecid.toString()}/query\" with request:`,\n        transformedRequest,\n      );\n      const fetchResponse = await this.#fetch(\n        '' + new URL(`/api/v2/canister/${ecid.toString()}/query`, this.host),\n        {\n          ...this.#fetchOptions,\n          ...transformedRequest.request,\n          body,\n        },\n      );\n      if (fetchResponse.status === 200) {\n        const queryResponse: QueryResponse = cbor.decode(await fetchResponse.arrayBuffer());\n        response = {\n          ...queryResponse,\n          httpDetails: {\n            ok: fetchResponse.ok,\n            status: fetchResponse.status,\n            statusText: fetchResponse.statusText,\n            headers: httpHeadersTransform(fetchResponse.headers),\n          },\n          requestId,\n        };\n      } else {\n        throw new AgentHTTPResponseError(\n          `Gateway returned an error:\\n` +\n            `  Code: ${fetchResponse.status} (${fetchResponse.statusText})\\n` +\n            `  Body: ${await fetchResponse.text()}\\n`,\n          {\n            ok: fetchResponse.ok,\n            status: fetchResponse.status,\n            statusText: fetchResponse.statusText,\n            headers: httpHeadersTransform(fetchResponse.headers),\n          },\n        );\n      }\n    } catch (error) {\n      if (tries < this.#retryTimes) {\n        this.log.warn(\n          `Caught exception while attempting to make query:\\n` +\n            `  ${error}\\n` +\n            `  Retrying query.`,\n        );\n        return await this.#requestAndRetryQuery({ ...args, tries: tries + 1 });\n      }\n      throw error;\n    }\n\n    const timestamp = response.signatures?.[0]?.timestamp;\n\n    // Skip watermark verification if the user has set verifyQuerySignatures to false\n    if (!this.#verifyQuerySignatures) {\n      return response;\n    }\n\n    if (!timestamp) {\n      throw new Error(\n        'Timestamp not found in query response. This suggests a malformed or malicious response.',\n      );\n    }\n\n    // Convert the timestamp to milliseconds\n    const timeStampInMs = Number(BigInt(timestamp) / BigInt(1_000_000));\n\n    this.log.print('watermark and timestamp', {\n      waterMark: this.waterMark,\n      timestamp: timeStampInMs,\n    });\n\n    // If the timestamp is less than the watermark, retry the request up to the retry limit\n    if (Number(this.waterMark) > timeStampInMs) {\n      const error = new AgentError('Timestamp is below the watermark. Retrying query.');\n      this.log.error('Timestamp is below', error, {\n        timestamp,\n        waterMark: this.waterMark,\n      });\n      if (tries < this.#retryTimes) {\n        return await this.#requestAndRetryQuery({ ...args, tries: tries + 1 });\n      }\n      {\n        throw new AgentError(\n          `Timestamp failed to pass the watermark after retrying the configured ${\n            this.#retryTimes\n          } times. We cannot guarantee the integrity of the response since it could be a replay attack.`,\n        );\n      }\n    }\n\n    return response;\n  }\n\n  async #requestAndRetry(args: {\n    request: () => Promise<Response>;\n    backoff: BackoffStrategy;\n    tries: number;\n  }): Promise<Response> {\n    const { request, backoff, tries } = args;\n    const delay = tries === 0 ? 0 : backoff.next();\n\n    // If delay is null, the backoff strategy is exhausted due to a maximum number of retries, duration, or other reason\n    if (delay === null) {\n      throw new AgentError(\n        `Timestamp failed to pass the watermark after retrying the configured ${\n          this.#retryTimes\n        } times. We cannot guarantee the integrity of the response since it could be a replay attack.`,\n      );\n    }\n\n    if (delay > 0) {\n      await new Promise(resolve => setTimeout(resolve, delay));\n    }\n\n    let response: Response;\n    try {\n      response = await request();\n    } catch (error) {\n      if (this.#retryTimes > tries) {\n        this.log.warn(\n          `Caught exception while attempting to make request:\\n` +\n            `  ${error}\\n` +\n            `  Retrying request.`,\n        );\n        // Delay the request by the configured backoff strategy\n        return await this.#requestAndRetry({ request, backoff, tries: tries + 1 });\n      }\n      throw error;\n    }\n    if (response.ok) {\n      return response;\n    }\n\n    const responseText = await response.clone().text();\n    const errorMessage =\n      `Server returned an error:\\n` +\n      `  Code: ${response.status} (${response.statusText})\\n` +\n      `  Body: ${responseText}\\n`;\n\n    if (response.status === 404 && response.url.includes('api/v3')) {\n      throw new AgentHTTPResponseError('v3 api not supported. Fall back to v2', {\n        ok: response.ok,\n        status: response.status,\n        statusText: response.statusText,\n        headers: httpHeadersTransform(response.headers),\n      });\n    }\n    if (tries < this.#retryTimes) {\n      return await this.#requestAndRetry({ request, backoff, tries: tries + 1 });\n    }\n\n    throw new AgentHTTPResponseError(errorMessage, {\n      ok: response.ok,\n      status: response.status,\n      statusText: response.statusText,\n      headers: httpHeadersTransform(response.headers),\n    });\n  }\n\n  public async query(\n    canisterId: Principal | string,\n    fields: QueryFields,\n    identity?: Identity | Promise<Identity>,\n  ): Promise<ApiQueryResponse> {\n    const backoff = this.#backoffStrategy();\n    const ecid = fields.effectiveCanisterId\n      ? Principal.from(fields.effectiveCanisterId)\n      : Principal.from(canisterId);\n\n    this.log.print(`ecid ${ecid.toString()}`);\n    this.log.print(`canisterId ${canisterId.toString()}`);\n    const makeQuery = async () => {\n      const id = await (identity !== undefined ? await identity : await this.#identity);\n      if (!id) {\n        throw new IdentityInvalidError(\n          \"This identity has expired due this application's security policy. Please refresh your authentication.\",\n        );\n      }\n\n      const canister = Principal.from(canisterId);\n      const sender = id?.getPrincipal() || Principal.anonymous();\n\n      const request: QueryRequest = {\n        request_type: ReadRequestType.Query,\n        canister_id: canister,\n        method_name: fields.methodName,\n        arg: fields.arg,\n        sender,\n        ingress_expiry: new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS),\n      };\n\n      const requestId = await requestIdOf(request);\n\n      // TODO: remove this any. This can be a Signed or UnSigned request.\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      let transformedRequest: HttpAgentRequest = await this._transform({\n        request: {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/cbor',\n            ...(this.#credentials ? { Authorization: 'Basic ' + btoa(this.#credentials) } : {}),\n          },\n        },\n        endpoint: Endpoint.Query,\n        body: request,\n      });\n\n      // Apply transform for identity.\n      transformedRequest = (await id?.transformRequest(transformedRequest)) as HttpAgentRequest;\n\n      const body = cbor.encode(transformedRequest.body);\n\n      const args = {\n        canister: canister.toText(),\n        ecid,\n        transformedRequest,\n        body,\n        requestId,\n        backoff,\n        tries: 0,\n      };\n\n      return {\n        requestDetails: request,\n        query: await this.#requestAndRetryQuery(args),\n      };\n    };\n\n    const getSubnetStatus = async (): Promise<SubnetStatus | void> => {\n      if (!this.#verifyQuerySignatures) {\n        return undefined;\n      }\n      const subnetStatus = this.#subnetKeys.get(ecid.toString());\n      if (subnetStatus) {\n        return subnetStatus;\n      }\n      await this.fetchSubnetKeys(ecid.toString());\n      return this.#subnetKeys.get(ecid.toString());\n    };\n    // Attempt to make the query i=retryTimes times\n    // Make query and fetch subnet keys in parallel\n    const [queryResult, subnetStatus] = await Promise.all([makeQuery(), getSubnetStatus()]);\n    const { requestDetails, query } = queryResult;\n\n    const queryWithDetails = {\n      ...query,\n      requestDetails,\n    };\n\n    this.log.print('Query response:', queryWithDetails);\n    // Skip verification if the user has disabled it\n    if (!this.#verifyQuerySignatures) {\n      return queryWithDetails;\n    }\n\n    try {\n      return this.#verifyQueryResponse(queryWithDetails, subnetStatus);\n    } catch {\n      // In case the node signatures have changed, refresh the subnet keys and try again\n      this.log.warn('Query response verification failed. Retrying with fresh subnet keys.');\n      this.#subnetKeys.delete(canisterId.toString());\n      await this.fetchSubnetKeys(ecid.toString());\n\n      const updatedSubnetStatus = this.#subnetKeys.get(canisterId.toString());\n      if (!updatedSubnetStatus) {\n        throw new CertificateVerificationError(\n          'Invalid signature from replica signed query: no matching node key found.',\n        );\n      }\n      return this.#verifyQueryResponse(queryWithDetails, updatedSubnetStatus);\n    }\n  }\n\n  /**\n   * See https://internetcomputer.org/docs/current/references/ic-interface-spec/#http-query for details on validation\n   * @param queryResponse - The response from the query\n   * @param subnetStatus - The subnet status, including all node keys\n   * @returns ApiQueryResponse\n   */\n  #verifyQueryResponse = (\n    queryResponse: ApiQueryResponse,\n    subnetStatus: SubnetStatus | void,\n  ): ApiQueryResponse => {\n    if (this.#verifyQuerySignatures === false) {\n      // This should not be called if the user has disabled verification\n      return queryResponse;\n    }\n    if (!subnetStatus) {\n      throw new CertificateVerificationError(\n        'Invalid signature from replica signed query: no matching node key found.',\n      );\n    }\n    const { status, signatures = [], requestId } = queryResponse;\n\n    const domainSeparator = new TextEncoder().encode('\\x0Bic-response');\n    for (const sig of signatures) {\n      const { timestamp, identity } = sig;\n      const nodeId = Principal.fromUint8Array(identity).toText();\n      let hash: ArrayBuffer;\n\n      // Hash is constructed differently depending on the status\n      if (status === 'replied') {\n        const { reply } = queryResponse;\n        hash = hashOfMap({\n          status: status,\n          reply: reply,\n          timestamp: BigInt(timestamp),\n          request_id: requestId,\n        });\n      } else if (status === 'rejected') {\n        const { reject_code, reject_message, error_code } = queryResponse;\n        hash = hashOfMap({\n          status: status,\n          reject_code: reject_code,\n          reject_message: reject_message,\n          error_code: error_code,\n          timestamp: BigInt(timestamp),\n          request_id: requestId,\n        });\n      } else {\n        throw new Error(`Unknown status: ${status}`);\n      }\n\n      const separatorWithHash = concat(domainSeparator, new Uint8Array(hash));\n\n      // FIX: check for match without verifying N times\n      const pubKey = subnetStatus?.nodeKeys.get(nodeId);\n      if (!pubKey) {\n        throw new CertificateVerificationError(\n          'Invalid signature from replica signed query: no matching node key found.',\n        );\n      }\n      const rawKey = Ed25519PublicKey.fromDer(pubKey).rawKey;\n      const valid = ed25519.verify(\n        sig.signature,\n        new Uint8Array(separatorWithHash),\n        new Uint8Array(rawKey),\n      );\n      if (valid) return queryResponse;\n\n      throw new CertificateVerificationError(\n        `Invalid signature from replica ${nodeId} signed query.`,\n      );\n    }\n    return queryResponse;\n  };\n\n  public async createReadStateRequest(\n    fields: ReadStateOptions,\n    identity?: Identity | Promise<Identity>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): Promise<any> {\n    const id = await (identity !== undefined ? await identity : await this.#identity);\n    if (!id) {\n      throw new IdentityInvalidError(\n        \"This identity has expired due this application's security policy. Please refresh your authentication.\",\n      );\n    }\n    const sender = id?.getPrincipal() || Principal.anonymous();\n\n    // TODO: remove this any. This can be a Signed or UnSigned request.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const transformedRequest: any = await this._transform({\n      request: {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/cbor',\n          ...(this.#credentials ? { Authorization: 'Basic ' + btoa(this.#credentials) } : {}),\n        },\n      },\n      endpoint: Endpoint.ReadState,\n      body: {\n        request_type: ReadRequestType.ReadState,\n        paths: fields.paths,\n        sender,\n        ingress_expiry: new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS),\n      },\n    });\n\n    // Apply transform for identity.\n    return id?.transformRequest(transformedRequest);\n  }\n\n  public async readState(\n    canisterId: Principal | string,\n    fields: ReadStateOptions,\n    identity?: Identity | Promise<Identity>,\n    // eslint-disable-next-line\n    request?: any,\n  ): Promise<ReadStateResponse> {\n    const canister = typeof canisterId === 'string' ? Principal.fromText(canisterId) : canisterId;\n\n    const transformedRequest = request ?? (await this.createReadStateRequest(fields, identity));\n    const body = cbor.encode(transformedRequest.body);\n\n    this.log.print(\n      `fetching \"/api/v2/canister/${canister}/read_state\" with request:`,\n      transformedRequest,\n    );\n    // TODO - https://dfinity.atlassian.net/browse/SDK-1092\n    const backoff = this.#backoffStrategy();\n    try {\n      const response = await this.#requestAndRetry({\n        request: () =>\n          this.#fetch(\n            '' + new URL(`/api/v2/canister/${canister.toString()}/read_state`, this.host),\n            {\n              ...this.#fetchOptions,\n              ...transformedRequest.request,\n              body,\n            },\n          ),\n        backoff,\n        tries: 0,\n      });\n\n      if (!response.ok) {\n        throw new Error(\n          `Server returned an error:\\n` +\n            `  Code: ${response.status} (${response.statusText})\\n` +\n            `  Body: ${await response.text()}\\n`,\n        );\n      }\n      const decodedResponse: ReadStateResponse = cbor.decode(await response.arrayBuffer());\n\n      this.log.print('Read state response:', decodedResponse);\n      const parsedTime = await this.parseTimeFromResponse(decodedResponse);\n      if (parsedTime > 0) {\n        this.log.print('Read state response time:', parsedTime);\n        this.#waterMark = parsedTime;\n      }\n\n      return decodedResponse;\n    } catch (error) {\n      this.log.error('Caught exception while attempting to read state', error as AgentError);\n      throw error;\n    }\n  }\n\n  public async parseTimeFromResponse(response: { certificate: ArrayBuffer }): Promise<number> {\n    let tree: HashTree;\n    if (response.certificate) {\n      const decoded: { tree: HashTree } | undefined = cbor.decode(response.certificate);\n      if (decoded && 'tree' in decoded) {\n        tree = decoded.tree;\n      } else {\n        throw new Error('Could not decode time from response');\n      }\n      const timeLookup = lookup_path(['time'], tree);\n      if (timeLookup.status !== LookupStatus.Found) {\n        throw new Error('Time was not found in the response or was not in its expected format.');\n      }\n\n      if (!(timeLookup.value instanceof ArrayBuffer) && !ArrayBuffer.isView(timeLookup)) {\n        throw new Error('Time was not found in the response or was not in its expected format.');\n      }\n      const date = decodeTime(bufFromBufLike(timeLookup.value as ArrayBuffer));\n      this.log.print('Time from response:', date);\n      this.log.print('Time from response in milliseconds:', Number(date));\n      return Number(date);\n    } else {\n      this.log.warn('No certificate found in response');\n    }\n    return 0;\n  }\n\n  /**\n   * Allows agent to sync its time with the network. Can be called during intialization or mid-lifecycle if the device's clock has drifted away from the network time. This is necessary to set the Expiry for a request\n   * @param {Principal} canisterId - Pass a canister ID if you need to sync the time with a particular replica. Uses the management canister by default\n   */\n  public async syncTime(canisterId?: Principal): Promise<void> {\n    const CanisterStatus = await import('../../canisterStatus');\n    const callTime = Date.now();\n    try {\n      if (!canisterId) {\n        this.log.print(\n          'Syncing time with the IC. No canisterId provided, so falling back to ryjl3-tyaaa-aaaaa-aaaba-cai',\n        );\n      }\n      const status = await CanisterStatus.request({\n        // Fall back with canisterId of the ICP Ledger\n        canisterId: canisterId ?? Principal.from('ryjl3-tyaaa-aaaaa-aaaba-cai'),\n        agent: this,\n        paths: ['time'],\n      });\n\n      const replicaTime = status.get('time');\n      if (replicaTime) {\n        this.#timeDiffMsecs = Number(replicaTime as bigint) - Number(callTime);\n      }\n    } catch (error) {\n      this.log.error('Caught exception while attempting to sync time', error as AgentError);\n    }\n  }\n\n  public async status(): Promise<JsonObject> {\n    const headers: Record<string, string> = this.#credentials\n      ? {\n          Authorization: 'Basic ' + btoa(this.#credentials),\n        }\n      : {};\n\n    this.log.print(`fetching \"/api/v2/status\"`);\n    const backoff = this.#backoffStrategy();\n    const response = await this.#requestAndRetry({\n      backoff,\n      request: () =>\n        this.#fetch('' + new URL(`/api/v2/status`, this.host), { headers, ...this.#fetchOptions }),\n      tries: 0,\n    });\n    return cbor.decode(await response.arrayBuffer());\n  }\n\n  public async fetchRootKey(): Promise<ArrayBuffer> {\n    if (!this.#rootKeyFetched) {\n      const status = await this.status();\n      // Hex-encoded version of the replica root key\n      this.rootKey = (status as JsonObject & { root_key: ArrayBuffer }).root_key;\n      this.#rootKeyFetched = true;\n    }\n    return this.rootKey;\n  }\n\n  public invalidateIdentity(): void {\n    this.#identity = null;\n  }\n\n  public replaceIdentity(identity: Identity): void {\n    this.#identity = Promise.resolve(identity);\n  }\n\n  public async fetchSubnetKeys(canisterId: Principal | string) {\n    const effectiveCanisterId: Principal = Principal.from(canisterId);\n    const response = await request({\n      canisterId: effectiveCanisterId,\n      paths: ['subnet'],\n      agent: this,\n    });\n\n    const subnetResponse = response.get('subnet');\n    if (subnetResponse && typeof subnetResponse === 'object' && 'nodeKeys' in subnetResponse) {\n      this.#subnetKeys.set(effectiveCanisterId.toText(), subnetResponse as SubnetStatus);\n      return subnetResponse as SubnetStatus;\n    }\n    // If the subnet status is not returned, return undefined\n    return undefined;\n  }\n\n  protected _transform(request: HttpAgentRequest): Promise<HttpAgentRequest> {\n    let p = Promise.resolve(request);\n    if (request.endpoint === Endpoint.Call) {\n      for (const fn of this.#updatePipeline) {\n        p = p.then(r => fn(r).then(r2 => r2 || r));\n      }\n    } else {\n      for (const fn of this.#queryPipeline) {\n        p = p.then(r => fn(r).then(r2 => r2 || r));\n      }\n    }\n\n    return p;\n  }\n}\n\n"],"mappings":";;;;;;;;;;;;AACA,SAASA,SAAS,QAAQ,oBAAoB;AAC9C,SAASC,UAAU,QAAQ,cAAc;AACzC,SAASC,iBAAiB,QAAkB,YAAY;AACxD,OAAO,KAAKC,IAAI,MAAM,YAAY;AAClC,SAAoBC,SAAS,EAAEC,WAAW,QAAQ,kBAAkB;AACpE,SAASC,cAAc,EAAEC,MAAM,EAAEC,OAAO,QAAQ,oBAAoB;AAUpE,SAASC,MAAM,EAAEC,oBAAoB,EAAEC,kBAAkB,QAAQ,cAAc;AAC/E,SAMEC,SAAS,EAITC,iBAAiB,QACZ,SAAS;AAChB,SAASC,sBAAsB,QAAQ,UAAU;AACjD,SAAuBC,OAAO,QAAQ,sBAAsB;AAC5D,SACEC,4BAA4B,EAE5BC,YAAY,EACZC,WAAW,QACN,mBAAmB;AAC1B,SAASC,OAAO,QAAQ,uBAAuB;AAC/C,SAASC,YAAY,QAAQ,0BAA0B;AACvD,SAASC,gBAAgB,QAAQ,kBAAkB;AACnD,SAASC,UAAU,QAAQ,iBAAiB;AAC5C,SAASC,aAAa,QAAQ,kBAAkB;AAChD,SAAkDC,kBAAkB,QAAQ,uBAAuB;AACnG,cAAc,cAAc;AAC5B,SAAgBZ,SAAS,QAAQ,SAAS;AAE1C,WAAYa,2BAOX;AAPD,WAAYA,2BAA2B;EACrCA,2BAAA,yBAAqB;EACrBA,2BAAA,6BAAyB;EACzBA,2BAAA,uBAAmB;EACnBA,2BAAA,yBAAqB;EACrBA,2BAAA,uBAAmB;EACnBA,2BAAA,iBAAa;AACf,CAAC,EAPWA,2BAA2B,KAA3BA,2BAA2B;AASvC;AACA,MAAMC,qCAAqC,GAAG,CAAC,GAAG,EAAE,GAAG,IAAI;AAE3D;AACA,OAAO,MAAMC,WAAW,GACtB,+EAA+E,GAC/E,+EAA+E,GAC/E,8EAA8E,GAC9E,sCAAsC;AAExC,OAAO,MAAMC,sBAAsB,GAAG,UAAU;AAEhD;AACA,MAAMC,UAAU,GAAG,SAAS;AAC5B,MAAMC,cAAc,GAAG,UAAU;AAEjC,MAAMC,WAAW,GAAG,SAAS;AAC7B,MAAMC,eAAe,GAAG,UAAU;AAElC,MAAMC,cAAc,GAAG,YAAY;AACnC,MAAMC,kBAAkB,GAAG,aAAa;AAExC,MAAMC,qBAAsB,SAAQlC,UAAU;EAC5CmC,YAA4BC,OAAe;IACzC,KAAK,CAACA,OAAO,CAAC;IADY,KAAAA,OAAO,GAAPA,OAAO;EAEnC;;AAEF,OAAM,MAAOC,oBAAqB,SAAQrC,UAAU;EAClDmC,YAA4BC,OAAe;IACzC,KAAK,CAACA,OAAO,CAAC;IADY,KAAAA,OAAO,GAAPA,OAAO;EAEnC;;AA8DF,SAASE,eAAeA,CAAA;EACtB,IAAIC,YAAY;EAEhB,IAAI,OAAOC,MAAM,KAAK,WAAW,EAAE;IACjC;IACA,IAAIA,MAAM,CAACC,KAAK,EAAE;MAChBF,YAAY,GAAGC,MAAM,CAACC,KAAK,CAACC,IAAI,CAACF,MAAM,CAAC;KACzC,MAAM;MACL,MAAM,IAAIN,qBAAqB,CAC7B,kHAAkH,CACnH;;GAEJ,MAAM,IAAI,OAAOS,MAAM,KAAK,WAAW,EAAE;IACxC;IACA,IAAIA,MAAM,CAACF,KAAK,EAAE;MAChBF,YAAY,GAAGI,MAAM,CAACF,KAAK,CAACC,IAAI,CAACC,MAAM,CAAC;KACzC,MAAM;MACL,MAAM,IAAIT,qBAAqB,CAC7B,oHAAoH,CACrH;;GAEJ,MAAM,IAAI,OAAOU,IAAI,KAAK,WAAW,EAAE;IACtC,IAAIA,IAAI,CAACH,KAAK,EAAE;MACdF,YAAY,GAAGK,IAAI,CAACH,KAAK,CAACC,IAAI,CAACE,IAAI,CAAC;;;EAIxC,IAAIL,YAAY,EAAE;IAChB,OAAOA,YAAY;;EAErB,MAAM,IAAIL,qBAAqB,CAC7B,uJAAuJ,CACxJ;AACH;AAEA,SAASW,aAAaA,CAACC,cAAkC;EACvD,IAAIC,IAAS;EACb,IAAID,cAAc,KAAKE,SAAS,EAAE;IAChC,IAAI,CAACF,cAAc,CAACG,KAAK,CAAC,UAAU,CAAC,IAAI,OAAOT,MAAM,KAAK,WAAW,EAAE;MACtEO,IAAI,GAAG,IAAIG,GAAG,CAACV,MAAM,CAACW,QAAQ,CAACC,QAAQ,GAAG,IAAI,GAAGN,cAAc,CAAC;KACjE,MAAM;MACLC,IAAI,GAAG,IAAIG,GAAG,CAACJ,cAAc,CAAC;;GAEjC,MAAM;IACL;IACA,MAAMO,UAAU,GAAG,CAAC,SAAS,EAAE,SAAS,EAAE,WAAW,EAAE,WAAW,CAAC;IACnE,MAAMC,WAAW,GAAG,CAAC,aAAa,EAAE,YAAY,CAAC;IACjD,MAAMH,QAAQ,GAAG,OAAOX,MAAM,KAAK,WAAW,GAAGA,MAAM,CAACW,QAAQ,GAAGH,SAAS;IAC5E,MAAMO,QAAQ,GAAGJ,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAEI,QAAQ;IACnC,IAAIC,SAAS;IACb,IAAID,QAAQ,IAAI,OAAOA,QAAQ,KAAK,QAAQ,EAAE;MAC5C,IAAID,WAAW,CAACG,IAAI,CAACV,IAAI,IAAIQ,QAAQ,CAACG,QAAQ,CAACX,IAAI,CAAC,CAAC,EAAE;QACrDS,SAAS,GAAGD,QAAQ;OACrB,MAAM;QACLC,SAAS,GAAGH,UAAU,CAACM,IAAI,CAACZ,IAAI,IAAIQ,QAAQ,CAACG,QAAQ,CAACX,IAAI,CAAC,CAAC;;;IAIhE,IAAII,QAAQ,IAAIK,SAAS,EAAE;MACzB;MACAT,IAAI,GAAG,IAAIG,GAAG,CACZ,GAAGC,QAAQ,CAACC,QAAQ,KAAKI,SAAS,GAAGL,QAAQ,CAACS,IAAI,GAAG,GAAG,GAAGT,QAAQ,CAACS,IAAI,GAAG,EAAE,EAAE,CAChF;KACF,MAAM;MACLb,IAAI,GAAG,IAAIG,GAAG,CAAC,oBAAoB,CAAC;;;EAGxC,OAAOH,IAAI,CAACc,QAAQ,EAAE;AACxB;AAcA;;;;;;;;;;AAUA,OAAM,MAAOC,SAAS;EAkCpB;;;;EAIA3B,YAAA,EAA0C;IAAA,IAA9B4B,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAhB,SAAA,GAAAgB,SAAA,MAA4B,EAAE;;;IApC1CE,mBAAA,CAAAC,GAAA;IACAC,gBAAA,CAAAD,GAAA;IACAE,uBAAA,CAAAF,GAAA;IACAG,sBAAA,CAAAH,GAAA;IACAI,wBAAA,CAAAJ,GAAA,OAAiB,CAAC;IAElBK,sBAAA,CAAAL,GAAA;IACAM,yBAAA,CAAAN,GAAA,OAAkB,KAAK;IACvBO,qBAAA,CAAAP,GAAA,eAAqB,CAAC;IACtBQ,0BAAA,CAAAR,GAAA;IAEA;IACgB,KAAAS,QAAQ,GAAG,IAAI;IACxB,KAAAC,MAAM,GAAqB,EAAE;IAEpC;IACAC,oBAAA,CAAAX,GAAA,OAAa,CAAC;IAMP,KAAAY,GAAG,GAAkB,IAAIzD,aAAa,EAAE;IAE/C0D,wBAAA,CAAAb,GAAA,OAAgD,EAAE;IAClDc,yBAAA,CAAAd,GAAA,OAAiD,EAAE;IAEnDe,qBAAA,CAAAf,GAAA,OAAkD,IAAIhD,YAAY,CAAC;MACjEgE,cAAc,EAAE,CAAC,GAAG,EAAE,GAAG,IAAI,CAAE;KAChC,CAAC;IACFC,gCAAA,CAAAjB,GAAA,OAAyB,IAAI;IA2kB7B;;;;;;IAMAkB,8BAAA,CAAAlB,GAAA,OAAuB,CACrBmB,aAA+B,EAC/BC,YAAiC,KACb;MACpB,IAAIC,sBAAA,KAAI,EAAAJ,gCAAA,MAAuB,KAAK,KAAK,EAAE;QACzC;QACA,OAAOE,aAAa;;MAEtB,IAAI,CAACC,YAAY,EAAE;QACjB,MAAM,IAAIxE,4BAA4B,CACpC,0EAA0E,CAC3E;;MAEH,MAAM;QAAE0E,MAAM;QAAEC,UAAU,GAAG,EAAE;QAAEC;MAAS,CAAE,GAAGL,aAAa;MAE5D,MAAMM,eAAe,GAAG,IAAIC,WAAW,EAAE,CAACC,MAAM,CAAC,iBAAiB,CAAC;MACnE,KAAK,MAAMC,GAAG,IAAIL,UAAU,EAAE;QAC5B,MAAM;UAAEM,SAAS;UAAEC;QAAQ,CAAE,GAAGF,GAAG;QACnC,MAAMG,MAAM,GAAGnG,SAAS,CAACoG,cAAc,CAACF,QAAQ,CAAC,CAACG,MAAM,EAAE;QAC1D,IAAIC,IAAiB;QAErB;QACA,IAAIZ,MAAM,KAAK,SAAS,EAAE;UACxB,MAAM;YAAEa;UAAK,CAAE,GAAGhB,aAAa;UAC/Be,IAAI,GAAGlG,SAAS,CAAC;YACfsF,MAAM,EAAEA,MAAM;YACda,KAAK,EAAEA,KAAK;YACZN,SAAS,EAAEO,MAAM,CAACP,SAAS,CAAC;YAC5BQ,UAAU,EAAEb;WACb,CAAC;SACH,MAAM,IAAIF,MAAM,KAAK,UAAU,EAAE;UAChC,MAAM;YAAEgB,WAAW;YAAEC,cAAc;YAAEC;UAAU,CAAE,GAAGrB,aAAa;UACjEe,IAAI,GAAGlG,SAAS,CAAC;YACfsF,MAAM,EAAEA,MAAM;YACdgB,WAAW,EAAEA,WAAW;YACxBC,cAAc,EAAEA,cAAc;YAC9BC,UAAU,EAAEA,UAAU;YACtBX,SAAS,EAAEO,MAAM,CAACP,SAAS,CAAC;YAC5BQ,UAAU,EAAEb;WACb,CAAC;SACH,MAAM;UACL,MAAM,IAAIiB,KAAK,CAAC,mBAAmBnB,MAAM,EAAE,CAAC;;QAG9C,MAAMoB,iBAAiB,GAAGvG,MAAM,CAACsF,eAAe,EAAE,IAAIkB,UAAU,CAACT,IAAI,CAAC,CAAC;QAEvE;QACA,MAAMU,MAAM,GAAGxB,YAAY,aAAZA,YAAY,uBAAZA,YAAY,CAAEyB,QAAQ,CAACC,GAAG,CAACf,MAAM,CAAC;QACjD,IAAI,CAACa,MAAM,EAAE;UACX,MAAM,IAAIhG,4BAA4B,CACpC,0EAA0E,CAC3E;;QAEH,MAAMmG,MAAM,GAAG9F,gBAAgB,CAAC+F,OAAO,CAACJ,MAAM,CAAC,CAACG,MAAM;QACtD,MAAME,KAAK,GAAGlG,OAAO,CAACmG,MAAM,CAC1BtB,GAAG,CAACuB,SAAS,EACb,IAAIR,UAAU,CAACD,iBAAiB,CAAC,EACjC,IAAIC,UAAU,CAACI,MAAM,CAAC,CACvB;QACD,IAAIE,KAAK,EAAE,OAAO9B,aAAa;QAE/B,MAAM,IAAIvE,4BAA4B,CACpC,kCAAkCmF,MAAM,gBAAgB,CACzD;;MAEH,OAAOZ,aAAa;IACtB,CAAC;IA5oBC,IAAI,CAACT,MAAM,GAAGd,OAAO;IACrBwD,sBAAA,KAAI,EAAAnD,gBAAA,EAAUL,OAAO,CAACtB,KAAK,IAAIH,eAAe,EAAE,IAAIG,KAAK,CAACC,IAAI,CAACC,MAAM,CAAC;IACtE4E,sBAAA,KAAI,EAAAlD,uBAAA,EAAiBN,OAAO,CAACyD,YAAY;IACzCD,sBAAA,KAAI,EAAAjD,sBAAA,EAAgBP,OAAO,CAAC0D,WAAW;IACvC,IAAI,CAACC,OAAO,GAAG3D,OAAO,CAAC2D,OAAO,GAAG3D,OAAO,CAAC2D,OAAO,GAAGnH,OAAO,CAACmB,WAAW,CAAC;IAEvE,MAAMqB,IAAI,GAAGF,aAAa,CAACkB,OAAO,CAAChB,IAAI,CAAC;IACxC,IAAI,CAACA,IAAI,GAAG,IAAIG,GAAG,CAACH,IAAI,CAAC;IAEzB,IAAIgB,OAAO,CAAC4D,qBAAqB,KAAK3E,SAAS,EAAE;MAC/CuE,sBAAA,KAAI,EAAAnC,gCAAA,EAA0BrB,OAAO,CAAC4D,qBAAqB;;IAE7D;IACAJ,sBAAA,KAAI,EAAA7C,qBAAA,EAAe,CAAAkD,EAAA,GAAA7D,OAAO,CAAC8D,UAAU,cAAAD,EAAA,cAAAA,EAAA,GAAI,CAAC;IAC1C;IACA,MAAME,qBAAqB,GAAGA,CAAA,KAC5B,IAAIvG,kBAAkB,CAAC;MACrBwG,aAAa,EAAEvC,sBAAA,KAAI,EAAAd,qBAAA;KACpB,CAAC;IACJ6C,sBAAA,KAAI,EAAA5C,0BAAA,EAAoBZ,OAAO,CAACiE,eAAe,IAAIF,qBAAqB;IACxE;IACA,IAAI,IAAI,CAAC/E,IAAI,CAACQ,QAAQ,CAACG,QAAQ,CAAC7B,cAAc,CAAC,EAAE;MAC/C,IAAI,CAACkB,IAAI,CAACQ,QAAQ,GAAG3B,UAAU;KAChC,MAAM,IAAI,IAAI,CAACmB,IAAI,CAACQ,QAAQ,CAACG,QAAQ,CAAC3B,eAAe,CAAC,EAAE;MACvD,IAAI,CAACgB,IAAI,CAACQ,QAAQ,GAAGzB,WAAW;KACjC,MAAM,IAAI,IAAI,CAACiB,IAAI,CAACQ,QAAQ,CAACG,QAAQ,CAACzB,kBAAkB,CAAC,EAAE;MAC1D,IAAI,CAACc,IAAI,CAACQ,QAAQ,GAAGvB,cAAc;;IAGrC,IAAI+B,OAAO,CAACkE,WAAW,EAAE;MACvB,MAAM;QAAEC,IAAI;QAAEC;MAAQ,CAAE,GAAGpE,OAAO,CAACkE,WAAW;MAC9CV,sBAAA,KAAI,EAAA/C,sBAAA,EAAgB,GAAG0D,IAAI,GAAGC,QAAQ,GAAG,GAAG,GAAGA,QAAQ,GAAG,EAAE,EAAE;;IAEhEZ,sBAAA,KAAI,EAAArD,mBAAA,EAAakE,OAAO,CAACC,OAAO,CAACtE,OAAO,CAACkC,QAAQ,IAAI,IAAIhG,iBAAiB,EAAE,CAAC;IAE7E;IACA,IAAI,CAACqI,YAAY,CAAC,QAAQ,EAAE5H,kBAAkB,CAACC,SAAS,CAAC,CAAC;IAC1D,IAAIoD,OAAO,CAACwE,cAAc,EAAE;MAC1B,IAAI,CAACD,YAAY,CAAC,OAAO,EAAE5H,kBAAkB,CAACC,SAAS,CAAC,CAAC;;IAE3D,IAAIoD,OAAO,CAACyE,YAAY,EAAE;MACxB,IAAI,CAACzD,GAAG,CAAC0D,SAAS,CAAC1D,GAAG,IAAG;QACvB,IAAIA,GAAG,CAAC2D,KAAK,KAAK,OAAO,EAAE;UACzBC,OAAO,CAACC,KAAK,CAAC7D,GAAG,CAAC3C,OAAO,CAAC;SAC3B,MAAM,IAAI2C,GAAG,CAAC2D,KAAK,KAAK,MAAM,EAAE;UAC/BC,OAAO,CAACE,IAAI,CAAC9D,GAAG,CAAC3C,OAAO,CAAC;SAC1B,MAAM;UACLuG,OAAO,CAAC5D,GAAG,CAACA,GAAG,CAAC3C,OAAO,CAAC;;MAE5B,CAAC,CAAC;;EAEN;EAtEA,IAAI0G,SAASA,CAAA;IACX,OAAOtD,sBAAA,KAAI,EAAAV,oBAAA,MAAW;EACxB;EAsEO,OAAOiE,UAAUA,CAAA,EAA+B;IAAA,IAA9BhF,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAhB,SAAA,GAAAgB,SAAA,MAA4B,EAAE;IACrD,OAAO,IAAI,IAAI,CAAAgF,MAAA,CAAAC,MAAA,KAAMlF,OAAO,EAAG;EACjC;EAEO,aAAamF,MAAMA,CAAA,EAGvB;IAAA,IAFDnF,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAhB,SAAA,GAAAgB,SAAA,MAA+D;MAC7DmF,kBAAkB,EAAE;KACrB;IAED,MAAMC,KAAK,GAAGtF,SAAS,CAACiF,UAAU,CAAChF,OAAO,CAAC;IAC3C,MAAMsF,YAAY,GAAkC,CAACD,KAAK,CAACE,QAAQ,EAAE,CAAC;IACtE,IAAIF,KAAK,CAACrG,IAAI,CAACc,QAAQ,EAAE,KAAK,oBAAoB,IAAIE,OAAO,CAACoF,kBAAkB,EAAE;MAChFE,YAAY,CAACE,IAAI,CAACH,KAAK,CAACI,YAAY,EAAE,CAAC;;IAEzC,MAAMpB,OAAO,CAACqB,GAAG,CAACJ,YAAY,CAAC;IAC/B,OAAOD,KAAK;EACd;EAEO,aAAaM,IAAIA,CACtBN,KAAuD;;IAEvD,IAAI;MACF,IAAI,QAAQ,IAAIA,KAAK,EAAE;QACrB,OAAO,MAAMtF,SAAS,CAACoF,MAAM,CAACE,KAAK,CAACvE,MAAM,CAAC;;MAE7C,OAAO,MAAMf,SAAS,CAACoF,MAAM,CAAC;QAC5BzG,KAAK,EAAE2G,KAAK,CAACO,MAAM;QACnBnC,YAAY,EAAE4B,KAAK,CAACQ,aAAa;QACjCnC,WAAW,EAAE2B,KAAK,CAACS,YAAY;QAC/B9G,IAAI,EAAEqG,KAAK,CAACU,KAAK,CAACjG,QAAQ,EAAE;QAC5BoC,QAAQ,EAAE,CAAA2B,EAAA,GAAAwB,KAAK,CAACW,SAAS,cAAAnC,EAAA,cAAAA,EAAA,GAAI5E;OAC9B,CAAC;KACH,CAAC,OAAAgH,EAAA,EAAM;MACN,MAAM,IAAIhK,UAAU,CAAC,4CAA4C,CAAC;;EAEtE;EAEOiK,OAAOA,CAAA;IACZ,MAAM1G,QAAQ,GAAG,IAAI,CAACR,IAAI,CAACQ,QAAQ;IACnC,OAAOA,QAAQ,KAAK,WAAW,IAAIA,QAAQ,CAACG,QAAQ,CAAC,WAAW,CAAC;EACnE;EAEO4E,YAAYA,CACjB4B,IAAwB,EACxBC,EAA+B,EACJ;IAAA,IAA3BC,QAAQ,GAAApG,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAhB,SAAA,GAAAgB,SAAA,MAAGmG,EAAE,CAACC,QAAQ,IAAI,CAAC;IAE3B,IAAIF,IAAI,KAAK,QAAQ,EAAE;MACrB;MACA,MAAMG,CAAC,GAAG7E,sBAAA,KAAI,EAAAP,yBAAA,MAAgB,CAACqF,SAAS,CAACC,CAAC,IAAI,CAACA,CAAC,CAACH,QAAQ,IAAI,CAAC,IAAIA,QAAQ,CAAC;MAC3E5E,sBAAA,KAAI,EAAAP,yBAAA,MAAgB,CAACuF,MAAM,CACzBH,CAAC,IAAI,CAAC,GAAGA,CAAC,GAAG7E,sBAAA,KAAI,EAAAP,yBAAA,MAAgB,CAAChB,MAAM,EACxC,CAAC,EACD+E,MAAM,CAACC,MAAM,CAACkB,EAAE,EAAE;QAAEC;MAAQ,CAAE,CAAC,CAChC;KACF,MAAM,IAAIF,IAAI,KAAK,OAAO,EAAE;MAC3B;MACA,MAAMG,CAAC,GAAG7E,sBAAA,KAAI,EAAAR,wBAAA,MAAe,CAACsF,SAAS,CAACC,CAAC,IAAI,CAACA,CAAC,CAACH,QAAQ,IAAI,CAAC,IAAIA,QAAQ,CAAC;MAC1E5E,sBAAA,KAAI,EAAAR,wBAAA,MAAe,CAACwF,MAAM,CACxBH,CAAC,IAAI,CAAC,GAAGA,CAAC,GAAG7E,sBAAA,KAAI,EAAAR,wBAAA,MAAe,CAACf,MAAM,EACvC,CAAC,EACD+E,MAAM,CAACC,MAAM,CAACkB,EAAE,EAAE;QAAEC;MAAQ,CAAE,CAAC,CAChC;;EAEL;EAEO,MAAMK,YAAYA,CAAA;IACvB,IAAI,CAACjF,sBAAA,KAAI,EAAAtB,mBAAA,MAAU,EAAE;MACnB,MAAM,IAAI7B,oBAAoB,CAC5B,uGAAuG,CACxG;;IAEH,OAAO,CAAC,MAAMmD,sBAAA,KAAI,EAAAtB,mBAAA,MAAU,EAAEuG,YAAY,EAAE;EAC9C;EAEO,MAAMC,IAAIA,CACfC,UAA8B,EAC9B5G,OAKC,EACDkC,QAAuC;;IAEvC,MAAM2E,QAAQ,GAAG,CAAAhD,EAAA,GAAA7D,OAAO,CAAC6G,QAAQ,cAAAhD,EAAA,cAAAA,EAAA,GAAI,IAAI;IACzC,MAAMiD,EAAE,GAAG,OAAO5E,QAAQ,KAAKjD,SAAS,GAAG,MAAMiD,QAAQ,GAAG,MAAMT,sBAAA,KAAI,EAAAtB,mBAAA,MAAU,CAAC;IACjF,IAAI,CAAC2G,EAAE,EAAE;MACP,MAAM,IAAIxI,oBAAoB,CAC5B,uGAAuG,CACxG;;IAEH,MAAMyI,QAAQ,GAAG/K,SAAS,CAAC2J,IAAI,CAACiB,UAAU,CAAC;IAC3C,MAAMI,IAAI,GAAGhH,OAAO,CAACiH,mBAAmB,GACpCjL,SAAS,CAAC2J,IAAI,CAAC3F,OAAO,CAACiH,mBAAmB,CAAC,GAC3CF,QAAQ;IAEZ,MAAMG,MAAM,GAAcJ,EAAE,CAACJ,YAAY,EAAE,IAAI1K,SAAS,CAACmL,SAAS,EAAE;IAEpE,IAAIC,cAAc,GAAG,IAAI3K,MAAM,CAACiB,qCAAqC,CAAC;IAEtE;IACA,IAAI2J,IAAI,CAACC,GAAG,CAAC7F,sBAAA,KAAI,EAAAjB,wBAAA,MAAe,CAAC,GAAG,IAAK,GAAG,EAAE,EAAE;MAC9C4G,cAAc,GAAG,IAAI3K,MAAM,CAACiB,qCAAqC,GAAG+D,sBAAA,KAAI,EAAAjB,wBAAA,MAAe,CAAC;;IAG1F,MAAM+G,MAAM,GAAgB;MAC1BC,YAAY,EAAE3K,iBAAiB,CAAC4K,IAAI;MACpCC,WAAW,EAAEX,QAAQ;MACrBY,WAAW,EAAE3H,OAAO,CAAC4H,UAAU;MAC/BC,GAAG,EAAE7H,OAAO,CAAC6H,GAAG;MAChBX,MAAM;MACNE;KACD;IAED;IACA,IAAIU,kBAAkB,GAAS,MAAM,IAAI,CAACC,UAAU,CAAC;MACnDhL,OAAO,EAAE;QACPiL,IAAI,EAAE,IAAI;QACVC,MAAM,EAAE,MAAM;QACdC,OAAO,EAAAjD,MAAA,CAAAC,MAAA;UACL,cAAc,EAAE;QAAkB,GAC9BzD,sBAAA,KAAI,EAAAhB,sBAAA,MAAa,GAAG;UAAE0H,aAAa,EAAE,QAAQ,GAAGC,IAAI,CAAC3G,sBAAA,KAAI,EAAAhB,sBAAA,MAAa;QAAC,CAAE,GAAG,EAAG;OAEtF;MACD4H,QAAQ;MACRL,IAAI,EAAET;KACP,CAA4B;IAE7B,MAAMe,KAAK,GAAsBR,kBAAkB,CAACE,IAAI,CAACM,KAAK,GAC1DC,OAAO,CAACT,kBAAkB,CAACE,IAAI,CAACM,KAAK,CAAC,GACtCrJ,SAAS;IAEbsI,MAAM,CAACe,KAAK,GAAGA,KAAK;IAEpB,SAASC,OAAOA,CAACC,GAAgB;MAC/B,OAAO,IAAIzF,UAAU,CAACyF,GAAG,CAAU;IACrC;IAEA;IACAV,kBAAkB,GAAG,MAAMhB,EAAE,CAAC2B,gBAAgB,CAACX,kBAAkB,CAAC;IAElE,MAAME,IAAI,GAAG7L,IAAI,CAAC4F,MAAM,CAAC+F,kBAAkB,CAACE,IAAI,CAAC;IACjD,MAAMU,OAAO,GAAGjH,sBAAA,KAAI,EAAAb,0BAAA,MAAiB,CAAA+F,IAAA,CAArB,IAAI,CAAmB;IACvC,IAAI;MACF;MACA,MAAMgC,WAAW,GAAGA,CAAA,KAAK;QACvB,IAAI,CAAC3H,GAAG,CAAC4H,KAAK,CACZ,8BAA8B5B,IAAI,CAAC3E,MAAM,EAAE,sBAAsB,EACjEyF,kBAAkB,CACnB;QACD,OAAOrG,sBAAA,KAAI,EAAApB,gBAAA,MAAO,CAAAsG,IAAA,CAAX,IAAI,EAAQ,EAAE,GAAG,IAAIxH,GAAG,CAAC,oBAAoB6H,IAAI,CAAC3E,MAAM,EAAE,OAAO,EAAE,IAAI,CAACrD,IAAI,CAAC,EAAAiG,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAC/EzD,sBAAA,KAAI,EAAAlB,sBAAA,MAAa,GACjBuH,kBAAkB,CAAC/K,OAAO;UAC7BiL;QAAI,GACJ;MACJ,CAAC;MAED,MAAMa,YAAY,GAAGA,CAAA,KAAK;QACxB,IAAI,CAAC7H,GAAG,CAAC4H,KAAK,CACZ,8BAA8B5B,IAAI,CAAC3E,MAAM,EAAE,sBAAsB,EACjEyF,kBAAkB,CACnB;QACD,OAAOrG,sBAAA,KAAI,EAAApB,gBAAA,MAAO,CAAAsG,IAAA,CAAX,IAAI,EAAQ,EAAE,GAAG,IAAIxH,GAAG,CAAC,oBAAoB6H,IAAI,CAAC3E,MAAM,EAAE,OAAO,EAAE,IAAI,CAACrD,IAAI,CAAC,EAAAiG,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAC/EzD,sBAAA,KAAI,EAAAlB,sBAAA,MAAa,GACjBuH,kBAAkB,CAAC/K,OAAO;UAC7BiL;QAAI,GACJ;MACJ,CAAC;MAGD,MAAMjL,OAAO,GAAG0E,sBAAA,KAAI,EAAAqH,oBAAA,OAAAC,0BAAA,CAAiB,CAAApC,IAAA,CAArB,IAAI,EAAkB;QACpC5J,OAAO,EAAE8J,QAAQ,GAAG8B,WAAW,GAAGE,YAAY;QAC9CH,OAAO;QACPM,KAAK,EAAE;OACR,CAAC;MAEF,MAAM,CAACC,QAAQ,EAAErH,SAAS,CAAC,GAAG,MAAMyC,OAAO,CAACqB,GAAG,CAAC,CAAC3I,OAAO,EAAEV,WAAW,CAACkL,MAAM,CAAC,CAAC,CAAC;MAE/E,MAAM2B,cAAc,GAAG,MAAMD,QAAQ,CAACE,WAAW,EAAE;MACnD,MAAMC,YAAY,GAChBH,QAAQ,CAACvH,MAAM,KAAK,GAAG,IAAIwH,cAAc,CAACG,UAAU,GAAG,CAAC,GACpDlN,IAAI,CAACmN,MAAM,CAACJ,cAAc,CAAC,GAC3B,IACiC;MAEvC;MACA,IAAIE,YAAY,aAAZA,YAAY,uBAAZA,YAAY,CAAEG,WAAW,EAAE;QAC7B,MAAMC,IAAI,GAAG,MAAM,IAAI,CAACC,qBAAqB,CAAC;UAAEF,WAAW,EAAEH,YAAY,CAACG;QAAW,CAAE,CAAC;QACxF/F,sBAAA,KAAI,EAAAzC,oBAAA,EAAcyI,IAAI;;MAGxB,OAAO;QACL5H,SAAS;QACTqH,QAAQ,EAAE;UACRS,EAAE,EAAET,QAAQ,CAACS,EAAE;UACfhI,MAAM,EAAEuH,QAAQ,CAACvH,MAAM;UACvBiI,UAAU,EAAEV,QAAQ,CAACU,UAAU;UAC/B3B,IAAI,EAAEoB,YAAY;UAClBlB,OAAO,EAAExL,oBAAoB,CAACuM,QAAQ,CAACf,OAAO;SAC/C;QACD0B,cAAc,EAAErC;OACjB;KACF,CAAC,OAAO1C,KAAK,EAAE;MACd;MACA,IAAKA,KAAoB,CAACxG,OAAO,CAACwL,QAAQ,CAAC,uBAAuB,CAAC,EAAE;QACnE,IAAI,CAAC7I,GAAG,CAAC8D,IAAI,CAAC,uCAAuC,CAAC;QACtD,OAAO,IAAI,CAAC6B,IAAI,CACdC,UAAU,EAAA3B,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAELlF,OAAO;UACV;UACA6G,QAAQ,EAAE;QAAK,IAEjB3E,QAAQ,CACT;;MAGH,IAAI,CAAClB,GAAG,CAAC6D,KAAK,CAAC,0BAA0B,EAAEA,KAAc,CAAC;MAC1D,MAAMA,KAAK;;EAEf;EAgMO,MAAMiF,KAAKA,CAChBlD,UAA8B,EAC9BmD,MAAmB,EACnB7H,QAAuC;IAEvC,MAAMwG,OAAO,GAAGjH,sBAAA,KAAI,EAAAb,0BAAA,MAAiB,CAAA+F,IAAA,CAArB,IAAI,CAAmB;IACvC,MAAMK,IAAI,GAAG+C,MAAM,CAAC9C,mBAAmB,GACnCjL,SAAS,CAAC2J,IAAI,CAACoE,MAAM,CAAC9C,mBAAmB,CAAC,GAC1CjL,SAAS,CAAC2J,IAAI,CAACiB,UAAU,CAAC;IAE9B,IAAI,CAAC5F,GAAG,CAAC4H,KAAK,CAAC,QAAQ5B,IAAI,CAAClH,QAAQ,EAAE,EAAE,CAAC;IACzC,IAAI,CAACkB,GAAG,CAAC4H,KAAK,CAAC,cAAchC,UAAU,CAAC9G,QAAQ,EAAE,EAAE,CAAC;IACrD,MAAMkK,SAAS,GAAG,MAAAA,CAAA,KAAW;MAC3B,MAAMlD,EAAE,GAAG,OAAO5E,QAAQ,KAAKjD,SAAS,GAAG,MAAMiD,QAAQ,GAAG,MAAMT,sBAAA,KAAI,EAAAtB,mBAAA,MAAU,CAAC;MACjF,IAAI,CAAC2G,EAAE,EAAE;QACP,MAAM,IAAIxI,oBAAoB,CAC5B,uGAAuG,CACxG;;MAGH,MAAMyI,QAAQ,GAAG/K,SAAS,CAAC2J,IAAI,CAACiB,UAAU,CAAC;MAC3C,MAAMM,MAAM,GAAG,CAAAJ,EAAE,aAAFA,EAAE,uBAAFA,EAAE,CAAEJ,YAAY,EAAE,KAAI1K,SAAS,CAACmL,SAAS,EAAE;MAE1D,MAAMpK,OAAO,GAAiB;QAC5ByK,YAAY;QACZE,WAAW,EAAEX,QAAQ;QACrBY,WAAW,EAAEoC,MAAM,CAACnC,UAAU;QAC9BC,GAAG,EAAEkC,MAAM,CAAClC,GAAG;QACfX,MAAM;QACNE,cAAc,EAAE,IAAI3K,MAAM,CAACiB,qCAAqC;OACjE;MAED,MAAMkE,SAAS,GAAG,MAAMvF,WAAW,CAACU,OAAO,CAAC;MAE5C;MACA;MACA,IAAI+K,kBAAkB,GAAqB,MAAM,IAAI,CAACC,UAAU,CAAC;QAC/DhL,OAAO,EAAE;UACPkL,MAAM,EAAE,MAAM;UACdC,OAAO,EAAAjD,MAAA,CAAAC,MAAA;YACL,cAAc,EAAE;UAAkB,GAC9BzD,sBAAA,KAAI,EAAAhB,sBAAA,MAAa,GAAG;YAAE0H,aAAa,EAAE,QAAQ,GAAGC,IAAI,CAAC3G,sBAAA,KAAI,EAAAhB,sBAAA,MAAa;UAAC,CAAE,GAAG,EAAG;SAEtF;QACD4H,QAAQ;QACRL,IAAI,EAAEjL;OACP,CAAC;MAEF;MACA+K,kBAAkB,GAAI,OAAMhB,EAAE,aAAFA,EAAE,uBAAFA,EAAE,CAAE2B,gBAAgB,CAACX,kBAAkB,CAAC,CAAqB;MAEzF,MAAME,IAAI,GAAG7L,IAAI,CAAC4F,MAAM,CAAC+F,kBAAkB,CAACE,IAAI,CAAC;MAEjD,MAAMiC,IAAI,GAAG;QACXlD,QAAQ,EAAEA,QAAQ,CAAC1E,MAAM,EAAE;QAC3B2E,IAAI;QACJc,kBAAkB;QAClBE,IAAI;QACJpG,SAAS;QACT8G,OAAO;QACPM,KAAK,EAAE;OACR;MAED,OAAO;QACLY,cAAc,EAAE7M,OAAO;QACvB+M,KAAK,EAAE,MAAMrI,sBAAA,KAAI,EAAAqH,oBAAA,OAAAoB,+BAAA,CAAsB,CAAAvD,IAAA,CAA1B,IAAI,EAAuBsD,IAAI;OAC7C;IACH,CAAC;IAED,MAAME,eAAe,GAAG,MAAAA,CAAA,KAAyC;MAC/D,IAAI,CAAC1I,sBAAA,KAAI,EAAAJ,gCAAA,MAAuB,EAAE;QAChC,OAAOpC,SAAS;;MAElB,MAAMuC,YAAY,GAAGC,sBAAA,KAAI,EAAAN,qBAAA,MAAY,CAAC+B,GAAG,CAAC8D,IAAI,CAAClH,QAAQ,EAAE,CAAC;MAC1D,IAAI0B,YAAY,EAAE;QAChB,OAAOA,YAAY;;MAErB,MAAM,IAAI,CAAC4I,eAAe,CAACpD,IAAI,CAAClH,QAAQ,EAAE,CAAC;MAC3C,OAAO2B,sBAAA,KAAI,EAAAN,qBAAA,MAAY,CAAC+B,GAAG,CAAC8D,IAAI,CAAClH,QAAQ,EAAE,CAAC;IAC9C,CAAC;IACD;IACA;IACA,MAAM,CAACuK,WAAW,EAAE7I,YAAY,CAAC,GAAG,MAAM6C,OAAO,CAACqB,GAAG,CAAC,CAACsE,SAAS,EAAE,EAAEG,eAAe,EAAE,CAAC,CAAC;IACvF,MAAM;MAAEP,cAAc;MAAEE;IAAK,CAAE,GAAGO,WAAW;IAE7C,MAAMC,gBAAgB,GAAArF,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACjB4E,KAAK;MACRF;IAAc,EACf;IAED,IAAI,CAAC5I,GAAG,CAAC4H,KAAK,CAAC,iBAAiB,EAAE0B,gBAAgB,CAAC;IACnD;IACA,IAAI,CAAC7I,sBAAA,KAAI,EAAAJ,gCAAA,MAAuB,EAAE;MAChC,OAAOiJ,gBAAgB;;IAGzB,IAAI;MACF,OAAO7I,sBAAA,KAAI,EAAAH,8BAAA,MAAqB,CAAAqF,IAAA,CAAzB,IAAI,EAAsB2D,gBAAgB,EAAE9I,YAAY,CAAC;KACjE,CAAC,OAAAqC,EAAA,EAAM;MACN;MACA,IAAI,CAAC7C,GAAG,CAAC8D,IAAI,CAAC,sEAAsE,CAAC;MACrFrD,sBAAA,KAAI,EAAAN,qBAAA,MAAY,CAACoJ,MAAM,CAAC3D,UAAU,CAAC9G,QAAQ,EAAE,CAAC;MAC9C,MAAM,IAAI,CAACsK,eAAe,CAACpD,IAAI,CAAClH,QAAQ,EAAE,CAAC;MAE3C,MAAM0K,mBAAmB,GAAG/I,sBAAA,KAAI,EAAAN,qBAAA,MAAY,CAAC+B,GAAG,CAAC0D,UAAU,CAAC9G,QAAQ,EAAE,CAAC;MACvE,IAAI,CAAC0K,mBAAmB,EAAE;QACxB,MAAM,IAAIxN,4BAA4B,CACpC,0EAA0E,CAC3E;;MAEH,OAAOyE,sBAAA,KAAI,EAAAH,8BAAA,MAAqB,CAAAqF,IAAA,CAAzB,IAAI,EAAsB2D,gBAAgB,EAAEE,mBAAmB,CAAC;;EAE3E;EA4EO,MAAMC,sBAAsBA,CACjCV,MAAwB,EACxB7H,QAAuC;IAGvC,MAAM4E,EAAE,GAAG,OAAO5E,QAAQ,KAAKjD,SAAS,GAAG,MAAMiD,QAAQ,GAAG,MAAMT,sBAAA,KAAI,EAAAtB,mBAAA,MAAU,CAAC;IACjF,IAAI,CAAC2G,EAAE,EAAE;MACP,MAAM,IAAIxI,oBAAoB,CAC5B,uGAAuG,CACxG;;IAEH,MAAM4I,MAAM,GAAG,CAAAJ,EAAE,aAAFA,EAAE,uBAAFA,EAAE,CAAEJ,YAAY,EAAE,KAAI1K,SAAS,CAACmL,SAAS,EAAE;IAE1D;IACA;IACA,MAAMW,kBAAkB,GAAQ,MAAM,IAAI,CAACC,UAAU,CAAC;MACpDhL,OAAO,EAAE;QACPkL,MAAM,EAAE,MAAM;QACdC,OAAO,EAAAjD,MAAA,CAAAC,MAAA;UACL,cAAc,EAAE;QAAkB,GAC9BzD,sBAAA,KAAI,EAAAhB,sBAAA,MAAa,GAAG;UAAE0H,aAAa,EAAE,QAAQ,GAAGC,IAAI,CAAC3G,sBAAA,KAAI,EAAAhB,sBAAA,MAAa;QAAC,CAAE,GAAG,EAAG;OAEtF;MACD4H,QAAQ;MACRL,IAAI,EAAE;QACJR,YAAY;QACZkD,KAAK,EAAEX,MAAM,CAACW,KAAK;QACnBxD,MAAM;QACNE,cAAc,EAAE,IAAI3K,MAAM,CAACiB,qCAAqC;;KAEnE,CAAC;IAEF;IACA,OAAOoJ,EAAE,aAAFA,EAAE,uBAAFA,EAAE,CAAE2B,gBAAgB,CAACX,kBAAkB,CAAC;EACjD;EAEO,MAAM6C,SAASA,CACpB/D,UAA8B,EAC9BmD,MAAwB,EACxB7H,QAAuC;EACvC;EACAnF,OAAa;IAEb,MAAMgK,QAAQ,GAAG,OAAOH,UAAU,KAAK,QAAQ,GAAG5K,SAAS,CAAC4O,QAAQ,CAAChE,UAAU,CAAC,GAAGA,UAAU;IAE7F,MAAMkB,kBAAkB,GAAG/K,OAAO,aAAPA,OAAO,cAAPA,OAAO,GAAK,MAAM,IAAI,CAAC0N,sBAAsB,CAACV,MAAM,EAAE7H,QAAQ,CAAE;IAC3F,MAAM8F,IAAI,GAAG7L,IAAI,CAAC4F,MAAM,CAAC+F,kBAAkB,CAACE,IAAI,CAAC;IAEjD,IAAI,CAAChH,GAAG,CAAC4H,KAAK,CACZ,8BAA8B7B,QAAQ,4BAA4B,EAClEe,kBAAkB,CACnB;IACD;IACA,MAAMY,OAAO,GAAGjH,sBAAA,KAAI,EAAAb,0BAAA,MAAiB,CAAA+F,IAAA,CAArB,IAAI,CAAmB;IACvC,IAAI;MACF,MAAMsC,QAAQ,GAAG,MAAMxH,sBAAA,KAAI,EAAAqH,oBAAA,OAAAC,0BAAA,CAAiB,CAAApC,IAAA,CAArB,IAAI,EAAkB;QAC3C5J,OAAO,EAAEA,CAAA,KACP0E,sBAAA,KAAI,EAAApB,gBAAA,MAAO,CAAAsG,IAAA,CAAX,IAAI,EACF,EAAE,GAAG,IAAIxH,GAAG,CAAC,oBAAoB4H,QAAQ,CAACjH,QAAQ,EAAE,aAAa,EAAE,IAAI,CAACd,IAAI,CAAC,EAAAiG,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAExEzD,sBAAA,KAAI,EAAAnB,uBAAA,MAAc,GAClBwH,kBAAkB,CAAC/K,OAAO;UAC7BiL;QAAI,GAEP;QACHU,OAAO;QACPM,KAAK,EAAE;OACR,CAAC;MAEF,IAAI,CAACC,QAAQ,CAACS,EAAE,EAAE;QAChB,MAAM,IAAI7G,KAAK,CACb,6BAA6B,GAC3B,WAAWoG,QAAQ,CAACvH,MAAM,KAAKuH,QAAQ,CAACU,UAAU,KAAK,GACvD,WAAW,MAAMV,QAAQ,CAAC4B,IAAI,EAAE,IAAI,CACvC;;MAEH,MAAMC,eAAe,GAAsB3O,IAAI,CAACmN,MAAM,CAAC,MAAML,QAAQ,CAACE,WAAW,EAAE,CAAC;MAEpF,IAAI,CAACnI,GAAG,CAAC4H,KAAK,CAAC,sBAAsB,EAAEkC,eAAe,CAAC;MACvD,MAAMC,UAAU,GAAG,MAAM,IAAI,CAACtB,qBAAqB,CAACqB,eAAe,CAAC;MACpE,IAAIC,UAAU,GAAG,CAAC,EAAE;QAClB,IAAI,CAAC/J,GAAG,CAAC4H,KAAK,CAAC,2BAA2B,EAAEmC,UAAU,CAAC;QACvDvH,sBAAA,KAAI,EAAAzC,oBAAA,EAAcgK,UAAU;;MAG9B,OAAOD,eAAe;KACvB,CAAC,OAAOjG,KAAK,EAAE;MACd,IAAI,CAAC7D,GAAG,CAAC6D,KAAK,CAAC,iDAAiD,EAAEA,KAAmB,CAAC;MACtF,MAAMA,KAAK;;EAEf;EAEO,MAAM4E,qBAAqBA,CAACR,QAAsC;IACvE,IAAI+B,IAAc;IAClB,IAAI/B,QAAQ,CAACM,WAAW,EAAE;MACxB,MAAM0B,OAAO,GAAmC9O,IAAI,CAACmN,MAAM,CAACL,QAAQ,CAACM,WAAW,CAAC;MACjF,IAAI0B,OAAO,IAAI,MAAM,IAAIA,OAAO,EAAE;QAChCD,IAAI,GAAGC,OAAO,CAACD,IAAI;OACpB,MAAM;QACL,MAAM,IAAInI,KAAK,CAAC,qCAAqC,CAAC;;MAExD,MAAMqI,UAAU,GAAGhO,WAAW,CAAC,CAAC,MAAM,CAAC,EAAE8N,IAAI,CAAC;MAC9C,IAAIE,UAAU,CAACxJ,MAAM,KAAKzE,YAAY,CAACkO,KAAK,EAAE;QAC5C,MAAM,IAAItI,KAAK,CAAC,uEAAuE,CAAC;;MAG1F,IAAI,EAAEqI,UAAU,CAACE,KAAK,YAAYC,WAAW,CAAC,IAAI,CAACA,WAAW,CAACC,MAAM,CAACJ,UAAU,CAAC,EAAE;QACjF,MAAM,IAAIrI,KAAK,CAAC,uEAAuE,CAAC;;MAE1F,MAAM0I,IAAI,GAAGjO,UAAU,CAAChB,cAAc,CAAC4O,UAAU,CAACE,KAAoB,CAAC,CAAC;MACxE,IAAI,CAACpK,GAAG,CAAC4H,KAAK,CAAC,qBAAqB,EAAE2C,IAAI,CAAC;MAC3C,IAAI,CAACvK,GAAG,CAAC4H,KAAK,CAAC,qCAAqC,EAAE4C,MAAM,CAACD,IAAI,CAAC,CAAC;MACnE,OAAOC,MAAM,CAACD,IAAI,CAAC;KACpB,MAAM;MACL,IAAI,CAACvK,GAAG,CAAC8D,IAAI,CAAC,kCAAkC,CAAC;;IAEnD,OAAO,CAAC;EACV;EAEA;;;;EAIO,MAAMS,QAAQA,CAACqB,UAAsB;IAC1C,MAAM6E,cAAc,GAAG,MAAM,MAAM,CAAC,sBAAsB,CAAC;IAC3D,MAAMC,QAAQ,GAAGC,IAAI,CAACC,GAAG,EAAE;IAC3B,IAAI;MACF,IAAI,CAAChF,UAAU,EAAE;QACf,IAAI,CAAC5F,GAAG,CAAC4H,KAAK,CACZ,kGAAkG,CACnG;;MAEH,MAAMlH,MAAM,GAAG,MAAM+J,cAAc,CAAC1O,OAAO,CAAC;QAC1C;QACA6J,UAAU,EAAEA,UAAU,aAAVA,UAAU,cAAVA,UAAU,GAAI5K,SAAS,CAAC2J,IAAI,CAAC,6BAA6B,CAAC;QACvEN,KAAK,EAAE,IAAI;QACXqF,KAAK,EAAE,CAAC,MAAM;OACf,CAAC;MAEF,MAAMmB,WAAW,GAAGnK,MAAM,CAACwB,GAAG,CAAC,MAAM,CAAC;MACtC,IAAI2I,WAAW,EAAE;QACfrI,sBAAA,KAAI,EAAAhD,wBAAA,EAAkBgL,MAAM,CAACK,WAAqB,CAAC,GAAGL,MAAM,CAACE,QAAQ,CAAC;;KAEzE,CAAC,OAAO7G,KAAK,EAAE;MACd,IAAI,CAAC7D,GAAG,CAAC6D,KAAK,CAAC,gDAAgD,EAAEA,KAAmB,CAAC;;EAEzF;EAEO,MAAMnD,MAAMA,CAAA;IACjB,MAAMwG,OAAO,GAA2BzG,sBAAA,KAAI,EAAAhB,sBAAA,MAAa,GACrD;MACE0H,aAAa,EAAE,QAAQ,GAAGC,IAAI,CAAC3G,sBAAA,KAAI,EAAAhB,sBAAA,MAAa;KACjD,GACD,EAAE;IAEN,IAAI,CAACO,GAAG,CAAC4H,KAAK,CAAC,2BAA2B,CAAC;IAC3C,MAAMF,OAAO,GAAGjH,sBAAA,KAAI,EAAAb,0BAAA,MAAiB,CAAA+F,IAAA,CAArB,IAAI,CAAmB;IACvC,MAAMsC,QAAQ,GAAG,MAAMxH,sBAAA,KAAI,EAAAqH,oBAAA,OAAAC,0BAAA,CAAiB,CAAApC,IAAA,CAArB,IAAI,EAAkB;MAC3C+B,OAAO;MACP3L,OAAO,EAAEA,CAAA,KACP0E,sBAAA,KAAI,EAAApB,gBAAA,MAAO,CAAAsG,IAAA,CAAX,IAAI,EAAQ,EAAE,GAAG,IAAIxH,GAAG,CAAC,gBAAgB,EAAE,IAAI,CAACH,IAAI,CAAC,EAAAiG,MAAA,CAAAC,MAAA;QAAIgD;MAAO,GAAKzG,sBAAA,KAAI,EAAAnB,uBAAA,MAAc,EAAG;MAC5F0I,KAAK,EAAE;KACR,CAAC;IACF,OAAO7M,IAAI,CAACmN,MAAM,CAAC,MAAML,QAAQ,CAACE,WAAW,EAAE,CAAC;EAClD;EAEO,MAAM1D,YAAYA,CAAA;IACvB,IAAI,CAAChE,sBAAA,KAAI,EAAAf,yBAAA,MAAgB,EAAE;MACzB,MAAMgB,MAAM,GAAG,MAAM,IAAI,CAACA,MAAM,EAAE;MAClC;MACA,IAAI,CAACiC,OAAO,GAAIjC,MAAiD,CAACoK,QAAQ;MAC1EtI,sBAAA,KAAI,EAAA9C,yBAAA,EAAmB,IAAI;;IAE7B,OAAO,IAAI,CAACiD,OAAO;EACrB;EAEOoI,kBAAkBA,CAAA;IACvBvI,sBAAA,KAAI,EAAArD,mBAAA,EAAa,IAAI;EACvB;EAEO6L,eAAeA,CAAC9J,QAAkB;IACvCsB,sBAAA,KAAI,EAAArD,mBAAA,EAAakE,OAAO,CAACC,OAAO,CAACpC,QAAQ,CAAC;EAC5C;EAEO,MAAMkI,eAAeA,CAACxD,UAA8B;IACzD,MAAMK,mBAAmB,GAAcjL,SAAS,CAAC2J,IAAI,CAACiB,UAAU,CAAC;IACjE,MAAMqC,QAAQ,GAAG,MAAMlM,OAAO,CAAC;MAC7B6J,UAAU,EAAEK,mBAAmB;MAC/ByD,KAAK,EAAE,CAAC,QAAQ,CAAC;MACjBrF,KAAK,EAAE;KACR,CAAC;IAEF,MAAM4G,cAAc,GAAGhD,QAAQ,CAAC/F,GAAG,CAAC,QAAQ,CAAC;IAC7C,IAAI+I,cAAc,IAAI,OAAOA,cAAc,KAAK,QAAQ,IAAI,UAAU,IAAIA,cAAc,EAAE;MACxFxK,sBAAA,KAAI,EAAAN,qBAAA,MAAY,CAACf,GAAG,CAAC6G,mBAAmB,CAAC5E,MAAM,EAAE,EAAE4J,cAA8B,CAAC;MAClF,OAAOA,cAA8B;;IAEvC;IACA,OAAOhN,SAAS;EAClB;EAEU8I,UAAUA,CAAChL,OAAyB;IAC5C,IAAImP,CAAC,GAAG7H,OAAO,CAACC,OAAO,CAACvH,OAAO,CAAC;IAChC,IAAIA,OAAO,CAACsL,QAAQ,iCAAoB;MACtC,KAAK,MAAMjC,EAAE,IAAI3E,sBAAA,KAAI,EAAAP,yBAAA,MAAgB,EAAE;QACrCgL,CAAC,GAAGA,CAAC,CAACC,IAAI,CAACC,CAAC,IAAIhG,EAAE,CAACgG,CAAC,CAAC,CAACD,IAAI,CAACE,EAAE,IAAIA,EAAE,IAAID,CAAC,CAAC,CAAC;;KAE7C,MAAM;MACL,KAAK,MAAMhG,EAAE,IAAI3E,sBAAA,KAAI,EAAAR,wBAAA,MAAe,EAAE;QACpCiL,CAAC,GAAGA,CAAC,CAACC,IAAI,CAACC,CAAC,IAAIhG,EAAE,CAACgG,CAAC,CAAC,CAACD,IAAI,CAACE,EAAE,IAAIA,EAAE,IAAID,CAAC,CAAC,CAAC;;;IAI9C,OAAOF,CAAC;EACV;;orBAhlBA,eAAKhC,gCAAuBD,IAO3B;;EACC,MAAM;IAAEjD,IAAI;IAAEc,kBAAkB;IAAEE,IAAI;IAAEpG,SAAS;IAAE8G,OAAO;IAAEM;EAAK,CAAE,GAAGiB,IAAI;EAE1E,MAAMqC,KAAK,GAAGtD,KAAK,KAAK,CAAC,GAAG,CAAC,GAAGN,OAAO,CAAC6D,IAAI,EAAE;EAC9C,IAAI,CAACvL,GAAG,CAAC4H,KAAK,CAAC,8BAA8B5B,IAAI,CAAClH,QAAQ,EAAE,qBAAqB,EAAE;IACjFkJ,KAAK;IACLN,OAAO;IACP4D;GACD,CAAC;EAEF;EACA,IAAIA,KAAK,KAAK,IAAI,EAAE;IAClB,MAAM,IAAIrQ,UAAU,CAClB,wEACEwF,sBAAA,KAAI,EAAAd,qBAAA,MACN,8FAA8F,CAC/F;;EAGH,IAAI2L,KAAK,GAAG,CAAC,EAAE;IACb,MAAM,IAAIjI,OAAO,CAACC,OAAO,IAAIkI,UAAU,CAAClI,OAAO,EAAEgI,KAAK,CAAC,CAAC;;EAE1D,IAAIrD,QAA0B;EAC9B;EACA,IAAI;IACF,IAAI,CAACjI,GAAG,CAAC4H,KAAK,CACZ,8BAA8B5B,IAAI,CAAClH,QAAQ,EAAE,uBAAuB,EACpEgI,kBAAkB,CACnB;IACD,MAAM2E,aAAa,GAAG,MAAMhL,sBAAA,KAAI,EAAApB,gBAAA,MAAO,CAAAsG,IAAA,CAAX,IAAI,EAC9B,EAAE,GAAG,IAAIxH,GAAG,CAAC,oBAAoB6H,IAAI,CAAClH,QAAQ,EAAE,QAAQ,EAAE,IAAI,CAACd,IAAI,CAAC,EAAAiG,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAE/DzD,sBAAA,KAAI,EAAAnB,uBAAA,MAAc,GAClBwH,kBAAkB,CAAC/K,OAAO;MAC7BiL;IAAI,GAEP;IACD,IAAIyE,aAAa,CAAC/K,MAAM,KAAK,GAAG,EAAE;MAChC,MAAMH,aAAa,GAAkBpF,IAAI,CAACmN,MAAM,CAAC,MAAMmD,aAAa,CAACtD,WAAW,EAAE,CAAC;MACnFF,QAAQ,GAAAhE,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACH3D,aAAa;QAChBmL,WAAW,EAAE;UACXhD,EAAE,EAAE+C,aAAa,CAAC/C,EAAE;UACpBhI,MAAM,EAAE+K,aAAa,CAAC/K,MAAM;UAC5BiI,UAAU,EAAE8C,aAAa,CAAC9C,UAAU;UACpCzB,OAAO,EAAExL,oBAAoB,CAAC+P,aAAa,CAACvE,OAAO;SACpD;QACDtG;MAAS,EACV;KACF,MAAM;MACL,MAAM,IAAI9E,sBAAsB,CAC9B,8BAA8B,GAC5B,WAAW2P,aAAa,CAAC/K,MAAM,KAAK+K,aAAa,CAAC9C,UAAU,KAAK,GACjE,WAAW,MAAM8C,aAAa,CAAC5B,IAAI,EAAE,IAAI,EAC3C;QACEnB,EAAE,EAAE+C,aAAa,CAAC/C,EAAE;QACpBhI,MAAM,EAAE+K,aAAa,CAAC/K,MAAM;QAC5BiI,UAAU,EAAE8C,aAAa,CAAC9C,UAAU;QACpCzB,OAAO,EAAExL,oBAAoB,CAAC+P,aAAa,CAACvE,OAAO;OACpD,CACF;;GAEJ,CAAC,OAAOrD,KAAK,EAAE;IACd,IAAImE,KAAK,GAAGvH,sBAAA,KAAI,EAAAd,qBAAA,MAAY,EAAE;MAC5B,IAAI,CAACK,GAAG,CAAC8D,IAAI,CACX,oDAAoD,GAClD,KAAKD,KAAK,IAAI,GACd,mBAAmB,CACtB;MACD,OAAO,MAAMpD,sBAAA,KAAI,EAAAqH,oBAAA,OAAAoB,+BAAA,CAAsB,CAAAvD,IAAA,CAA1B,IAAI,EAAA1B,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAA4B+E,IAAI;QAAEjB,KAAK,EAAEA,KAAK,GAAG;MAAC,GAAG;;IAExE,MAAMnE,KAAK;;EAGb,MAAM5C,SAAS,GAAG,CAAAgE,EAAA,IAAApC,EAAA,GAAAoF,QAAQ,CAACtH,UAAU,cAAAkC,EAAA,uBAAAA,EAAA,CAAG,CAAC,CAAC,cAAAoC,EAAA,uBAAAA,EAAA,CAAEhE,SAAS;EAErD;EACA,IAAI,CAACR,sBAAA,KAAI,EAAAJ,gCAAA,MAAuB,EAAE;IAChC,OAAO4H,QAAQ;;EAGjB,IAAI,CAAChH,SAAS,EAAE;IACd,MAAM,IAAIY,KAAK,CACb,yFAAyF,CAC1F;;EAGH;EACA,MAAM8J,aAAa,GAAGnB,MAAM,CAAChJ,MAAM,CAACP,SAAS,CAAC,GAAGO,MAAM,CAAC,OAAS,CAAC,CAAC;EAEnE,IAAI,CAACxB,GAAG,CAAC4H,KAAK,CAAC,yBAAyB,EAAE;IACxC7D,SAAS,EAAE,IAAI,CAACA,SAAS;IACzB9C,SAAS,EAAE0K;GACZ,CAAC;EAEF;EACA,IAAInB,MAAM,CAAC,IAAI,CAACzG,SAAS,CAAC,GAAG4H,aAAa,EAAE;IAC1C,MAAM9H,KAAK,GAAG,IAAI5I,UAAU,CAAC,mDAAmD,CAAC;IACjF,IAAI,CAAC+E,GAAG,CAAC6D,KAAK,CAAC,oBAAoB,EAAEA,KAAK,EAAE;MAC1C5C,SAAS;MACT8C,SAAS,EAAE,IAAI,CAACA;KACjB,CAAC;IACF,IAAIiE,KAAK,GAAGvH,sBAAA,KAAI,EAAAd,qBAAA,MAAY,EAAE;MAC5B,OAAO,MAAMc,sBAAA,KAAI,EAAAqH,oBAAA,OAAAoB,+BAAA,CAAsB,CAAAvD,IAAA,CAA1B,IAAI,EAAA1B,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAA4B+E,IAAI;QAAEjB,KAAK,EAAEA,KAAK,GAAG;MAAC,GAAG;;IAExE;MACE,MAAM,IAAI/M,UAAU,CAClB,wEACEwF,sBAAA,KAAI,EAAAd,qBAAA,MACN,8FAA8F,CAC/F;;;EAIL,OAAOsI,QAAQ;AACjB,CAAC,EAAAF,0BAAA,GAED,eAAKA,2BAAkBkB,IAItB;EACC,MAAM;IAAElN,OAAO;IAAE2L,OAAO;IAAEM;EAAK,CAAE,GAAGiB,IAAI;EACxC,MAAMqC,KAAK,GAAGtD,KAAK,KAAK,CAAC,GAAG,CAAC,GAAGN,OAAO,CAAC6D,IAAI,EAAE;EAE9C;EACA,IAAID,KAAK,KAAK,IAAI,EAAE;IAClB,MAAM,IAAIrQ,UAAU,CAClB,wEACEwF,sBAAA,KAAI,EAAAd,qBAAA,MACN,8FAA8F,CAC/F;;EAGH,IAAI2L,KAAK,GAAG,CAAC,EAAE;IACb,MAAM,IAAIjI,OAAO,CAACC,OAAO,IAAIkI,UAAU,CAAClI,OAAO,EAAEgI,KAAK,CAAC,CAAC;;EAG1D,IAAIrD,QAAkB;EACtB,IAAI;IACFA,QAAQ,GAAG,MAAMlM,OAAO,EAAE;GAC3B,CAAC,OAAO8H,KAAK,EAAE;IACd,IAAIpD,sBAAA,KAAI,EAAAd,qBAAA,MAAY,GAAGqI,KAAK,EAAE;MAC5B,IAAI,CAAChI,GAAG,CAAC8D,IAAI,CACX,sDAAsD,GACpD,KAAKD,KAAK,IAAI,GACd,qBAAqB,CACxB;MACD;MACA,OAAO,MAAMpD,sBAAA,KAAI,EAAAqH,oBAAA,OAAAC,0BAAA,CAAiB,CAAApC,IAAA,CAArB,IAAI,EAAkB;QAAE5J,OAAO;QAAE2L,OAAO;QAAEM,KAAK,EAAEA,KAAK,GAAG;MAAC,CAAE,CAAC;;IAE5E,MAAMnE,KAAK;;EAEb,IAAIoE,QAAQ,CAACS,EAAE,EAAE;IACf,OAAOT,QAAQ;;EAGjB,MAAM2D,YAAY,GAAG,MAAM3D,QAAQ,CAAC4D,KAAK,EAAE,CAAChC,IAAI,EAAE;EAClD,MAAMiC,YAAY,GAChB,6BAA6B,GAC7B,WAAW7D,QAAQ,CAACvH,MAAM,KAAKuH,QAAQ,CAACU,UAAU,KAAK,GACvD,WAAWiD,YAAY,IAAI;EAE7B,IAAI3D,QAAQ,CAACvH,MAAM,KAAK,GAAG,IAAIuH,QAAQ,CAAC8D,GAAG,CAAClD,QAAQ,CAAC,QAAQ,CAAC,EAAE;IAC9D,MAAM,IAAI/M,sBAAsB,CAAC,uCAAuC,EAAE;MACxE4M,EAAE,EAAET,QAAQ,CAACS,EAAE;MACfhI,MAAM,EAAEuH,QAAQ,CAACvH,MAAM;MACvBiI,UAAU,EAAEV,QAAQ,CAACU,UAAU;MAC/BzB,OAAO,EAAExL,oBAAoB,CAACuM,QAAQ,CAACf,OAAO;KAC/C,CAAC;;EAEJ,IAAIc,KAAK,GAAGvH,sBAAA,KAAI,EAAAd,qBAAA,MAAY,EAAE;IAC5B,OAAO,MAAMc,sBAAA,KAAI,EAAAqH,oBAAA,OAAAC,0BAAA,CAAiB,CAAApC,IAAA,CAArB,IAAI,EAAkB;MAAE5J,OAAO;MAAE2L,OAAO;MAAEM,KAAK,EAAEA,KAAK,GAAG;IAAC,CAAE,CAAC;;EAG5E,MAAM,IAAIlM,sBAAsB,CAACgQ,YAAY,EAAE;IAC7CpD,EAAE,EAAET,QAAQ,CAACS,EAAE;IACfhI,MAAM,EAAEuH,QAAQ,CAACvH,MAAM;IACvBiI,UAAU,EAAEV,QAAQ,CAACU,UAAU;IAC/BzB,OAAO,EAAExL,oBAAoB,CAACuM,QAAQ,CAACf,OAAO;GAC/C,CAAC;AACJ,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}