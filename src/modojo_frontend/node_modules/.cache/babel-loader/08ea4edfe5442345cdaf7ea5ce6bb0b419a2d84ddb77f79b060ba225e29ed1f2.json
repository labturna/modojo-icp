{"ast":null,"code":"/**\n * Concatenate multiple array buffers.\n * @param buffers The buffers to concatenate.\n */\nexport function concat() {\n  for (var _len = arguments.length, buffers = new Array(_len), _key = 0; _key < _len; _key++) {\n    buffers[_key] = arguments[_key];\n  }\n  const result = new Uint8Array(buffers.reduce((acc, curr) => acc + curr.byteLength, 0));\n  let index = 0;\n  for (const b of buffers) {\n    result.set(new Uint8Array(b), index);\n    index += b.byteLength;\n  }\n  return result;\n}\n/**\n * Returns an hexadecimal representation of an array buffer.\n * @param bytes The array buffer.\n */\nexport function toHexString(bytes) {\n  return new Uint8Array(bytes).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n/**\n * Return an array buffer from its hexadecimal representation.\n * @param hexString The hexadecimal string.\n */\nexport function fromHexString(hexString) {\n  var _a;\n  return new Uint8Array(((_a = hexString.match(/.{1,2}/g)) !== null && _a !== void 0 ? _a : []).map(byte => parseInt(byte, 16)));\n}\n/**\n * A class that abstracts a pipe-like ArrayBuffer.\n */\nexport class PipeArrayBuffer {\n  /**\n   * Creates a new instance of a pipe\n   * @param buffer an optional buffer to start with\n   * @param length an optional amount of bytes to use for the length.\n   */\n  constructor(buffer) {\n    let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (buffer === null || buffer === void 0 ? void 0 : buffer.byteLength) || 0;\n    this._buffer = bufFromBufLike(buffer || new ArrayBuffer(0));\n    this._view = new Uint8Array(this._buffer, 0, length);\n  }\n  get buffer() {\n    // Return a copy of the buffer.\n    return bufFromBufLike(this._view.slice());\n  }\n  get byteLength() {\n    return this._view.byteLength;\n  }\n  /**\n   * Read `num` number of bytes from the front of the pipe.\n   * @param num The number of bytes to read.\n   */\n  read(num) {\n    const result = this._view.subarray(0, num);\n    this._view = this._view.subarray(num);\n    return result.slice().buffer;\n  }\n  readUint8() {\n    const result = this._view[0];\n    this._view = this._view.subarray(1);\n    return result;\n  }\n  /**\n   * Write a buffer to the end of the pipe.\n   * @param buf The bytes to write.\n   */\n  write(buf) {\n    const b = new Uint8Array(buf);\n    const offset = this._view.byteLength;\n    if (this._view.byteOffset + this._view.byteLength + b.byteLength >= this._buffer.byteLength) {\n      // Alloc grow the view to include the new bytes.\n      this.alloc(b.byteLength);\n    } else {\n      // Update the view to include the new bytes.\n      this._view = new Uint8Array(this._buffer, this._view.byteOffset, this._view.byteLength + b.byteLength);\n    }\n    this._view.set(b, offset);\n  }\n  /**\n   * Whether or not there is more data to read from the buffer\n   */\n  get end() {\n    return this._view.byteLength === 0;\n  }\n  /**\n   * Allocate a fixed amount of memory in the buffer. This does not affect the view.\n   * @param amount A number of bytes to add to the buffer.\n   */\n  alloc(amount) {\n    // Add a little bit of exponential growth.\n    const b = new ArrayBuffer((this._buffer.byteLength + amount) * 1.2 | 0);\n    const v = new Uint8Array(b, 0, this._view.byteLength + amount);\n    v.set(this._view);\n    this._buffer = b;\n    this._view = v;\n  }\n}\n/**\n * Returns a true ArrayBuffer from a Uint8Array, as Uint8Array.buffer is unsafe.\n * @param {Uint8Array} arr Uint8Array to convert\n * @returns ArrayBuffer\n */\nexport function uint8ToBuf(arr) {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength).buffer;\n}\n/**\n * Returns a true ArrayBuffer from an ArrayBufferLike object.\n * @param bufLike a buffer-like object\n * @returns ArrayBuffer\n */\nexport function bufFromBufLike(bufLike) {\n  if (bufLike instanceof Uint8Array) {\n    return uint8ToBuf(bufLike);\n  }\n  if (bufLike instanceof ArrayBuffer) {\n    return bufLike;\n  }\n  if (Array.isArray(bufLike)) {\n    return uint8ToBuf(new Uint8Array(bufLike));\n  }\n  if ('buffer' in bufLike) {\n    return bufFromBufLike(bufLike.buffer);\n  }\n  return uint8ToBuf(new Uint8Array(bufLike));\n}","map":{"version":3,"names":["concat","_len","arguments","length","buffers","Array","_key","result","Uint8Array","reduce","acc","curr","byteLength","index","b","set","toHexString","bytes","str","byte","toString","padStart","fromHexString","hexString","_a","match","map","parseInt","PipeArrayBuffer","constructor","buffer","undefined","_buffer","bufFromBufLike","ArrayBuffer","_view","slice","read","num","subarray","readUint8","write","buf","offset","byteOffset","alloc","end","amount","v","uint8ToBuf","arr","DataView","bufLike","isArray"],"sources":["/home/arslan/modojo/node_modules/@dfinity/candid/src/utils/buffer.ts"],"sourcesContent":["/**\n * Concatenate multiple array buffers.\n * @param buffers The buffers to concatenate.\n */\nexport function concat(...buffers: ArrayBuffer[]): ArrayBuffer {\n  const result = new Uint8Array(buffers.reduce((acc, curr) => acc + curr.byteLength, 0));\n  let index = 0;\n  for (const b of buffers) {\n    result.set(new Uint8Array(b), index);\n    index += b.byteLength;\n  }\n  return result;\n}\n\n/**\n * Returns an hexadecimal representation of an array buffer.\n * @param bytes The array buffer.\n */\nexport function toHexString(bytes: ArrayBuffer): string {\n  return new Uint8Array(bytes).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n\n/**\n * Return an array buffer from its hexadecimal representation.\n * @param hexString The hexadecimal string.\n */\nexport function fromHexString(hexString: string): ArrayBuffer {\n  return new Uint8Array((hexString.match(/.{1,2}/g) ?? []).map(byte => parseInt(byte, 16)));\n}\n\n/**\n * A class that abstracts a pipe-like ArrayBuffer.\n */\nexport class PipeArrayBuffer {\n  /**\n   * The reading view. It's a sliding window as we read and write, pointing to the buffer.\n   * @private\n   */\n  private _view: Uint8Array;\n\n  /**\n   * The actual buffer containing the bytes.\n   * @private\n   */\n  private _buffer: ArrayBuffer;\n\n  /**\n   * Creates a new instance of a pipe\n   * @param buffer an optional buffer to start with\n   * @param length an optional amount of bytes to use for the length.\n   */\n  constructor(buffer?: ArrayBuffer, length = buffer?.byteLength || 0) {\n    this._buffer = bufFromBufLike(buffer || new ArrayBuffer(0));\n    this._view = new Uint8Array(this._buffer, 0, length);\n  }\n\n  get buffer(): ArrayBuffer {\n    // Return a copy of the buffer.\n    return bufFromBufLike(this._view.slice());\n  }\n\n  get byteLength(): number {\n    return this._view.byteLength;\n  }\n\n  /**\n   * Read `num` number of bytes from the front of the pipe.\n   * @param num The number of bytes to read.\n   */\n  public read(num: number): ArrayBuffer {\n    const result = this._view.subarray(0, num);\n    this._view = this._view.subarray(num);\n    return result.slice().buffer;\n  }\n\n  public readUint8(): number | undefined {\n    const result = this._view[0];\n    this._view = this._view.subarray(1);\n    return result;\n  }\n\n  /**\n   * Write a buffer to the end of the pipe.\n   * @param buf The bytes to write.\n   */\n  public write(buf: ArrayBuffer): void {\n    const b = new Uint8Array(buf);\n    const offset = this._view.byteLength;\n    if (this._view.byteOffset + this._view.byteLength + b.byteLength >= this._buffer.byteLength) {\n      // Alloc grow the view to include the new bytes.\n      this.alloc(b.byteLength);\n    } else {\n      // Update the view to include the new bytes.\n      this._view = new Uint8Array(\n        this._buffer,\n        this._view.byteOffset,\n        this._view.byteLength + b.byteLength,\n      );\n    }\n\n    this._view.set(b, offset);\n  }\n\n  /**\n   * Whether or not there is more data to read from the buffer\n   */\n  public get end(): boolean {\n    return this._view.byteLength === 0;\n  }\n\n  /**\n   * Allocate a fixed amount of memory in the buffer. This does not affect the view.\n   * @param amount A number of bytes to add to the buffer.\n   */\n  public alloc(amount: number) {\n    // Add a little bit of exponential growth.\n    const b = new ArrayBuffer(((this._buffer.byteLength + amount) * 1.2) | 0);\n    const v = new Uint8Array(b, 0, this._view.byteLength + amount);\n    v.set(this._view);\n    this._buffer = b;\n    this._view = v;\n  }\n}\n\n/**\n * Returns a true ArrayBuffer from a Uint8Array, as Uint8Array.buffer is unsafe.\n * @param {Uint8Array} arr Uint8Array to convert\n * @returns ArrayBuffer\n */\nexport function uint8ToBuf(arr: Uint8Array): ArrayBuffer {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength).buffer;\n}\n\n/**\n * Returns a true ArrayBuffer from an ArrayBufferLike object.\n * @param bufLike a buffer-like object\n * @returns ArrayBuffer\n */\nexport function bufFromBufLike(\n  bufLike:\n    | ArrayBuffer\n    | Uint8Array\n    | DataView\n    | ArrayBufferView\n    | ArrayBufferLike\n    | [number]\n    | number[]\n    | { buffer: ArrayBuffer },\n): ArrayBuffer {\n  if (bufLike instanceof Uint8Array) {\n    return uint8ToBuf(bufLike);\n  }\n  if (bufLike instanceof ArrayBuffer) {\n    return bufLike;\n  }\n  if (Array.isArray(bufLike)) {\n    return uint8ToBuf(new Uint8Array(bufLike));\n  }\n  if ('buffer' in bufLike) {\n    return bufFromBufLike(bufLike.buffer);\n  }\n  return uint8ToBuf(new Uint8Array(bufLike));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}