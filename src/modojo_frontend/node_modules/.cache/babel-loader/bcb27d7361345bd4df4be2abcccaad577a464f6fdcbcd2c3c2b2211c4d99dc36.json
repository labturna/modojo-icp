{"ast":null,"code":"import * as cbor from './cbor';\nimport { AgentError } from './errors';\nimport { hash } from './request_id';\nimport { bufEquals, concat, fromHex, toHex } from './utils/buffer';\nimport { Principal } from '@dfinity/principal';\nimport * as bls from './utils/bls';\nimport { decodeTime } from './utils/leb';\n/**\n * A certificate may fail verification with respect to the provided public key\n */\nexport class CertificateVerificationError extends AgentError {\n  constructor(reason) {\n    super(`Invalid certificate: ${reason}`);\n  }\n}\nexport var NodeType;\n(function (NodeType) {\n  NodeType[NodeType[\"Empty\"] = 0] = \"Empty\";\n  NodeType[NodeType[\"Fork\"] = 1] = \"Fork\";\n  NodeType[NodeType[\"Labeled\"] = 2] = \"Labeled\";\n  NodeType[NodeType[\"Leaf\"] = 3] = \"Leaf\";\n  NodeType[NodeType[\"Pruned\"] = 4] = \"Pruned\";\n})(NodeType || (NodeType = {}));\n/**\n * Make a human readable string out of a hash tree.\n * @param tree\n */\nexport function hashTreeToString(tree) {\n  const indent = s => s.split('\\n').map(x => '  ' + x).join('\\n');\n  function labelToString(label) {\n    const decoder = new TextDecoder(undefined, {\n      fatal: true\n    });\n    try {\n      return JSON.stringify(decoder.decode(label));\n    } catch (e) {\n      return `data(...${label.byteLength} bytes)`;\n    }\n  }\n  switch (tree[0]) {\n    case NodeType.Empty:\n      return '()';\n    case NodeType.Fork:\n      {\n        if (tree[1] instanceof Array && tree[2] instanceof ArrayBuffer) {\n          const left = hashTreeToString(tree[1]);\n          const right = hashTreeToString(tree[2]);\n          return `sub(\\n left:\\n${indent(left)}\\n---\\n right:\\n${indent(right)}\\n)`;\n        } else {\n          throw new Error('Invalid tree structure for fork');\n        }\n      }\n    case NodeType.Labeled:\n      {\n        if (tree[1] instanceof ArrayBuffer && tree[2] instanceof ArrayBuffer) {\n          const label = labelToString(tree[1]);\n          const sub = hashTreeToString(tree[2]);\n          return `label(\\n label:\\n${indent(label)}\\n sub:\\n${indent(sub)}\\n)`;\n        } else {\n          throw new Error('Invalid tree structure for labeled');\n        }\n      }\n    case NodeType.Leaf:\n      {\n        if (!tree[1]) {\n          throw new Error('Invalid tree structure for leaf');\n        } else if (Array.isArray(tree[1])) {\n          return JSON.stringify(tree[1]);\n        }\n        return `leaf(...${tree[1].byteLength} bytes)`;\n      }\n    case NodeType.Pruned:\n      {\n        if (!tree[1]) {\n          throw new Error('Invalid tree structure for pruned');\n        } else if (Array.isArray(tree[1])) {\n          return JSON.stringify(tree[1]);\n        }\n        return `pruned(${toHex(new Uint8Array(tree[1]))}`;\n      }\n    default:\n      {\n        return `unknown(${JSON.stringify(tree[0])})`;\n      }\n  }\n}\nfunction isBufferGreaterThan(a, b) {\n  const a8 = new Uint8Array(a);\n  const b8 = new Uint8Array(b);\n  for (let i = 0; i < a8.length; i++) {\n    if (a8[i] > b8[i]) {\n      return true;\n    }\n  }\n  return false;\n}\nexport class Certificate {\n  constructor(certificate, _rootKey, _canisterId, _blsVerify) {\n    let _maxAgeInMinutes = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 5;\n    this._rootKey = _rootKey;\n    this._canisterId = _canisterId;\n    this._blsVerify = _blsVerify;\n    this._maxAgeInMinutes = _maxAgeInMinutes;\n    this.cert = cbor.decode(new Uint8Array(certificate));\n  }\n  /**\n   * Create a new instance of a certificate, automatically verifying it. Throws a\n   * CertificateVerificationError if the certificate cannot be verified.\n   * @constructs  Certificate\n   * @param {CreateCertificateOptions} options {@link CreateCertificateOptions}\n   * @param {ArrayBuffer} options.certificate The bytes of the certificate\n   * @param {ArrayBuffer} options.rootKey The root key to verify against\n   * @param {Principal} options.canisterId The effective or signing canister ID\n   * @param {number} options.maxAgeInMinutes The maximum age of the certificate in minutes. Default is 5 minutes.\n   * @throws {CertificateVerificationError}\n   */\n  static async create(options) {\n    const cert = Certificate.createUnverified(options);\n    await cert.verify();\n    return cert;\n  }\n  static createUnverified(options) {\n    let blsVerify = options.blsVerify;\n    if (!blsVerify) {\n      blsVerify = bls.blsVerify;\n    }\n    return new Certificate(options.certificate, options.rootKey, options.canisterId, blsVerify, options.maxAgeInMinutes);\n  }\n  lookup(path) {\n    // constrain the type of the result, so that empty HashTree is undefined\n    return lookup_path(path, this.cert.tree);\n  }\n  lookup_label(label) {\n    return this.lookup([label]);\n  }\n  async verify() {\n    const rootHash = await reconstruct(this.cert.tree);\n    const derKey = await this._checkDelegationAndGetKey(this.cert.delegation);\n    const sig = this.cert.signature;\n    const key = extractDER(derKey);\n    const msg = concat(domain_sep('ic-state-root'), rootHash);\n    let sigVer = false;\n    const lookupTime = lookupResultToBuffer(this.lookup(['time']));\n    if (!lookupTime) {\n      // Should never happen - time is always present in IC certificates\n      throw new CertificateVerificationError('Certificate does not contain a time');\n    }\n    const FIVE_MINUTES_IN_MSEC = 5 * 60 * 1000;\n    const MAX_AGE_IN_MSEC = this._maxAgeInMinutes * 60 * 1000;\n    const now = Date.now();\n    const earliestCertificateTime = now - MAX_AGE_IN_MSEC;\n    const fiveMinutesFromNow = now + FIVE_MINUTES_IN_MSEC;\n    const certTime = decodeTime(lookupTime);\n    if (certTime.getTime() < earliestCertificateTime) {\n      throw new CertificateVerificationError(`Certificate is signed more than ${this._maxAgeInMinutes} minutes in the past. Certificate time: ` + certTime.toISOString() + ' Current time: ' + new Date(now).toISOString());\n    } else if (certTime.getTime() > fiveMinutesFromNow) {\n      throw new CertificateVerificationError('Certificate is signed more than 5 minutes in the future. Certificate time: ' + certTime.toISOString() + ' Current time: ' + new Date(now).toISOString());\n    }\n    try {\n      sigVer = await this._blsVerify(new Uint8Array(key), new Uint8Array(sig), new Uint8Array(msg));\n    } catch (err) {\n      sigVer = false;\n    }\n    if (!sigVer) {\n      throw new CertificateVerificationError('Signature verification failed');\n    }\n  }\n  async _checkDelegationAndGetKey(d) {\n    if (!d) {\n      return this._rootKey;\n    }\n    const cert = await Certificate.createUnverified({\n      certificate: d.certificate,\n      rootKey: this._rootKey,\n      canisterId: this._canisterId,\n      blsVerify: this._blsVerify,\n      // Do not check max age for delegation certificates\n      maxAgeInMinutes: Infinity\n    });\n    if (cert.cert.delegation) {\n      throw new CertificateVerificationError('Delegation certificates cannot be nested');\n    }\n    await cert.verify();\n    const canisterInRange = check_canister_ranges({\n      canisterId: this._canisterId,\n      subnetId: Principal.fromUint8Array(new Uint8Array(d.subnet_id)),\n      tree: cert.cert.tree\n    });\n    if (!canisterInRange) {\n      throw new CertificateVerificationError(`Canister ${this._canisterId} not in range of delegations for subnet 0x${toHex(d.subnet_id)}`);\n    }\n    const publicKeyLookup = lookupResultToBuffer(cert.lookup(['subnet', d.subnet_id, 'public_key']));\n    if (!publicKeyLookup) {\n      throw new Error(`Could not find subnet key for subnet 0x${toHex(d.subnet_id)}`);\n    }\n    return publicKeyLookup;\n  }\n}\nconst DER_PREFIX = fromHex('308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100');\nconst KEY_LENGTH = 96;\nfunction extractDER(buf) {\n  const expectedLength = DER_PREFIX.byteLength + KEY_LENGTH;\n  if (buf.byteLength !== expectedLength) {\n    throw new TypeError(`BLS DER-encoded public key must be ${expectedLength} bytes long`);\n  }\n  const prefix = buf.slice(0, DER_PREFIX.byteLength);\n  if (!bufEquals(prefix, DER_PREFIX)) {\n    throw new TypeError(`BLS DER-encoded public key is invalid. Expect the following prefix: ${DER_PREFIX}, but get ${prefix}`);\n  }\n  return buf.slice(DER_PREFIX.byteLength);\n}\n/**\n * utility function to constrain the type of a path\n * @param {ArrayBuffer | HashTree | undefined} result - the result of a lookup\n * @returns ArrayBuffer or Undefined\n */\nexport function lookupResultToBuffer(result) {\n  if (result.status !== LookupStatus.Found) {\n    return undefined;\n  }\n  if (result.value instanceof ArrayBuffer) {\n    return result.value;\n  }\n  if (result.value instanceof Uint8Array) {\n    return result.value.buffer;\n  }\n  return undefined;\n}\n/**\n * @param t\n */\nexport async function reconstruct(t) {\n  switch (t[0]) {\n    case NodeType.Empty:\n      return hash(domain_sep('ic-hashtree-empty'));\n    case NodeType.Pruned:\n      return t[1];\n    case NodeType.Leaf:\n      return hash(concat(domain_sep('ic-hashtree-leaf'), t[1]));\n    case NodeType.Labeled:\n      return hash(concat(domain_sep('ic-hashtree-labeled'), t[1], await reconstruct(t[2])));\n    case NodeType.Fork:\n      return hash(concat(domain_sep('ic-hashtree-fork'), await reconstruct(t[1]), await reconstruct(t[2])));\n    default:\n      throw new Error('unreachable');\n  }\n}\nfunction domain_sep(s) {\n  const len = new Uint8Array([s.length]);\n  const str = new TextEncoder().encode(s);\n  return concat(len, str);\n}\nexport var LookupStatus;\n(function (LookupStatus) {\n  LookupStatus[\"Unknown\"] = \"unknown\";\n  LookupStatus[\"Absent\"] = \"absent\";\n  LookupStatus[\"Found\"] = \"found\";\n})(LookupStatus || (LookupStatus = {}));\nvar LabelLookupStatus;\n(function (LabelLookupStatus) {\n  LabelLookupStatus[\"Less\"] = \"less\";\n  LabelLookupStatus[\"Greater\"] = \"greater\";\n})(LabelLookupStatus || (LabelLookupStatus = {}));\nexport function lookup_path(path, tree) {\n  if (path.length === 0) {\n    switch (tree[0]) {\n      case NodeType.Leaf:\n        {\n          if (!tree[1]) {\n            throw new Error('Invalid tree structure for leaf');\n          }\n          if (tree[1] instanceof ArrayBuffer) {\n            return {\n              status: LookupStatus.Found,\n              value: tree[1]\n            };\n          }\n          if (tree[1] instanceof Uint8Array) {\n            return {\n              status: LookupStatus.Found,\n              value: tree[1].buffer\n            };\n          }\n          return {\n            status: LookupStatus.Found,\n            value: tree[1]\n          };\n        }\n      default:\n        {\n          return {\n            status: LookupStatus.Found,\n            value: tree\n          };\n        }\n    }\n  }\n  const label = typeof path[0] === 'string' ? new TextEncoder().encode(path[0]) : path[0];\n  const lookupResult = find_label(label, tree);\n  switch (lookupResult.status) {\n    case LookupStatus.Found:\n      {\n        return lookup_path(path.slice(1), lookupResult.value);\n      }\n    case LabelLookupStatus.Greater:\n    case LabelLookupStatus.Less:\n      {\n        return {\n          status: LookupStatus.Absent\n        };\n      }\n    default:\n      {\n        return lookupResult;\n      }\n  }\n}\n/**\n * If the tree is a fork, flatten it into an array of trees\n * @param t - the tree to flatten\n * @returns HashTree[] - the flattened tree\n */\nexport function flatten_forks(t) {\n  switch (t[0]) {\n    case NodeType.Empty:\n      return [];\n    case NodeType.Fork:\n      return flatten_forks(t[1]).concat(flatten_forks(t[2]));\n    default:\n      return [t];\n  }\n}\nexport function find_label(label, tree) {\n  switch (tree[0]) {\n    // if we have a labelled node, compare the node's label to the one we are\n    // looking for\n    case NodeType.Labeled:\n      // if the label we're searching for is greater than this node's label,\n      // we need to keep searching\n      if (isBufferGreaterThan(label, tree[1])) {\n        return {\n          status: LabelLookupStatus.Greater\n        };\n      }\n      // if the label we're searching for is equal this node's label, we can\n      // stop searching and return the found node\n      if (bufEquals(label, tree[1])) {\n        return {\n          status: LookupStatus.Found,\n          value: tree[2]\n        };\n      }\n      // if the label we're searching for is not greater than or equal to this\n      // node's label, then it's less than this node's label, and we can stop\n      // searching because we've looked too far\n      return {\n        status: LabelLookupStatus.Less\n      };\n    // if we have a fork node, we need to search both sides, starting with the left\n    case NodeType.Fork:\n      // search in the left node\n      const leftLookupResult = find_label(label, tree[1]);\n      switch (leftLookupResult.status) {\n        // if the label we're searching for is greater than the left node lookup,\n        // we need to search the right node\n        case LabelLookupStatus.Greater:\n          {\n            const rightLookupResult = find_label(label, tree[2]);\n            // if the label we're searching for is less than the right node lookup,\n            // then we can stop searching and say that the label is provably Absent\n            if (rightLookupResult.status === LabelLookupStatus.Less) {\n              return {\n                status: LookupStatus.Absent\n              };\n            }\n            // if the label we're searching for is less than or equal to the right\n            // node lookup, then we let the caller handle it\n            return rightLookupResult;\n          }\n        // if the left node returns an uncertain result, we need to search the\n        // right node\n        case LookupStatus.Unknown:\n          {\n            let rightLookupResult = find_label(label, tree[2]);\n            // if the label we're searching for is less than the right node lookup,\n            // then we also need to return an uncertain result\n            if (rightLookupResult.status === LabelLookupStatus.Less) {\n              return {\n                status: LookupStatus.Unknown\n              };\n            }\n            // if the label we're searching for is less than or equal to the right\n            // node lookup, then we let the caller handle it\n            return rightLookupResult;\n          }\n        // if the label we're searching for is not greater than the left node\n        // lookup, or the result is not uncertain, we stop searching and return\n        // whatever the result of the left node lookup was, which can be either\n        // Found or Absent\n        default:\n          {\n            return leftLookupResult;\n          }\n      }\n    // if we encounter a Pruned node, we can't know for certain if the label\n    // we're searching for is present or not\n    case NodeType.Pruned:\n      return {\n        status: LookupStatus.Unknown\n      };\n    // if the current node is Empty, or a Leaf, we can stop searching because\n    // we know for sure that the label we're searching for is not present\n    default:\n      return {\n        status: LookupStatus.Absent\n      };\n  }\n}\n/**\n * Check if a canister falls within a range of canisters\n * @param canisterId Principal\n * @param ranges [Principal, Principal][]\n * @returns\n */\nexport function check_canister_ranges(params) {\n  const {\n    canisterId,\n    subnetId,\n    tree\n  } = params;\n  const rangeLookup = lookup_path(['subnet', subnetId.toUint8Array(), 'canister_ranges'], tree);\n  if (rangeLookup.status !== LookupStatus.Found || !(rangeLookup.value instanceof ArrayBuffer)) {\n    throw new Error(`Could not find canister ranges for subnet ${subnetId}`);\n  }\n  const ranges_arr = cbor.decode(rangeLookup.value);\n  const ranges = ranges_arr.map(v => [Principal.fromUint8Array(v[0]), Principal.fromUint8Array(v[1])]);\n  const canisterInRange = ranges.some(r => r[0].ltEq(canisterId) && r[1].gtEq(canisterId));\n  return canisterInRange;\n}","map":{"version":3,"names":["cbor","AgentError","hash","bufEquals","concat","fromHex","toHex","Principal","bls","decodeTime","CertificateVerificationError","constructor","reason","NodeType","hashTreeToString","tree","indent","s","split","map","x","join","labelToString","label","decoder","TextDecoder","undefined","fatal","JSON","stringify","decode","e","byteLength","Empty","Fork","Array","ArrayBuffer","left","right","Error","Labeled","sub","Leaf","isArray","Pruned","Uint8Array","isBufferGreaterThan","a","b","a8","b8","i","length","Certificate","certificate","_rootKey","_canisterId","_blsVerify","_maxAgeInMinutes","arguments","cert","create","options","createUnverified","verify","blsVerify","rootKey","canisterId","maxAgeInMinutes","lookup","path","lookup_path","lookup_label","rootHash","reconstruct","derKey","_checkDelegationAndGetKey","delegation","sig","signature","key","extractDER","msg","domain_sep","sigVer","lookupTime","lookupResultToBuffer","FIVE_MINUTES_IN_MSEC","MAX_AGE_IN_MSEC","now","Date","earliestCertificateTime","fiveMinutesFromNow","certTime","getTime","toISOString","err","d","Infinity","canisterInRange","check_canister_ranges","subnetId","fromUint8Array","subnet_id","publicKeyLookup","DER_PREFIX","KEY_LENGTH","buf","expectedLength","TypeError","prefix","slice","result","status","LookupStatus","Found","value","buffer","t","len","str","TextEncoder","encode","LabelLookupStatus","lookupResult","find_label","Greater","Less","Absent","flatten_forks","leftLookupResult","rightLookupResult","Unknown","params","rangeLookup","toUint8Array","ranges_arr","ranges","v","some","r","ltEq","gtEq"],"sources":["/home/arslan/modojo/node_modules/@dfinity/agent/src/certificate.ts"],"sourcesContent":["import * as cbor from './cbor';\nimport { AgentError } from './errors';\nimport { hash } from './request_id';\nimport { bufEquals, concat, fromHex, toHex } from './utils/buffer';\nimport { Principal } from '@dfinity/principal';\nimport * as bls from './utils/bls';\nimport { decodeTime } from './utils/leb';\n\n/**\n * A certificate may fail verification with respect to the provided public key\n */\nexport class CertificateVerificationError extends AgentError {\n  constructor(reason: string) {\n    super(`Invalid certificate: ${reason}`);\n  }\n}\n\nexport interface Cert {\n  tree: HashTree;\n  signature: ArrayBuffer;\n  delegation?: Delegation;\n}\n\nexport enum NodeType {\n  Empty = 0,\n  Fork = 1,\n  Labeled = 2,\n  Leaf = 3,\n  Pruned = 4,\n}\n\nexport type NodeLabel = ArrayBuffer | Uint8Array;\n\nexport type HashTree =\n  | [NodeType.Empty]\n  | [NodeType.Fork, HashTree, HashTree]\n  | [NodeType.Labeled, NodeLabel, HashTree]\n  | [NodeType.Leaf, NodeLabel]\n  | [NodeType.Pruned, NodeLabel];\n\n/**\n * Make a human readable string out of a hash tree.\n * @param tree\n */\nexport function hashTreeToString(tree: HashTree): string {\n  const indent = (s: string) =>\n    s\n      .split('\\n')\n      .map(x => '  ' + x)\n      .join('\\n');\n  function labelToString(label: ArrayBuffer): string {\n    const decoder = new TextDecoder(undefined, { fatal: true });\n    try {\n      return JSON.stringify(decoder.decode(label));\n    } catch (e) {\n      return `data(...${label.byteLength} bytes)`;\n    }\n  }\n\n  switch (tree[0]) {\n    case NodeType.Empty:\n      return '()';\n    case NodeType.Fork: {\n      if (tree[1] instanceof Array && tree[2] instanceof ArrayBuffer) {\n        const left = hashTreeToString(tree[1]);\n        const right = hashTreeToString(tree[2]);\n        return `sub(\\n left:\\n${indent(left)}\\n---\\n right:\\n${indent(right)}\\n)`;\n      } else {\n        throw new Error('Invalid tree structure for fork');\n      }\n    }\n    case NodeType.Labeled: {\n      if (tree[1] instanceof ArrayBuffer && tree[2] instanceof ArrayBuffer) {\n        const label = labelToString(tree[1]);\n        const sub = hashTreeToString(tree[2]);\n        return `label(\\n label:\\n${indent(label)}\\n sub:\\n${indent(sub)}\\n)`;\n      } else {\n        throw new Error('Invalid tree structure for labeled');\n      }\n    }\n    case NodeType.Leaf: {\n      if (!tree[1]) {\n        throw new Error('Invalid tree structure for leaf');\n      } else if (Array.isArray(tree[1])) {\n        return JSON.stringify(tree[1]);\n      }\n      return `leaf(...${tree[1].byteLength} bytes)`;\n    }\n    case NodeType.Pruned: {\n      if (!tree[1]) {\n        throw new Error('Invalid tree structure for pruned');\n      } else if (Array.isArray(tree[1])) {\n        return JSON.stringify(tree[1]);\n      }\n\n      return `pruned(${toHex(new Uint8Array(tree[1]))}`;\n    }\n    default: {\n      return `unknown(${JSON.stringify(tree[0])})`;\n    }\n  }\n}\n\ninterface Delegation extends Record<string, unknown> {\n  subnet_id: ArrayBuffer;\n  certificate: ArrayBuffer;\n}\n\nfunction isBufferGreaterThan(a: ArrayBuffer, b: ArrayBuffer): boolean {\n  const a8 = new Uint8Array(a);\n  const b8 = new Uint8Array(b);\n  for (let i = 0; i < a8.length; i++) {\n    if (a8[i] > b8[i]) {\n      return true;\n    }\n  }\n  return false;\n}\n\ntype VerifyFunc = (pk: Uint8Array, sig: Uint8Array, msg: Uint8Array) => Promise<boolean> | boolean;\n\nexport interface CreateCertificateOptions {\n  /**\n   * The bytes encoding the certificate to be verified\n   */\n  certificate: ArrayBuffer;\n  /**\n   * The root key against which to verify the certificate\n   * (normally, the root key of the IC main network)\n   */\n  rootKey: ArrayBuffer;\n  /**\n   * The effective canister ID of the request when verifying a response, or\n   * the signing canister ID when verifying a certified variable.\n   */\n  canisterId: Principal;\n  /**\n   * BLS Verification strategy. Default strategy uses bls12_381 from @noble/curves\n   */\n  blsVerify?: VerifyFunc;\n\n  /**\n   * The maximum age of the certificate in minutes. Default is 5 minutes.\n   * @default 5\n   * This is used to verify the time the certificate was signed, particularly for validating Delegation certificates, which can live for longer than the default window of +/- 5 minutes. If the certificate is\n   * older than the specified age, it will fail verification.\n   */\n  maxAgeInMinutes?: number;\n}\n\nexport class Certificate {\n  public cert: Cert;\n\n  /**\n   * Create a new instance of a certificate, automatically verifying it. Throws a\n   * CertificateVerificationError if the certificate cannot be verified.\n   * @constructs  Certificate\n   * @param {CreateCertificateOptions} options {@link CreateCertificateOptions}\n   * @param {ArrayBuffer} options.certificate The bytes of the certificate\n   * @param {ArrayBuffer} options.rootKey The root key to verify against\n   * @param {Principal} options.canisterId The effective or signing canister ID\n   * @param {number} options.maxAgeInMinutes The maximum age of the certificate in minutes. Default is 5 minutes.\n   * @throws {CertificateVerificationError}\n   */\n  public static async create(options: CreateCertificateOptions): Promise<Certificate> {\n    const cert = Certificate.createUnverified(options);\n\n    await cert.verify();\n    return cert;\n  }\n\n  private static createUnverified(options: CreateCertificateOptions): Certificate {\n    let blsVerify = options.blsVerify;\n    if (!blsVerify) {\n      blsVerify = bls.blsVerify;\n    }\n    return new Certificate(\n      options.certificate,\n      options.rootKey,\n      options.canisterId,\n      blsVerify,\n      options.maxAgeInMinutes,\n    );\n  }\n\n  private constructor(\n    certificate: ArrayBuffer,\n    private _rootKey: ArrayBuffer,\n    private _canisterId: Principal,\n    private _blsVerify: VerifyFunc,\n    // Default to 5 minutes\n    private _maxAgeInMinutes: number = 5,\n  ) {\n    this.cert = cbor.decode(new Uint8Array(certificate));\n  }\n\n  public lookup(path: Array<ArrayBuffer | string>): LookupResult {\n    // constrain the type of the result, so that empty HashTree is undefined\n    return lookup_path(path, this.cert.tree);\n  }\n\n  public lookup_label(label: ArrayBuffer): LookupResult {\n    return this.lookup([label]);\n  }\n\n  private async verify(): Promise<void> {\n    const rootHash = await reconstruct(this.cert.tree);\n    const derKey = await this._checkDelegationAndGetKey(this.cert.delegation);\n    const sig = this.cert.signature;\n    const key = extractDER(derKey);\n    const msg = concat(domain_sep('ic-state-root'), rootHash);\n    let sigVer = false;\n\n    const lookupTime = lookupResultToBuffer(this.lookup(['time']));\n    if (!lookupTime) {\n      // Should never happen - time is always present in IC certificates\n      throw new CertificateVerificationError('Certificate does not contain a time');\n    }\n\n    const FIVE_MINUTES_IN_MSEC = 5 * 60 * 1000;\n    const MAX_AGE_IN_MSEC = this._maxAgeInMinutes * 60 * 1000;\n    const now = Date.now();\n    const earliestCertificateTime = now - MAX_AGE_IN_MSEC;\n    const fiveMinutesFromNow = now + FIVE_MINUTES_IN_MSEC;\n\n    const certTime = decodeTime(lookupTime);\n\n    if (certTime.getTime() < earliestCertificateTime) {\n      throw new CertificateVerificationError(\n        `Certificate is signed more than ${this._maxAgeInMinutes} minutes in the past. Certificate time: ` +\n          certTime.toISOString() +\n          ' Current time: ' +\n          new Date(now).toISOString(),\n      );\n    } else if (certTime.getTime() > fiveMinutesFromNow) {\n      throw new CertificateVerificationError(\n        'Certificate is signed more than 5 minutes in the future. Certificate time: ' +\n          certTime.toISOString() +\n          ' Current time: ' +\n          new Date(now).toISOString(),\n      );\n    }\n\n    try {\n      sigVer = await this._blsVerify(new Uint8Array(key), new Uint8Array(sig), new Uint8Array(msg));\n    } catch (err) {\n      sigVer = false;\n    }\n    if (!sigVer) {\n      throw new CertificateVerificationError('Signature verification failed');\n    }\n  }\n\n  private async _checkDelegationAndGetKey(d?: Delegation): Promise<ArrayBuffer> {\n    if (!d) {\n      return this._rootKey;\n    }\n\n    const cert: Certificate = await Certificate.createUnverified({\n      certificate: d.certificate,\n      rootKey: this._rootKey,\n      canisterId: this._canisterId,\n      blsVerify: this._blsVerify,\n      // Do not check max age for delegation certificates\n      maxAgeInMinutes: Infinity,\n    });\n\n    if (cert.cert.delegation) {\n      throw new CertificateVerificationError('Delegation certificates cannot be nested');\n    }\n\n    await cert.verify();\n\n    const canisterInRange = check_canister_ranges({\n      canisterId: this._canisterId,\n      subnetId: Principal.fromUint8Array(new Uint8Array(d.subnet_id)),\n      tree: cert.cert.tree,\n    });\n    if (!canisterInRange) {\n      throw new CertificateVerificationError(\n        `Canister ${this._canisterId} not in range of delegations for subnet 0x${toHex(\n          d.subnet_id,\n        )}`,\n      );\n    }\n    const publicKeyLookup = lookupResultToBuffer(\n      cert.lookup(['subnet', d.subnet_id, 'public_key']),\n    );\n    if (!publicKeyLookup) {\n      throw new Error(`Could not find subnet key for subnet 0x${toHex(d.subnet_id)}`);\n    }\n    return publicKeyLookup;\n  }\n}\n\nconst DER_PREFIX = fromHex(\n  '308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100',\n);\nconst KEY_LENGTH = 96;\n\nfunction extractDER(buf: ArrayBuffer): ArrayBuffer {\n  const expectedLength = DER_PREFIX.byteLength + KEY_LENGTH;\n  if (buf.byteLength !== expectedLength) {\n    throw new TypeError(`BLS DER-encoded public key must be ${expectedLength} bytes long`);\n  }\n  const prefix = buf.slice(0, DER_PREFIX.byteLength);\n  if (!bufEquals(prefix, DER_PREFIX)) {\n    throw new TypeError(\n      `BLS DER-encoded public key is invalid. Expect the following prefix: ${DER_PREFIX}, but get ${prefix}`,\n    );\n  }\n\n  return buf.slice(DER_PREFIX.byteLength);\n}\n\n/**\n * utility function to constrain the type of a path\n * @param {ArrayBuffer | HashTree | undefined} result - the result of a lookup\n * @returns ArrayBuffer or Undefined\n */\nexport function lookupResultToBuffer(result: LookupResult): ArrayBuffer | undefined {\n  if (result.status !== LookupStatus.Found) {\n    return undefined;\n  }\n\n  if (result.value instanceof ArrayBuffer) {\n    return result.value;\n  }\n\n  if (result.value instanceof Uint8Array) {\n    return result.value.buffer;\n  }\n\n  return undefined;\n}\n\n/**\n * @param t\n */\nexport async function reconstruct(t: HashTree): Promise<ArrayBuffer> {\n  switch (t[0]) {\n    case NodeType.Empty:\n      return hash(domain_sep('ic-hashtree-empty'));\n    case NodeType.Pruned:\n      return t[1] as ArrayBuffer;\n    case NodeType.Leaf:\n      return hash(concat(domain_sep('ic-hashtree-leaf'), t[1] as ArrayBuffer));\n    case NodeType.Labeled:\n      return hash(\n        concat(\n          domain_sep('ic-hashtree-labeled'),\n          t[1] as ArrayBuffer,\n          await reconstruct(t[2] as HashTree),\n        ),\n      );\n    case NodeType.Fork:\n      return hash(\n        concat(\n          domain_sep('ic-hashtree-fork'),\n          await reconstruct(t[1] as HashTree),\n          await reconstruct(t[2] as HashTree),\n        ),\n      );\n    default:\n      throw new Error('unreachable');\n  }\n}\n\nfunction domain_sep(s: string): ArrayBuffer {\n  const len = new Uint8Array([s.length]);\n  const str = new TextEncoder().encode(s);\n  return concat(len, str);\n}\n\nexport enum LookupStatus {\n  Unknown = 'unknown',\n  Absent = 'absent',\n  Found = 'found',\n}\n\nexport interface LookupResultAbsent {\n  status: LookupStatus.Absent;\n}\n\nexport interface LookupResultUnknown {\n  status: LookupStatus.Unknown;\n}\n\nexport interface LookupResultFound {\n  status: LookupStatus.Found;\n  value: ArrayBuffer | HashTree;\n}\n\nexport type LookupResult = LookupResultAbsent | LookupResultUnknown | LookupResultFound;\n\nenum LabelLookupStatus {\n  Less = 'less',\n  Greater = 'greater',\n}\n\ninterface LookupResultGreater {\n  status: LabelLookupStatus.Greater;\n}\n\ninterface LookupResultLess {\n  status: LabelLookupStatus.Less;\n}\n\ntype LabelLookupResult = LookupResult | LookupResultGreater | LookupResultLess;\n\nexport function lookup_path(path: Array<ArrayBuffer | string>, tree: HashTree): LookupResult {\n  if (path.length === 0) {\n    switch (tree[0]) {\n      case NodeType.Leaf: {\n        if (!tree[1]) {\n          throw new Error('Invalid tree structure for leaf');\n        }\n\n        if (tree[1] instanceof ArrayBuffer) {\n          return {\n            status: LookupStatus.Found,\n            value: tree[1],\n          };\n        }\n\n        if (tree[1] instanceof Uint8Array) {\n          return {\n            status: LookupStatus.Found,\n            value: tree[1].buffer,\n          };\n        }\n\n        return {\n          status: LookupStatus.Found,\n          value: tree[1],\n        };\n      }\n\n      default: {\n        return {\n          status: LookupStatus.Found,\n          value: tree,\n        };\n      }\n    }\n  }\n\n  const label = typeof path[0] === 'string' ? new TextEncoder().encode(path[0]) : path[0];\n  const lookupResult = find_label(label, tree);\n\n  switch (lookupResult.status) {\n    case LookupStatus.Found: {\n      return lookup_path(path.slice(1), lookupResult.value as HashTree);\n    }\n\n    case LabelLookupStatus.Greater:\n    case LabelLookupStatus.Less: {\n      return {\n        status: LookupStatus.Absent,\n      };\n    }\n\n    default: {\n      return lookupResult;\n    }\n  }\n}\n\n/**\n * If the tree is a fork, flatten it into an array of trees\n * @param t - the tree to flatten\n * @returns HashTree[] - the flattened tree\n */\nexport function flatten_forks(t: HashTree): HashTree[] {\n  switch (t[0]) {\n    case NodeType.Empty:\n      return [];\n    case NodeType.Fork:\n      return flatten_forks(t[1] as HashTree).concat(flatten_forks(t[2] as HashTree));\n    default:\n      return [t];\n  }\n}\n\nexport function find_label(label: ArrayBuffer, tree: HashTree): LabelLookupResult {\n  switch (tree[0]) {\n    // if we have a labelled node, compare the node's label to the one we are\n    // looking for\n    case NodeType.Labeled:\n      // if the label we're searching for is greater than this node's label,\n      // we need to keep searching\n      if (isBufferGreaterThan(label, tree[1])) {\n        return {\n          status: LabelLookupStatus.Greater,\n        };\n      }\n\n      // if the label we're searching for is equal this node's label, we can\n      // stop searching and return the found node\n      if (bufEquals(label, tree[1])) {\n        return {\n          status: LookupStatus.Found,\n          value: tree[2],\n        };\n      }\n\n      // if the label we're searching for is not greater than or equal to this\n      // node's label, then it's less than this node's label, and we can stop\n      // searching because we've looked too far\n      return {\n        status: LabelLookupStatus.Less,\n      };\n\n    // if we have a fork node, we need to search both sides, starting with the left\n    case NodeType.Fork:\n      // search in the left node\n      const leftLookupResult = find_label(label, tree[1]);\n\n      switch (leftLookupResult.status) {\n        // if the label we're searching for is greater than the left node lookup,\n        // we need to search the right node\n        case LabelLookupStatus.Greater: {\n          const rightLookupResult = find_label(label, tree[2]);\n\n          // if the label we're searching for is less than the right node lookup,\n          // then we can stop searching and say that the label is provably Absent\n          if (rightLookupResult.status === LabelLookupStatus.Less) {\n            return {\n              status: LookupStatus.Absent,\n            };\n          }\n\n          // if the label we're searching for is less than or equal to the right\n          // node lookup, then we let the caller handle it\n          return rightLookupResult;\n        }\n\n        // if the left node returns an uncertain result, we need to search the\n        // right node\n        case LookupStatus.Unknown: {\n          let rightLookupResult = find_label(label, tree[2]);\n\n          // if the label we're searching for is less than the right node lookup,\n          // then we also need to return an uncertain result\n          if (rightLookupResult.status === LabelLookupStatus.Less) {\n            return {\n              status: LookupStatus.Unknown,\n            };\n          }\n\n          // if the label we're searching for is less than or equal to the right\n          // node lookup, then we let the caller handle it\n          return rightLookupResult;\n        }\n\n        // if the label we're searching for is not greater than the left node\n        // lookup, or the result is not uncertain, we stop searching and return\n        // whatever the result of the left node lookup was, which can be either\n        // Found or Absent\n        default: {\n          return leftLookupResult;\n        }\n      }\n\n    // if we encounter a Pruned node, we can't know for certain if the label\n    // we're searching for is present or not\n    case NodeType.Pruned:\n      return {\n        status: LookupStatus.Unknown,\n      };\n\n    // if the current node is Empty, or a Leaf, we can stop searching because\n    // we know for sure that the label we're searching for is not present\n    default:\n      return {\n        status: LookupStatus.Absent,\n      };\n  }\n}\n\n/**\n * Check if a canister falls within a range of canisters\n * @param canisterId Principal\n * @param ranges [Principal, Principal][]\n * @returns\n */\nexport function check_canister_ranges(params: {\n  canisterId: Principal;\n  subnetId: Principal;\n  tree: HashTree;\n}): boolean {\n  const { canisterId, subnetId, tree } = params;\n  const rangeLookup = lookup_path(['subnet', subnetId.toUint8Array(), 'canister_ranges'], tree);\n\n  if (rangeLookup.status !== LookupStatus.Found || !(rangeLookup.value instanceof ArrayBuffer)) {\n    throw new Error(`Could not find canister ranges for subnet ${subnetId}`);\n  }\n\n  const ranges_arr: Array<[Uint8Array, Uint8Array]> = cbor.decode(rangeLookup.value);\n  const ranges: Array<[Principal, Principal]> = ranges_arr.map(v => [\n    Principal.fromUint8Array(v[0]),\n    Principal.fromUint8Array(v[1]),\n  ]);\n\n  const canisterInRange = ranges.some(r => r[0].ltEq(canisterId) && r[1].gtEq(canisterId));\n\n  return canisterInRange;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}