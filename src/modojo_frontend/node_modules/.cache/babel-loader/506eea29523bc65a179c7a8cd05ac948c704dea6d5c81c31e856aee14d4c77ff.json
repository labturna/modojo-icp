{"ast":null,"code":"var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nvar _PartialDelegationIdentity_delegation;\nimport { fromHex, requestIdOf, SignIdentity, toHex } from '@dfinity/agent';\nimport { Principal } from '@dfinity/principal';\nimport * as cbor from 'simple-cbor';\nimport { PartialIdentity } from './partial';\nconst domainSeparator = new TextEncoder().encode('\\x1Aic-request-auth-delegation');\nconst requestDomainSeparator = new TextEncoder().encode('\\x0Aic-request');\nfunction _parseBlob(value) {\n  if (typeof value !== 'string' || value.length < 64) {\n    throw new Error('Invalid public key.');\n  }\n  return fromHex(value);\n}\n/**\n * A single delegation object that is signed by a private key. This is constructed by\n * `DelegationChain.create()`.\n *\n * {@see DelegationChain}\n */\nexport class Delegation {\n  constructor(pubkey, expiration, targets) {\n    this.pubkey = pubkey;\n    this.expiration = expiration;\n    this.targets = targets;\n  }\n  toCBOR() {\n    // Expiration field needs to be encoded as a u64 specifically.\n    return cbor.value.map(Object.assign({\n      pubkey: cbor.value.bytes(this.pubkey),\n      expiration: cbor.value.u64(this.expiration.toString(16), 16)\n    }, this.targets && {\n      targets: cbor.value.array(this.targets.map(t => cbor.value.bytes(t.toUint8Array())))\n    }));\n  }\n  toJSON() {\n    // every string should be hex and once-de-hexed,\n    // discoverable what it is (e.g. de-hex to get JSON with a 'type' property, or de-hex to DER\n    // with an OID). After de-hex, if it's not obvious what it is, it's an ArrayBuffer.\n    return Object.assign({\n      expiration: this.expiration.toString(16),\n      pubkey: toHex(this.pubkey)\n    }, this.targets && {\n      targets: this.targets.map(p => p.toHex())\n    });\n  }\n}\n/**\n * Sign a single delegation object for a period of time.\n * @param from The identity that lends its delegation.\n * @param to The identity that receives the delegation.\n * @param expiration An expiration date for this delegation.\n * @param targets Limit this delegation to the target principals.\n */\nasync function _createSingleDelegation(from, to, expiration, targets) {\n  const delegation = new Delegation(to.toDer(), BigInt(+expiration) * BigInt(1000000),\n  // In nanoseconds.\n  targets);\n  // The signature is calculated by signing the concatenation of the domain separator\n  // and the message.\n  // Note: To ensure Safari treats this as a user gesture, ensure to not use async methods\n  // besides the actualy webauthn functionality (such as `sign`). Safari will de-register\n  // a user gesture if you await an async call thats not fetch, xhr, or setTimeout.\n  const challenge = new Uint8Array([...domainSeparator, ...new Uint8Array(requestIdOf(delegation))]);\n  const signature = await from.sign(challenge);\n  return {\n    delegation,\n    signature\n  };\n}\n/**\n * A chain of delegations. This is JSON Serializable.\n * This is the object to serialize and pass to a DelegationIdentity. It does not keep any\n * private keys.\n */\nexport class DelegationChain {\n  constructor(delegations, publicKey) {\n    this.delegations = delegations;\n    this.publicKey = publicKey;\n  }\n  /**\n   * Create a delegation chain between two (or more) keys. By default, the expiration time\n   * will be very short (15 minutes).\n   *\n   * To build a chain of more than 2 identities, this function needs to be called multiple times,\n   * passing the previous delegation chain into the options argument. For example:\n   * @example\n   * const rootKey = createKey();\n   * const middleKey = createKey();\n   * const bottomeKey = createKey();\n   *\n   * const rootToMiddle = await DelegationChain.create(\n   *   root, middle.getPublicKey(), Date.parse('2100-01-01'),\n   * );\n   * const middleToBottom = await DelegationChain.create(\n   *   middle, bottom.getPublicKey(), Date.parse('2100-01-01'), { previous: rootToMiddle },\n   * );\n   *\n   * // We can now use a delegation identity that uses the delegation above:\n   * const identity = DelegationIdentity.fromDelegation(bottomKey, middleToBottom);\n   * @param from The identity that will delegate.\n   * @param to The identity that gets delegated. It can now sign messages as if it was the\n   *           identity above.\n   * @param expiration The length the delegation is valid. By default, 15 minutes from calling\n   *                   this function.\n   * @param options A set of options for this delegation. expiration and previous\n   * @param options.previous - Another DelegationChain that this chain should start with.\n   * @param options.targets - targets that scope the delegation (e.g. Canister Principals)\n   */\n  static async create(from, to) {\n    let expiration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Date(Date.now() + 15 * 60 * 1000);\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var _a, _b;\n    const delegation = await _createSingleDelegation(from, to, expiration, options.targets);\n    return new DelegationChain([...(((_a = options.previous) === null || _a === void 0 ? void 0 : _a.delegations) || []), delegation], ((_b = options.previous) === null || _b === void 0 ? void 0 : _b.publicKey) || from.getPublicKey().toDer());\n  }\n  /**\n   * Creates a DelegationChain object from a JSON string.\n   * @param json The JSON string to parse.\n   */\n  static fromJSON(json) {\n    const {\n      publicKey,\n      delegations\n    } = typeof json === 'string' ? JSON.parse(json) : json;\n    if (!Array.isArray(delegations)) {\n      throw new Error('Invalid delegations.');\n    }\n    const parsedDelegations = delegations.map(signedDelegation => {\n      const {\n        delegation,\n        signature\n      } = signedDelegation;\n      const {\n        pubkey,\n        expiration,\n        targets\n      } = delegation;\n      if (targets !== undefined && !Array.isArray(targets)) {\n        throw new Error('Invalid targets.');\n      }\n      return {\n        delegation: new Delegation(_parseBlob(pubkey), BigInt('0x' + expiration),\n        // expiration in JSON is an hexa string (See toJSON() below).\n        targets && targets.map(t => {\n          if (typeof t !== 'string') {\n            throw new Error('Invalid target.');\n          }\n          return Principal.fromHex(t);\n        })),\n        signature: _parseBlob(signature)\n      };\n    });\n    return new this(parsedDelegations, _parseBlob(publicKey));\n  }\n  /**\n   * Creates a DelegationChain object from a list of delegations and a DER-encoded public key.\n   * @param delegations The list of delegations.\n   * @param publicKey The DER-encoded public key of the key-pair signing the first delegation.\n   */\n  static fromDelegations(delegations, publicKey) {\n    return new this(delegations, publicKey);\n  }\n  toJSON() {\n    return {\n      delegations: this.delegations.map(signedDelegation => {\n        const {\n          delegation,\n          signature\n        } = signedDelegation;\n        const {\n          targets\n        } = delegation;\n        return {\n          delegation: Object.assign({\n            expiration: delegation.expiration.toString(16),\n            pubkey: toHex(delegation.pubkey)\n          }, targets && {\n            targets: targets.map(t => t.toHex())\n          }),\n          signature: toHex(signature)\n        };\n      }),\n      publicKey: toHex(this.publicKey)\n    };\n  }\n}\n/**\n * An Identity that adds delegation to a request. Everywhere in this class, the name\n * innerKey refers to the SignIdentity that is being used to sign the requests, while\n * originalKey is the identity that is being borrowed. More identities can be used\n * in the middle to delegate.\n */\nexport class DelegationIdentity extends SignIdentity {\n  constructor(_inner, _delegation) {\n    super();\n    this._inner = _inner;\n    this._delegation = _delegation;\n  }\n  /**\n   * Create a delegation without having access to delegateKey.\n   * @param key The key used to sign the reqyests.\n   * @param delegation A delegation object created using `createDelegation`.\n   */\n  static fromDelegation(key, delegation) {\n    return new this(key, delegation);\n  }\n  getDelegation() {\n    return this._delegation;\n  }\n  getPublicKey() {\n    return {\n      derKey: this._delegation.publicKey,\n      toDer: () => this._delegation.publicKey\n    };\n  }\n  sign(blob) {\n    return this._inner.sign(blob);\n  }\n  async transformRequest(request) {\n    const {\n        body\n      } = request,\n      fields = __rest(request, [\"body\"]);\n    const requestId = await requestIdOf(body);\n    return Object.assign(Object.assign({}, fields), {\n      body: {\n        content: body,\n        sender_sig: await this.sign(new Uint8Array([...requestDomainSeparator, ...new Uint8Array(requestId)])),\n        sender_delegation: this._delegation.delegations,\n        sender_pubkey: this._delegation.publicKey\n      }\n    });\n  }\n}\n/**\n * A partial delegated identity, representing a delegation chain and the public key that it targets\n */\nexport class PartialDelegationIdentity extends PartialIdentity {\n  constructor(inner, delegation) {\n    super(inner);\n    _PartialDelegationIdentity_delegation.set(this, void 0);\n    __classPrivateFieldSet(this, _PartialDelegationIdentity_delegation, delegation, \"f\");\n  }\n  /**\n   * The Delegation Chain of this identity.\n   */\n  get delegation() {\n    return __classPrivateFieldGet(this, _PartialDelegationIdentity_delegation, \"f\");\n  }\n  /**\n   * Create a {@link PartialDelegationIdentity} from a {@link PublicKey} and a {@link DelegationChain}.\n   * @param key The {@link PublicKey} to delegate to.\n   * @param delegation a {@link DelegationChain} targeting the inner key.\n   * @constructs PartialDelegationIdentity\n   */\n  static fromDelegation(key, delegation) {\n    return new PartialDelegationIdentity(key, delegation);\n  }\n}\n_PartialDelegationIdentity_delegation = new WeakMap();\n/**\n * Analyze a DelegationChain and validate that it's valid, ie. not expired and apply to the\n * scope.\n * @param chain The chain to validate.\n * @param checks Various checks to validate on the chain.\n */\nexport function isDelegationValid(chain, checks) {\n  // Verify that the no delegation is expired. If any are in the chain, returns false.\n  for (const {\n    delegation\n  } of chain.delegations) {\n    // prettier-ignore\n    if (+new Date(Number(delegation.expiration / BigInt(1000000))) <= +Date.now()) {\n      return false;\n    }\n  }\n  // Check the scopes.\n  const scopes = [];\n  const maybeScope = checks === null || checks === void 0 ? void 0 : checks.scope;\n  if (maybeScope) {\n    if (Array.isArray(maybeScope)) {\n      scopes.push(...maybeScope.map(s => typeof s === 'string' ? Principal.fromText(s) : s));\n    } else {\n      scopes.push(typeof maybeScope === 'string' ? Principal.fromText(maybeScope) : maybeScope);\n    }\n  }\n  for (const s of scopes) {\n    const scope = s.toText();\n    for (const {\n      delegation\n    } of chain.delegations) {\n      if (delegation.targets === undefined) {\n        continue;\n      }\n      let none = true;\n      for (const target of delegation.targets) {\n        if (target.toText() === scope) {\n          none = false;\n          break;\n        }\n      }\n      if (none) {\n        return false;\n      }\n    }\n  }\n  return true;\n}","map":{"version":3,"names":["fromHex","requestIdOf","SignIdentity","toHex","Principal","cbor","PartialIdentity","domainSeparator","TextEncoder","encode","requestDomainSeparator","_parseBlob","value","length","Error","Delegation","constructor","pubkey","expiration","targets","toCBOR","map","Object","assign","bytes","u64","toString","array","t","toUint8Array","toJSON","p","_createSingleDelegation","from","to","delegation","toDer","BigInt","challenge","Uint8Array","signature","sign","DelegationChain","delegations","publicKey","create","arguments","undefined","Date","now","options","_a","previous","_b","getPublicKey","fromJSON","json","JSON","parse","Array","isArray","parsedDelegations","signedDelegation","fromDelegations","DelegationIdentity","_inner","_delegation","fromDelegation","key","getDelegation","derKey","blob","transformRequest","request","body","fields","__rest","requestId","content","sender_sig","sender_delegation","sender_pubkey","PartialDelegationIdentity","inner","_PartialDelegationIdentity_delegation","set","__classPrivateFieldSet","__classPrivateFieldGet","isDelegationValid","chain","checks","Number","scopes","maybeScope","scope","push","s","fromText","toText","none","target"],"sources":["/home/arslan/modojo/node_modules/@dfinity/identity/src/identity/delegation.ts"],"sourcesContent":["import {\n  DerEncodedPublicKey,\n  fromHex,\n  HttpAgentRequest,\n  PublicKey,\n  requestIdOf,\n  Signature,\n  SignIdentity,\n  toHex,\n} from '@dfinity/agent';\nimport { Principal } from '@dfinity/principal';\nimport * as cbor from 'simple-cbor';\nimport { PartialIdentity } from './partial';\n\nconst domainSeparator = new TextEncoder().encode('\\x1Aic-request-auth-delegation');\nconst requestDomainSeparator = new TextEncoder().encode('\\x0Aic-request');\n\nfunction _parseBlob(value: unknown): ArrayBuffer {\n  if (typeof value !== 'string' || value.length < 64) {\n    throw new Error('Invalid public key.');\n  }\n\n  return fromHex(value);\n}\n\n/**\n * A single delegation object that is signed by a private key. This is constructed by\n * `DelegationChain.create()`.\n *\n * {@see DelegationChain}\n */\nexport class Delegation {\n  constructor(\n    public readonly pubkey: ArrayBuffer,\n    public readonly expiration: bigint,\n    public readonly targets?: Principal[],\n  ) {}\n\n  public toCBOR(): cbor.CborValue {\n    // Expiration field needs to be encoded as a u64 specifically.\n    return cbor.value.map({\n      pubkey: cbor.value.bytes(this.pubkey),\n      expiration: cbor.value.u64(this.expiration.toString(16), 16),\n      ...(this.targets && {\n        targets: cbor.value.array(this.targets.map(t => cbor.value.bytes(t.toUint8Array()))),\n      }),\n    });\n  }\n\n  public toJSON(): JsonnableDelegation {\n    // every string should be hex and once-de-hexed,\n    // discoverable what it is (e.g. de-hex to get JSON with a 'type' property, or de-hex to DER\n    // with an OID). After de-hex, if it's not obvious what it is, it's an ArrayBuffer.\n    return {\n      expiration: this.expiration.toString(16),\n      pubkey: toHex(this.pubkey),\n      ...(this.targets && { targets: this.targets.map(p => p.toHex()) }),\n    };\n  }\n}\n\n/**\n * Type of ReturnType<Delegation.toJSON>.\n * The goal here is to stringify all non-JSON-compatible types to some bytes representation we can\n * stringify as hex.\n * (Hex shouldn't be ambiguous ever, because you can encode as DER with semantic OIDs).\n */\ninterface JsonnableDelegation {\n  // A BigInt of Nanoseconds since epoch as hex\n  expiration: string;\n  // Hexadecimal representation of the DER public key.\n  pubkey: string;\n  // Array of strings, where each string is hex of principal blob (*NOT* textual representation).\n  targets?: string[];\n}\n\n/**\n * A signed delegation, which lends its identity to the public key in the delegation\n * object. This is constructed by `DelegationChain.create()`.\n *\n * {@see DelegationChain}\n */\nexport interface SignedDelegation {\n  delegation: Delegation;\n  signature: Signature;\n}\n\n/**\n * Sign a single delegation object for a period of time.\n * @param from The identity that lends its delegation.\n * @param to The identity that receives the delegation.\n * @param expiration An expiration date for this delegation.\n * @param targets Limit this delegation to the target principals.\n */\nasync function _createSingleDelegation(\n  from: SignIdentity,\n  to: PublicKey,\n  expiration: Date,\n  targets?: Principal[],\n): Promise<SignedDelegation> {\n  const delegation: Delegation = new Delegation(\n    to.toDer(),\n    BigInt(+expiration) * BigInt(1000000), // In nanoseconds.\n    targets,\n  );\n  // The signature is calculated by signing the concatenation of the domain separator\n  // and the message.\n  // Note: To ensure Safari treats this as a user gesture, ensure to not use async methods\n  // besides the actualy webauthn functionality (such as `sign`). Safari will de-register\n  // a user gesture if you await an async call thats not fetch, xhr, or setTimeout.\n  const challenge = new Uint8Array([\n    ...domainSeparator,\n    ...new Uint8Array(requestIdOf(delegation)),\n  ]);\n  const signature = await from.sign(challenge);\n\n  return {\n    delegation,\n    signature,\n  };\n}\n\nexport interface JsonnableDelegationChain {\n  publicKey: string;\n  delegations: Array<{\n    signature: string;\n    delegation: {\n      pubkey: string;\n      expiration: string;\n      targets?: string[];\n    };\n  }>;\n}\n\n/**\n * A chain of delegations. This is JSON Serializable.\n * This is the object to serialize and pass to a DelegationIdentity. It does not keep any\n * private keys.\n */\nexport class DelegationChain {\n  /**\n   * Create a delegation chain between two (or more) keys. By default, the expiration time\n   * will be very short (15 minutes).\n   *\n   * To build a chain of more than 2 identities, this function needs to be called multiple times,\n   * passing the previous delegation chain into the options argument. For example:\n   * @example\n   * const rootKey = createKey();\n   * const middleKey = createKey();\n   * const bottomeKey = createKey();\n   *\n   * const rootToMiddle = await DelegationChain.create(\n   *   root, middle.getPublicKey(), Date.parse('2100-01-01'),\n   * );\n   * const middleToBottom = await DelegationChain.create(\n   *   middle, bottom.getPublicKey(), Date.parse('2100-01-01'), { previous: rootToMiddle },\n   * );\n   *\n   * // We can now use a delegation identity that uses the delegation above:\n   * const identity = DelegationIdentity.fromDelegation(bottomKey, middleToBottom);\n   * @param from The identity that will delegate.\n   * @param to The identity that gets delegated. It can now sign messages as if it was the\n   *           identity above.\n   * @param expiration The length the delegation is valid. By default, 15 minutes from calling\n   *                   this function.\n   * @param options A set of options for this delegation. expiration and previous\n   * @param options.previous - Another DelegationChain that this chain should start with.\n   * @param options.targets - targets that scope the delegation (e.g. Canister Principals)\n   */\n  public static async create(\n    from: SignIdentity,\n    to: PublicKey,\n    expiration: Date = new Date(Date.now() + 15 * 60 * 1000),\n    options: {\n      previous?: DelegationChain;\n      targets?: Principal[];\n    } = {},\n  ): Promise<DelegationChain> {\n    const delegation = await _createSingleDelegation(from, to, expiration, options.targets);\n    return new DelegationChain(\n      [...(options.previous?.delegations || []), delegation],\n      options.previous?.publicKey || from.getPublicKey().toDer(),\n    );\n  }\n\n  /**\n   * Creates a DelegationChain object from a JSON string.\n   * @param json The JSON string to parse.\n   */\n  public static fromJSON(json: string | JsonnableDelegationChain): DelegationChain {\n    const { publicKey, delegations } = typeof json === 'string' ? JSON.parse(json) : json;\n    if (!Array.isArray(delegations)) {\n      throw new Error('Invalid delegations.');\n    }\n\n    const parsedDelegations: SignedDelegation[] = delegations.map(signedDelegation => {\n      const { delegation, signature } = signedDelegation;\n      const { pubkey, expiration, targets } = delegation;\n      if (targets !== undefined && !Array.isArray(targets)) {\n        throw new Error('Invalid targets.');\n      }\n\n      return {\n        delegation: new Delegation(\n          _parseBlob(pubkey),\n          BigInt('0x' + expiration), // expiration in JSON is an hexa string (See toJSON() below).\n          targets &&\n            targets.map((t: unknown) => {\n              if (typeof t !== 'string') {\n                throw new Error('Invalid target.');\n              }\n              return Principal.fromHex(t);\n            }),\n        ),\n        signature: _parseBlob(signature) as Signature,\n      };\n    });\n\n    return new this(parsedDelegations, _parseBlob(publicKey) as DerEncodedPublicKey);\n  }\n\n  /**\n   * Creates a DelegationChain object from a list of delegations and a DER-encoded public key.\n   * @param delegations The list of delegations.\n   * @param publicKey The DER-encoded public key of the key-pair signing the first delegation.\n   */\n  public static fromDelegations(\n    delegations: SignedDelegation[],\n    publicKey: DerEncodedPublicKey,\n  ): DelegationChain {\n    return new this(delegations, publicKey);\n  }\n\n  protected constructor(\n    public readonly delegations: SignedDelegation[],\n    public readonly publicKey: DerEncodedPublicKey,\n  ) {}\n\n  public toJSON(): JsonnableDelegationChain {\n    return {\n      delegations: this.delegations.map(signedDelegation => {\n        const { delegation, signature } = signedDelegation;\n        const { targets } = delegation;\n        return {\n          delegation: {\n            expiration: delegation.expiration.toString(16),\n            pubkey: toHex(delegation.pubkey),\n            ...(targets && {\n              targets: targets.map(t => t.toHex()),\n            }),\n          },\n          signature: toHex(signature),\n        };\n      }),\n      publicKey: toHex(this.publicKey),\n    };\n  }\n}\n\n/**\n * An Identity that adds delegation to a request. Everywhere in this class, the name\n * innerKey refers to the SignIdentity that is being used to sign the requests, while\n * originalKey is the identity that is being borrowed. More identities can be used\n * in the middle to delegate.\n */\nexport class DelegationIdentity extends SignIdentity {\n  /**\n   * Create a delegation without having access to delegateKey.\n   * @param key The key used to sign the reqyests.\n   * @param delegation A delegation object created using `createDelegation`.\n   */\n  public static fromDelegation(\n    key: Pick<SignIdentity, 'sign'>,\n    delegation: DelegationChain,\n  ): DelegationIdentity {\n    return new this(key, delegation);\n  }\n\n  protected constructor(\n    private _inner: Pick<SignIdentity, 'sign'>,\n    private _delegation: DelegationChain,\n  ) {\n    super();\n  }\n\n  public getDelegation(): DelegationChain {\n    return this._delegation;\n  }\n\n  public getPublicKey(): PublicKey {\n    return {\n      derKey: this._delegation.publicKey,\n      toDer: () => this._delegation.publicKey,\n    };\n  }\n  public sign(blob: ArrayBuffer): Promise<Signature> {\n    return this._inner.sign(blob);\n  }\n\n  public async transformRequest(request: HttpAgentRequest): Promise<unknown> {\n    const { body, ...fields } = request;\n    const requestId = await requestIdOf(body);\n    return {\n      ...fields,\n      body: {\n        content: body,\n        sender_sig: await this.sign(\n          new Uint8Array([...requestDomainSeparator, ...new Uint8Array(requestId)]),\n        ),\n        sender_delegation: this._delegation.delegations,\n        sender_pubkey: this._delegation.publicKey,\n      },\n    };\n  }\n}\n\n/**\n * A partial delegated identity, representing a delegation chain and the public key that it targets\n */\nexport class PartialDelegationIdentity extends PartialIdentity {\n  #delegation: DelegationChain;\n\n  /**\n   * The Delegation Chain of this identity.\n   */\n  get delegation(): DelegationChain {\n    return this.#delegation;\n  }\n\n  private constructor(inner: PublicKey, delegation: DelegationChain) {\n    super(inner);\n    this.#delegation = delegation;\n  }\n\n  /**\n   * Create a {@link PartialDelegationIdentity} from a {@link PublicKey} and a {@link DelegationChain}.\n   * @param key The {@link PublicKey} to delegate to.\n   * @param delegation a {@link DelegationChain} targeting the inner key.\n   * @constructs PartialDelegationIdentity\n   */\n  public static fromDelegation(key: PublicKey, delegation: DelegationChain) {\n    return new PartialDelegationIdentity(key, delegation);\n  }\n}\n\n/**\n * List of things to check for a delegation chain validity.\n */\nexport interface DelegationValidChecks {\n  /**\n   * Check that the scope is amongst the scopes that this delegation has access to.\n   */\n  scope?: Principal | string | Array<Principal | string>;\n}\n\n/**\n * Analyze a DelegationChain and validate that it's valid, ie. not expired and apply to the\n * scope.\n * @param chain The chain to validate.\n * @param checks Various checks to validate on the chain.\n */\nexport function isDelegationValid(chain: DelegationChain, checks?: DelegationValidChecks): boolean {\n  // Verify that the no delegation is expired. If any are in the chain, returns false.\n  for (const { delegation } of chain.delegations) {\n    // prettier-ignore\n    if (+new Date(Number(delegation.expiration / BigInt(1000000))) <= +Date.now()) {\n      return false;\n    }\n  }\n\n  // Check the scopes.\n  const scopes: Principal[] = [];\n  const maybeScope = checks?.scope;\n  if (maybeScope) {\n    if (Array.isArray(maybeScope)) {\n      scopes.push(...maybeScope.map(s => (typeof s === 'string' ? Principal.fromText(s) : s)));\n    } else {\n      scopes.push(typeof maybeScope === 'string' ? Principal.fromText(maybeScope) : maybeScope);\n    }\n  }\n\n  for (const s of scopes) {\n    const scope = s.toText();\n    for (const { delegation } of chain.delegations) {\n      if (delegation.targets === undefined) {\n        continue;\n      }\n\n      let none = true;\n      for (const target of delegation.targets) {\n        if (target.toText() === scope) {\n          none = false;\n          break;\n        }\n      }\n      if (none) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}