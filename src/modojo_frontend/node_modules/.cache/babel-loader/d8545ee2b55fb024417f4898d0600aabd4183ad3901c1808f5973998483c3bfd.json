{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CallbackIterable, compareBy } from '../../../../base/common/arrays.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable, DisposableStore, MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { Range } from '../../core/range.js';\nimport { ignoreBracketsInToken } from '../../languages/supports.js';\nimport { BracketsUtils } from '../../languages/supports/richEditBrackets.js';\nimport { BracketPairsTree } from './bracketPairsTree/bracketPairsTree.js';\nexport class BracketPairsTextModelPart extends Disposable {\n  get canBuildAST() {\n    const maxSupportedDocumentLength = /* max lines */50000 * /* average column count */100;\n    return this.textModel.getValueLength() <= maxSupportedDocumentLength;\n  }\n  constructor(textModel, languageConfigurationService) {\n    super();\n    this.textModel = textModel;\n    this.languageConfigurationService = languageConfigurationService;\n    this.bracketPairsTree = this._register(new MutableDisposable());\n    this.onDidChangeEmitter = new Emitter();\n    this.onDidChange = this.onDidChangeEmitter.event;\n    this.bracketsRequested = false;\n    this._register(this.languageConfigurationService.onDidChange(e => {\n      var _a;\n      if (!e.languageId || ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.didLanguageChange(e.languageId))) {\n        this.bracketPairsTree.clear();\n        this.updateBracketPairsTree();\n      }\n    }));\n  }\n  //#region TextModel events\n  handleDidChangeOptions(e) {\n    this.bracketPairsTree.clear();\n    this.updateBracketPairsTree();\n  }\n  handleDidChangeLanguage(e) {\n    this.bracketPairsTree.clear();\n    this.updateBracketPairsTree();\n  }\n  handleDidChangeContent(change) {\n    var _a;\n    (_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.handleContentChanged(change);\n  }\n  handleDidChangeBackgroundTokenizationState() {\n    var _a;\n    (_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.handleDidChangeBackgroundTokenizationState();\n  }\n  handleDidChangeTokens(e) {\n    var _a;\n    (_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.handleDidChangeTokens(e);\n  }\n  //#endregion\n  updateBracketPairsTree() {\n    if (this.bracketsRequested && this.canBuildAST) {\n      if (!this.bracketPairsTree.value) {\n        const store = new DisposableStore();\n        this.bracketPairsTree.value = createDisposableRef(store.add(new BracketPairsTree(this.textModel, languageId => {\n          return this.languageConfigurationService.getLanguageConfiguration(languageId);\n        })), store);\n        store.add(this.bracketPairsTree.value.object.onDidChange(e => this.onDidChangeEmitter.fire(e)));\n        this.onDidChangeEmitter.fire();\n      }\n    } else {\n      if (this.bracketPairsTree.value) {\n        this.bracketPairsTree.clear();\n        // Important: Don't call fire if there was no change!\n        this.onDidChangeEmitter.fire();\n      }\n    }\n  }\n  /**\n   * Returns all bracket pairs that intersect the given range.\n   * The result is sorted by the start position.\n  */\n  getBracketPairsInRange(range) {\n    var _a;\n    this.bracketsRequested = true;\n    this.updateBracketPairsTree();\n    return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getBracketPairsInRange(range, false)) || CallbackIterable.empty;\n  }\n  getBracketPairsInRangeWithMinIndentation(range) {\n    var _a;\n    this.bracketsRequested = true;\n    this.updateBracketPairsTree();\n    return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getBracketPairsInRange(range, true)) || CallbackIterable.empty;\n  }\n  getBracketsInRange(range) {\n    let onlyColorizedBrackets = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var _a;\n    this.bracketsRequested = true;\n    this.updateBracketPairsTree();\n    return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getBracketsInRange(range, onlyColorizedBrackets)) || CallbackIterable.empty;\n  }\n  findMatchingBracketUp(_bracket, _position, maxDuration) {\n    const position = this.textModel.validatePosition(_position);\n    const languageId = this.textModel.getLanguageIdAtPosition(position.lineNumber, position.column);\n    if (this.canBuildAST) {\n      const closingBracketInfo = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew.getClosingBracketInfo(_bracket);\n      if (!closingBracketInfo) {\n        return null;\n      }\n      const bracketPair = this.getBracketPairsInRange(Range.fromPositions(_position, _position)).findLast(b => closingBracketInfo.closes(b.openingBracketInfo));\n      if (bracketPair) {\n        return bracketPair.openingBracketRange;\n      }\n      return null;\n    } else {\n      // Fallback to old bracket matching code:\n      const bracket = _bracket.toLowerCase();\n      const bracketsSupport = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n      if (!bracketsSupport) {\n        return null;\n      }\n      const data = bracketsSupport.textIsBracket[bracket];\n      if (!data) {\n        return null;\n      }\n      return stripBracketSearchCanceled(this._findMatchingBracketUp(data, position, createTimeBasedContinueBracketSearchPredicate(maxDuration)));\n    }\n  }\n  matchBracket(position, maxDuration) {\n    if (this.canBuildAST) {\n      const bracketPair = this.getBracketPairsInRange(Range.fromPositions(position, position)).filter(item => item.closingBracketRange !== undefined && (item.openingBracketRange.containsPosition(position) || item.closingBracketRange.containsPosition(position))).findLastMaxBy(compareBy(item => item.openingBracketRange.containsPosition(position) ? item.openingBracketRange : item.closingBracketRange, Range.compareRangesUsingStarts));\n      if (bracketPair) {\n        return [bracketPair.openingBracketRange, bracketPair.closingBracketRange];\n      }\n      return null;\n    } else {\n      // Fallback to old bracket matching code:\n      const continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);\n      return this._matchBracket(this.textModel.validatePosition(position), continueSearchPredicate);\n    }\n  }\n  _establishBracketSearchOffsets(position, lineTokens, modeBrackets, tokenIndex) {\n    const tokenCount = lineTokens.getCount();\n    const currentLanguageId = lineTokens.getLanguageId(tokenIndex);\n    // limit search to not go before `maxBracketLength`\n    let searchStartOffset = Math.max(0, position.column - 1 - modeBrackets.maxBracketLength);\n    for (let i = tokenIndex - 1; i >= 0; i--) {\n      const tokenEndOffset = lineTokens.getEndOffset(i);\n      if (tokenEndOffset <= searchStartOffset) {\n        break;\n      }\n      if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n        searchStartOffset = tokenEndOffset;\n        break;\n      }\n    }\n    // limit search to not go after `maxBracketLength`\n    let searchEndOffset = Math.min(lineTokens.getLineContent().length, position.column - 1 + modeBrackets.maxBracketLength);\n    for (let i = tokenIndex + 1; i < tokenCount; i++) {\n      const tokenStartOffset = lineTokens.getStartOffset(i);\n      if (tokenStartOffset >= searchEndOffset) {\n        break;\n      }\n      if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n        searchEndOffset = tokenStartOffset;\n        break;\n      }\n    }\n    return {\n      searchStartOffset,\n      searchEndOffset\n    };\n  }\n  _matchBracket(position, continueSearchPredicate) {\n    const lineNumber = position.lineNumber;\n    const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n    const lineText = this.textModel.getLineContent(lineNumber);\n    const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n    if (tokenIndex < 0) {\n      return null;\n    }\n    const currentModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).brackets;\n    // check that the token is not to be ignored\n    if (currentModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {\n      let {\n        searchStartOffset,\n        searchEndOffset\n      } = this._establishBracketSearchOffsets(position, lineTokens, currentModeBrackets, tokenIndex);\n      // it might be the case that [currentTokenStart -> currentTokenEnd] contains multiple brackets\n      // `bestResult` will contain the most right-side result\n      let bestResult = null;\n      while (true) {\n        const foundBracket = BracketsUtils.findNextBracketInRange(currentModeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n        if (!foundBracket) {\n          // there are no more brackets in this text\n          break;\n        }\n        // check that we didn't hit a bracket too far away from position\n        if (foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n          const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n          const r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);\n          if (r) {\n            if (r instanceof BracketSearchCanceled) {\n              return null;\n            }\n            bestResult = r;\n          }\n        }\n        searchStartOffset = foundBracket.endColumn - 1;\n      }\n      if (bestResult) {\n        return bestResult;\n      }\n    }\n    // If position is in between two tokens, try also looking in the previous token\n    if (tokenIndex > 0 && lineTokens.getStartOffset(tokenIndex) === position.column - 1) {\n      const prevTokenIndex = tokenIndex - 1;\n      const prevModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(prevTokenIndex)).brackets;\n      // check that previous token is not to be ignored\n      if (prevModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(prevTokenIndex))) {\n        const {\n          searchStartOffset,\n          searchEndOffset\n        } = this._establishBracketSearchOffsets(position, lineTokens, prevModeBrackets, prevTokenIndex);\n        const foundBracket = BracketsUtils.findPrevBracketInRange(prevModeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n        // check that we didn't hit a bracket too far away from position\n        if (foundBracket && foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n          const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n          const r = this._matchFoundBracket(foundBracket, prevModeBrackets.textIsBracket[foundBracketText], prevModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);\n          if (r) {\n            if (r instanceof BracketSearchCanceled) {\n              return null;\n            }\n            return r;\n          }\n        }\n      }\n    }\n    return null;\n  }\n  _matchFoundBracket(foundBracket, data, isOpen, continueSearchPredicate) {\n    if (!data) {\n      return null;\n    }\n    const matched = isOpen ? this._findMatchingBracketDown(data, foundBracket.getEndPosition(), continueSearchPredicate) : this._findMatchingBracketUp(data, foundBracket.getStartPosition(), continueSearchPredicate);\n    if (!matched) {\n      return null;\n    }\n    if (matched instanceof BracketSearchCanceled) {\n      return matched;\n    }\n    return [foundBracket, matched];\n  }\n  _findMatchingBracketUp(bracket, position, continueSearchPredicate) {\n    // console.log('_findMatchingBracketUp: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n    const languageId = bracket.languageId;\n    const reversedBracketRegex = bracket.reversedRegex;\n    let count = -1;\n    let totalCallCount = 0;\n    const searchPrevMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n      while (true) {\n        if (continueSearchPredicate && ++totalCallCount % 100 === 0 && !continueSearchPredicate()) {\n          return BracketSearchCanceled.INSTANCE;\n        }\n        const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n        if (!r) {\n          break;\n        }\n        const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n        if (bracket.isOpen(hitText)) {\n          count++;\n        } else if (bracket.isClose(hitText)) {\n          count--;\n        }\n        if (count === 0) {\n          return r;\n        }\n        searchEndOffset = r.startColumn - 1;\n      }\n      return null;\n    };\n    for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n      const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n      const tokenCount = lineTokens.getCount();\n      const lineText = this.textModel.getLineContent(lineNumber);\n      let tokenIndex = tokenCount - 1;\n      let searchStartOffset = lineText.length;\n      let searchEndOffset = lineText.length;\n      if (lineNumber === position.lineNumber) {\n        tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        searchStartOffset = position.column - 1;\n        searchEndOffset = position.column - 1;\n      }\n      let prevSearchInToken = true;\n      for (; tokenIndex >= 0; tokenIndex--) {\n        const searchInToken = lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));\n        if (searchInToken) {\n          // this token should be searched\n          if (prevSearchInToken) {\n            // the previous token should be searched, simply extend searchStartOffset\n            searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n          } else {\n            // the previous token should not be searched\n            searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n            searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n          }\n        } else {\n          // this token should not be searched\n          if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n            const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n            if (r) {\n              return r;\n            }\n          }\n        }\n        prevSearchInToken = searchInToken;\n      }\n      if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n        const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n        if (r) {\n          return r;\n        }\n      }\n    }\n    return null;\n  }\n  _findMatchingBracketDown(bracket, position, continueSearchPredicate) {\n    // console.log('_findMatchingBracketDown: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n    const languageId = bracket.languageId;\n    const bracketRegex = bracket.forwardRegex;\n    let count = 1;\n    let totalCallCount = 0;\n    const searchNextMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n      while (true) {\n        if (continueSearchPredicate && ++totalCallCount % 100 === 0 && !continueSearchPredicate()) {\n          return BracketSearchCanceled.INSTANCE;\n        }\n        const r = BracketsUtils.findNextBracketInRange(bracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n        if (!r) {\n          break;\n        }\n        const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n        if (bracket.isOpen(hitText)) {\n          count++;\n        } else if (bracket.isClose(hitText)) {\n          count--;\n        }\n        if (count === 0) {\n          return r;\n        }\n        searchStartOffset = r.endColumn - 1;\n      }\n      return null;\n    };\n    const lineCount = this.textModel.getLineCount();\n    for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n      const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n      const tokenCount = lineTokens.getCount();\n      const lineText = this.textModel.getLineContent(lineNumber);\n      let tokenIndex = 0;\n      let searchStartOffset = 0;\n      let searchEndOffset = 0;\n      if (lineNumber === position.lineNumber) {\n        tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        searchStartOffset = position.column - 1;\n        searchEndOffset = position.column - 1;\n      }\n      let prevSearchInToken = true;\n      for (; tokenIndex < tokenCount; tokenIndex++) {\n        const searchInToken = lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));\n        if (searchInToken) {\n          // this token should be searched\n          if (prevSearchInToken) {\n            // the previous token should be searched, simply extend searchEndOffset\n            searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n          } else {\n            // the previous token should not be searched\n            searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n            searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n          }\n        } else {\n          // this token should not be searched\n          if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n            const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n            if (r) {\n              return r;\n            }\n          }\n        }\n        prevSearchInToken = searchInToken;\n      }\n      if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n        const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n        if (r) {\n          return r;\n        }\n      }\n    }\n    return null;\n  }\n  findPrevBracket(_position) {\n    var _a;\n    const position = this.textModel.validatePosition(_position);\n    if (this.canBuildAST) {\n      this.bracketsRequested = true;\n      this.updateBracketPairsTree();\n      return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getFirstBracketBefore(position)) || null;\n    }\n    let languageId = null;\n    let modeBrackets = null;\n    let bracketConfig = null;\n    for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n      const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n      const tokenCount = lineTokens.getCount();\n      const lineText = this.textModel.getLineContent(lineNumber);\n      let tokenIndex = tokenCount - 1;\n      let searchStartOffset = lineText.length;\n      let searchEndOffset = lineText.length;\n      if (lineNumber === position.lineNumber) {\n        tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        searchStartOffset = position.column - 1;\n        searchEndOffset = position.column - 1;\n        const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n        if (languageId !== tokenLanguageId) {\n          languageId = tokenLanguageId;\n          modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n          bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n        }\n      }\n      let prevSearchInToken = true;\n      for (; tokenIndex >= 0; tokenIndex--) {\n        const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n        if (languageId !== tokenLanguageId) {\n          // language id change!\n          if (modeBrackets && bracketConfig && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n            const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n            if (r) {\n              return this._toFoundBracket(bracketConfig, r);\n            }\n            prevSearchInToken = false;\n          }\n          languageId = tokenLanguageId;\n          modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n          bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n        }\n        const searchInToken = !!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));\n        if (searchInToken) {\n          // this token should be searched\n          if (prevSearchInToken) {\n            // the previous token should be searched, simply extend searchStartOffset\n            searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n          } else {\n            // the previous token should not be searched\n            searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n            searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n          }\n        } else {\n          // this token should not be searched\n          if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n            const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n            if (r) {\n              return this._toFoundBracket(bracketConfig, r);\n            }\n          }\n        }\n        prevSearchInToken = searchInToken;\n      }\n      if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n        if (r) {\n          return this._toFoundBracket(bracketConfig, r);\n        }\n      }\n    }\n    return null;\n  }\n  findNextBracket(_position) {\n    var _a;\n    const position = this.textModel.validatePosition(_position);\n    if (this.canBuildAST) {\n      this.bracketsRequested = true;\n      this.updateBracketPairsTree();\n      return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getFirstBracketAfter(position)) || null;\n    }\n    const lineCount = this.textModel.getLineCount();\n    let languageId = null;\n    let modeBrackets = null;\n    let bracketConfig = null;\n    for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n      const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n      const tokenCount = lineTokens.getCount();\n      const lineText = this.textModel.getLineContent(lineNumber);\n      let tokenIndex = 0;\n      let searchStartOffset = 0;\n      let searchEndOffset = 0;\n      if (lineNumber === position.lineNumber) {\n        tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        searchStartOffset = position.column - 1;\n        searchEndOffset = position.column - 1;\n        const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n        if (languageId !== tokenLanguageId) {\n          languageId = tokenLanguageId;\n          modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n          bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n        }\n      }\n      let prevSearchInToken = true;\n      for (; tokenIndex < tokenCount; tokenIndex++) {\n        const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n        if (languageId !== tokenLanguageId) {\n          // language id change!\n          if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n            const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n            if (r) {\n              return this._toFoundBracket(bracketConfig, r);\n            }\n            prevSearchInToken = false;\n          }\n          languageId = tokenLanguageId;\n          modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n          bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n        }\n        const searchInToken = !!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));\n        if (searchInToken) {\n          // this token should be searched\n          if (prevSearchInToken) {\n            // the previous token should be searched, simply extend searchEndOffset\n            searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n          } else {\n            // the previous token should not be searched\n            searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n            searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n          }\n        } else {\n          // this token should not be searched\n          if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n            const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n            if (r) {\n              return this._toFoundBracket(bracketConfig, r);\n            }\n          }\n        }\n        prevSearchInToken = searchInToken;\n      }\n      if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n        if (r) {\n          return this._toFoundBracket(bracketConfig, r);\n        }\n      }\n    }\n    return null;\n  }\n  findEnclosingBrackets(_position, maxDuration) {\n    const position = this.textModel.validatePosition(_position);\n    if (this.canBuildAST) {\n      const range = Range.fromPositions(position);\n      const bracketPair = this.getBracketPairsInRange(Range.fromPositions(position, position)).findLast(item => item.closingBracketRange !== undefined && item.range.strictContainsRange(range));\n      if (bracketPair) {\n        return [bracketPair.openingBracketRange, bracketPair.closingBracketRange];\n      }\n      return null;\n    }\n    const continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);\n    const lineCount = this.textModel.getLineCount();\n    const savedCounts = new Map();\n    let counts = [];\n    const resetCounts = (languageId, modeBrackets) => {\n      if (!savedCounts.has(languageId)) {\n        const tmp = [];\n        for (let i = 0, len = modeBrackets ? modeBrackets.brackets.length : 0; i < len; i++) {\n          tmp[i] = 0;\n        }\n        savedCounts.set(languageId, tmp);\n      }\n      counts = savedCounts.get(languageId);\n    };\n    let totalCallCount = 0;\n    const searchInRange = (modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n      while (true) {\n        if (continueSearchPredicate && ++totalCallCount % 100 === 0 && !continueSearchPredicate()) {\n          return BracketSearchCanceled.INSTANCE;\n        }\n        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n        if (!r) {\n          break;\n        }\n        const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n        const bracket = modeBrackets.textIsBracket[hitText];\n        if (bracket) {\n          if (bracket.isOpen(hitText)) {\n            counts[bracket.index]++;\n          } else if (bracket.isClose(hitText)) {\n            counts[bracket.index]--;\n          }\n          if (counts[bracket.index] === -1) {\n            return this._matchFoundBracket(r, bracket, false, continueSearchPredicate);\n          }\n        }\n        searchStartOffset = r.endColumn - 1;\n      }\n      return null;\n    };\n    let languageId = null;\n    let modeBrackets = null;\n    for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n      const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n      const tokenCount = lineTokens.getCount();\n      const lineText = this.textModel.getLineContent(lineNumber);\n      let tokenIndex = 0;\n      let searchStartOffset = 0;\n      let searchEndOffset = 0;\n      if (lineNumber === position.lineNumber) {\n        tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        searchStartOffset = position.column - 1;\n        searchEndOffset = position.column - 1;\n        const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n        if (languageId !== tokenLanguageId) {\n          languageId = tokenLanguageId;\n          modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n          resetCounts(languageId, modeBrackets);\n        }\n      }\n      let prevSearchInToken = true;\n      for (; tokenIndex < tokenCount; tokenIndex++) {\n        const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n        if (languageId !== tokenLanguageId) {\n          // language id change!\n          if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n            const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n            if (r) {\n              return stripBracketSearchCanceled(r);\n            }\n            prevSearchInToken = false;\n          }\n          languageId = tokenLanguageId;\n          modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n          resetCounts(languageId, modeBrackets);\n        }\n        const searchInToken = !!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));\n        if (searchInToken) {\n          // this token should be searched\n          if (prevSearchInToken) {\n            // the previous token should be searched, simply extend searchEndOffset\n            searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n          } else {\n            // the previous token should not be searched\n            searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n            searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n          }\n        } else {\n          // this token should not be searched\n          if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n            const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n            if (r) {\n              return stripBracketSearchCanceled(r);\n            }\n          }\n        }\n        prevSearchInToken = searchInToken;\n      }\n      if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n        if (r) {\n          return stripBracketSearchCanceled(r);\n        }\n      }\n    }\n    return null;\n  }\n  _toFoundBracket(bracketConfig, r) {\n    if (!r) {\n      return null;\n    }\n    let text = this.textModel.getValueInRange(r);\n    text = text.toLowerCase();\n    const bracketInfo = bracketConfig.getBracketInfo(text);\n    if (!bracketInfo) {\n      return null;\n    }\n    return {\n      range: r,\n      bracketInfo\n    };\n  }\n}\nfunction createDisposableRef(object, disposable) {\n  return {\n    object,\n    dispose: () => disposable === null || disposable === void 0 ? void 0 : disposable.dispose()\n  };\n}\nfunction createTimeBasedContinueBracketSearchPredicate(maxDuration) {\n  if (typeof maxDuration === 'undefined') {\n    return () => true;\n  } else {\n    const startTime = Date.now();\n    return () => {\n      return Date.now() - startTime <= maxDuration;\n    };\n  }\n}\nclass BracketSearchCanceled {\n  constructor() {\n    this._searchCanceledBrand = undefined;\n  }\n}\nBracketSearchCanceled.INSTANCE = new BracketSearchCanceled();\nfunction stripBracketSearchCanceled(result) {\n  if (result instanceof BracketSearchCanceled) {\n    return null;\n  }\n  return result;\n}","map":{"version":3,"names":["CallbackIterable","compareBy","Emitter","Disposable","DisposableStore","MutableDisposable","Range","ignoreBracketsInToken","BracketsUtils","BracketPairsTree","BracketPairsTextModelPart","canBuildAST","maxSupportedDocumentLength","textModel","getValueLength","constructor","languageConfigurationService","bracketPairsTree","_register","onDidChangeEmitter","onDidChange","event","bracketsRequested","e","_a","languageId","value","object","didLanguageChange","clear","updateBracketPairsTree","handleDidChangeOptions","handleDidChangeLanguage","handleDidChangeContent","change","handleContentChanged","handleDidChangeBackgroundTokenizationState","handleDidChangeTokens","store","createDisposableRef","add","getLanguageConfiguration","fire","getBracketPairsInRange","range","empty","getBracketPairsInRangeWithMinIndentation","getBracketsInRange","onlyColorizedBrackets","arguments","length","undefined","findMatchingBracketUp","_bracket","_position","maxDuration","position","validatePosition","getLanguageIdAtPosition","lineNumber","column","closingBracketInfo","bracketsNew","getClosingBracketInfo","bracketPair","fromPositions","findLast","b","closes","openingBracketInfo","openingBracketRange","bracket","toLowerCase","bracketsSupport","brackets","data","textIsBracket","stripBracketSearchCanceled","_findMatchingBracketUp","createTimeBasedContinueBracketSearchPredicate","matchBracket","filter","item","closingBracketRange","containsPosition","findLastMaxBy","compareRangesUsingStarts","continueSearchPredicate","_matchBracket","_establishBracketSearchOffsets","lineTokens","modeBrackets","tokenIndex","tokenCount","getCount","currentLanguageId","getLanguageId","searchStartOffset","Math","max","maxBracketLength","i","tokenEndOffset","getEndOffset","getStandardTokenType","searchEndOffset","min","getLineContent","tokenStartOffset","getStartOffset","tokenization","getLineTokens","lineText","findTokenIndexAtOffset","currentModeBrackets","bestResult","foundBracket","findNextBracketInRange","forwardRegex","startColumn","endColumn","foundBracketText","substring","r","_matchFoundBracket","textIsOpenBracket","BracketSearchCanceled","prevTokenIndex","prevModeBrackets","findPrevBracketInRange","reversedRegex","isOpen","matched","_findMatchingBracketDown","getEndPosition","getStartPosition","reversedBracketRegex","count","totalCallCount","searchPrevMatchingBracketInRange","INSTANCE","hitText","isClose","prevSearchInToken","searchInToken","bracketRegex","searchNextMatchingBracketInRange","lineCount","getLineCount","findPrevBracket","getFirstBracketBefore","bracketConfig","tokenLanguageId","_toFoundBracket","findNextBracket","getFirstBracketAfter","findEnclosingBrackets","strictContainsRange","savedCounts","Map","counts","resetCounts","has","tmp","len","set","get","searchInRange","index","text","getValueInRange","bracketInfo","getBracketInfo","disposable","dispose","startTime","Date","now","_searchCanceledBrand","result"],"sources":["/home/arslan/modojo/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsImpl.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CallbackIterable, compareBy } from '../../../../base/common/arrays.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable, DisposableStore, MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { Range } from '../../core/range.js';\nimport { ignoreBracketsInToken } from '../../languages/supports.js';\nimport { BracketsUtils } from '../../languages/supports/richEditBrackets.js';\nimport { BracketPairsTree } from './bracketPairsTree/bracketPairsTree.js';\nexport class BracketPairsTextModelPart extends Disposable {\n    get canBuildAST() {\n        const maxSupportedDocumentLength = /* max lines */ 50000 * /* average column count */ 100;\n        return this.textModel.getValueLength() <= maxSupportedDocumentLength;\n    }\n    constructor(textModel, languageConfigurationService) {\n        super();\n        this.textModel = textModel;\n        this.languageConfigurationService = languageConfigurationService;\n        this.bracketPairsTree = this._register(new MutableDisposable());\n        this.onDidChangeEmitter = new Emitter();\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.bracketsRequested = false;\n        this._register(this.languageConfigurationService.onDidChange(e => {\n            var _a;\n            if (!e.languageId || ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.didLanguageChange(e.languageId))) {\n                this.bracketPairsTree.clear();\n                this.updateBracketPairsTree();\n            }\n        }));\n    }\n    //#region TextModel events\n    handleDidChangeOptions(e) {\n        this.bracketPairsTree.clear();\n        this.updateBracketPairsTree();\n    }\n    handleDidChangeLanguage(e) {\n        this.bracketPairsTree.clear();\n        this.updateBracketPairsTree();\n    }\n    handleDidChangeContent(change) {\n        var _a;\n        (_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.handleContentChanged(change);\n    }\n    handleDidChangeBackgroundTokenizationState() {\n        var _a;\n        (_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.handleDidChangeBackgroundTokenizationState();\n    }\n    handleDidChangeTokens(e) {\n        var _a;\n        (_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.handleDidChangeTokens(e);\n    }\n    //#endregion\n    updateBracketPairsTree() {\n        if (this.bracketsRequested && this.canBuildAST) {\n            if (!this.bracketPairsTree.value) {\n                const store = new DisposableStore();\n                this.bracketPairsTree.value = createDisposableRef(store.add(new BracketPairsTree(this.textModel, (languageId) => {\n                    return this.languageConfigurationService.getLanguageConfiguration(languageId);\n                })), store);\n                store.add(this.bracketPairsTree.value.object.onDidChange(e => this.onDidChangeEmitter.fire(e)));\n                this.onDidChangeEmitter.fire();\n            }\n        }\n        else {\n            if (this.bracketPairsTree.value) {\n                this.bracketPairsTree.clear();\n                // Important: Don't call fire if there was no change!\n                this.onDidChangeEmitter.fire();\n            }\n        }\n    }\n    /**\n     * Returns all bracket pairs that intersect the given range.\n     * The result is sorted by the start position.\n    */\n    getBracketPairsInRange(range) {\n        var _a;\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getBracketPairsInRange(range, false)) || CallbackIterable.empty;\n    }\n    getBracketPairsInRangeWithMinIndentation(range) {\n        var _a;\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getBracketPairsInRange(range, true)) || CallbackIterable.empty;\n    }\n    getBracketsInRange(range, onlyColorizedBrackets = false) {\n        var _a;\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getBracketsInRange(range, onlyColorizedBrackets)) || CallbackIterable.empty;\n    }\n    findMatchingBracketUp(_bracket, _position, maxDuration) {\n        const position = this.textModel.validatePosition(_position);\n        const languageId = this.textModel.getLanguageIdAtPosition(position.lineNumber, position.column);\n        if (this.canBuildAST) {\n            const closingBracketInfo = this.languageConfigurationService\n                .getLanguageConfiguration(languageId)\n                .bracketsNew.getClosingBracketInfo(_bracket);\n            if (!closingBracketInfo) {\n                return null;\n            }\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(_position, _position)).findLast((b) => closingBracketInfo.closes(b.openingBracketInfo));\n            if (bracketPair) {\n                return bracketPair.openingBracketRange;\n            }\n            return null;\n        }\n        else {\n            // Fallback to old bracket matching code:\n            const bracket = _bracket.toLowerCase();\n            const bracketsSupport = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n            if (!bracketsSupport) {\n                return null;\n            }\n            const data = bracketsSupport.textIsBracket[bracket];\n            if (!data) {\n                return null;\n            }\n            return stripBracketSearchCanceled(this._findMatchingBracketUp(data, position, createTimeBasedContinueBracketSearchPredicate(maxDuration)));\n        }\n    }\n    matchBracket(position, maxDuration) {\n        if (this.canBuildAST) {\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(position, position)).filter((item) => item.closingBracketRange !== undefined &&\n                (item.openingBracketRange.containsPosition(position) ||\n                    item.closingBracketRange.containsPosition(position))).findLastMaxBy(compareBy((item) => item.openingBracketRange.containsPosition(position)\n                ? item.openingBracketRange\n                : item.closingBracketRange, Range.compareRangesUsingStarts));\n            if (bracketPair) {\n                return [bracketPair.openingBracketRange, bracketPair.closingBracketRange];\n            }\n            return null;\n        }\n        else {\n            // Fallback to old bracket matching code:\n            const continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);\n            return this._matchBracket(this.textModel.validatePosition(position), continueSearchPredicate);\n        }\n    }\n    _establishBracketSearchOffsets(position, lineTokens, modeBrackets, tokenIndex) {\n        const tokenCount = lineTokens.getCount();\n        const currentLanguageId = lineTokens.getLanguageId(tokenIndex);\n        // limit search to not go before `maxBracketLength`\n        let searchStartOffset = Math.max(0, position.column - 1 - modeBrackets.maxBracketLength);\n        for (let i = tokenIndex - 1; i >= 0; i--) {\n            const tokenEndOffset = lineTokens.getEndOffset(i);\n            if (tokenEndOffset <= searchStartOffset) {\n                break;\n            }\n            if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n                searchStartOffset = tokenEndOffset;\n                break;\n            }\n        }\n        // limit search to not go after `maxBracketLength`\n        let searchEndOffset = Math.min(lineTokens.getLineContent().length, position.column - 1 + modeBrackets.maxBracketLength);\n        for (let i = tokenIndex + 1; i < tokenCount; i++) {\n            const tokenStartOffset = lineTokens.getStartOffset(i);\n            if (tokenStartOffset >= searchEndOffset) {\n                break;\n            }\n            if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n                searchEndOffset = tokenStartOffset;\n                break;\n            }\n        }\n        return { searchStartOffset, searchEndOffset };\n    }\n    _matchBracket(position, continueSearchPredicate) {\n        const lineNumber = position.lineNumber;\n        const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n        const lineText = this.textModel.getLineContent(lineNumber);\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        if (tokenIndex < 0) {\n            return null;\n        }\n        const currentModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).brackets;\n        // check that the token is not to be ignored\n        if (currentModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {\n            let { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, currentModeBrackets, tokenIndex);\n            // it might be the case that [currentTokenStart -> currentTokenEnd] contains multiple brackets\n            // `bestResult` will contain the most right-side result\n            let bestResult = null;\n            while (true) {\n                const foundBracket = BracketsUtils.findNextBracketInRange(currentModeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!foundBracket) {\n                    // there are no more brackets in this text\n                    break;\n                }\n                // check that we didn't hit a bracket too far away from position\n                if (foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n                    const r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);\n                    if (r) {\n                        if (r instanceof BracketSearchCanceled) {\n                            return null;\n                        }\n                        bestResult = r;\n                    }\n                }\n                searchStartOffset = foundBracket.endColumn - 1;\n            }\n            if (bestResult) {\n                return bestResult;\n            }\n        }\n        // If position is in between two tokens, try also looking in the previous token\n        if (tokenIndex > 0 && lineTokens.getStartOffset(tokenIndex) === position.column - 1) {\n            const prevTokenIndex = tokenIndex - 1;\n            const prevModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(prevTokenIndex)).brackets;\n            // check that previous token is not to be ignored\n            if (prevModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(prevTokenIndex))) {\n                const { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, prevModeBrackets, prevTokenIndex);\n                const foundBracket = BracketsUtils.findPrevBracketInRange(prevModeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                // check that we didn't hit a bracket too far away from position\n                if (foundBracket && foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n                    const r = this._matchFoundBracket(foundBracket, prevModeBrackets.textIsBracket[foundBracketText], prevModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);\n                    if (r) {\n                        if (r instanceof BracketSearchCanceled) {\n                            return null;\n                        }\n                        return r;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    _matchFoundBracket(foundBracket, data, isOpen, continueSearchPredicate) {\n        if (!data) {\n            return null;\n        }\n        const matched = (isOpen\n            ? this._findMatchingBracketDown(data, foundBracket.getEndPosition(), continueSearchPredicate)\n            : this._findMatchingBracketUp(data, foundBracket.getStartPosition(), continueSearchPredicate));\n        if (!matched) {\n            return null;\n        }\n        if (matched instanceof BracketSearchCanceled) {\n            return matched;\n        }\n        return [foundBracket, matched];\n    }\n    _findMatchingBracketUp(bracket, position, continueSearchPredicate) {\n        // console.log('_findMatchingBracketUp: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n        const languageId = bracket.languageId;\n        const reversedBracketRegex = bracket.reversedRegex;\n        let count = -1;\n        let totalCallCount = 0;\n        const searchPrevMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                if (bracket.isOpen(hitText)) {\n                    count++;\n                }\n                else if (bracket.isClose(hitText)) {\n                    count--;\n                }\n                if (count === 0) {\n                    return r;\n                }\n                searchEndOffset = r.startColumn - 1;\n            }\n            return null;\n        };\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = tokenCount - 1;\n            let searchStartOffset = lineText.length;\n            let searchEndOffset = lineText.length;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex >= 0; tokenIndex--) {\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchStartOffset\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return r;\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return r;\n                }\n            }\n        }\n        return null;\n    }\n    _findMatchingBracketDown(bracket, position, continueSearchPredicate) {\n        // console.log('_findMatchingBracketDown: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n        const languageId = bracket.languageId;\n        const bracketRegex = bracket.forwardRegex;\n        let count = 1;\n        let totalCallCount = 0;\n        const searchNextMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findNextBracketInRange(bracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                if (bracket.isOpen(hitText)) {\n                    count++;\n                }\n                else if (bracket.isClose(hitText)) {\n                    count--;\n                }\n                if (count === 0) {\n                    return r;\n                }\n                searchStartOffset = r.endColumn - 1;\n            }\n            return null;\n        };\n        const lineCount = this.textModel.getLineCount();\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return r;\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return r;\n                }\n            }\n        }\n        return null;\n    }\n    findPrevBracket(_position) {\n        var _a;\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            this.bracketsRequested = true;\n            this.updateBracketPairsTree();\n            return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getFirstBracketBefore(position)) || null;\n        }\n        let languageId = null;\n        let modeBrackets = null;\n        let bracketConfig = null;\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = tokenCount - 1;\n            let searchStartOffset = lineText.length;\n            let searchEndOffset = lineText.length;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex >= 0; tokenIndex--) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && bracketConfig && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchStartOffset\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return this._toFoundBracket(bracketConfig, r);\n                }\n            }\n        }\n        return null;\n    }\n    findNextBracket(_position) {\n        var _a;\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            this.bracketsRequested = true;\n            this.updateBracketPairsTree();\n            return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getFirstBracketAfter(position)) || null;\n        }\n        const lineCount = this.textModel.getLineCount();\n        let languageId = null;\n        let modeBrackets = null;\n        let bracketConfig = null;\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return this._toFoundBracket(bracketConfig, r);\n                }\n            }\n        }\n        return null;\n    }\n    findEnclosingBrackets(_position, maxDuration) {\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            const range = Range.fromPositions(position);\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(position, position)).findLast((item) => item.closingBracketRange !== undefined && item.range.strictContainsRange(range));\n            if (bracketPair) {\n                return [bracketPair.openingBracketRange, bracketPair.closingBracketRange];\n            }\n            return null;\n        }\n        const continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);\n        const lineCount = this.textModel.getLineCount();\n        const savedCounts = new Map();\n        let counts = [];\n        const resetCounts = (languageId, modeBrackets) => {\n            if (!savedCounts.has(languageId)) {\n                const tmp = [];\n                for (let i = 0, len = modeBrackets ? modeBrackets.brackets.length : 0; i < len; i++) {\n                    tmp[i] = 0;\n                }\n                savedCounts.set(languageId, tmp);\n            }\n            counts = savedCounts.get(languageId);\n        };\n        let totalCallCount = 0;\n        const searchInRange = (modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                const bracket = modeBrackets.textIsBracket[hitText];\n                if (bracket) {\n                    if (bracket.isOpen(hitText)) {\n                        counts[bracket.index]++;\n                    }\n                    else if (bracket.isClose(hitText)) {\n                        counts[bracket.index]--;\n                    }\n                    if (counts[bracket.index] === -1) {\n                        return this._matchFoundBracket(r, bracket, false, continueSearchPredicate);\n                    }\n                }\n                searchStartOffset = r.endColumn - 1;\n            }\n            return null;\n        };\n        let languageId = null;\n        let modeBrackets = null;\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    resetCounts(languageId, modeBrackets);\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return stripBracketSearchCanceled(r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    resetCounts(languageId, modeBrackets);\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return stripBracketSearchCanceled(r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return stripBracketSearchCanceled(r);\n                }\n            }\n        }\n        return null;\n    }\n    _toFoundBracket(bracketConfig, r) {\n        if (!r) {\n            return null;\n        }\n        let text = this.textModel.getValueInRange(r);\n        text = text.toLowerCase();\n        const bracketInfo = bracketConfig.getBracketInfo(text);\n        if (!bracketInfo) {\n            return null;\n        }\n        return {\n            range: r,\n            bracketInfo\n        };\n    }\n}\nfunction createDisposableRef(object, disposable) {\n    return {\n        object,\n        dispose: () => disposable === null || disposable === void 0 ? void 0 : disposable.dispose(),\n    };\n}\nfunction createTimeBasedContinueBracketSearchPredicate(maxDuration) {\n    if (typeof maxDuration === 'undefined') {\n        return () => true;\n    }\n    else {\n        const startTime = Date.now();\n        return () => {\n            return (Date.now() - startTime <= maxDuration);\n        };\n    }\n}\nclass BracketSearchCanceled {\n    constructor() {\n        this._searchCanceledBrand = undefined;\n    }\n}\nBracketSearchCanceled.INSTANCE = new BracketSearchCanceled();\nfunction stripBracketSearchCanceled(result) {\n    if (result instanceof BracketSearchCanceled) {\n        return null;\n    }\n    return result;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}