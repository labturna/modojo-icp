{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { Range } from '../core/range.js';\nimport { SingleTextEdit } from '../core/textEdit.js';\n/**\n * Maps a line range in the original text model to a line range in the modified text model.\n */\nexport class LineRangeMapping {\n  static inverse(mapping, originalLineCount, modifiedLineCount) {\n    const result = [];\n    let lastOriginalEndLineNumber = 1;\n    let lastModifiedEndLineNumber = 1;\n    for (const m of mapping) {\n      const r = new LineRangeMapping(new LineRange(lastOriginalEndLineNumber, m.original.startLineNumber), new LineRange(lastModifiedEndLineNumber, m.modified.startLineNumber));\n      if (!r.modified.isEmpty) {\n        result.push(r);\n      }\n      lastOriginalEndLineNumber = m.original.endLineNumberExclusive;\n      lastModifiedEndLineNumber = m.modified.endLineNumberExclusive;\n    }\n    const r = new LineRangeMapping(new LineRange(lastOriginalEndLineNumber, originalLineCount + 1), new LineRange(lastModifiedEndLineNumber, modifiedLineCount + 1));\n    if (!r.modified.isEmpty) {\n      result.push(r);\n    }\n    return result;\n  }\n  static clip(mapping, originalRange, modifiedRange) {\n    const result = [];\n    for (const m of mapping) {\n      const original = m.original.intersect(originalRange);\n      const modified = m.modified.intersect(modifiedRange);\n      if (original && !original.isEmpty && modified && !modified.isEmpty) {\n        result.push(new LineRangeMapping(original, modified));\n      }\n    }\n    return result;\n  }\n  constructor(originalRange, modifiedRange) {\n    this.original = originalRange;\n    this.modified = modifiedRange;\n  }\n  toString() {\n    return `{${this.original.toString()}->${this.modified.toString()}}`;\n  }\n  flip() {\n    return new LineRangeMapping(this.modified, this.original);\n  }\n  join(other) {\n    return new LineRangeMapping(this.original.join(other.original), this.modified.join(other.modified));\n  }\n  /**\n   * This method assumes that the LineRangeMapping describes a valid diff!\n   * I.e. if one range is empty, the other range cannot be the entire document.\n   * It avoids various problems when the line range points to non-existing line-numbers.\n  */\n  toRangeMapping() {\n    const origInclusiveRange = this.original.toInclusiveRange();\n    const modInclusiveRange = this.modified.toInclusiveRange();\n    if (origInclusiveRange && modInclusiveRange) {\n      return new RangeMapping(origInclusiveRange, modInclusiveRange);\n    } else if (this.original.startLineNumber === 1 || this.modified.startLineNumber === 1) {\n      if (!(this.modified.startLineNumber === 1 && this.original.startLineNumber === 1)) {\n        // If one line range starts at 1, the other one must start at 1 as well.\n        throw new BugIndicatingError('not a valid diff');\n      }\n      // Because one range is empty and both ranges start at line 1, none of the ranges can cover all lines.\n      // Thus, `endLineNumberExclusive` is a valid line number.\n      return new RangeMapping(new Range(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1), new Range(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1));\n    } else {\n      // We can assume here that both startLineNumbers are greater than 1.\n      return new RangeMapping(new Range(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), new Range(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER));\n    }\n  }\n}\n/**\n * Maps a line range in the original text model to a line range in the modified text model.\n * Also contains inner range mappings.\n */\nexport class DetailedLineRangeMapping extends LineRangeMapping {\n  static fromRangeMappings(rangeMappings) {\n    const originalRange = LineRange.join(rangeMappings.map(r => LineRange.fromRangeInclusive(r.originalRange)));\n    const modifiedRange = LineRange.join(rangeMappings.map(r => LineRange.fromRangeInclusive(r.modifiedRange)));\n    return new DetailedLineRangeMapping(originalRange, modifiedRange, rangeMappings);\n  }\n  constructor(originalRange, modifiedRange, innerChanges) {\n    super(originalRange, modifiedRange);\n    this.innerChanges = innerChanges;\n  }\n  flip() {\n    var _a;\n    return new DetailedLineRangeMapping(this.modified, this.original, (_a = this.innerChanges) === null || _a === void 0 ? void 0 : _a.map(c => c.flip()));\n  }\n  withInnerChangesFromLineRanges() {\n    return new DetailedLineRangeMapping(this.original, this.modified, [this.toRangeMapping()]);\n  }\n}\n/**\n * Maps a range in the original text model to a range in the modified text model.\n */\nexport class RangeMapping {\n  constructor(originalRange, modifiedRange) {\n    this.originalRange = originalRange;\n    this.modifiedRange = modifiedRange;\n  }\n  toString() {\n    return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;\n  }\n  flip() {\n    return new RangeMapping(this.modifiedRange, this.originalRange);\n  }\n  /**\n   * Creates a single text edit that describes the change from the original to the modified text.\n  */\n  toTextEdit(modified) {\n    const newText = modified.getValueOfRange(this.modifiedRange);\n    return new SingleTextEdit(this.originalRange, newText);\n  }\n}","map":{"version":3,"names":["BugIndicatingError","LineRange","Range","SingleTextEdit","LineRangeMapping","inverse","mapping","originalLineCount","modifiedLineCount","result","lastOriginalEndLineNumber","lastModifiedEndLineNumber","m","r","original","startLineNumber","modified","isEmpty","push","endLineNumberExclusive","clip","originalRange","modifiedRange","intersect","constructor","toString","flip","join","other","toRangeMapping","origInclusiveRange","toInclusiveRange","modInclusiveRange","RangeMapping","Number","MAX_SAFE_INTEGER","DetailedLineRangeMapping","fromRangeMappings","rangeMappings","map","fromRangeInclusive","innerChanges","_a","c","withInnerChangesFromLineRanges","toTextEdit","newText","getValueOfRange"],"sources":["/home/arslan/modojo/node_modules/monaco-editor/esm/vs/editor/common/diff/rangeMapping.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { Range } from '../core/range.js';\nimport { SingleTextEdit } from '../core/textEdit.js';\n/**\n * Maps a line range in the original text model to a line range in the modified text model.\n */\nexport class LineRangeMapping {\n    static inverse(mapping, originalLineCount, modifiedLineCount) {\n        const result = [];\n        let lastOriginalEndLineNumber = 1;\n        let lastModifiedEndLineNumber = 1;\n        for (const m of mapping) {\n            const r = new LineRangeMapping(new LineRange(lastOriginalEndLineNumber, m.original.startLineNumber), new LineRange(lastModifiedEndLineNumber, m.modified.startLineNumber));\n            if (!r.modified.isEmpty) {\n                result.push(r);\n            }\n            lastOriginalEndLineNumber = m.original.endLineNumberExclusive;\n            lastModifiedEndLineNumber = m.modified.endLineNumberExclusive;\n        }\n        const r = new LineRangeMapping(new LineRange(lastOriginalEndLineNumber, originalLineCount + 1), new LineRange(lastModifiedEndLineNumber, modifiedLineCount + 1));\n        if (!r.modified.isEmpty) {\n            result.push(r);\n        }\n        return result;\n    }\n    static clip(mapping, originalRange, modifiedRange) {\n        const result = [];\n        for (const m of mapping) {\n            const original = m.original.intersect(originalRange);\n            const modified = m.modified.intersect(modifiedRange);\n            if (original && !original.isEmpty && modified && !modified.isEmpty) {\n                result.push(new LineRangeMapping(original, modified));\n            }\n        }\n        return result;\n    }\n    constructor(originalRange, modifiedRange) {\n        this.original = originalRange;\n        this.modified = modifiedRange;\n    }\n    toString() {\n        return `{${this.original.toString()}->${this.modified.toString()}}`;\n    }\n    flip() {\n        return new LineRangeMapping(this.modified, this.original);\n    }\n    join(other) {\n        return new LineRangeMapping(this.original.join(other.original), this.modified.join(other.modified));\n    }\n    /**\n     * This method assumes that the LineRangeMapping describes a valid diff!\n     * I.e. if one range is empty, the other range cannot be the entire document.\n     * It avoids various problems when the line range points to non-existing line-numbers.\n    */\n    toRangeMapping() {\n        const origInclusiveRange = this.original.toInclusiveRange();\n        const modInclusiveRange = this.modified.toInclusiveRange();\n        if (origInclusiveRange && modInclusiveRange) {\n            return new RangeMapping(origInclusiveRange, modInclusiveRange);\n        }\n        else if (this.original.startLineNumber === 1 || this.modified.startLineNumber === 1) {\n            if (!(this.modified.startLineNumber === 1 && this.original.startLineNumber === 1)) {\n                // If one line range starts at 1, the other one must start at 1 as well.\n                throw new BugIndicatingError('not a valid diff');\n            }\n            // Because one range is empty and both ranges start at line 1, none of the ranges can cover all lines.\n            // Thus, `endLineNumberExclusive` is a valid line number.\n            return new RangeMapping(new Range(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1), new Range(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1));\n        }\n        else {\n            // We can assume here that both startLineNumbers are greater than 1.\n            return new RangeMapping(new Range(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), new Range(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER));\n        }\n    }\n}\n/**\n * Maps a line range in the original text model to a line range in the modified text model.\n * Also contains inner range mappings.\n */\nexport class DetailedLineRangeMapping extends LineRangeMapping {\n    static fromRangeMappings(rangeMappings) {\n        const originalRange = LineRange.join(rangeMappings.map(r => LineRange.fromRangeInclusive(r.originalRange)));\n        const modifiedRange = LineRange.join(rangeMappings.map(r => LineRange.fromRangeInclusive(r.modifiedRange)));\n        return new DetailedLineRangeMapping(originalRange, modifiedRange, rangeMappings);\n    }\n    constructor(originalRange, modifiedRange, innerChanges) {\n        super(originalRange, modifiedRange);\n        this.innerChanges = innerChanges;\n    }\n    flip() {\n        var _a;\n        return new DetailedLineRangeMapping(this.modified, this.original, (_a = this.innerChanges) === null || _a === void 0 ? void 0 : _a.map(c => c.flip()));\n    }\n    withInnerChangesFromLineRanges() {\n        return new DetailedLineRangeMapping(this.original, this.modified, [this.toRangeMapping()]);\n    }\n}\n/**\n * Maps a range in the original text model to a range in the modified text model.\n */\nexport class RangeMapping {\n    constructor(originalRange, modifiedRange) {\n        this.originalRange = originalRange;\n        this.modifiedRange = modifiedRange;\n    }\n    toString() {\n        return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;\n    }\n    flip() {\n        return new RangeMapping(this.modifiedRange, this.originalRange);\n    }\n    /**\n     * Creates a single text edit that describes the change from the original to the modified text.\n    */\n    toTextEdit(modified) {\n        const newText = modified.getValueOfRange(this.modifiedRange);\n        return new SingleTextEdit(this.originalRange, newText);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}