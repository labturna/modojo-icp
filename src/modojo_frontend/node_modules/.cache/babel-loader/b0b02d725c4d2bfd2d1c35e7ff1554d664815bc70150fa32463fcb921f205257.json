{"ast":null,"code":"\"use strict\";\n\n// Derived from: https://github.com/dfinity/motoko-playground/blob/main/src/workers/file.ts\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validatePackage = exports.installPackages = exports.fetchPackage = void 0;\n// @ts-ignore\nconst isomorphic_parse_github_url_1 = __importDefault(require(\"isomorphic-parse-github-url\"));\nconst cross_fetch_1 = __importDefault(require(\"cross-fetch\"));\nconst sanitize_filename_1 = __importDefault(require(\"sanitize-filename\"));\nfunction parseGithubPackageInfo(path) {\n  if (!path) {\n    return;\n  }\n  if (typeof path === 'object') {\n    return path;\n  }\n  let result;\n  try {\n    result = (0, isomorphic_parse_github_url_1.default)(path);\n    if (!result) {\n      return;\n    }\n  } catch (err) {\n    // console.warn(err);\n    return;\n  }\n  const {\n    name,\n    filepath,\n    branch,\n    owner\n  } = result;\n  return {\n    name,\n    repo: `https://github.com/${owner}/${name}.git`,\n    version: branch,\n    dir: filepath,\n    branch\n    // homepage: ,\n  };\n}\nfunction fetchPackageFiles(info) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const prefix = 'https://github.com/';\n    const suffix = '.git';\n    if (!info.repo.startsWith(prefix) || !info.repo.endsWith(suffix)) {\n      return;\n    }\n    const repoPart = info.repo.slice(prefix.length, -suffix.length);\n    const possiblyCDN = !(info.branch && info.branch.length % 2 === 0 && /^[A-F0-9]+$/i.test(info.branch) || info.branch === 'master' || info.branch === 'main');\n    if (possiblyCDN) {\n      try {\n        const result = yield fetchFromService(info, 'CDN', `https://data.jsdelivr.com/v1/package/gh/${repoPart}@${info.branch}/flat`, `https://cdn.jsdelivr.net/gh/${repoPart}@${info.branch}`, 'files', 'name');\n        if (result === null || result === void 0 ? void 0 : result.length) {\n          return result;\n        }\n      } catch (err) {\n        console.error('[CDN]', err);\n      }\n    }\n    return yield fetchFromService(info, 'GitHub', `https://api.github.com/repos/${repoPart}/git/trees/${info.branch}?recursive=1`, `https://raw.githubusercontent.com/${repoPart}/${info.branch}/`, 'tree', 'path', file => file.type === 'blob');\n  });\n}\nfunction fetchFromService(info, serviceName, metaUrl, baseUrl, resultProperty, pathProperty, condition) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const response = yield (0, cross_fetch_1.default)(metaUrl);\n    if (!response.ok) {\n      throw Error(response.statusText || `Could not fetch from ${serviceName}: ${info.repo}`);\n    }\n    const json = yield response.json();\n    if (!json.hasOwnProperty(resultProperty)) {\n      throw new Error(`Unexpected response from ${serviceName}`);\n    }\n    // Remove leading and trailing '/' from directory\n    let directory = info.dir ? info.dir.replace(/^\\//, '').replace(/\\/$/, '') : '';\n    const files = {};\n    yield Promise.all(json[resultProperty].filter(file => {\n      return (!directory || file[pathProperty].startsWith(file[pathProperty].startsWith('/') ? `/${directory}` : directory)) && (!condition || condition(file)) && /\\.mo$/.test(file[pathProperty]);\n    }).map(file => __awaiter(this, void 0, void 0, function* () {\n      const response = yield (0, cross_fetch_1.default)(`${baseUrl}${file[pathProperty]}`);\n      if (!response.ok) {\n        throw Error(response.statusText);\n      }\n      const content = yield response.text();\n      let path = file[pathProperty];\n      if (path.startsWith('/')) {\n        path = path.slice(1);\n      }\n      if (directory) {\n        // Remove directory prefix\n        path = path.slice(directory.length + 1);\n      }\n      files[path] = {\n        content\n      };\n    })));\n    return files;\n  });\n}\nfunction fetchPackage(name, info) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (typeof info === 'string') {\n      info = parseGithubPackageInfo(info);\n    }\n    const files = yield fetchPackageFiles(info);\n    if (!files) {\n      return;\n    }\n    return {\n      name,\n      version: info.version,\n      files\n    };\n  });\n}\nexports.fetchPackage = fetchPackage;\nfunction installPackages(mo, packages) {\n  return __awaiter(this, void 0, void 0, function* () {\n    yield Promise.all(Object.entries(packages).map(_ref => {\n      let [name, info] = _ref;\n      return __awaiter(this, void 0, void 0, function* () {\n        const pkg = yield fetchPackage(name, info);\n        mo.loadPackage(pkg);\n        return pkg;\n      });\n    }));\n  });\n}\nexports.installPackages = installPackages;\nfunction validatePackage(pkg) {\n  function showValue(value) {\n    const string = JSON.stringify(value);\n    return string.length > 50 ? string.substring(0, 50) + '...' : string;\n  }\n  function getPackageDisplayName() {\n    return `(${pkg.name} / ${pkg.version})`;\n  }\n  if (typeof pkg !== 'object' || Array.isArray(pkg)) {\n    throw new Error(`Unexpected package: ${showValue(pkg)}`);\n  }\n  if (typeof pkg.name !== 'string' || (0, sanitize_filename_1.default)(pkg.name) !== pkg.name) {\n    throw new Error(`Invalid package name ${getPackageDisplayName()}`);\n  }\n  if (typeof pkg.version !== 'string' || (0, sanitize_filename_1.default)(pkg.version) !== pkg.version) {\n    throw new Error(`Invalid package version ${getPackageDisplayName()}`);\n  }\n  if (typeof pkg.files !== 'object' || Array.isArray(pkg.files)) {\n    throw new Error(`Invalid package files: ${showValue(pkg.files)}`);\n  }\n  Object.entries(pkg.files).forEach(_ref2 => {\n    let [path, file] = _ref2;\n    if (typeof path !== 'string' || path.split('/').some(p => (0, sanitize_filename_1.default)(p) !== p)) {\n      throw new Error(`Invalid file path ${getPackageDisplayName()} [${path}]`);\n    }\n    if (typeof file !== 'object' || Array.isArray(file)) {\n      throw new Error(`Invalid file ${getPackageDisplayName()} [${path}]: ${showValue(file)}`);\n    }\n    if (typeof file.content !== 'string') {\n      throw new Error(`Invalid file content ${getPackageDisplayName()} [${path}]: ${showValue(file.content)}`);\n    }\n  });\n}\nexports.validatePackage = validatePackage;","map":{"version":3,"names":["isomorphic_parse_github_url_1","__importDefault","require","cross_fetch_1","sanitize_filename_1","parseGithubPackageInfo","path","result","default","err","name","filepath","branch","owner","repo","version","dir","fetchPackageFiles","info","prefix","suffix","startsWith","endsWith","repoPart","slice","length","possiblyCDN","test","fetchFromService","console","error","file","type","serviceName","metaUrl","baseUrl","resultProperty","pathProperty","condition","response","ok","Error","statusText","json","hasOwnProperty","directory","replace","files","Promise","all","filter","map","__awaiter","content","text","fetchPackage","exports","installPackages","mo","packages","Object","entries","_ref","pkg","loadPackage","validatePackage","showValue","value","string","JSON","stringify","substring","getPackageDisplayName","Array","isArray","forEach","_ref2","split","some","p"],"sources":["/home/arslan/modojo/node_modules/motoko/src/package.ts"],"sourcesContent":["// Derived from: https://github.com/dfinity/motoko-playground/blob/main/src/workers/file.ts\n\n// @ts-ignore\nimport { default as parse } from 'isomorphic-parse-github-url';\nimport fetch from 'cross-fetch';\nimport { Motoko } from '.';\nimport sanitize from 'sanitize-filename';\n\nexport interface PackageInfo {\n    name: string;\n    repo: string;\n    version: string;\n    dir?: string;\n    branch?: string | undefined;\n}\n\nexport interface Package {\n    name: string;\n    version: string;\n    files: PackageFiles;\n}\n\nexport type PackageFiles = Record<string, PackageFile>;\n\nexport interface PackageFile {\n    content: string;\n}\n\nfunction parseGithubPackageInfo(path: string | PackageInfo): PackageInfo {\n    if (!path) {\n        return;\n    }\n    if (typeof path === 'object') {\n        return path;\n    }\n\n    let result;\n    try {\n        result = parse(path);\n        if (!result) {\n            return;\n        }\n    } catch (err) {\n        // console.warn(err);\n        return;\n    }\n\n    const { name, filepath, branch, owner } = result;\n    return {\n        name,\n        repo: `https://github.com/${owner}/${name}.git`,\n        version: branch,\n        dir: filepath,\n        branch,\n        // homepage: ,\n    };\n}\n\nasync function fetchPackageFiles(\n    info: PackageInfo,\n): Promise<PackageFiles | undefined> {\n    const prefix = 'https://github.com/';\n    const suffix = '.git';\n    if (!info.repo.startsWith(prefix) || !info.repo.endsWith(suffix)) {\n        return;\n    }\n    const repoPart = info.repo.slice(prefix.length, -suffix.length);\n\n    const possiblyCDN = !(\n        (info.branch &&\n            info.branch.length % 2 === 0 &&\n            /^[A-F0-9]+$/i.test(info.branch)) ||\n        info.branch === 'master' ||\n        info.branch === 'main'\n    );\n    if (possiblyCDN) {\n        try {\n            const result = await fetchFromService(\n                info,\n                'CDN',\n                `https://data.jsdelivr.com/v1/package/gh/${repoPart}@${info.branch}/flat`,\n                `https://cdn.jsdelivr.net/gh/${repoPart}@${info.branch}`,\n                'files',\n                'name',\n            );\n            if (result?.length) {\n                return result;\n            }\n        }\n        catch(err) {\n            console.error('[CDN]', err);\n        }\n    }\n    return await fetchFromService(\n        info,\n        'GitHub',\n        `https://api.github.com/repos/${repoPart}/git/trees/${info.branch}?recursive=1`,\n        `https://raw.githubusercontent.com/${repoPart}/${info.branch}/`,\n        'tree',\n        'path',\n        (file) => file.type === 'blob',\n    );\n}\n\nasync function fetchFromService(\n    info: PackageInfo,\n    serviceName: string,\n    metaUrl: string,\n    baseUrl: string,\n    resultProperty: string,\n    pathProperty: string,\n    condition?: (file: any) => boolean,\n): Promise<PackageFiles | undefined> {\n    const response = await fetch(metaUrl);\n    if (!response.ok) {\n        throw Error(\n            response.statusText ||\n                `Could not fetch from ${serviceName}: ${info.repo}`,\n        );\n    }\n    const json = await response.json();\n    if (!json.hasOwnProperty(resultProperty)) {\n        throw new Error(`Unexpected response from ${serviceName}`);\n    }\n    // Remove leading and trailing '/' from directory\n    let directory = info.dir\n        ? info.dir.replace(/^\\//, '').replace(/\\/$/, '')\n        : '';\n    const files: Record<string, PackageFile> = {};\n    await Promise.all(\n        (<any[]>json[resultProperty])\n            .filter((file) => {\n                return (\n                    (!directory ||\n                        file[pathProperty].startsWith(\n                            file[pathProperty].startsWith('/')\n                                ? `/${directory}`\n                                : directory,\n                        )) &&\n                    (!condition || condition(file)) &&\n                    /\\.mo$/.test(file[pathProperty])\n                );\n            })\n            .map(async (file) => {\n                const response = await fetch(`${baseUrl}${file[pathProperty]}`);\n                if (!response.ok) {\n                    throw Error(response.statusText);\n                }\n                const content = await response.text();\n                let path = file[pathProperty];\n                if (path.startsWith('/')) {\n                    path = path.slice(1);\n                }\n                if (directory) {\n                    // Remove directory prefix\n                    path = path.slice(directory.length + 1);\n                }\n                files[path] = {\n                    content,\n                };\n            }),\n    );\n    return files;\n}\n\nexport async function fetchPackage(\n    name: string,\n    info: string | PackageInfo,\n): Promise<Package | undefined> {\n    if (typeof info === 'string') {\n        info = parseGithubPackageInfo(info);\n    }\n    const files = await fetchPackageFiles(info);\n    if (!files) {\n        return;\n    }\n    return {\n        name,\n        version: info.version,\n        files,\n    };\n}\n\nexport async function installPackages(\n    mo: Motoko,\n    packages: Record<string, string | PackageInfo>,\n) {\n    await Promise.all(\n        Object.entries(packages).map(async ([name, info]) => {\n            const pkg = await fetchPackage(name, info);\n            mo.loadPackage(pkg);\n            return pkg;\n        }),\n    );\n}\n\nexport function validatePackage(pkg: Package) {\n    function showValue(value: any) {\n        const string = JSON.stringify(value);\n        return string.length > 50 ? string.substring(0, 50) + '...' : string;\n    }\n    function getPackageDisplayName() {\n        return `(${pkg.name} / ${pkg.version})`;\n    }\n\n    if (typeof pkg !== 'object' || Array.isArray(pkg)) {\n        throw new Error(`Unexpected package: ${showValue(pkg)}`);\n    }\n    if (typeof pkg.name !== 'string' || sanitize(pkg.name) !== pkg.name) {\n        throw new Error(`Invalid package name ${getPackageDisplayName()}`);\n    }\n    if (\n        typeof pkg.version !== 'string' ||\n        sanitize(pkg.version) !== pkg.version\n    ) {\n        throw new Error(`Invalid package version ${getPackageDisplayName()}`);\n    }\n    if (typeof pkg.files !== 'object' || Array.isArray(pkg.files)) {\n        throw new Error(`Invalid package files: ${showValue(pkg.files)}`);\n    }\n\n    Object.entries(pkg.files).forEach(([path, file]) => {\n        if (\n            typeof path !== 'string' ||\n            path.split('/').some((p) => sanitize(p) !== p)\n        ) {\n            throw new Error(\n                `Invalid file path ${getPackageDisplayName()} [${path}]`,\n            );\n        }\n        if (typeof file !== 'object' || Array.isArray(file)) {\n            throw new Error(\n                `Invalid file ${getPackageDisplayName()} [${path}]: ${showValue(\n                    file,\n                )}`,\n            );\n        }\n        if (typeof file.content !== 'string') {\n            throw new Error(\n                `Invalid file content ${getPackageDisplayName()} [${path}]: ${showValue(\n                    file.content,\n                )}`,\n            );\n        }\n    });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}