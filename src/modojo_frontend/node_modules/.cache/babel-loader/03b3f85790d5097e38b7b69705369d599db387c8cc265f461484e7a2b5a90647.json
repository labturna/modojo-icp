{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { Principal } from '@dfinity/principal';\nimport { requestIdOf } from './request_id';\nimport { concat, toHex } from './utils/buffer';\nconst domainSeparator = new TextEncoder().encode('\\x0Aic-request');\n/**\n * An Identity that can sign blobs.\n */\nexport class SignIdentity {\n  /**\n   * Get the principal represented by this identity. Normally should be a\n   * `Principal.selfAuthenticating()`.\n   */\n  getPrincipal() {\n    if (!this._principal) {\n      this._principal = Principal.selfAuthenticating(new Uint8Array(this.getPublicKey().toDer()));\n    }\n    return this._principal;\n  }\n  /**\n   * Transform a request into a signed version of the request. This is done last\n   * after the transforms on the body of a request. The returned object can be\n   * anything, but must be serializable to CBOR.\n   * @param request - internet computer request to transform\n   */\n  async transformRequest(request) {\n    const {\n        body\n      } = request,\n      fields = __rest(request, [\"body\"]);\n    const requestId = await requestIdOf(body);\n    return Object.assign(Object.assign({}, fields), {\n      body: {\n        content: body,\n        sender_pubkey: this.getPublicKey().toDer(),\n        sender_sig: await this.sign(concat(domainSeparator, requestId))\n      }\n    });\n  }\n}\nexport class AnonymousIdentity {\n  getPrincipal() {\n    return Principal.anonymous();\n  }\n  async transformRequest(request) {\n    return Object.assign(Object.assign({}, request), {\n      body: {\n        content: request.body\n      }\n    });\n  }\n}\n/**\n * Create an IdentityDescriptor from a @dfinity/identity Identity\n * @param identity - identity describe in returned descriptor\n */\nexport function createIdentityDescriptor(identity) {\n  const identityIndicator = 'getPublicKey' in identity ? {\n    type: 'PublicKeyIdentity',\n    publicKey: toHex(identity.getPublicKey().toDer())\n  } : {\n    type: 'AnonymousIdentity'\n  };\n  return identityIndicator;\n}","map":{"version":3,"names":["Principal","requestIdOf","concat","toHex","domainSeparator","TextEncoder","encode","SignIdentity","getPrincipal","_principal","selfAuthenticating","Uint8Array","getPublicKey","toDer","transformRequest","request","body","fields","__rest","requestId","Object","assign","content","sender_pubkey","sender_sig","sign","AnonymousIdentity","anonymous","createIdentityDescriptor","identity","identityIndicator","type","publicKey"],"sources":["/home/arslan/modojo/node_modules/@dfinity/agent/src/auth.ts"],"sourcesContent":["import { Principal } from '@dfinity/principal';\nimport { HttpAgentRequest } from './agent/http/types';\nimport { requestIdOf } from './request_id';\nimport { concat, toHex } from './utils/buffer';\n\nconst domainSeparator = new TextEncoder().encode('\\x0Aic-request');\n\n/**\n * A Key Pair, containing a secret and public key.\n */\nexport interface KeyPair {\n  secretKey: ArrayBuffer;\n  publicKey: PublicKey;\n}\n\n/**\n * A public key that is DER encoded. This is a branded ArrayBuffer.\n */\nexport type DerEncodedPublicKey = ArrayBuffer & { __derEncodedPublicKey__?: void };\n\n/**\n * A signature array buffer.\n */\nexport type Signature = ArrayBuffer & { __signature__: void };\n\n/**\n * A Public Key implementation.\n */\nexport interface PublicKey {\n  toDer(): DerEncodedPublicKey;\n  // rawKey, toRaw, and derKey are optional for backwards compatibility.\n  toRaw?(): ArrayBuffer;\n  rawKey?: ArrayBuffer;\n  derKey?: DerEncodedPublicKey;\n}\n\n/**\n * A General Identity object. This does not have to be a private key (for example,\n * the Anonymous identity), but it must be able to transform request.\n */\nexport interface Identity {\n  /**\n   * Get the principal represented by this identity. Normally should be a\n   * `Principal.selfAuthenticating()`.\n   */\n  getPrincipal(): Principal;\n\n  /**\n   * Transform a request into a signed version of the request. This is done last\n   * after the transforms on the body of a request. The returned object can be\n   * anything, but must be serializable to CBOR.\n   */\n  transformRequest(request: HttpAgentRequest): Promise<unknown>;\n}\n\n/**\n * An Identity that can sign blobs.\n */\nexport abstract class SignIdentity implements Identity {\n  protected _principal: Principal | undefined;\n\n  /**\n   * Returns the public key that would match this identity's signature.\n   */\n  public abstract getPublicKey(): PublicKey;\n\n  /**\n   * Signs a blob of data, with this identity's private key.\n   */\n  public abstract sign(blob: ArrayBuffer): Promise<Signature>;\n\n  /**\n   * Get the principal represented by this identity. Normally should be a\n   * `Principal.selfAuthenticating()`.\n   */\n  public getPrincipal(): Principal {\n    if (!this._principal) {\n      this._principal = Principal.selfAuthenticating(new Uint8Array(this.getPublicKey().toDer()));\n    }\n    return this._principal;\n  }\n\n  /**\n   * Transform a request into a signed version of the request. This is done last\n   * after the transforms on the body of a request. The returned object can be\n   * anything, but must be serializable to CBOR.\n   * @param request - internet computer request to transform\n   */\n  public async transformRequest(request: HttpAgentRequest): Promise<unknown> {\n    const { body, ...fields } = request;\n    const requestId = await requestIdOf(body);\n    return {\n      ...fields,\n      body: {\n        content: body,\n        sender_pubkey: this.getPublicKey().toDer(),\n        sender_sig: await this.sign(concat(domainSeparator, requestId)),\n      },\n    };\n  }\n}\n\nexport class AnonymousIdentity implements Identity {\n  public getPrincipal(): Principal {\n    return Principal.anonymous();\n  }\n\n  public async transformRequest(request: HttpAgentRequest): Promise<unknown> {\n    return {\n      ...request,\n      body: { content: request.body },\n    };\n  }\n}\n\n/*\n * We need to communicate with other agents on the page about identities,\n * but those messages may need to go across boundaries where it's not possible to\n * serialize/deserialize object prototypes easily.\n * So these are lightweight, serializable objects that contain enough information to recreate\n * SignIdentities, but don't commit to having all methods of SignIdentity.\n *\n * Use Case:\n * * DOM Events that let differently-versioned components communicate to one another about\n *   Identities, even if they're using slightly different versions of agent packages to\n *   create/interpret them.\n */\nexport interface AnonymousIdentityDescriptor {\n  type: 'AnonymousIdentity';\n}\nexport interface PublicKeyIdentityDescriptor {\n  type: 'PublicKeyIdentity';\n  publicKey: string;\n}\nexport type IdentityDescriptor = AnonymousIdentityDescriptor | PublicKeyIdentityDescriptor;\n\n/**\n * Create an IdentityDescriptor from a @dfinity/identity Identity\n * @param identity - identity describe in returned descriptor\n */\nexport function createIdentityDescriptor(\n  identity: SignIdentity | AnonymousIdentity,\n): IdentityDescriptor {\n  const identityIndicator: IdentityDescriptor =\n    'getPublicKey' in identity\n      ? { type: 'PublicKeyIdentity', publicKey: toHex(identity.getPublicKey().toDer()) }\n      : { type: 'AnonymousIdentity' };\n  return identityIndicator;\n}\n"],"mappings":";;;;;;;;AAAA,SAASA,SAAS,QAAQ,oBAAoB;AAE9C,SAASC,WAAW,QAAQ,cAAc;AAC1C,SAASC,MAAM,EAAEC,KAAK,QAAQ,gBAAgB;AAE9C,MAAMC,eAAe,GAAG,IAAIC,WAAW,EAAE,CAACC,MAAM,CAAC,gBAAgB,CAAC;AAkDlE;;;AAGA,OAAM,MAAgBC,YAAY;EAahC;;;;EAIOC,YAAYA,CAAA;IACjB,IAAI,CAAC,IAAI,CAACC,UAAU,EAAE;MACpB,IAAI,CAACA,UAAU,GAAGT,SAAS,CAACU,kBAAkB,CAAC,IAAIC,UAAU,CAAC,IAAI,CAACC,YAAY,EAAE,CAACC,KAAK,EAAE,CAAC,CAAC;;IAE7F,OAAO,IAAI,CAACJ,UAAU;EACxB;EAEA;;;;;;EAMO,MAAMK,gBAAgBA,CAACC,OAAyB;IACrD,MAAM;QAAEC;MAAI,IAAgBD,OAAO;MAAlBE,MAAM,GAAAC,MAAA,CAAKH,OAAO,EAA7B,QAAmB,CAAU;IACnC,MAAMI,SAAS,GAAG,MAAMlB,WAAW,CAACe,IAAI,CAAC;IACzC,OAAAI,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACKJ,MAAM;MACTD,IAAI,EAAE;QACJM,OAAO,EAAEN,IAAI;QACbO,aAAa,EAAE,IAAI,CAACX,YAAY,EAAE,CAACC,KAAK,EAAE;QAC1CW,UAAU,EAAE,MAAM,IAAI,CAACC,IAAI,CAACvB,MAAM,CAACE,eAAe,EAAEe,SAAS,CAAC;;IAC/D;EAEL;;AAGF,OAAM,MAAOO,iBAAiB;EACrBlB,YAAYA,CAAA;IACjB,OAAOR,SAAS,CAAC2B,SAAS,EAAE;EAC9B;EAEO,MAAMb,gBAAgBA,CAACC,OAAyB;IACrD,OAAAK,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACKN,OAAO;MACVC,IAAI,EAAE;QAAEM,OAAO,EAAEP,OAAO,CAACC;MAAI;IAAE;EAEnC;;AAwBF;;;;AAIA,OAAM,SAAUY,wBAAwBA,CACtCC,QAA0C;EAE1C,MAAMC,iBAAiB,GACrB,cAAc,IAAID,QAAQ,GACtB;IAAEE,IAAI,EAAE,mBAAmB;IAAEC,SAAS,EAAE7B,KAAK,CAAC0B,QAAQ,CAACjB,YAAY,EAAE,CAACC,KAAK,EAAE;EAAC,CAAE,GAChF;IAAEkB,IAAI,EAAE;EAAmB,CAAE;EACnC,OAAOD,iBAAiB;AAC1B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}