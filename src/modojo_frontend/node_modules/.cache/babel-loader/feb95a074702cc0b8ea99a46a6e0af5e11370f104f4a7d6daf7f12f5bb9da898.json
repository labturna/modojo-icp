{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.file = void 0;\nfunction getValidPath(path) {\n  if (typeof path !== 'string') {\n    throw new Error('File path must be a string');\n  }\n  if (path.startsWith('/')) {\n    path = path.slice(1);\n  }\n  if (path.endsWith('/')) {\n    path = path.slice(0, -1);\n  }\n  return path;\n}\nconst file = (mo, path) => {\n  path = getValidPath(path);\n  const result = {\n    get path() {\n      return path;\n    },\n    set path(newPath) {\n      path = newPath;\n    },\n    // file(subPath) {\n    //     subPath = getValidPath(subPath);\n    //     return exports.file(`${path}/${subPath}`);\n    // },\n    clone() {\n      return exports.file(path);\n    },\n    read() {\n      return mo.read(path);\n    },\n    write(content) {\n      return mo.write(path, content);\n    },\n    rename(newPath) {\n      let result = mo.rename(path, newPath);\n      path = newPath;\n      return result;\n    },\n    delete() {\n      return mo.delete(path);\n    },\n    list() {\n      return mo.list(path);\n    },\n    check() {\n      return mo.check(path);\n    },\n    run() {\n      return mo.run(path);\n    },\n    candid() {\n      return mo.candid(path);\n    },\n    wasm(mode) {\n      return mo.wasm(path, mode);\n    },\n    parseCandid() {\n      return mo.parseCandid(result.read());\n    },\n    parseMotoko() {\n      return mo.parseMotoko(result.read());\n    },\n    parseMotokoTyped() {\n      return mo.parseMotokoTyped(path);\n    }\n  };\n  return result;\n};\nexports.file = file;","map":{"version":3,"names":["getValidPath","path","Error","startsWith","slice","endsWith","file","mo","result","newPath","clone","exports","read","write","content","rename","delete","list","check","run","candid","wasm","mode","parseCandid","parseMotoko","parseMotokoTyped"],"sources":["/home/arslan/modojo/node_modules/motoko/src/file.ts"],"sourcesContent":["import { Motoko, WasmMode } from '.';\n\nfunction getValidPath(path: string): string {\n    if (typeof path !== 'string') {\n        throw new Error('File path must be a string');\n    }\n    if (path.startsWith('/')) {\n        path = path.slice(1);\n    }\n    if (path.endsWith('/')) {\n        path = path.slice(0, -1);\n    }\n    return path;\n}\n\nexport type MotokoFile = ReturnType<typeof file>;\n\nexport const file = (mo: Motoko, path: string) => {\n    path = getValidPath(path);\n    const result = {\n        get path(): string {\n            return path;\n        },\n        set path(newPath) {\n            path = newPath;\n        },\n        // file(subPath) {\n        //     subPath = getValidPath(subPath);\n        //     return exports.file(`${path}/${subPath}`);\n        // },\n        clone() {\n            return exports.file(path);\n        },\n        read(): string {\n            return mo.read(path);\n        },\n        write(content: string) {\n            return mo.write(path, content);\n        },\n        rename(newPath: string) {\n            let result = mo.rename(path, newPath);\n            path = newPath;\n            return result;\n        },\n        delete() {\n            return mo.delete(path);\n        },\n        list() {\n            return mo.list(path);\n        },\n        check() {\n            return mo.check(path);\n        },\n        run() {\n            return mo.run(path);\n        },\n        candid() {\n            return mo.candid(path);\n        },\n        wasm(mode: WasmMode) {\n            return mo.wasm(path, mode);\n        },\n        parseCandid() {\n            return mo.parseCandid(result.read());\n        },\n        parseMotoko() {\n            return mo.parseMotoko(result.read());\n        },\n        parseMotokoTyped() {\n            return mo.parseMotokoTyped(path);\n        },\n    };\n    return result;\n};\n"],"mappings":";;;;;;AAEA,SAASA,YAAYA,CAACC,IAAY;EAC9B,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;IAC1B,MAAM,IAAIC,KAAK,CAAC,4BAA4B,CAAC;;EAEjD,IAAID,IAAI,CAACE,UAAU,CAAC,GAAG,CAAC,EAAE;IACtBF,IAAI,GAAGA,IAAI,CAACG,KAAK,CAAC,CAAC,CAAC;;EAExB,IAAIH,IAAI,CAACI,QAAQ,CAAC,GAAG,CAAC,EAAE;IACpBJ,IAAI,GAAGA,IAAI,CAACG,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;;EAE5B,OAAOH,IAAI;AACf;AAIO,MAAMK,IAAI,GAAGA,CAACC,EAAU,EAAEN,IAAY,KAAI;EAC7CA,IAAI,GAAGD,YAAY,CAACC,IAAI,CAAC;EACzB,MAAMO,MAAM,GAAG;IACX,IAAIP,IAAIA,CAAA;MACJ,OAAOA,IAAI;IACf,CAAC;IACD,IAAIA,IAAIA,CAACQ,OAAO;MACZR,IAAI,GAAGQ,OAAO;IAClB,CAAC;IACD;IACA;IACA;IACA;IACAC,KAAKA,CAAA;MACD,OAAOC,OAAO,CAACL,IAAI,CAACL,IAAI,CAAC;IAC7B,CAAC;IACDW,IAAIA,CAAA;MACA,OAAOL,EAAE,CAACK,IAAI,CAACX,IAAI,CAAC;IACxB,CAAC;IACDY,KAAKA,CAACC,OAAe;MACjB,OAAOP,EAAE,CAACM,KAAK,CAACZ,IAAI,EAAEa,OAAO,CAAC;IAClC,CAAC;IACDC,MAAMA,CAACN,OAAe;MAClB,IAAID,MAAM,GAAGD,EAAE,CAACQ,MAAM,CAACd,IAAI,EAAEQ,OAAO,CAAC;MACrCR,IAAI,GAAGQ,OAAO;MACd,OAAOD,MAAM;IACjB,CAAC;IACDQ,MAAMA,CAAA;MACF,OAAOT,EAAE,CAACS,MAAM,CAACf,IAAI,CAAC;IAC1B,CAAC;IACDgB,IAAIA,CAAA;MACA,OAAOV,EAAE,CAACU,IAAI,CAAChB,IAAI,CAAC;IACxB,CAAC;IACDiB,KAAKA,CAAA;MACD,OAAOX,EAAE,CAACW,KAAK,CAACjB,IAAI,CAAC;IACzB,CAAC;IACDkB,GAAGA,CAAA;MACC,OAAOZ,EAAE,CAACY,GAAG,CAAClB,IAAI,CAAC;IACvB,CAAC;IACDmB,MAAMA,CAAA;MACF,OAAOb,EAAE,CAACa,MAAM,CAACnB,IAAI,CAAC;IAC1B,CAAC;IACDoB,IAAIA,CAACC,IAAc;MACf,OAAOf,EAAE,CAACc,IAAI,CAACpB,IAAI,EAAEqB,IAAI,CAAC;IAC9B,CAAC;IACDC,WAAWA,CAAA;MACP,OAAOhB,EAAE,CAACgB,WAAW,CAACf,MAAM,CAACI,IAAI,EAAE,CAAC;IACxC,CAAC;IACDY,WAAWA,CAAA;MACP,OAAOjB,EAAE,CAACiB,WAAW,CAAChB,MAAM,CAACI,IAAI,EAAE,CAAC;IACxC,CAAC;IACDa,gBAAgBA,CAAA;MACZ,OAAOlB,EAAE,CAACkB,gBAAgB,CAACxB,IAAI,CAAC;IACpC;GACH;EACD,OAAOO,MAAM;AACjB,CAAC;AAxDYG,OAAA,CAAAL,IAAI,GAAAA,IAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}