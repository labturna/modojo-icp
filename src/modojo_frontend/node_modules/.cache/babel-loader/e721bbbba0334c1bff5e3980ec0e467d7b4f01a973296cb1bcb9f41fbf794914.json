{"ast":null,"code":"/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { Principal as PrincipalId } from '@dfinity/principal';\nimport { concat, PipeArrayBuffer as Pipe } from './utils/buffer';\nimport { idlLabelToId } from './utils/hash';\nimport { lebDecode, lebEncode, readIntLE, readUIntLE, safeRead, safeReadUint8, slebDecode, slebEncode, writeIntLE, writeUIntLE } from './utils/leb128';\nimport { iexp2 } from './utils/bigint-math';\nconst magicNumber = 'DIDL';\nconst toReadableString_max = 400; // will not display arguments after 400chars. Makes sure 2mb blobs don't get inside the error\nfunction zipWith(xs, ys, f) {\n  return xs.map((x, i) => f(x, ys[i]));\n}\n/**\n * An IDL Type Table, which precedes the data in the stream.\n */\nclass TypeTable {\n  constructor() {\n    // List of types. Needs to be an array as the index needs to be stable.\n    this._typs = [];\n    this._idx = new Map();\n  }\n  has(obj) {\n    return this._idx.has(obj.name);\n  }\n  add(type, buf) {\n    const idx = this._typs.length;\n    this._idx.set(type.name, idx);\n    this._typs.push(buf);\n  }\n  merge(obj, knot) {\n    const idx = this._idx.get(obj.name);\n    const knotIdx = this._idx.get(knot);\n    if (idx === undefined) {\n      throw new Error('Missing type index for ' + obj);\n    }\n    if (knotIdx === undefined) {\n      throw new Error('Missing type index for ' + knot);\n    }\n    this._typs[idx] = this._typs[knotIdx];\n    // Delete the type.\n    this._typs.splice(knotIdx, 1);\n    this._idx.delete(knot);\n  }\n  encode() {\n    const len = lebEncode(this._typs.length);\n    const buf = concat(...this._typs);\n    return concat(len, buf);\n  }\n  indexOf(typeName) {\n    if (!this._idx.has(typeName)) {\n      throw new Error('Missing type index for ' + typeName);\n    }\n    return slebEncode(this._idx.get(typeName) || 0);\n  }\n}\nexport class Visitor {\n  visitType(t, data) {\n    throw new Error('Not implemented');\n  }\n  visitPrimitive(t, data) {\n    return this.visitType(t, data);\n  }\n  visitEmpty(t, data) {\n    return this.visitPrimitive(t, data);\n  }\n  visitBool(t, data) {\n    return this.visitPrimitive(t, data);\n  }\n  visitNull(t, data) {\n    return this.visitPrimitive(t, data);\n  }\n  visitReserved(t, data) {\n    return this.visitPrimitive(t, data);\n  }\n  visitText(t, data) {\n    return this.visitPrimitive(t, data);\n  }\n  visitNumber(t, data) {\n    return this.visitPrimitive(t, data);\n  }\n  visitInt(t, data) {\n    return this.visitNumber(t, data);\n  }\n  visitNat(t, data) {\n    return this.visitNumber(t, data);\n  }\n  visitFloat(t, data) {\n    return this.visitPrimitive(t, data);\n  }\n  visitFixedInt(t, data) {\n    return this.visitNumber(t, data);\n  }\n  visitFixedNat(t, data) {\n    return this.visitNumber(t, data);\n  }\n  visitPrincipal(t, data) {\n    return this.visitPrimitive(t, data);\n  }\n  visitConstruct(t, data) {\n    return this.visitType(t, data);\n  }\n  visitVec(t, ty, data) {\n    return this.visitConstruct(t, data);\n  }\n  visitOpt(t, ty, data) {\n    return this.visitConstruct(t, data);\n  }\n  visitRecord(t, fields, data) {\n    return this.visitConstruct(t, data);\n  }\n  visitTuple(t, components, data) {\n    const fields = components.map((ty, i) => [`_${i}_`, ty]);\n    return this.visitRecord(t, fields, data);\n  }\n  visitVariant(t, fields, data) {\n    return this.visitConstruct(t, data);\n  }\n  visitRec(t, ty, data) {\n    return this.visitConstruct(ty, data);\n  }\n  visitFunc(t, data) {\n    return this.visitConstruct(t, data);\n  }\n  visitService(t, data) {\n    return this.visitConstruct(t, data);\n  }\n}\n/**\n * Represents an IDL type.\n */\nexport class Type {\n  /* Display type name */\n  display() {\n    return this.name;\n  }\n  valueToString(x) {\n    return toReadableString(x);\n  }\n  /* Implement `T` in the IDL spec, only needed for non-primitive types */\n  buildTypeTable(typeTable) {\n    if (!typeTable.has(this)) {\n      this._buildTypeTableImpl(typeTable);\n    }\n  }\n}\nexport class PrimitiveType extends Type {\n  checkType(t) {\n    if (this.name !== t.name) {\n      throw new Error(`type mismatch: type on the wire ${t.name}, expect type ${this.name}`);\n    }\n    return t;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _buildTypeTableImpl(typeTable) {\n    // No type table encoding for Primitive types.\n    return;\n  }\n}\nexport class ConstructType extends Type {\n  checkType(t) {\n    if (t instanceof RecClass) {\n      const ty = t.getType();\n      if (typeof ty === 'undefined') {\n        throw new Error('type mismatch with uninitialized type');\n      }\n      return ty;\n    }\n    throw new Error(`type mismatch: type on the wire ${t.name}, expect type ${this.name}`);\n  }\n  encodeType(typeTable) {\n    return typeTable.indexOf(this.name);\n  }\n}\n/**\n * Represents an IDL Empty, a type which has no inhabitants.\n * Since no values exist for this type, it cannot be serialised or deserialised.\n * Result types like `Result<Text, Empty>` should always succeed.\n */\nexport class EmptyClass extends PrimitiveType {\n  accept(v, d) {\n    return v.visitEmpty(this, d);\n  }\n  covariant(x) {\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n  encodeValue() {\n    throw new Error('Empty cannot appear as a function argument');\n  }\n  valueToString() {\n    throw new Error('Empty cannot appear as a value');\n  }\n  encodeType() {\n    return slebEncode(-17 /* IDLTypeIds.Empty */);\n  }\n  decodeValue() {\n    throw new Error('Empty cannot appear as an output');\n  }\n  get name() {\n    return 'empty';\n  }\n}\n/**\n * Represents an IDL Unknown, a placeholder type for deserialization only.\n * When decoding a value as Unknown, all fields will be retained but the names are only available in\n * hashed form.\n * A deserialized unknown will offer it's actual type by calling the `type()` function.\n * Unknown cannot be serialized and attempting to do so will throw an error.\n */\nexport class UnknownClass extends Type {\n  checkType(t) {\n    throw new Error('Method not implemented for unknown.');\n  }\n  accept(v, d) {\n    throw v.visitType(this, d);\n  }\n  covariant(x) {\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n  encodeValue() {\n    throw new Error('Unknown cannot appear as a function argument');\n  }\n  valueToString() {\n    throw new Error('Unknown cannot appear as a value');\n  }\n  encodeType() {\n    throw new Error('Unknown cannot be serialized');\n  }\n  decodeValue(b, t) {\n    let decodedValue = t.decodeValue(b, t);\n    if (Object(decodedValue) !== decodedValue) {\n      // decodedValue is primitive. Box it, otherwise we cannot add the type() function.\n      // The type() function is important for primitives because otherwise we cannot tell apart the\n      // different number types.\n      decodedValue = Object(decodedValue);\n    }\n    let typeFunc;\n    if (t instanceof RecClass) {\n      typeFunc = () => t.getType();\n    } else {\n      typeFunc = () => t;\n    }\n    // Do not use 'decodedValue.type = typeFunc' because this would lead to an enumerable property\n    // 'type' which means it would be serialized if the value would be candid encoded again.\n    // This in turn leads to problems if the decoded value is a variant because these values are\n    // only allowed to have a single property.\n    Object.defineProperty(decodedValue, 'type', {\n      value: typeFunc,\n      writable: true,\n      enumerable: false,\n      configurable: true\n    });\n    return decodedValue;\n  }\n  _buildTypeTableImpl() {\n    throw new Error('Unknown cannot be serialized');\n  }\n  get name() {\n    return 'Unknown';\n  }\n}\n/**\n * Represents an IDL Bool\n */\nexport class BoolClass extends PrimitiveType {\n  accept(v, d) {\n    return v.visitBool(this, d);\n  }\n  covariant(x) {\n    if (typeof x === 'boolean') return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n  encodeValue(x) {\n    return new Uint8Array([x ? 1 : 0]);\n  }\n  encodeType() {\n    return slebEncode(-2 /* IDLTypeIds.Bool */);\n  }\n  decodeValue(b, t) {\n    this.checkType(t);\n    switch (safeReadUint8(b)) {\n      case 0:\n        return false;\n      case 1:\n        return true;\n      default:\n        throw new Error('Boolean value out of range');\n    }\n  }\n  get name() {\n    return 'bool';\n  }\n}\n/**\n * Represents an IDL Null\n */\nexport class NullClass extends PrimitiveType {\n  accept(v, d) {\n    return v.visitNull(this, d);\n  }\n  covariant(x) {\n    if (x === null) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n  encodeValue() {\n    return new ArrayBuffer(0);\n  }\n  encodeType() {\n    return slebEncode(-1 /* IDLTypeIds.Null */);\n  }\n  decodeValue(b, t) {\n    this.checkType(t);\n    return null;\n  }\n  get name() {\n    return 'null';\n  }\n}\n/**\n * Represents an IDL Reserved\n */\nexport class ReservedClass extends PrimitiveType {\n  accept(v, d) {\n    return v.visitReserved(this, d);\n  }\n  covariant(x) {\n    return true;\n  }\n  encodeValue() {\n    return new ArrayBuffer(0);\n  }\n  encodeType() {\n    return slebEncode(-16 /* IDLTypeIds.Reserved */);\n  }\n  decodeValue(b, t) {\n    if (t.name !== this.name) {\n      t.decodeValue(b, t);\n    }\n    return null;\n  }\n  get name() {\n    return 'reserved';\n  }\n}\n/**\n * Represents an IDL Text\n */\nexport class TextClass extends PrimitiveType {\n  accept(v, d) {\n    return v.visitText(this, d);\n  }\n  covariant(x) {\n    if (typeof x === 'string') return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n  encodeValue(x) {\n    const buf = new TextEncoder().encode(x);\n    const len = lebEncode(buf.byteLength);\n    return concat(len, buf);\n  }\n  encodeType() {\n    return slebEncode(-15 /* IDLTypeIds.Text */);\n  }\n  decodeValue(b, t) {\n    this.checkType(t);\n    const len = lebDecode(b);\n    const buf = safeRead(b, Number(len));\n    const decoder = new TextDecoder('utf8', {\n      fatal: true\n    });\n    return decoder.decode(buf);\n  }\n  get name() {\n    return 'text';\n  }\n  valueToString(x) {\n    return '\"' + x + '\"';\n  }\n}\n/**\n * Represents an IDL Int\n */\nexport class IntClass extends PrimitiveType {\n  accept(v, d) {\n    return v.visitInt(this, d);\n  }\n  covariant(x) {\n    // We allow encoding of JavaScript plain numbers.\n    // But we will always decode to bigint.\n    if (typeof x === 'bigint' || Number.isInteger(x)) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n  encodeValue(x) {\n    return slebEncode(x);\n  }\n  encodeType() {\n    return slebEncode(-4 /* IDLTypeIds.Int */);\n  }\n  decodeValue(b, t) {\n    this.checkType(t);\n    return slebDecode(b);\n  }\n  get name() {\n    return 'int';\n  }\n  valueToString(x) {\n    return x.toString();\n  }\n}\n/**\n * Represents an IDL Nat\n */\nexport class NatClass extends PrimitiveType {\n  accept(v, d) {\n    return v.visitNat(this, d);\n  }\n  covariant(x) {\n    // We allow encoding of JavaScript plain numbers.\n    // But we will always decode to bigint.\n    if (typeof x === 'bigint' && x >= BigInt(0) || Number.isInteger(x) && x >= 0) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n  encodeValue(x) {\n    return lebEncode(x);\n  }\n  encodeType() {\n    return slebEncode(-3 /* IDLTypeIds.Nat */);\n  }\n  decodeValue(b, t) {\n    this.checkType(t);\n    return lebDecode(b);\n  }\n  get name() {\n    return 'nat';\n  }\n  valueToString(x) {\n    return x.toString();\n  }\n}\n/**\n * Represents an IDL Float\n */\nexport class FloatClass extends PrimitiveType {\n  constructor(_bits) {\n    super();\n    this._bits = _bits;\n    if (_bits !== 32 && _bits !== 64) {\n      throw new Error('not a valid float type');\n    }\n  }\n  accept(v, d) {\n    return v.visitFloat(this, d);\n  }\n  covariant(x) {\n    if (typeof x === 'number' || x instanceof Number) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n  encodeValue(x) {\n    const buf = new ArrayBuffer(this._bits / 8);\n    const view = new DataView(buf);\n    if (this._bits === 32) {\n      view.setFloat32(0, x, true);\n    } else {\n      view.setFloat64(0, x, true);\n    }\n    return buf;\n  }\n  encodeType() {\n    const opcode = this._bits === 32 ? -13 /* IDLTypeIds.Float32 */ : -14 /* IDLTypeIds.Float64 */;\n    return slebEncode(opcode);\n  }\n  decodeValue(b, t) {\n    this.checkType(t);\n    const bytes = safeRead(b, this._bits / 8);\n    const view = new DataView(bytes);\n    if (this._bits === 32) {\n      return view.getFloat32(0, true);\n    } else {\n      return view.getFloat64(0, true);\n    }\n  }\n  get name() {\n    return 'float' + this._bits;\n  }\n  valueToString(x) {\n    return x.toString();\n  }\n}\n/**\n * Represents an IDL fixed-width Int(n)\n */\nexport class FixedIntClass extends PrimitiveType {\n  constructor(_bits) {\n    super();\n    this._bits = _bits;\n  }\n  accept(v, d) {\n    return v.visitFixedInt(this, d);\n  }\n  covariant(x) {\n    const min = iexp2(this._bits - 1) * BigInt(-1);\n    const max = iexp2(this._bits - 1) - BigInt(1);\n    let ok = false;\n    if (typeof x === 'bigint') {\n      ok = x >= min && x <= max;\n    } else if (Number.isInteger(x)) {\n      const v = BigInt(x);\n      ok = v >= min && v <= max;\n    } else {\n      ok = false;\n    }\n    if (ok) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n  encodeValue(x) {\n    return writeIntLE(x, this._bits / 8);\n  }\n  encodeType() {\n    const offset = Math.log2(this._bits) - 3;\n    return slebEncode(-9 - offset);\n  }\n  decodeValue(b, t) {\n    this.checkType(t);\n    const num = readIntLE(b, this._bits / 8);\n    if (this._bits <= 32) {\n      return Number(num);\n    } else {\n      return num;\n    }\n  }\n  get name() {\n    return `int${this._bits}`;\n  }\n  valueToString(x) {\n    return x.toString();\n  }\n}\n/**\n * Represents an IDL fixed-width Nat(n)\n */\nexport class FixedNatClass extends PrimitiveType {\n  constructor(_bits) {\n    super();\n    this._bits = _bits;\n  }\n  accept(v, d) {\n    return v.visitFixedNat(this, d);\n  }\n  covariant(x) {\n    const max = iexp2(this._bits);\n    let ok = false;\n    if (typeof x === 'bigint' && x >= BigInt(0)) {\n      ok = x < max;\n    } else if (Number.isInteger(x) && x >= 0) {\n      const v = BigInt(x);\n      ok = v < max;\n    } else {\n      ok = false;\n    }\n    if (ok) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n  encodeValue(x) {\n    return writeUIntLE(x, this._bits / 8);\n  }\n  encodeType() {\n    const offset = Math.log2(this._bits) - 3;\n    return slebEncode(-5 - offset);\n  }\n  decodeValue(b, t) {\n    this.checkType(t);\n    const num = readUIntLE(b, this._bits / 8);\n    if (this._bits <= 32) {\n      return Number(num);\n    } else {\n      return num;\n    }\n  }\n  get name() {\n    return `nat${this._bits}`;\n  }\n  valueToString(x) {\n    return x.toString();\n  }\n}\n/**\n * Represents an IDL Array\n *\n * Arrays of fixed-sized nat/int type (e.g. nat8), are encoded from and decoded to TypedArrays (e.g. Uint8Array).\n * Arrays of float or other non-primitive types are encoded/decoded as untyped array in Javascript.\n * @param {Type} t\n */\nexport class VecClass extends ConstructType {\n  constructor(_type) {\n    super();\n    this._type = _type;\n    // If true, this vector is really a blob and we can just use memcpy.\n    //\n    // NOTE:\n    // With support of encoding/dencoding of TypedArrays, this optimization is\n    // only used when plain array of bytes are passed as encoding input in order\n    // to be backward compatible.\n    this._blobOptimization = false;\n    if (_type instanceof FixedNatClass && _type._bits === 8) {\n      this._blobOptimization = true;\n    }\n  }\n  accept(v, d) {\n    return v.visitVec(this, this._type, d);\n  }\n  covariant(x) {\n    // Special case for ArrayBuffer\n    const bits = this._type instanceof FixedNatClass ? this._type._bits : this._type instanceof FixedIntClass ? this._type._bits : 0;\n    if (ArrayBuffer.isView(x) && bits == x.BYTES_PER_ELEMENT * 8 || Array.isArray(x) && x.every((v, idx) => {\n      try {\n        return this._type.covariant(v);\n      } catch (e) {\n        throw new Error(`Invalid ${this.display()} argument: \\n\\nindex ${idx} -> ${e.message}`);\n      }\n    })) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n  encodeValue(x) {\n    const len = lebEncode(x.length);\n    if (this._blobOptimization) {\n      return concat(len, new Uint8Array(x));\n    }\n    if (ArrayBuffer.isView(x)) {\n      return concat(len, new Uint8Array(x.buffer));\n    }\n    const buf = new Pipe(new ArrayBuffer(len.byteLength + x.length), 0);\n    buf.write(len);\n    for (const d of x) {\n      const encoded = this._type.encodeValue(d);\n      buf.write(new Uint8Array(encoded));\n    }\n    return buf.buffer;\n  }\n  _buildTypeTableImpl(typeTable) {\n    this._type.buildTypeTable(typeTable);\n    const opCode = slebEncode(-19 /* IDLTypeIds.Vector */);\n    const buffer = this._type.encodeType(typeTable);\n    typeTable.add(this, concat(opCode, buffer));\n  }\n  decodeValue(b, t) {\n    const vec = this.checkType(t);\n    if (!(vec instanceof VecClass)) {\n      throw new Error('Not a vector type');\n    }\n    const len = Number(lebDecode(b));\n    if (this._type instanceof FixedNatClass) {\n      if (this._type._bits == 8) {\n        return new Uint8Array(b.read(len));\n      }\n      if (this._type._bits == 16) {\n        return new Uint16Array(b.read(len * 2));\n      }\n      if (this._type._bits == 32) {\n        return new Uint32Array(b.read(len * 4));\n      }\n      if (this._type._bits == 64) {\n        return new BigUint64Array(b.read(len * 8));\n      }\n    }\n    if (this._type instanceof FixedIntClass) {\n      if (this._type._bits == 8) {\n        return new Int8Array(b.read(len));\n      }\n      if (this._type._bits == 16) {\n        return new Int16Array(b.read(len * 2));\n      }\n      if (this._type._bits == 32) {\n        return new Int32Array(b.read(len * 4));\n      }\n      if (this._type._bits == 64) {\n        return new BigInt64Array(b.read(len * 8));\n      }\n    }\n    const rets = [];\n    for (let i = 0; i < len; i++) {\n      rets.push(this._type.decodeValue(b, vec._type));\n    }\n    return rets;\n  }\n  get name() {\n    return `vec ${this._type.name}`;\n  }\n  display() {\n    return `vec ${this._type.display()}`;\n  }\n  valueToString(x) {\n    const elements = x.map(e => this._type.valueToString(e));\n    return 'vec {' + elements.join('; ') + '}';\n  }\n}\n/**\n * Represents an IDL Option\n * @param {Type} t\n */\nexport class OptClass extends ConstructType {\n  constructor(_type) {\n    super();\n    this._type = _type;\n  }\n  accept(v, d) {\n    return v.visitOpt(this, this._type, d);\n  }\n  covariant(x) {\n    try {\n      if (Array.isArray(x) && (x.length === 0 || x.length === 1 && this._type.covariant(x[0]))) return true;\n    } catch (e) {\n      throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)} \\n\\n-> ${e.message}`);\n    }\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n  encodeValue(x) {\n    if (x.length === 0) {\n      return new Uint8Array([0]);\n    } else {\n      return concat(new Uint8Array([1]), this._type.encodeValue(x[0]));\n    }\n  }\n  _buildTypeTableImpl(typeTable) {\n    this._type.buildTypeTable(typeTable);\n    const opCode = slebEncode(-18 /* IDLTypeIds.Opt */);\n    const buffer = this._type.encodeType(typeTable);\n    typeTable.add(this, concat(opCode, buffer));\n  }\n  decodeValue(b, t) {\n    const opt = this.checkType(t);\n    if (!(opt instanceof OptClass)) {\n      throw new Error('Not an option type');\n    }\n    switch (safeReadUint8(b)) {\n      case 0:\n        return [];\n      case 1:\n        return [this._type.decodeValue(b, opt._type)];\n      default:\n        throw new Error('Not an option value');\n    }\n  }\n  get name() {\n    return `opt ${this._type.name}`;\n  }\n  display() {\n    return `opt ${this._type.display()}`;\n  }\n  valueToString(x) {\n    if (x.length === 0) {\n      return 'null';\n    } else {\n      return `opt ${this._type.valueToString(x[0])}`;\n    }\n  }\n}\n/**\n * Represents an IDL Record\n * @param {object} [fields] - mapping of function name to Type\n */\nexport class RecordClass extends ConstructType {\n  constructor() {\n    let fields = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    this._fields = Object.entries(fields).sort((a, b) => idlLabelToId(a[0]) - idlLabelToId(b[0]));\n  }\n  accept(v, d) {\n    return v.visitRecord(this, this._fields, d);\n  }\n  tryAsTuple() {\n    const res = [];\n    for (let i = 0; i < this._fields.length; i++) {\n      const [key, type] = this._fields[i];\n      if (key !== `_${i}_`) {\n        return null;\n      }\n      res.push(type);\n    }\n    return res;\n  }\n  covariant(x) {\n    if (typeof x === 'object' && this._fields.every(_ref => {\n      let [k, t] = _ref;\n      // eslint-disable-next-line\n      if (!x.hasOwnProperty(k)) {\n        throw new Error(`Record is missing key \"${k}\".`);\n      }\n      try {\n        return t.covariant(x[k]);\n      } catch (e) {\n        throw new Error(`Invalid ${this.display()} argument: \\n\\nfield ${k} -> ${e.message}`);\n      }\n    })) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n  encodeValue(x) {\n    const values = this._fields.map(_ref2 => {\n      let [key] = _ref2;\n      return x[key];\n    });\n    const bufs = zipWith(this._fields, values, (_ref3, d) => {\n      let [, c] = _ref3;\n      return c.encodeValue(d);\n    });\n    return concat(...bufs);\n  }\n  _buildTypeTableImpl(T) {\n    this._fields.forEach(_ref4 => {\n      let [_, value] = _ref4;\n      return value.buildTypeTable(T);\n    });\n    const opCode = slebEncode(-20 /* IDLTypeIds.Record */);\n    const len = lebEncode(this._fields.length);\n    const fields = this._fields.map(_ref5 => {\n      let [key, value] = _ref5;\n      return concat(lebEncode(idlLabelToId(key)), value.encodeType(T));\n    });\n    T.add(this, concat(opCode, len, concat(...fields)));\n  }\n  decodeValue(b, t) {\n    const record = this.checkType(t);\n    if (!(record instanceof RecordClass)) {\n      throw new Error('Not a record type');\n    }\n    const x = {};\n    let expectedRecordIdx = 0;\n    let actualRecordIdx = 0;\n    while (actualRecordIdx < record._fields.length) {\n      const [hash, type] = record._fields[actualRecordIdx];\n      if (expectedRecordIdx >= this._fields.length) {\n        // skip unexpected left over fields present on the wire\n        type.decodeValue(b, type);\n        actualRecordIdx++;\n        continue;\n      }\n      const [expectKey, expectType] = this._fields[expectedRecordIdx];\n      const expectedId = idlLabelToId(this._fields[expectedRecordIdx][0]);\n      const actualId = idlLabelToId(hash);\n      if (expectedId === actualId) {\n        // the current field on the wire matches the expected field\n        x[expectKey] = expectType.decodeValue(b, type);\n        expectedRecordIdx++;\n        actualRecordIdx++;\n      } else if (actualId > expectedId) {\n        // The expected field does not exist on the wire\n        if (expectType instanceof OptClass || expectType instanceof ReservedClass) {\n          x[expectKey] = [];\n          expectedRecordIdx++;\n        } else {\n          throw new Error('Cannot find required field ' + expectKey);\n        }\n      } else {\n        // The field on the wire does not exist in the output type, so we can skip it\n        type.decodeValue(b, type);\n        actualRecordIdx++;\n      }\n    }\n    // initialize left over expected optional fields\n    for (const [expectKey, expectType] of this._fields.slice(expectedRecordIdx)) {\n      if (expectType instanceof OptClass || expectType instanceof ReservedClass) {\n        // TODO this assumes null value in opt is represented as []\n        x[expectKey] = [];\n      } else {\n        throw new Error('Cannot find required field ' + expectKey);\n      }\n    }\n    return x;\n  }\n  get name() {\n    const fields = this._fields.map(_ref6 => {\n      let [key, value] = _ref6;\n      return key + ':' + value.name;\n    });\n    return `record {${fields.join('; ')}}`;\n  }\n  display() {\n    const fields = this._fields.map(_ref7 => {\n      let [key, value] = _ref7;\n      return key + ':' + value.display();\n    });\n    return `record {${fields.join('; ')}}`;\n  }\n  valueToString(x) {\n    const values = this._fields.map(_ref8 => {\n      let [key] = _ref8;\n      return x[key];\n    });\n    const fields = zipWith(this._fields, values, (_ref9, d) => {\n      let [k, c] = _ref9;\n      return k + '=' + c.valueToString(d);\n    });\n    return `record {${fields.join('; ')}}`;\n  }\n}\n/**\n * Represents Tuple, a syntactic sugar for Record.\n * @param {Type} components\n */\nexport class TupleClass extends RecordClass {\n  constructor(_components) {\n    const x = {};\n    _components.forEach((e, i) => x['_' + i + '_'] = e);\n    super(x);\n    this._components = _components;\n  }\n  accept(v, d) {\n    return v.visitTuple(this, this._components, d);\n  }\n  covariant(x) {\n    // `>=` because tuples can be covariant when encoded.\n    if (Array.isArray(x) && x.length >= this._fields.length && this._components.every((t, i) => {\n      try {\n        return t.covariant(x[i]);\n      } catch (e) {\n        throw new Error(`Invalid ${this.display()} argument: \\n\\nindex ${i} -> ${e.message}`);\n      }\n    })) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n  encodeValue(x) {\n    const bufs = zipWith(this._components, x, (c, d) => c.encodeValue(d));\n    return concat(...bufs);\n  }\n  decodeValue(b, t) {\n    const tuple = this.checkType(t);\n    if (!(tuple instanceof TupleClass)) {\n      throw new Error('not a tuple type');\n    }\n    if (tuple._components.length < this._components.length) {\n      throw new Error('tuple mismatch');\n    }\n    const res = [];\n    for (const [i, wireType] of tuple._components.entries()) {\n      if (i >= this._components.length) {\n        // skip value\n        wireType.decodeValue(b, wireType);\n      } else {\n        res.push(this._components[i].decodeValue(b, wireType));\n      }\n    }\n    return res;\n  }\n  display() {\n    const fields = this._components.map(value => value.display());\n    return `record {${fields.join('; ')}}`;\n  }\n  valueToString(values) {\n    const fields = zipWith(this._components, values, (c, d) => c.valueToString(d));\n    return `record {${fields.join('; ')}}`;\n  }\n}\n/**\n * Represents an IDL Variant\n * @param {object} [fields] - mapping of function name to Type\n */\nexport class VariantClass extends ConstructType {\n  constructor() {\n    let fields = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    this._fields = Object.entries(fields).sort((a, b) => idlLabelToId(a[0]) - idlLabelToId(b[0]));\n  }\n  accept(v, d) {\n    return v.visitVariant(this, this._fields, d);\n  }\n  covariant(x) {\n    if (typeof x === 'object' && Object.entries(x).length === 1 && this._fields.every(_ref10 => {\n      let [k, v] = _ref10;\n      try {\n        // eslint-disable-next-line\n        return !x.hasOwnProperty(k) || v.covariant(x[k]);\n      } catch (e) {\n        throw new Error(`Invalid ${this.display()} argument: \\n\\nvariant ${k} -> ${e.message}`);\n      }\n    })) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n  encodeValue(x) {\n    for (let i = 0; i < this._fields.length; i++) {\n      const [name, type] = this._fields[i];\n      // eslint-disable-next-line\n      if (x.hasOwnProperty(name)) {\n        const idx = lebEncode(i);\n        const buf = type.encodeValue(x[name]);\n        return concat(idx, buf);\n      }\n    }\n    throw Error('Variant has no data: ' + x);\n  }\n  _buildTypeTableImpl(typeTable) {\n    this._fields.forEach(_ref11 => {\n      let [, type] = _ref11;\n      type.buildTypeTable(typeTable);\n    });\n    const opCode = slebEncode(-21 /* IDLTypeIds.Variant */);\n    const len = lebEncode(this._fields.length);\n    const fields = this._fields.map(_ref12 => {\n      let [key, value] = _ref12;\n      return concat(lebEncode(idlLabelToId(key)), value.encodeType(typeTable));\n    });\n    typeTable.add(this, concat(opCode, len, ...fields));\n  }\n  decodeValue(b, t) {\n    const variant = this.checkType(t);\n    if (!(variant instanceof VariantClass)) {\n      throw new Error('Not a variant type');\n    }\n    const idx = Number(lebDecode(b));\n    if (idx >= variant._fields.length) {\n      throw Error('Invalid variant index: ' + idx);\n    }\n    const [wireHash, wireType] = variant._fields[idx];\n    for (const [key, expectType] of this._fields) {\n      if (idlLabelToId(wireHash) === idlLabelToId(key)) {\n        const value = expectType.decodeValue(b, wireType);\n        return {\n          [key]: value\n        };\n      }\n    }\n    throw new Error('Cannot find field hash ' + wireHash);\n  }\n  get name() {\n    const fields = this._fields.map(_ref13 => {\n      let [key, type] = _ref13;\n      return key + ':' + type.name;\n    });\n    return `variant {${fields.join('; ')}}`;\n  }\n  display() {\n    const fields = this._fields.map(_ref14 => {\n      let [key, type] = _ref14;\n      return key + (type.name === 'null' ? '' : `:${type.display()}`);\n    });\n    return `variant {${fields.join('; ')}}`;\n  }\n  valueToString(x) {\n    for (const [name, type] of this._fields) {\n      // eslint-disable-next-line\n      if (x.hasOwnProperty(name)) {\n        const value = type.valueToString(x[name]);\n        if (value === 'null') {\n          return `variant {${name}}`;\n        } else {\n          return `variant {${name}=${value}}`;\n        }\n      }\n    }\n    throw new Error('Variant has no data: ' + x);\n  }\n}\n/**\n * Represents a reference to an IDL type, used for defining recursive data\n * types.\n */\nexport class RecClass extends ConstructType {\n  constructor() {\n    super(...arguments);\n    this._id = RecClass._counter++;\n    this._type = undefined;\n  }\n  accept(v, d) {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    return v.visitRec(this, this._type, d);\n  }\n  fill(t) {\n    this._type = t;\n  }\n  getType() {\n    return this._type;\n  }\n  covariant(x) {\n    if (this._type ? this._type.covariant(x) : false) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n  encodeValue(x) {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    return this._type.encodeValue(x);\n  }\n  _buildTypeTableImpl(typeTable) {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    typeTable.add(this, new Uint8Array([]));\n    this._type.buildTypeTable(typeTable);\n    typeTable.merge(this, this._type.name);\n  }\n  decodeValue(b, t) {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    return this._type.decodeValue(b, t);\n  }\n  get name() {\n    return `rec_${this._id}`;\n  }\n  display() {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    return `μ${this.name}.${this._type.name}`;\n  }\n  valueToString(x) {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    return this._type.valueToString(x);\n  }\n}\nRecClass._counter = 0;\nfunction decodePrincipalId(b) {\n  const x = safeReadUint8(b);\n  if (x !== 1) {\n    throw new Error('Cannot decode principal');\n  }\n  const len = Number(lebDecode(b));\n  return PrincipalId.fromUint8Array(new Uint8Array(safeRead(b, len)));\n}\n/**\n * Represents an IDL principal reference\n */\nexport class PrincipalClass extends PrimitiveType {\n  accept(v, d) {\n    return v.visitPrincipal(this, d);\n  }\n  covariant(x) {\n    if (x && x._isPrincipal) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n  encodeValue(x) {\n    const buf = x.toUint8Array();\n    const len = lebEncode(buf.byteLength);\n    return concat(new Uint8Array([1]), len, buf);\n  }\n  encodeType() {\n    return slebEncode(-24 /* IDLTypeIds.Principal */);\n  }\n  decodeValue(b, t) {\n    this.checkType(t);\n    return decodePrincipalId(b);\n  }\n  get name() {\n    return 'principal';\n  }\n  valueToString(x) {\n    return `${this.name} \"${x.toText()}\"`;\n  }\n}\n/**\n * Represents an IDL function reference.\n * @param argTypes Argument types.\n * @param retTypes Return types.\n * @param annotations Function annotations.\n */\nexport class FuncClass extends ConstructType {\n  constructor(argTypes, retTypes) {\n    let annotations = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    super();\n    this.argTypes = argTypes;\n    this.retTypes = retTypes;\n    this.annotations = annotations;\n  }\n  static argsToString(types, v) {\n    if (types.length !== v.length) {\n      throw new Error('arity mismatch');\n    }\n    return '(' + types.map((t, i) => t.valueToString(v[i])).join(', ') + ')';\n  }\n  accept(v, d) {\n    return v.visitFunc(this, d);\n  }\n  covariant(x) {\n    if (Array.isArray(x) && x.length === 2 && x[0] && x[0]._isPrincipal && typeof x[1] === 'string') return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n  encodeValue(_ref15) {\n    let [principal, methodName] = _ref15;\n    const buf = principal.toUint8Array();\n    const len = lebEncode(buf.byteLength);\n    const canister = concat(new Uint8Array([1]), len, buf);\n    const method = new TextEncoder().encode(methodName);\n    const methodLen = lebEncode(method.byteLength);\n    return concat(new Uint8Array([1]), canister, methodLen, method);\n  }\n  _buildTypeTableImpl(T) {\n    this.argTypes.forEach(arg => arg.buildTypeTable(T));\n    this.retTypes.forEach(arg => arg.buildTypeTable(T));\n    const opCode = slebEncode(-22 /* IDLTypeIds.Func */);\n    const argLen = lebEncode(this.argTypes.length);\n    const args = concat(...this.argTypes.map(arg => arg.encodeType(T)));\n    const retLen = lebEncode(this.retTypes.length);\n    const rets = concat(...this.retTypes.map(arg => arg.encodeType(T)));\n    const annLen = lebEncode(this.annotations.length);\n    const anns = concat(...this.annotations.map(a => this.encodeAnnotation(a)));\n    T.add(this, concat(opCode, argLen, args, retLen, rets, annLen, anns));\n  }\n  decodeValue(b) {\n    const x = safeReadUint8(b);\n    if (x !== 1) {\n      throw new Error('Cannot decode function reference');\n    }\n    const canister = decodePrincipalId(b);\n    const mLen = Number(lebDecode(b));\n    const buf = safeRead(b, mLen);\n    const decoder = new TextDecoder('utf8', {\n      fatal: true\n    });\n    const method = decoder.decode(buf);\n    return [canister, method];\n  }\n  get name() {\n    const args = this.argTypes.map(arg => arg.name).join(', ');\n    const rets = this.retTypes.map(arg => arg.name).join(', ');\n    const annon = ' ' + this.annotations.join(' ');\n    return `(${args}) -> (${rets})${annon}`;\n  }\n  valueToString(_ref16) {\n    let [principal, str] = _ref16;\n    return `func \"${principal.toText()}\".${str}`;\n  }\n  display() {\n    const args = this.argTypes.map(arg => arg.display()).join(', ');\n    const rets = this.retTypes.map(arg => arg.display()).join(', ');\n    const annon = ' ' + this.annotations.join(' ');\n    return `(${args}) → (${rets})${annon}`;\n  }\n  encodeAnnotation(ann) {\n    if (ann === 'query') {\n      return new Uint8Array([1]);\n    } else if (ann === 'oneway') {\n      return new Uint8Array([2]);\n    } else if (ann === 'composite_query') {\n      return new Uint8Array([3]);\n    } else {\n      throw new Error('Illegal function annotation');\n    }\n  }\n}\nexport class ServiceClass extends ConstructType {\n  constructor(fields) {\n    super();\n    this._fields = Object.entries(fields).sort((a, b) => {\n      if (a[0] < b[0]) {\n        return -1;\n      }\n      if (a[0] > b[0]) {\n        return 1;\n      }\n      return 0;\n    });\n  }\n  accept(v, d) {\n    return v.visitService(this, d);\n  }\n  covariant(x) {\n    if (x && x._isPrincipal) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n  encodeValue(x) {\n    const buf = x.toUint8Array();\n    const len = lebEncode(buf.length);\n    return concat(new Uint8Array([1]), len, buf);\n  }\n  _buildTypeTableImpl(T) {\n    this._fields.forEach(_ref17 => {\n      let [_, func] = _ref17;\n      return func.buildTypeTable(T);\n    });\n    const opCode = slebEncode(-23 /* IDLTypeIds.Service */);\n    const len = lebEncode(this._fields.length);\n    const meths = this._fields.map(_ref18 => {\n      let [label, func] = _ref18;\n      const labelBuf = new TextEncoder().encode(label);\n      const labelLen = lebEncode(labelBuf.length);\n      return concat(labelLen, labelBuf, func.encodeType(T));\n    });\n    T.add(this, concat(opCode, len, ...meths));\n  }\n  decodeValue(b) {\n    return decodePrincipalId(b);\n  }\n  get name() {\n    const fields = this._fields.map(_ref19 => {\n      let [key, value] = _ref19;\n      return key + ':' + value.name;\n    });\n    return `service {${fields.join('; ')}}`;\n  }\n  valueToString(x) {\n    return `service \"${x.toText()}\"`;\n  }\n}\n/**\n * Takes an unknown value and returns a string representation of it.\n * @param x - unknown value\n * @returns {string} string representation of the value\n */\nfunction toReadableString(x) {\n  const str = JSON.stringify(x, (_key, value) => typeof value === 'bigint' ? `BigInt(${value})` : value);\n  return str && str.length > toReadableString_max ? str.substring(0, toReadableString_max - 3) + '...' : str;\n}\n/**\n * Encode a array of values\n * @param argTypes - array of Types\n * @param args - array of values\n * @returns {ArrayBuffer} serialised value\n */\nexport function encode(argTypes, args) {\n  if (args.length < argTypes.length) {\n    throw Error('Wrong number of message arguments');\n  }\n  const typeTable = new TypeTable();\n  argTypes.forEach(t => t.buildTypeTable(typeTable));\n  const magic = new TextEncoder().encode(magicNumber);\n  const table = typeTable.encode();\n  const len = lebEncode(args.length);\n  const typs = concat(...argTypes.map(t => t.encodeType(typeTable)));\n  const vals = concat(...zipWith(argTypes, args, (t, x) => {\n    try {\n      t.covariant(x);\n    } catch (e) {\n      const err = new Error(e.message + '\\n\\n');\n      throw err;\n    }\n    return t.encodeValue(x);\n  }));\n  return concat(magic, table, len, typs, vals);\n}\n/**\n * Decode a binary value\n * @param retTypes - Types expected in the buffer.\n * @param bytes - hex-encoded string, or buffer.\n * @returns Value deserialised to JS type\n */\nexport function decode(retTypes, bytes) {\n  const b = new Pipe(bytes);\n  if (bytes.byteLength < magicNumber.length) {\n    throw new Error('Message length smaller than magic number');\n  }\n  const magicBuffer = safeRead(b, magicNumber.length);\n  const magic = new TextDecoder().decode(magicBuffer);\n  if (magic !== magicNumber) {\n    throw new Error('Wrong magic number: ' + JSON.stringify(magic));\n  }\n  function readTypeTable(pipe) {\n    const typeTable = [];\n    const len = Number(lebDecode(pipe));\n    for (let i = 0; i < len; i++) {\n      const ty = Number(slebDecode(pipe));\n      switch (ty) {\n        case -18 /* IDLTypeIds.Opt */:\n        case -19 /* IDLTypeIds.Vector */:\n          {\n            const t = Number(slebDecode(pipe));\n            typeTable.push([ty, t]);\n            break;\n          }\n        case -20 /* IDLTypeIds.Record */:\n        case -21 /* IDLTypeIds.Variant */:\n          {\n            const fields = [];\n            let objectLength = Number(lebDecode(pipe));\n            let prevHash;\n            while (objectLength--) {\n              const hash = Number(lebDecode(pipe));\n              if (hash >= Math.pow(2, 32)) {\n                throw new Error('field id out of 32-bit range');\n              }\n              if (typeof prevHash === 'number' && prevHash >= hash) {\n                throw new Error('field id collision or not sorted');\n              }\n              prevHash = hash;\n              const t = Number(slebDecode(pipe));\n              fields.push([hash, t]);\n            }\n            typeTable.push([ty, fields]);\n            break;\n          }\n        case -22 /* IDLTypeIds.Func */:\n          {\n            const args = [];\n            let argLength = Number(lebDecode(pipe));\n            while (argLength--) {\n              args.push(Number(slebDecode(pipe)));\n            }\n            const returnValues = [];\n            let returnValuesLength = Number(lebDecode(pipe));\n            while (returnValuesLength--) {\n              returnValues.push(Number(slebDecode(pipe)));\n            }\n            const annotations = [];\n            let annotationLength = Number(lebDecode(pipe));\n            while (annotationLength--) {\n              const annotation = Number(lebDecode(pipe));\n              switch (annotation) {\n                case 1:\n                  {\n                    annotations.push('query');\n                    break;\n                  }\n                case 2:\n                  {\n                    annotations.push('oneway');\n                    break;\n                  }\n                case 3:\n                  {\n                    annotations.push('composite_query');\n                    break;\n                  }\n                default:\n                  throw new Error('unknown annotation');\n              }\n            }\n            typeTable.push([ty, [args, returnValues, annotations]]);\n            break;\n          }\n        case -23 /* IDLTypeIds.Service */:\n          {\n            let servLength = Number(lebDecode(pipe));\n            const methods = [];\n            while (servLength--) {\n              const nameLength = Number(lebDecode(pipe));\n              const funcName = new TextDecoder().decode(safeRead(pipe, nameLength));\n              const funcType = slebDecode(pipe);\n              methods.push([funcName, funcType]);\n            }\n            typeTable.push([ty, methods]);\n            break;\n          }\n        default:\n          throw new Error('Illegal op_code: ' + ty);\n      }\n    }\n    const rawList = [];\n    const length = Number(lebDecode(pipe));\n    for (let i = 0; i < length; i++) {\n      rawList.push(Number(slebDecode(pipe)));\n    }\n    return [typeTable, rawList];\n  }\n  const [rawTable, rawTypes] = readTypeTable(b);\n  if (rawTypes.length < retTypes.length) {\n    throw new Error('Wrong number of return values');\n  }\n  const table = rawTable.map(_ => Rec());\n  function getType(t) {\n    if (t < -24) {\n      throw new Error('future value not supported');\n    }\n    if (t < 0) {\n      switch (t) {\n        case -1:\n          return Null;\n        case -2:\n          return Bool;\n        case -3:\n          return Nat;\n        case -4:\n          return Int;\n        case -5:\n          return Nat8;\n        case -6:\n          return Nat16;\n        case -7:\n          return Nat32;\n        case -8:\n          return Nat64;\n        case -9:\n          return Int8;\n        case -10:\n          return Int16;\n        case -11:\n          return Int32;\n        case -12:\n          return Int64;\n        case -13:\n          return Float32;\n        case -14:\n          return Float64;\n        case -15:\n          return Text;\n        case -16:\n          return Reserved;\n        case -17:\n          return Empty;\n        case -24:\n          return Principal;\n        default:\n          throw new Error('Illegal op_code: ' + t);\n      }\n    }\n    if (t >= rawTable.length) {\n      throw new Error('type index out of range');\n    }\n    return table[t];\n  }\n  function buildType(entry) {\n    switch (entry[0]) {\n      case -19 /* IDLTypeIds.Vector */:\n        {\n          const ty = getType(entry[1]);\n          return Vec(ty);\n        }\n      case -18 /* IDLTypeIds.Opt */:\n        {\n          const ty = getType(entry[1]);\n          return Opt(ty);\n        }\n      case -20 /* IDLTypeIds.Record */:\n        {\n          const fields = {};\n          for (const [hash, ty] of entry[1]) {\n            const name = `_${hash}_`;\n            fields[name] = getType(ty);\n          }\n          const record = Record(fields);\n          const tuple = record.tryAsTuple();\n          if (Array.isArray(tuple)) {\n            return Tuple(...tuple);\n          } else {\n            return record;\n          }\n        }\n      case -21 /* IDLTypeIds.Variant */:\n        {\n          const fields = {};\n          for (const [hash, ty] of entry[1]) {\n            const name = `_${hash}_`;\n            fields[name] = getType(ty);\n          }\n          return Variant(fields);\n        }\n      case -22 /* IDLTypeIds.Func */:\n        {\n          const [args, returnValues, annotations] = entry[1];\n          return Func(args.map(t => getType(t)), returnValues.map(t => getType(t)), annotations);\n        }\n      case -23 /* IDLTypeIds.Service */:\n        {\n          const rec = {};\n          const methods = entry[1];\n          for (const [name, typeRef] of methods) {\n            let type = getType(typeRef);\n            if (type instanceof RecClass) {\n              // unpack reference type\n              type = type.getType();\n            }\n            if (!(type instanceof FuncClass)) {\n              throw new Error('Illegal service definition: services can only contain functions');\n            }\n            rec[name] = type;\n          }\n          return Service(rec);\n        }\n      default:\n        throw new Error('Illegal op_code: ' + entry[0]);\n    }\n  }\n  rawTable.forEach((entry, i) => {\n    // Process function type first, so that we can construct the correct service type\n    if (entry[0] === -22 /* IDLTypeIds.Func */) {\n      const t = buildType(entry);\n      table[i].fill(t);\n    }\n  });\n  rawTable.forEach((entry, i) => {\n    if (entry[0] !== -22 /* IDLTypeIds.Func */) {\n      const t = buildType(entry);\n      table[i].fill(t);\n    }\n  });\n  const types = rawTypes.map(t => getType(t));\n  const output = retTypes.map((t, i) => {\n    return t.decodeValue(b, types[i]);\n  });\n  // skip unused values\n  for (let ind = retTypes.length; ind < types.length; ind++) {\n    types[ind].decodeValue(b, types[ind]);\n  }\n  if (b.byteLength > 0) {\n    throw new Error('decode: Left-over bytes');\n  }\n  return output;\n}\n// Export Types instances.\nexport const Empty = new EmptyClass();\nexport const Reserved = new ReservedClass();\n/**\n * Client-only type for deserializing unknown data. Not supported by Candid, and its use is discouraged.\n */\nexport const Unknown = new UnknownClass();\nexport const Bool = new BoolClass();\nexport const Null = new NullClass();\nexport const Text = new TextClass();\nexport const Int = new IntClass();\nexport const Nat = new NatClass();\nexport const Float32 = new FloatClass(32);\nexport const Float64 = new FloatClass(64);\nexport const Int8 = new FixedIntClass(8);\nexport const Int16 = new FixedIntClass(16);\nexport const Int32 = new FixedIntClass(32);\nexport const Int64 = new FixedIntClass(64);\nexport const Nat8 = new FixedNatClass(8);\nexport const Nat16 = new FixedNatClass(16);\nexport const Nat32 = new FixedNatClass(32);\nexport const Nat64 = new FixedNatClass(64);\nexport const Principal = new PrincipalClass();\n/**\n *\n * @param types array of any types\n * @returns TupleClass from those types\n */\nexport function Tuple() {\n  for (var _len = arguments.length, types = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {\n    types[_key2] = arguments[_key2];\n  }\n  return new TupleClass(types);\n}\n/**\n *\n * @param t IDL Type\n * @returns VecClass from that type\n */\nexport function Vec(t) {\n  return new VecClass(t);\n}\n/**\n *\n * @param t IDL Type\n * @returns OptClass of Type\n */\nexport function Opt(t) {\n  return new OptClass(t);\n}\n/**\n *\n * @param t Record of string and IDL Type\n * @returns RecordClass of string and Type\n */\nexport function Record(t) {\n  return new RecordClass(t);\n}\n/**\n *\n * @param fields Record of string and IDL Type\n * @returns VariantClass\n */\nexport function Variant(fields) {\n  return new VariantClass(fields);\n}\n/**\n *\n * @returns new RecClass\n */\nexport function Rec() {\n  return new RecClass();\n}\n/**\n *\n * @param args array of IDL Types\n * @param ret array of IDL Types\n * @param annotations array of strings, [] by default\n * @returns new FuncClass\n */\nexport function Func(args, ret) {\n  let annotations = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  return new FuncClass(args, ret, annotations);\n}\n/**\n *\n * @param t Record of string and FuncClass\n * @returns ServiceClass\n */\nexport function Service(t) {\n  return new ServiceClass(t);\n}","map":{"version":3,"names":["Principal","PrincipalId","concat","PipeArrayBuffer","Pipe","idlLabelToId","lebDecode","lebEncode","readIntLE","readUIntLE","safeRead","safeReadUint8","slebDecode","slebEncode","writeIntLE","writeUIntLE","iexp2","magicNumber","toReadableString_max","zipWith","xs","ys","f","map","x","i","TypeTable","constructor","_typs","_idx","Map","has","obj","name","add","type","buf","idx","length","set","push","merge","knot","get","knotIdx","undefined","Error","splice","delete","encode","len","indexOf","typeName","Visitor","visitType","t","data","visitPrimitive","visitEmpty","visitBool","visitNull","visitReserved","visitText","visitNumber","visitInt","visitNat","visitFloat","visitFixedInt","visitFixedNat","visitPrincipal","visitConstruct","visitVec","ty","visitOpt","visitRecord","fields","visitTuple","components","visitVariant","visitRec","visitFunc","visitService","Type","display","valueToString","toReadableString","buildTypeTable","typeTable","_buildTypeTableImpl","PrimitiveType","checkType","ConstructType","RecClass","getType","encodeType","EmptyClass","accept","v","d","covariant","encodeValue","decodeValue","UnknownClass","b","decodedValue","Object","typeFunc","defineProperty","value","writable","enumerable","configurable","BoolClass","Uint8Array","NullClass","ArrayBuffer","ReservedClass","TextClass","TextEncoder","byteLength","Number","decoder","TextDecoder","fatal","decode","IntClass","isInteger","toString","NatClass","BigInt","FloatClass","_bits","view","DataView","setFloat32","setFloat64","opcode","bytes","getFloat32","getFloat64","FixedIntClass","min","max","ok","offset","Math","log2","num","FixedNatClass","VecClass","_type","_blobOptimization","bits","isView","BYTES_PER_ELEMENT","Array","isArray","every","e","message","buffer","write","encoded","opCode","vec","read","Uint16Array","Uint32Array","BigUint64Array","Int8Array","Int16Array","Int32Array","BigInt64Array","rets","elements","join","OptClass","opt","RecordClass","arguments","_fields","entries","sort","a","tryAsTuple","res","key","_ref","k","hasOwnProperty","values","_ref2","bufs","_ref3","c","T","forEach","_ref4","_","_ref5","record","expectedRecordIdx","actualRecordIdx","hash","expectKey","expectType","expectedId","actualId","slice","_ref6","_ref7","_ref8","_ref9","TupleClass","_components","tuple","wireType","VariantClass","_ref10","_ref11","_ref12","variant","wireHash","_ref13","_ref14","_id","_counter","fill","decodePrincipalId","fromUint8Array","PrincipalClass","_isPrincipal","toUint8Array","toText","FuncClass","argTypes","retTypes","annotations","argsToString","types","_ref15","principal","methodName","canister","method","methodLen","arg","argLen","args","retLen","annLen","anns","encodeAnnotation","mLen","annon","_ref16","str","ann","ServiceClass","_ref17","func","meths","_ref18","label","labelBuf","labelLen","_ref19","JSON","stringify","_key","substring","magic","table","typs","vals","err","magicBuffer","readTypeTable","pipe","objectLength","prevHash","pow","argLength","returnValues","returnValuesLength","annotationLength","annotation","servLength","methods","nameLength","funcName","funcType","rawList","rawTable","rawTypes","Rec","Null","Bool","Nat","Int","Nat8","Nat16","Nat32","Nat64","Int8","Int16","Int32","Int64","Float32","Float64","Text","Reserved","Empty","buildType","entry","Vec","Opt","Record","Tuple","Variant","Func","rec","typeRef","Service","output","ind","Unknown","_len","_key2","ret"],"sources":["/home/arslan/modojo/node_modules/@dfinity/candid/src/idl.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { Principal as PrincipalId } from '@dfinity/principal';\nimport { JsonValue } from './types';\nimport { concat, PipeArrayBuffer as Pipe } from './utils/buffer';\nimport { idlLabelToId } from './utils/hash';\nimport {\n  lebDecode,\n  lebEncode,\n  readIntLE,\n  readUIntLE,\n  safeRead,\n  safeReadUint8,\n  slebDecode,\n  slebEncode,\n  writeIntLE,\n  writeUIntLE,\n} from './utils/leb128';\nimport { iexp2 } from './utils/bigint-math';\n\n/**\n * This module provides a combinator library to create serializers/deserializers\n * between JavaScript values and IDL used by canisters on the Internet Computer,\n * as documented at https://github.com/dfinity/candid/blob/119703ba342d2fef6ab4972d2541b9fe36ae8e36/spec/Candid.md\n */\n\nconst enum IDLTypeIds {\n  Null = -1,\n  Bool = -2,\n  Nat = -3,\n  Int = -4,\n  Float32 = -13,\n  Float64 = -14,\n  Text = -15,\n  Reserved = -16,\n  Empty = -17,\n  Opt = -18,\n  Vector = -19,\n  Record = -20,\n  Variant = -21,\n  Func = -22,\n  Service = -23,\n  Principal = -24,\n}\n\nconst magicNumber = 'DIDL';\nconst toReadableString_max = 400; // will not display arguments after 400chars. Makes sure 2mb blobs don't get inside the error\n\nfunction zipWith<TX, TY, TR>(xs: TX[], ys: TY[], f: (a: TX, b: TY) => TR): TR[] {\n  return xs.map((x, i) => f(x, ys[i]));\n}\n\n/**\n * An IDL Type Table, which precedes the data in the stream.\n */\nclass TypeTable {\n  // List of types. Needs to be an array as the index needs to be stable.\n  private _typs: ArrayBuffer[] = [];\n  private _idx = new Map<string, number>();\n\n  public has(obj: ConstructType) {\n    return this._idx.has(obj.name);\n  }\n\n  public add<T>(type: ConstructType<T>, buf: ArrayBuffer) {\n    const idx = this._typs.length;\n    this._idx.set(type.name, idx);\n    this._typs.push(buf);\n  }\n\n  public merge<T>(obj: ConstructType<T>, knot: string) {\n    const idx = this._idx.get(obj.name);\n    const knotIdx = this._idx.get(knot);\n    if (idx === undefined) {\n      throw new Error('Missing type index for ' + obj);\n    }\n    if (knotIdx === undefined) {\n      throw new Error('Missing type index for ' + knot);\n    }\n    this._typs[idx] = this._typs[knotIdx];\n\n    // Delete the type.\n    this._typs.splice(knotIdx, 1);\n    this._idx.delete(knot);\n  }\n\n  public encode() {\n    const len = lebEncode(this._typs.length);\n    const buf = concat(...this._typs);\n    return concat(len, buf);\n  }\n\n  public indexOf(typeName: string) {\n    if (!this._idx.has(typeName)) {\n      throw new Error('Missing type index for ' + typeName);\n    }\n    return slebEncode(this._idx.get(typeName) || 0);\n  }\n}\n\nexport abstract class Visitor<D, R> {\n  public visitType<T>(t: Type<T>, data: D): R {\n    throw new Error('Not implemented');\n  }\n  public visitPrimitive<T>(t: PrimitiveType<T>, data: D): R {\n    return this.visitType(t, data);\n  }\n  public visitEmpty(t: EmptyClass, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n  public visitBool(t: BoolClass, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n  public visitNull(t: NullClass, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n  public visitReserved(t: ReservedClass, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n  public visitText(t: TextClass, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n  public visitNumber<T>(t: PrimitiveType<T>, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n  public visitInt(t: IntClass, data: D): R {\n    return this.visitNumber(t, data);\n  }\n  public visitNat(t: NatClass, data: D): R {\n    return this.visitNumber(t, data);\n  }\n  public visitFloat(t: FloatClass, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n  public visitFixedInt(t: FixedIntClass, data: D): R {\n    return this.visitNumber(t, data);\n  }\n  public visitFixedNat(t: FixedNatClass, data: D): R {\n    return this.visitNumber(t, data);\n  }\n  public visitPrincipal(t: PrincipalClass, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n\n  public visitConstruct<T>(t: ConstructType<T>, data: D): R {\n    return this.visitType(t, data);\n  }\n  public visitVec<T>(t: VecClass<T>, ty: Type<T>, data: D): R {\n    return this.visitConstruct(t, data);\n  }\n  public visitOpt<T>(t: OptClass<T>, ty: Type<T>, data: D): R {\n    return this.visitConstruct(t, data);\n  }\n  public visitRecord(t: RecordClass, fields: Array<[string, Type]>, data: D): R {\n    return this.visitConstruct(t, data);\n  }\n  public visitTuple<T extends any[]>(t: TupleClass<T>, components: Type[], data: D): R {\n    const fields: Array<[string, Type]> = components.map((ty, i) => [`_${i}_`, ty]);\n    return this.visitRecord(t, fields, data);\n  }\n  public visitVariant(t: VariantClass, fields: Array<[string, Type]>, data: D): R {\n    return this.visitConstruct(t, data);\n  }\n  public visitRec<T>(t: RecClass<T>, ty: ConstructType<T>, data: D): R {\n    return this.visitConstruct(ty, data);\n  }\n  public visitFunc(t: FuncClass, data: D): R {\n    return this.visitConstruct(t, data);\n  }\n  public visitService(t: ServiceClass, data: D): R {\n    return this.visitConstruct(t, data);\n  }\n}\n\n/**\n * Represents an IDL type.\n */\nexport abstract class Type<T = any> {\n  public abstract readonly name: string;\n  public abstract accept<D, R>(v: Visitor<D, R>, d: D): R;\n\n  /* Display type name */\n  public display(): string {\n    return this.name;\n  }\n\n  public valueToString(x: T): string {\n    return toReadableString(x);\n  }\n\n  /* Implement `T` in the IDL spec, only needed for non-primitive types */\n  public buildTypeTable(typeTable: TypeTable): void {\n    if (!typeTable.has(this)) {\n      this._buildTypeTableImpl(typeTable);\n    }\n  }\n\n  /**\n   * Assert that JavaScript's `x` is the proper type represented by this\n   * Type.\n   */\n  public abstract covariant(x: any): x is T;\n\n  /**\n   * Encode the value. This needs to be public because it is used by\n   * encodeValue() from different types.\n   * @internal\n   */\n  public abstract encodeValue(x: T): ArrayBuffer;\n\n  /**\n   * Implement `I` in the IDL spec.\n   * Encode this type for the type table.\n   */\n  public abstract encodeType(typeTable: TypeTable): ArrayBuffer;\n\n  public abstract checkType(t: Type): Type;\n  public abstract decodeValue(x: Pipe, t: Type): T;\n\n  protected abstract _buildTypeTableImpl(typeTable: TypeTable): void;\n}\n\nexport abstract class PrimitiveType<T = any> extends Type<T> {\n  public checkType(t: Type): Type {\n    if (this.name !== t.name) {\n      throw new Error(`type mismatch: type on the wire ${t.name}, expect type ${this.name}`);\n    }\n    return t;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  public _buildTypeTableImpl(typeTable: TypeTable): void {\n    // No type table encoding for Primitive types.\n    return;\n  }\n}\n\nexport abstract class ConstructType<T = any> extends Type<T> {\n  public checkType(t: Type): ConstructType<T> {\n    if (t instanceof RecClass) {\n      const ty = t.getType();\n      if (typeof ty === 'undefined') {\n        throw new Error('type mismatch with uninitialized type');\n      }\n      return ty;\n    }\n    throw new Error(`type mismatch: type on the wire ${t.name}, expect type ${this.name}`);\n  }\n  public encodeType(typeTable: TypeTable) {\n    return typeTable.indexOf(this.name);\n  }\n}\n\n/**\n * Represents an IDL Empty, a type which has no inhabitants.\n * Since no values exist for this type, it cannot be serialised or deserialised.\n * Result types like `Result<Text, Empty>` should always succeed.\n */\nexport class EmptyClass extends PrimitiveType<never> {\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitEmpty(this, d);\n  }\n\n  public covariant(x: any): x is never {\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(): never {\n    throw new Error('Empty cannot appear as a function argument');\n  }\n\n  public valueToString(): never {\n    throw new Error('Empty cannot appear as a value');\n  }\n\n  public encodeType() {\n    return slebEncode(IDLTypeIds.Empty);\n  }\n\n  public decodeValue(): never {\n    throw new Error('Empty cannot appear as an output');\n  }\n\n  get name() {\n    return 'empty';\n  }\n}\n\n/**\n * Represents an IDL Unknown, a placeholder type for deserialization only.\n * When decoding a value as Unknown, all fields will be retained but the names are only available in\n * hashed form.\n * A deserialized unknown will offer it's actual type by calling the `type()` function.\n * Unknown cannot be serialized and attempting to do so will throw an error.\n */\nexport class UnknownClass extends Type {\n  public checkType(t: Type): Type {\n    throw new Error('Method not implemented for unknown.');\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    throw v.visitType(this, d);\n  }\n\n  public covariant(x: any): x is any {\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(): never {\n    throw new Error('Unknown cannot appear as a function argument');\n  }\n\n  public valueToString(): never {\n    throw new Error('Unknown cannot appear as a value');\n  }\n\n  public encodeType(): never {\n    throw new Error('Unknown cannot be serialized');\n  }\n\n  public decodeValue(b: Pipe, t: Type): any {\n    let decodedValue = t.decodeValue(b, t);\n\n    if (Object(decodedValue) !== decodedValue) {\n      // decodedValue is primitive. Box it, otherwise we cannot add the type() function.\n      // The type() function is important for primitives because otherwise we cannot tell apart the\n      // different number types.\n      decodedValue = Object(decodedValue);\n    }\n\n    let typeFunc;\n    if (t instanceof RecClass) {\n      typeFunc = () => t.getType();\n    } else {\n      typeFunc = () => t;\n    }\n    // Do not use 'decodedValue.type = typeFunc' because this would lead to an enumerable property\n    // 'type' which means it would be serialized if the value would be candid encoded again.\n    // This in turn leads to problems if the decoded value is a variant because these values are\n    // only allowed to have a single property.\n    Object.defineProperty(decodedValue, 'type', {\n      value: typeFunc,\n      writable: true,\n      enumerable: false,\n      configurable: true,\n    });\n    return decodedValue;\n  }\n\n  protected _buildTypeTableImpl(): void {\n    throw new Error('Unknown cannot be serialized');\n  }\n\n  get name() {\n    return 'Unknown';\n  }\n}\n\n/**\n * Represents an IDL Bool\n */\nexport class BoolClass extends PrimitiveType<boolean> {\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitBool(this, d);\n  }\n\n  public covariant(x: any): x is boolean {\n    if (typeof x === 'boolean') return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: boolean): ArrayBuffer {\n    return new Uint8Array([x ? 1 : 0]);\n  }\n\n  public encodeType() {\n    return slebEncode(IDLTypeIds.Bool);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    this.checkType(t);\n    switch (safeReadUint8(b)) {\n      case 0:\n        return false;\n      case 1:\n        return true;\n      default:\n        throw new Error('Boolean value out of range');\n    }\n  }\n\n  get name() {\n    return 'bool';\n  }\n}\n\n/**\n * Represents an IDL Null\n */\nexport class NullClass extends PrimitiveType<null> {\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitNull(this, d);\n  }\n\n  public covariant(x: any): x is null {\n    if (x === null) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue() {\n    return new ArrayBuffer(0);\n  }\n\n  public encodeType() {\n    return slebEncode(IDLTypeIds.Null);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    this.checkType(t);\n    return null;\n  }\n\n  get name() {\n    return 'null';\n  }\n}\n\n/**\n * Represents an IDL Reserved\n */\nexport class ReservedClass extends PrimitiveType<any> {\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitReserved(this, d);\n  }\n\n  public covariant(x: any): x is any {\n    return true;\n  }\n\n  public encodeValue() {\n    return new ArrayBuffer(0);\n  }\n\n  public encodeType() {\n    return slebEncode(IDLTypeIds.Reserved);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    if (t.name !== this.name) {\n      t.decodeValue(b, t);\n    }\n    return null;\n  }\n\n  get name() {\n    return 'reserved';\n  }\n}\n\n/**\n * Represents an IDL Text\n */\nexport class TextClass extends PrimitiveType<string> {\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitText(this, d);\n  }\n\n  public covariant(x: any): x is string {\n    if (typeof x === 'string') return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: string) {\n    const buf = new TextEncoder().encode(x);\n    const len = lebEncode(buf.byteLength);\n    return concat(len, buf);\n  }\n\n  public encodeType() {\n    return slebEncode(IDLTypeIds.Text);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    this.checkType(t);\n    const len = lebDecode(b);\n    const buf = safeRead(b, Number(len));\n    const decoder = new TextDecoder('utf8', { fatal: true });\n    return decoder.decode(buf);\n  }\n\n  get name() {\n    return 'text';\n  }\n\n  public valueToString(x: string) {\n    return '\"' + x + '\"';\n  }\n}\n\n/**\n * Represents an IDL Int\n */\nexport class IntClass extends PrimitiveType<bigint> {\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitInt(this, d);\n  }\n\n  public covariant(x: any): x is bigint {\n    // We allow encoding of JavaScript plain numbers.\n    // But we will always decode to bigint.\n    if (typeof x === 'bigint' || Number.isInteger(x)) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: bigint | number) {\n    return slebEncode(x);\n  }\n\n  public encodeType() {\n    return slebEncode(IDLTypeIds.Int);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    this.checkType(t);\n    return slebDecode(b);\n  }\n\n  get name() {\n    return 'int';\n  }\n\n  public valueToString(x: bigint) {\n    return x.toString();\n  }\n}\n\n/**\n * Represents an IDL Nat\n */\nexport class NatClass extends PrimitiveType<bigint> {\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitNat(this, d);\n  }\n\n  public covariant(x: any): x is bigint {\n    // We allow encoding of JavaScript plain numbers.\n    // But we will always decode to bigint.\n    if ((typeof x === 'bigint' && x >= BigInt(0)) || (Number.isInteger(x) && x >= 0)) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: bigint | number) {\n    return lebEncode(x);\n  }\n\n  public encodeType() {\n    return slebEncode(IDLTypeIds.Nat);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    this.checkType(t);\n    return lebDecode(b);\n  }\n\n  get name() {\n    return 'nat';\n  }\n\n  public valueToString(x: bigint) {\n    return x.toString();\n  }\n}\n\n/**\n * Represents an IDL Float\n */\nexport class FloatClass extends PrimitiveType<number> {\n  constructor(private _bits: number) {\n    super();\n    if (_bits !== 32 && _bits !== 64) {\n      throw new Error('not a valid float type');\n    }\n  }\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitFloat(this, d);\n  }\n\n  public covariant(x: any): x is number {\n    if (typeof x === 'number' || x instanceof Number) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: number) {\n    const buf = new ArrayBuffer(this._bits / 8);\n    const view = new DataView(buf);\n    if (this._bits === 32) {\n      view.setFloat32(0, x, true);\n    } else {\n      view.setFloat64(0, x, true);\n    }\n    return buf;\n  }\n\n  public encodeType() {\n    const opcode = this._bits === 32 ? IDLTypeIds.Float32 : IDLTypeIds.Float64;\n    return slebEncode(opcode);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    this.checkType(t);\n    const bytes = safeRead(b, this._bits / 8);\n    const view = new DataView(bytes);\n    if (this._bits === 32) {\n      return view.getFloat32(0, true);\n    } else {\n      return view.getFloat64(0, true);\n    }\n  }\n\n  get name() {\n    return 'float' + this._bits;\n  }\n\n  public valueToString(x: number) {\n    return x.toString();\n  }\n}\n\n/**\n * Represents an IDL fixed-width Int(n)\n */\nexport class FixedIntClass extends PrimitiveType<bigint | number> {\n  constructor(public readonly _bits: number) {\n    super();\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitFixedInt(this, d);\n  }\n\n  public covariant(x: any): x is bigint {\n    const min = iexp2(this._bits - 1) * BigInt(-1);\n    const max = iexp2(this._bits - 1) - BigInt(1);\n    let ok = false;\n    if (typeof x === 'bigint') {\n      ok = x >= min && x <= max;\n    } else if (Number.isInteger(x)) {\n      const v = BigInt(x);\n      ok = v >= min && v <= max;\n    } else {\n      ok = false;\n    }\n\n    if (ok) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: bigint | number) {\n    return writeIntLE(x, this._bits / 8);\n  }\n\n  public encodeType() {\n    const offset = Math.log2(this._bits) - 3;\n    return slebEncode(-9 - offset);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    this.checkType(t);\n    const num = readIntLE(b, this._bits / 8);\n    if (this._bits <= 32) {\n      return Number(num);\n    } else {\n      return num;\n    }\n  }\n\n  get name() {\n    return `int${this._bits}`;\n  }\n\n  public valueToString(x: bigint | number) {\n    return x.toString();\n  }\n}\n\n/**\n * Represents an IDL fixed-width Nat(n)\n */\nexport class FixedNatClass extends PrimitiveType<bigint | number> {\n  constructor(public readonly _bits: number) {\n    super();\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitFixedNat(this, d);\n  }\n\n  public covariant(x: any): x is bigint {\n    const max = iexp2(this._bits);\n    let ok = false;\n    if (typeof x === 'bigint' && x >= BigInt(0)) {\n      ok = x < max;\n    } else if (Number.isInteger(x) && x >= 0) {\n      const v = BigInt(x);\n      ok = v < max;\n    } else {\n      ok = false;\n    }\n    if (ok) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: bigint | number) {\n    return writeUIntLE(x, this._bits / 8);\n  }\n\n  public encodeType() {\n    const offset = Math.log2(this._bits) - 3;\n    return slebEncode(-5 - offset);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    this.checkType(t);\n    const num = readUIntLE(b, this._bits / 8);\n    if (this._bits <= 32) {\n      return Number(num);\n    } else {\n      return num;\n    }\n  }\n\n  get name() {\n    return `nat${this._bits}`;\n  }\n\n  public valueToString(x: bigint | number) {\n    return x.toString();\n  }\n}\n\n/**\n * Represents an IDL Array\n *\n * Arrays of fixed-sized nat/int type (e.g. nat8), are encoded from and decoded to TypedArrays (e.g. Uint8Array).\n * Arrays of float or other non-primitive types are encoded/decoded as untyped array in Javascript.\n * @param {Type} t\n */\nexport class VecClass<T> extends ConstructType<T[]> {\n  // If true, this vector is really a blob and we can just use memcpy.\n  //\n  // NOTE:\n  // With support of encoding/dencoding of TypedArrays, this optimization is\n  // only used when plain array of bytes are passed as encoding input in order\n  // to be backward compatible.\n  private _blobOptimization = false;\n\n  constructor(protected _type: Type<T>) {\n    super();\n    if (_type instanceof FixedNatClass && _type._bits === 8) {\n      this._blobOptimization = true;\n    }\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitVec(this, this._type, d);\n  }\n\n  public covariant(x: any): x is T[] {\n    // Special case for ArrayBuffer\n    const bits =\n      this._type instanceof FixedNatClass\n        ? this._type._bits\n        : this._type instanceof FixedIntClass\n        ? this._type._bits\n        : 0;\n\n    if (\n      (ArrayBuffer.isView(x) && bits == (x as any).BYTES_PER_ELEMENT * 8) ||\n      (Array.isArray(x) &&\n        x.every((v, idx) => {\n          try {\n            return this._type.covariant(v);\n          } catch (e: any) {\n            throw new Error(`Invalid ${this.display()} argument: \\n\\nindex ${idx} -> ${e.message}`);\n          }\n        }))\n    )\n      return true;\n\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: T[]) {\n    const len = lebEncode(x.length);\n    if (this._blobOptimization) {\n      return concat(len, new Uint8Array(x as unknown as number[]));\n    }\n    if (ArrayBuffer.isView(x)) {\n      return concat(len, new Uint8Array(x.buffer));\n    }\n    const buf = new Pipe(new ArrayBuffer(len.byteLength + x.length), 0);\n    buf.write(len);\n    for (const d of x) {\n      const encoded = this._type.encodeValue(d);\n      buf.write(new Uint8Array(encoded));\n    }\n    return buf.buffer;\n  }\n\n  public _buildTypeTableImpl(typeTable: TypeTable) {\n    this._type.buildTypeTable(typeTable);\n\n    const opCode = slebEncode(IDLTypeIds.Vector);\n    const buffer = this._type.encodeType(typeTable);\n    typeTable.add(this, concat(opCode, buffer));\n  }\n\n  public decodeValue(b: Pipe, t: Type): T[] {\n    const vec = this.checkType(t);\n    if (!(vec instanceof VecClass)) {\n      throw new Error('Not a vector type');\n    }\n    const len = Number(lebDecode(b));\n\n    if (this._type instanceof FixedNatClass) {\n      if (this._type._bits == 8) {\n        return new Uint8Array(b.read(len)) as unknown as T[];\n      }\n      if (this._type._bits == 16) {\n        return new Uint16Array(b.read(len * 2)) as unknown as T[];\n      }\n      if (this._type._bits == 32) {\n        return new Uint32Array(b.read(len * 4)) as unknown as T[];\n      }\n      if (this._type._bits == 64) {\n        return new BigUint64Array(b.read(len * 8)) as unknown as T[];\n      }\n    }\n\n    if (this._type instanceof FixedIntClass) {\n      if (this._type._bits == 8) {\n        return new Int8Array(b.read(len)) as unknown as T[];\n      }\n      if (this._type._bits == 16) {\n        return new Int16Array(b.read(len * 2)) as unknown as T[];\n      }\n      if (this._type._bits == 32) {\n        return new Int32Array(b.read(len * 4)) as unknown as T[];\n      }\n      if (this._type._bits == 64) {\n        return new BigInt64Array(b.read(len * 8)) as unknown as T[];\n      }\n    }\n\n    const rets: T[] = [];\n    for (let i = 0; i < len; i++) {\n      rets.push(this._type.decodeValue(b, vec._type));\n    }\n    return rets;\n  }\n\n  get name() {\n    return `vec ${this._type.name}`;\n  }\n\n  public display() {\n    return `vec ${this._type.display()}`;\n  }\n\n  public valueToString(x: T[]) {\n    const elements = x.map(e => this._type.valueToString(e));\n    return 'vec {' + elements.join('; ') + '}';\n  }\n}\n\n/**\n * Represents an IDL Option\n * @param {Type} t\n */\nexport class OptClass<T> extends ConstructType<[T] | []> {\n  constructor(protected _type: Type<T>) {\n    super();\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitOpt(this, this._type, d);\n  }\n\n  public covariant(x: any): x is [T] | [] {\n    try {\n      if (Array.isArray(x) && (x.length === 0 || (x.length === 1 && this._type.covariant(x[0]))))\n        return true;\n    } catch (e: any) {\n      throw new Error(\n        `Invalid ${this.display()} argument: ${toReadableString(x)} \\n\\n-> ${e.message}`,\n      );\n    }\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: [T] | []) {\n    if (x.length === 0) {\n      return new Uint8Array([0]);\n    } else {\n      return concat(new Uint8Array([1]), this._type.encodeValue(x[0]));\n    }\n  }\n\n  public _buildTypeTableImpl(typeTable: TypeTable) {\n    this._type.buildTypeTable(typeTable);\n\n    const opCode = slebEncode(IDLTypeIds.Opt);\n    const buffer = this._type.encodeType(typeTable);\n    typeTable.add(this, concat(opCode, buffer));\n  }\n\n  public decodeValue(b: Pipe, t: Type): [T] | [] {\n    const opt = this.checkType(t);\n    if (!(opt instanceof OptClass)) {\n      throw new Error('Not an option type');\n    }\n    switch (safeReadUint8(b)) {\n      case 0:\n        return [];\n      case 1:\n        return [this._type.decodeValue(b, opt._type)];\n      default:\n        throw new Error('Not an option value');\n    }\n  }\n\n  get name() {\n    return `opt ${this._type.name}`;\n  }\n\n  public display() {\n    return `opt ${this._type.display()}`;\n  }\n\n  public valueToString(x: [T] | []) {\n    if (x.length === 0) {\n      return 'null';\n    } else {\n      return `opt ${this._type.valueToString(x[0])}`;\n    }\n  }\n}\n\n/**\n * Represents an IDL Record\n * @param {object} [fields] - mapping of function name to Type\n */\nexport class RecordClass extends ConstructType<Record<string, any>> {\n  protected readonly _fields: Array<[string, Type]>;\n\n  constructor(fields: Record<string, Type> = {}) {\n    super();\n    this._fields = Object.entries(fields).sort((a, b) => idlLabelToId(a[0]) - idlLabelToId(b[0]));\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitRecord(this, this._fields, d);\n  }\n\n  public tryAsTuple(): Type[] | null {\n    const res: Type[] = [];\n    for (let i = 0; i < this._fields.length; i++) {\n      const [key, type] = this._fields[i];\n      if (key !== `_${i}_`) {\n        return null;\n      }\n      res.push(type);\n    }\n    return res;\n  }\n\n  public covariant(x: any): x is Record<string, any> {\n    if (\n      typeof x === 'object' &&\n      this._fields.every(([k, t]) => {\n        // eslint-disable-next-line\n        if (!x.hasOwnProperty(k)) {\n          throw new Error(`Record is missing key \"${k}\".`);\n        }\n        try {\n          return t.covariant(x[k]);\n        } catch (e: any) {\n          throw new Error(`Invalid ${this.display()} argument: \\n\\nfield ${k} -> ${e.message}`);\n        }\n      })\n    )\n      return true;\n\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: Record<string, any>) {\n    const values = this._fields.map(([key]) => x[key]);\n    const bufs = zipWith(this._fields, values, ([, c], d) => c.encodeValue(d));\n    return concat(...bufs);\n  }\n\n  public _buildTypeTableImpl(T: TypeTable) {\n    this._fields.forEach(([_, value]) => value.buildTypeTable(T));\n    const opCode = slebEncode(IDLTypeIds.Record);\n    const len = lebEncode(this._fields.length);\n    const fields = this._fields.map(([key, value]) =>\n      concat(lebEncode(idlLabelToId(key)), value.encodeType(T)),\n    );\n\n    T.add(this, concat(opCode, len, concat(...fields)));\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    const record = this.checkType(t);\n    if (!(record instanceof RecordClass)) {\n      throw new Error('Not a record type');\n    }\n    const x: Record<string, any> = {};\n\n    let expectedRecordIdx = 0;\n    let actualRecordIdx = 0;\n    while (actualRecordIdx < record._fields.length) {\n      const [hash, type] = record._fields[actualRecordIdx];\n\n      if (expectedRecordIdx >= this._fields.length) {\n        // skip unexpected left over fields present on the wire\n        type.decodeValue(b, type);\n        actualRecordIdx++;\n        continue;\n      }\n\n      const [expectKey, expectType] = this._fields[expectedRecordIdx];\n      const expectedId = idlLabelToId(this._fields[expectedRecordIdx][0]);\n      const actualId = idlLabelToId(hash);\n      if (expectedId === actualId) {\n        // the current field on the wire matches the expected field\n        x[expectKey] = expectType.decodeValue(b, type);\n        expectedRecordIdx++;\n        actualRecordIdx++;\n      } else if (actualId > expectedId) {\n        // The expected field does not exist on the wire\n        if (expectType instanceof OptClass || expectType instanceof ReservedClass) {\n          x[expectKey] = [];\n          expectedRecordIdx++;\n        } else {\n          throw new Error('Cannot find required field ' + expectKey);\n        }\n      } else {\n        // The field on the wire does not exist in the output type, so we can skip it\n        type.decodeValue(b, type);\n        actualRecordIdx++;\n      }\n    }\n\n    // initialize left over expected optional fields\n    for (const [expectKey, expectType] of this._fields.slice(expectedRecordIdx)) {\n      if (expectType instanceof OptClass || expectType instanceof ReservedClass) {\n        // TODO this assumes null value in opt is represented as []\n        x[expectKey] = [];\n      } else {\n        throw new Error('Cannot find required field ' + expectKey);\n      }\n    }\n    return x;\n  }\n\n  get name() {\n    const fields = this._fields.map(([key, value]) => key + ':' + value.name);\n    return `record {${fields.join('; ')}}`;\n  }\n\n  public display() {\n    const fields = this._fields.map(([key, value]) => key + ':' + value.display());\n    return `record {${fields.join('; ')}}`;\n  }\n\n  public valueToString(x: Record<string, any>) {\n    const values = this._fields.map(([key]) => x[key]);\n    const fields = zipWith(this._fields, values, ([k, c], d) => k + '=' + c.valueToString(d));\n    return `record {${fields.join('; ')}}`;\n  }\n}\n\n/**\n * Represents Tuple, a syntactic sugar for Record.\n * @param {Type} components\n */\nexport class TupleClass<T extends any[]> extends RecordClass {\n  protected readonly _components: Type[];\n\n  constructor(_components: Type[]) {\n    const x: Record<string, any> = {};\n    _components.forEach((e, i) => (x['_' + i + '_'] = e));\n    super(x);\n    this._components = _components;\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitTuple(this, this._components, d);\n  }\n\n  public covariant(x: any): x is T {\n    // `>=` because tuples can be covariant when encoded.\n\n    if (\n      Array.isArray(x) &&\n      x.length >= this._fields.length &&\n      this._components.every((t, i) => {\n        try {\n          return t.covariant(x[i]);\n        } catch (e: any) {\n          throw new Error(`Invalid ${this.display()} argument: \\n\\nindex ${i} -> ${e.message}`);\n        }\n      })\n    )\n      return true;\n\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: any[]) {\n    const bufs = zipWith(this._components, x, (c, d) => c.encodeValue(d));\n    return concat(...bufs);\n  }\n\n  public decodeValue(b: Pipe, t: Type): T {\n    const tuple = this.checkType(t);\n    if (!(tuple instanceof TupleClass)) {\n      throw new Error('not a tuple type');\n    }\n    if (tuple._components.length < this._components.length) {\n      throw new Error('tuple mismatch');\n    }\n    const res = [];\n    for (const [i, wireType] of tuple._components.entries()) {\n      if (i >= this._components.length) {\n        // skip value\n        wireType.decodeValue(b, wireType);\n      } else {\n        res.push(this._components[i].decodeValue(b, wireType));\n      }\n    }\n    return res as T;\n  }\n\n  public display() {\n    const fields = this._components.map(value => value.display());\n    return `record {${fields.join('; ')}}`;\n  }\n\n  public valueToString(values: any[]) {\n    const fields = zipWith(this._components, values, (c, d) => c.valueToString(d));\n    return `record {${fields.join('; ')}}`;\n  }\n}\n\n/**\n * Represents an IDL Variant\n * @param {object} [fields] - mapping of function name to Type\n */\nexport class VariantClass extends ConstructType<Record<string, any>> {\n  private readonly _fields: Array<[string, Type]>;\n\n  constructor(fields: Record<string, Type> = {}) {\n    super();\n    this._fields = Object.entries(fields).sort((a, b) => idlLabelToId(a[0]) - idlLabelToId(b[0]));\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitVariant(this, this._fields, d);\n  }\n\n  public covariant(x: any): x is Record<string, any> {\n    if (\n      typeof x === 'object' &&\n      Object.entries(x).length === 1 &&\n      this._fields.every(([k, v]) => {\n        try {\n          // eslint-disable-next-line\n          return !x.hasOwnProperty(k) || v.covariant(x[k]);\n        } catch (e: any) {\n          throw new Error(`Invalid ${this.display()} argument: \\n\\nvariant ${k} -> ${e.message}`);\n        }\n      })\n    )\n      return true;\n\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: Record<string, any>) {\n    for (let i = 0; i < this._fields.length; i++) {\n      const [name, type] = this._fields[i];\n      // eslint-disable-next-line\n      if (x.hasOwnProperty(name)) {\n        const idx = lebEncode(i);\n        const buf = type.encodeValue(x[name]);\n\n        return concat(idx, buf);\n      }\n    }\n    throw Error('Variant has no data: ' + x);\n  }\n\n  public _buildTypeTableImpl(typeTable: TypeTable) {\n    this._fields.forEach(([, type]) => {\n      type.buildTypeTable(typeTable);\n    });\n    const opCode = slebEncode(IDLTypeIds.Variant);\n    const len = lebEncode(this._fields.length);\n    const fields = this._fields.map(([key, value]) =>\n      concat(lebEncode(idlLabelToId(key)), value.encodeType(typeTable)),\n    );\n    typeTable.add(this, concat(opCode, len, ...fields));\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    const variant = this.checkType(t);\n    if (!(variant instanceof VariantClass)) {\n      throw new Error('Not a variant type');\n    }\n    const idx = Number(lebDecode(b));\n    if (idx >= variant._fields.length) {\n      throw Error('Invalid variant index: ' + idx);\n    }\n    const [wireHash, wireType] = variant._fields[idx];\n    for (const [key, expectType] of this._fields) {\n      if (idlLabelToId(wireHash) === idlLabelToId(key)) {\n        const value = expectType.decodeValue(b, wireType);\n        return { [key]: value };\n      }\n    }\n    throw new Error('Cannot find field hash ' + wireHash);\n  }\n\n  get name() {\n    const fields = this._fields.map(([key, type]) => key + ':' + type.name);\n    return `variant {${fields.join('; ')}}`;\n  }\n\n  public display() {\n    const fields = this._fields.map(\n      ([key, type]) => key + (type.name === 'null' ? '' : `:${type.display()}`),\n    );\n    return `variant {${fields.join('; ')}}`;\n  }\n\n  public valueToString(x: Record<string, any>) {\n    for (const [name, type] of this._fields) {\n      // eslint-disable-next-line\n      if (x.hasOwnProperty(name)) {\n        const value = type.valueToString(x[name]);\n        if (value === 'null') {\n          return `variant {${name}}`;\n        } else {\n          return `variant {${name}=${value}}`;\n        }\n      }\n    }\n    throw new Error('Variant has no data: ' + x);\n  }\n}\n\n/**\n * Represents a reference to an IDL type, used for defining recursive data\n * types.\n */\nexport class RecClass<T = any> extends ConstructType<T> {\n  private static _counter = 0;\n  private _id = RecClass._counter++;\n  private _type: ConstructType<T> | undefined = undefined;\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    return v.visitRec(this, this._type, d);\n  }\n\n  public fill(t: ConstructType<T>) {\n    this._type = t;\n  }\n\n  public getType() {\n    return this._type;\n  }\n\n  public covariant(x: any): x is T {\n    if (this._type ? this._type.covariant(x) : false) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: T) {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    return this._type.encodeValue(x);\n  }\n\n  public _buildTypeTableImpl(typeTable: TypeTable) {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    typeTable.add(this, new Uint8Array([]));\n    this._type.buildTypeTable(typeTable);\n    typeTable.merge(this, this._type.name);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    return this._type.decodeValue(b, t);\n  }\n\n  get name() {\n    return `rec_${this._id}`;\n  }\n\n  public display() {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    return `μ${this.name}.${this._type.name}`;\n  }\n\n  public valueToString(x: T) {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    return this._type.valueToString(x);\n  }\n}\n\nfunction decodePrincipalId(b: Pipe): PrincipalId {\n  const x = safeReadUint8(b);\n  if (x !== 1) {\n    throw new Error('Cannot decode principal');\n  }\n\n  const len = Number(lebDecode(b));\n  return PrincipalId.fromUint8Array(new Uint8Array(safeRead(b, len)));\n}\n\n/**\n * Represents an IDL principal reference\n */\nexport class PrincipalClass extends PrimitiveType<PrincipalId> {\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitPrincipal(this, d);\n  }\n\n  public covariant(x: any): x is PrincipalId {\n    if (x && x._isPrincipal) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: PrincipalId): ArrayBuffer {\n    const buf = x.toUint8Array();\n    const len = lebEncode(buf.byteLength);\n    return concat(new Uint8Array([1]), len, buf);\n  }\n\n  public encodeType() {\n    return slebEncode(IDLTypeIds.Principal);\n  }\n\n  public decodeValue(b: Pipe, t: Type): PrincipalId {\n    this.checkType(t);\n    return decodePrincipalId(b);\n  }\n\n  get name() {\n    return 'principal';\n  }\n  public valueToString(x: PrincipalId) {\n    return `${this.name} \"${x.toText()}\"`;\n  }\n}\n\n/**\n * Represents an IDL function reference.\n * @param argTypes Argument types.\n * @param retTypes Return types.\n * @param annotations Function annotations.\n */\nexport class FuncClass extends ConstructType<[PrincipalId, string]> {\n  public static argsToString(types: Type[], v: any[]) {\n    if (types.length !== v.length) {\n      throw new Error('arity mismatch');\n    }\n    return '(' + types.map((t, i) => t.valueToString(v[i])).join(', ') + ')';\n  }\n\n  constructor(public argTypes: Type[], public retTypes: Type[], public annotations: string[] = []) {\n    super();\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitFunc(this, d);\n  }\n  public covariant(x: any): x is [PrincipalId, string] {\n    if (Array.isArray(x) && x.length === 2 && x[0] && x[0]._isPrincipal && typeof x[1] === 'string')\n      return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue([principal, methodName]: [PrincipalId, string]) {\n    const buf = principal.toUint8Array();\n    const len = lebEncode(buf.byteLength);\n    const canister = concat(new Uint8Array([1]), len, buf);\n\n    const method = new TextEncoder().encode(methodName);\n    const methodLen = lebEncode(method.byteLength);\n    return concat(new Uint8Array([1]), canister, methodLen, method);\n  }\n\n  public _buildTypeTableImpl(T: TypeTable) {\n    this.argTypes.forEach(arg => arg.buildTypeTable(T));\n    this.retTypes.forEach(arg => arg.buildTypeTable(T));\n\n    const opCode = slebEncode(IDLTypeIds.Func);\n    const argLen = lebEncode(this.argTypes.length);\n    const args = concat(...this.argTypes.map(arg => arg.encodeType(T)));\n    const retLen = lebEncode(this.retTypes.length);\n    const rets = concat(...this.retTypes.map(arg => arg.encodeType(T)));\n    const annLen = lebEncode(this.annotations.length);\n    const anns = concat(...this.annotations.map(a => this.encodeAnnotation(a)));\n\n    T.add(this, concat(opCode, argLen, args, retLen, rets, annLen, anns));\n  }\n\n  public decodeValue(b: Pipe): [PrincipalId, string] {\n    const x = safeReadUint8(b);\n    if (x !== 1) {\n      throw new Error('Cannot decode function reference');\n    }\n    const canister = decodePrincipalId(b);\n\n    const mLen = Number(lebDecode(b));\n    const buf = safeRead(b, mLen);\n    const decoder = new TextDecoder('utf8', { fatal: true });\n    const method = decoder.decode(buf);\n\n    return [canister, method];\n  }\n\n  get name() {\n    const args = this.argTypes.map(arg => arg.name).join(', ');\n    const rets = this.retTypes.map(arg => arg.name).join(', ');\n    const annon = ' ' + this.annotations.join(' ');\n    return `(${args}) -> (${rets})${annon}`;\n  }\n\n  public valueToString([principal, str]: [PrincipalId, string]) {\n    return `func \"${principal.toText()}\".${str}`;\n  }\n\n  public display(): string {\n    const args = this.argTypes.map(arg => arg.display()).join(', ');\n    const rets = this.retTypes.map(arg => arg.display()).join(', ');\n    const annon = ' ' + this.annotations.join(' ');\n    return `(${args}) → (${rets})${annon}`;\n  }\n\n  private encodeAnnotation(ann: string): ArrayBuffer {\n    if (ann === 'query') {\n      return new Uint8Array([1]);\n    } else if (ann === 'oneway') {\n      return new Uint8Array([2]);\n    } else if (ann === 'composite_query') {\n      return new Uint8Array([3]);\n    } else {\n      throw new Error('Illegal function annotation');\n    }\n  }\n}\n\nexport class ServiceClass extends ConstructType<PrincipalId> {\n  public readonly _fields: Array<[string, FuncClass]>;\n  constructor(fields: Record<string, FuncClass>) {\n    super();\n    this._fields = Object.entries(fields).sort((a, b) => {\n      if (a[0] < b[0]) {\n        return -1;\n      }\n      if (a[0] > b[0]) {\n        return 1;\n      }\n      return 0;\n    });\n  }\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitService(this, d);\n  }\n  public covariant(x: any): x is PrincipalId {\n    if (x && x._isPrincipal) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: PrincipalId) {\n    const buf = x.toUint8Array();\n    const len = lebEncode(buf.length);\n    return concat(new Uint8Array([1]), len, buf);\n  }\n\n  public _buildTypeTableImpl(T: TypeTable) {\n    this._fields.forEach(([_, func]) => func.buildTypeTable(T));\n    const opCode = slebEncode(IDLTypeIds.Service);\n    const len = lebEncode(this._fields.length);\n    const meths = this._fields.map(([label, func]) => {\n      const labelBuf = new TextEncoder().encode(label);\n      const labelLen = lebEncode(labelBuf.length);\n      return concat(labelLen, labelBuf, func.encodeType(T));\n    });\n\n    T.add(this, concat(opCode, len, ...meths));\n  }\n\n  public decodeValue(b: Pipe): PrincipalId {\n    return decodePrincipalId(b);\n  }\n  get name() {\n    const fields = this._fields.map(([key, value]) => key + ':' + value.name);\n    return `service {${fields.join('; ')}}`;\n  }\n\n  public valueToString(x: PrincipalId) {\n    return `service \"${x.toText()}\"`;\n  }\n}\n\n/**\n * Takes an unknown value and returns a string representation of it.\n * @param x - unknown value\n * @returns {string} string representation of the value\n */\nfunction toReadableString(x: unknown): string {\n  const str = JSON.stringify(x, (_key, value) =>\n    typeof value === 'bigint' ? `BigInt(${value})` : value,\n  );\n\n  return str && str.length > toReadableString_max\n    ? str.substring(0, toReadableString_max - 3) + '...'\n    : str;\n}\n\n/**\n * Encode a array of values\n * @param argTypes - array of Types\n * @param args - array of values\n * @returns {ArrayBuffer} serialised value\n */\nexport function encode(argTypes: Array<Type<any>>, args: any[]): ArrayBuffer {\n  if (args.length < argTypes.length) {\n    throw Error('Wrong number of message arguments');\n  }\n\n  const typeTable = new TypeTable();\n  argTypes.forEach(t => t.buildTypeTable(typeTable));\n\n  const magic = new TextEncoder().encode(magicNumber);\n  const table = typeTable.encode();\n  const len = lebEncode(args.length);\n  const typs = concat(...argTypes.map(t => t.encodeType(typeTable)));\n  const vals = concat(\n    ...zipWith(argTypes, args, (t, x) => {\n      try {\n        t.covariant(x);\n      } catch (e: any) {\n        const err = new Error(e.message + '\\n\\n');\n        throw err;\n      }\n\n      return t.encodeValue(x);\n    }),\n  );\n\n  return concat(magic, table, len, typs, vals);\n}\n\n/**\n * Decode a binary value\n * @param retTypes - Types expected in the buffer.\n * @param bytes - hex-encoded string, or buffer.\n * @returns Value deserialised to JS type\n */\nexport function decode(retTypes: Type[], bytes: ArrayBuffer): JsonValue[] {\n  const b = new Pipe(bytes);\n\n  if (bytes.byteLength < magicNumber.length) {\n    throw new Error('Message length smaller than magic number');\n  }\n  const magicBuffer = safeRead(b, magicNumber.length);\n  const magic = new TextDecoder().decode(magicBuffer);\n  if (magic !== magicNumber) {\n    throw new Error('Wrong magic number: ' + JSON.stringify(magic));\n  }\n\n  function readTypeTable(pipe: Pipe): [Array<[IDLTypeIds, any]>, number[]] {\n    const typeTable: Array<[IDLTypeIds, any]> = [];\n    const len = Number(lebDecode(pipe));\n\n    for (let i = 0; i < len; i++) {\n      const ty = Number(slebDecode(pipe));\n      switch (ty) {\n        case IDLTypeIds.Opt:\n        case IDLTypeIds.Vector: {\n          const t = Number(slebDecode(pipe));\n          typeTable.push([ty, t]);\n          break;\n        }\n        case IDLTypeIds.Record:\n        case IDLTypeIds.Variant: {\n          const fields = [];\n          let objectLength = Number(lebDecode(pipe));\n          let prevHash;\n          while (objectLength--) {\n            const hash = Number(lebDecode(pipe));\n            if (hash >= Math.pow(2, 32)) {\n              throw new Error('field id out of 32-bit range');\n            }\n            if (typeof prevHash === 'number' && prevHash >= hash) {\n              throw new Error('field id collision or not sorted');\n            }\n            prevHash = hash;\n            const t = Number(slebDecode(pipe));\n            fields.push([hash, t]);\n          }\n          typeTable.push([ty, fields]);\n          break;\n        }\n        case IDLTypeIds.Func: {\n          const args = [];\n          let argLength = Number(lebDecode(pipe));\n          while (argLength--) {\n            args.push(Number(slebDecode(pipe)));\n          }\n          const returnValues = [];\n          let returnValuesLength = Number(lebDecode(pipe));\n          while (returnValuesLength--) {\n            returnValues.push(Number(slebDecode(pipe)));\n          }\n          const annotations = [];\n          let annotationLength = Number(lebDecode(pipe));\n          while (annotationLength--) {\n            const annotation = Number(lebDecode(pipe));\n            switch (annotation) {\n              case 1: {\n                annotations.push('query');\n                break;\n              }\n              case 2: {\n                annotations.push('oneway');\n                break;\n              }\n              case 3: {\n                annotations.push('composite_query');\n                break;\n              }\n              default:\n                throw new Error('unknown annotation');\n            }\n          }\n          typeTable.push([ty, [args, returnValues, annotations]]);\n          break;\n        }\n        case IDLTypeIds.Service: {\n          let servLength = Number(lebDecode(pipe));\n          const methods = [];\n          while (servLength--) {\n            const nameLength = Number(lebDecode(pipe));\n            const funcName = new TextDecoder().decode(safeRead(pipe, nameLength));\n            const funcType = slebDecode(pipe);\n            methods.push([funcName, funcType]);\n          }\n          typeTable.push([ty, methods]);\n          break;\n        }\n        default:\n          throw new Error('Illegal op_code: ' + ty);\n      }\n    }\n\n    const rawList: number[] = [];\n    const length = Number(lebDecode(pipe));\n    for (let i = 0; i < length; i++) {\n      rawList.push(Number(slebDecode(pipe)));\n    }\n    return [typeTable, rawList];\n  }\n  const [rawTable, rawTypes] = readTypeTable(b);\n  if (rawTypes.length < retTypes.length) {\n    throw new Error('Wrong number of return values');\n  }\n\n  const table: RecClass[] = rawTable.map(_ => Rec());\n  function getType(t: number): Type {\n    if (t < -24) {\n      throw new Error('future value not supported');\n    }\n    if (t < 0) {\n      switch (t) {\n        case -1:\n          return Null;\n        case -2:\n          return Bool;\n        case -3:\n          return Nat;\n        case -4:\n          return Int;\n        case -5:\n          return Nat8;\n        case -6:\n          return Nat16;\n        case -7:\n          return Nat32;\n        case -8:\n          return Nat64;\n        case -9:\n          return Int8;\n        case -10:\n          return Int16;\n        case -11:\n          return Int32;\n        case -12:\n          return Int64;\n        case -13:\n          return Float32;\n        case -14:\n          return Float64;\n        case -15:\n          return Text;\n        case -16:\n          return Reserved;\n        case -17:\n          return Empty;\n        case -24:\n          return Principal;\n        default:\n          throw new Error('Illegal op_code: ' + t);\n      }\n    }\n    if (t >= rawTable.length) {\n      throw new Error('type index out of range');\n    }\n    return table[t];\n  }\n  function buildType(entry: [IDLTypeIds, any]): Type {\n    switch (entry[0]) {\n      case IDLTypeIds.Vector: {\n        const ty = getType(entry[1]);\n        return Vec(ty);\n      }\n      case IDLTypeIds.Opt: {\n        const ty = getType(entry[1]);\n        return Opt(ty);\n      }\n      case IDLTypeIds.Record: {\n        const fields: Record<string, Type> = {};\n        for (const [hash, ty] of entry[1]) {\n          const name = `_${hash}_`;\n          fields[name] = getType(ty);\n        }\n        const record = Record(fields);\n        const tuple = record.tryAsTuple();\n        if (Array.isArray(tuple)) {\n          return Tuple(...tuple);\n        } else {\n          return record;\n        }\n      }\n      case IDLTypeIds.Variant: {\n        const fields: Record<string, Type> = {};\n        for (const [hash, ty] of entry[1]) {\n          const name = `_${hash}_`;\n          fields[name] = getType(ty);\n        }\n        return Variant(fields);\n      }\n      case IDLTypeIds.Func: {\n        const [args, returnValues, annotations] = entry[1];\n        return Func(\n          args.map((t: number) => getType(t)),\n          returnValues.map((t: number) => getType(t)),\n          annotations,\n        );\n      }\n      case IDLTypeIds.Service: {\n        const rec: Record<string, FuncClass> = {};\n        const methods = entry[1] as [[string, number]];\n        for (const [name, typeRef] of methods) {\n          let type: Type | undefined = getType(typeRef);\n\n          if (type instanceof RecClass) {\n            // unpack reference type\n            type = type.getType();\n          }\n          if (!(type instanceof FuncClass)) {\n            throw new Error('Illegal service definition: services can only contain functions');\n          }\n          rec[name] = type;\n        }\n        return Service(rec);\n      }\n      default:\n        throw new Error('Illegal op_code: ' + entry[0]);\n    }\n  }\n\n  rawTable.forEach((entry, i) => {\n    // Process function type first, so that we can construct the correct service type\n    if (entry[0] === IDLTypeIds.Func) {\n      const t = buildType(entry);\n      table[i].fill(t);\n    }\n  });\n  rawTable.forEach((entry, i) => {\n    if (entry[0] !== IDLTypeIds.Func) {\n      const t = buildType(entry);\n      table[i].fill(t);\n    }\n  });\n\n  const types = rawTypes.map(t => getType(t));\n  const output = retTypes.map((t, i) => {\n    return t.decodeValue(b, types[i]);\n  });\n\n  // skip unused values\n  for (let ind = retTypes.length; ind < types.length; ind++) {\n    types[ind].decodeValue(b, types[ind]);\n  }\n\n  if (b.byteLength > 0) {\n    throw new Error('decode: Left-over bytes');\n  }\n\n  return output;\n}\n\n/**\n * An Interface Factory, normally provided by a Candid code generation.\n */\nexport type InterfaceFactory = (idl: {\n  IDL: {\n    Empty: EmptyClass;\n    Reserved: ReservedClass;\n    Unknown: UnknownClass;\n    Bool: BoolClass;\n    Null: NullClass;\n    Text: TextClass;\n    Int: IntClass;\n    Nat: NatClass;\n\n    Float32: FloatClass;\n    Float64: FloatClass;\n\n    Int8: FixedIntClass;\n    Int16: FixedIntClass;\n    Int32: FixedIntClass;\n    Int64: FixedIntClass;\n\n    Nat8: FixedNatClass;\n    Nat16: FixedNatClass;\n    Nat32: FixedNatClass;\n    Nat64: FixedNatClass;\n\n    Principal: PrincipalClass;\n\n    Tuple: typeof Tuple;\n    Vec: typeof Vec;\n    Opt: typeof Opt;\n    Record: typeof Record;\n    Variant: typeof Variant;\n    Rec: typeof Rec;\n    Func: typeof Func;\n\n    Service(t: Record<string, FuncClass>): ServiceClass;\n  };\n}) => ServiceClass;\n\n// Export Types instances.\nexport const Empty = new EmptyClass();\nexport const Reserved = new ReservedClass();\n/**\n * Client-only type for deserializing unknown data. Not supported by Candid, and its use is discouraged.\n */\nexport const Unknown = new UnknownClass();\nexport const Bool = new BoolClass();\nexport const Null = new NullClass();\nexport const Text = new TextClass();\nexport const Int = new IntClass();\nexport const Nat = new NatClass();\n\nexport const Float32 = new FloatClass(32);\nexport const Float64 = new FloatClass(64);\n\nexport const Int8 = new FixedIntClass(8);\nexport const Int16 = new FixedIntClass(16);\nexport const Int32 = new FixedIntClass(32);\nexport const Int64 = new FixedIntClass(64);\n\nexport const Nat8 = new FixedNatClass(8);\nexport const Nat16 = new FixedNatClass(16);\nexport const Nat32 = new FixedNatClass(32);\nexport const Nat64 = new FixedNatClass(64);\n\nexport const Principal = new PrincipalClass();\n\n/**\n *\n * @param types array of any types\n * @returns TupleClass from those types\n */\nexport function Tuple<T extends any[]>(...types: T): TupleClass<T> {\n  return new TupleClass(types);\n}\n/**\n *\n * @param t IDL Type\n * @returns VecClass from that type\n */\nexport function Vec<T>(t: Type<T>): VecClass<T> {\n  return new VecClass(t);\n}\n/**\n *\n * @param t IDL Type\n * @returns OptClass of Type\n */\nexport function Opt<T>(t: Type<T>): OptClass<T> {\n  return new OptClass(t);\n}\n/**\n *\n * @param t Record of string and IDL Type\n * @returns RecordClass of string and Type\n */\nexport function Record(t: Record<string, Type>): RecordClass {\n  return new RecordClass(t);\n}\n\n/**\n *\n * @param fields Record of string and IDL Type\n * @returns VariantClass\n */\nexport function Variant(fields: Record<string, Type>): VariantClass {\n  return new VariantClass(fields);\n}\n/**\n *\n * @returns new RecClass\n */\nexport function Rec(): RecClass {\n  return new RecClass();\n}\n\n/**\n *\n * @param args array of IDL Types\n * @param ret array of IDL Types\n * @param annotations array of strings, [] by default\n * @returns new FuncClass\n */\nexport function Func(args: Type[], ret: Type[], annotations: string[] = []): FuncClass {\n  return new FuncClass(args, ret, annotations);\n}\n\n/**\n *\n * @param t Record of string and FuncClass\n * @returns ServiceClass\n */\nexport function Service(t: Record<string, FuncClass>): ServiceClass {\n  return new ServiceClass(t);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}