{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { distinct } from './arrays.js';\nimport { Iterable } from './iterator.js';\nimport { generateUuid } from './uuid.js';\nexport function createStringDataTransferItem(stringOrPromise) {\n  return {\n    asString: async () => stringOrPromise,\n    asFile: () => undefined,\n    value: typeof stringOrPromise === 'string' ? stringOrPromise : undefined\n  };\n}\nexport function createFileDataTransferItem(fileName, uri, data) {\n  const file = {\n    id: generateUuid(),\n    name: fileName,\n    uri,\n    data\n  };\n  return {\n    asString: async () => '',\n    asFile: () => file,\n    value: undefined\n  };\n}\nexport class VSDataTransfer {\n  constructor() {\n    this._entries = new Map();\n  }\n  get size() {\n    let size = 0;\n    for (const _ of this._entries) {\n      size++;\n    }\n    return size;\n  }\n  has(mimeType) {\n    return this._entries.has(this.toKey(mimeType));\n  }\n  matches(pattern) {\n    const mimes = [...this._entries.keys()];\n    if (Iterable.some(this, _ref => {\n      let [_, item] = _ref;\n      return item.asFile();\n    })) {\n      mimes.push('files');\n    }\n    return matchesMimeType_normalized(normalizeMimeType(pattern), mimes);\n  }\n  get(mimeType) {\n    var _a;\n    return (_a = this._entries.get(this.toKey(mimeType))) === null || _a === void 0 ? void 0 : _a[0];\n  }\n  /**\n   * Add a new entry to this data transfer.\n   *\n   * This does not replace existing entries for `mimeType`.\n   */\n  append(mimeType, value) {\n    const existing = this._entries.get(mimeType);\n    if (existing) {\n      existing.push(value);\n    } else {\n      this._entries.set(this.toKey(mimeType), [value]);\n    }\n  }\n  /**\n   * Set the entry for a given mime type.\n   *\n   * This replaces all existing entries for `mimeType`.\n   */\n  replace(mimeType, value) {\n    this._entries.set(this.toKey(mimeType), [value]);\n  }\n  /**\n   * Remove all entries for `mimeType`.\n   */\n  delete(mimeType) {\n    this._entries.delete(this.toKey(mimeType));\n  }\n  /**\n   * Iterate over all `[mime, item]` pairs in this data transfer.\n   *\n   * There may be multiple entries for each mime type.\n   */\n  *[Symbol.iterator]() {\n    for (const [mine, items] of this._entries) {\n      for (const item of items) {\n        yield [mine, item];\n      }\n    }\n  }\n  toKey(mimeType) {\n    return normalizeMimeType(mimeType);\n  }\n}\nfunction normalizeMimeType(mimeType) {\n  return mimeType.toLowerCase();\n}\nexport function matchesMimeType(pattern, mimeTypes) {\n  return matchesMimeType_normalized(normalizeMimeType(pattern), mimeTypes.map(normalizeMimeType));\n}\nfunction matchesMimeType_normalized(normalizedPattern, normalizedMimeTypes) {\n  // Anything wildcard\n  if (normalizedPattern === '*/*') {\n    return normalizedMimeTypes.length > 0;\n  }\n  // Exact match\n  if (normalizedMimeTypes.includes(normalizedPattern)) {\n    return true;\n  }\n  // Wildcard, such as `image/*`\n  const wildcard = normalizedPattern.match(/^([a-z]+)\\/([a-z]+|\\*)$/i);\n  if (!wildcard) {\n    return false;\n  }\n  const [_, type, subtype] = wildcard;\n  if (subtype === '*') {\n    return normalizedMimeTypes.some(mime => mime.startsWith(type + '/'));\n  }\n  return false;\n}\nexport const UriList = Object.freeze({\n  // http://amundsen.com/hypermedia/urilist/\n  create: entries => {\n    return distinct(entries.map(x => x.toString())).join('\\r\\n');\n  },\n  split: str => {\n    return str.split('\\r\\n');\n  },\n  parse: str => {\n    return UriList.split(str).filter(value => !value.startsWith('#'));\n  }\n});","map":{"version":3,"names":["distinct","Iterable","generateUuid","createStringDataTransferItem","stringOrPromise","asString","asFile","undefined","value","createFileDataTransferItem","fileName","uri","data","file","id","name","VSDataTransfer","constructor","_entries","Map","size","_","has","mimeType","toKey","matches","pattern","mimes","keys","some","_ref","item","push","matchesMimeType_normalized","normalizeMimeType","get","_a","append","existing","set","replace","delete","Symbol","iterator","mine","items","toLowerCase","matchesMimeType","mimeTypes","map","normalizedPattern","normalizedMimeTypes","length","includes","wildcard","match","type","subtype","mime","startsWith","UriList","Object","freeze","create","entries","x","toString","join","split","str","parse","filter"],"sources":["/home/arslan/modojo/node_modules/monaco-editor/esm/vs/base/common/dataTransfer.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { distinct } from './arrays.js';\nimport { Iterable } from './iterator.js';\nimport { generateUuid } from './uuid.js';\nexport function createStringDataTransferItem(stringOrPromise) {\n    return {\n        asString: async () => stringOrPromise,\n        asFile: () => undefined,\n        value: typeof stringOrPromise === 'string' ? stringOrPromise : undefined,\n    };\n}\nexport function createFileDataTransferItem(fileName, uri, data) {\n    const file = { id: generateUuid(), name: fileName, uri, data };\n    return {\n        asString: async () => '',\n        asFile: () => file,\n        value: undefined,\n    };\n}\nexport class VSDataTransfer {\n    constructor() {\n        this._entries = new Map();\n    }\n    get size() {\n        let size = 0;\n        for (const _ of this._entries) {\n            size++;\n        }\n        return size;\n    }\n    has(mimeType) {\n        return this._entries.has(this.toKey(mimeType));\n    }\n    matches(pattern) {\n        const mimes = [...this._entries.keys()];\n        if (Iterable.some(this, ([_, item]) => item.asFile())) {\n            mimes.push('files');\n        }\n        return matchesMimeType_normalized(normalizeMimeType(pattern), mimes);\n    }\n    get(mimeType) {\n        var _a;\n        return (_a = this._entries.get(this.toKey(mimeType))) === null || _a === void 0 ? void 0 : _a[0];\n    }\n    /**\n     * Add a new entry to this data transfer.\n     *\n     * This does not replace existing entries for `mimeType`.\n     */\n    append(mimeType, value) {\n        const existing = this._entries.get(mimeType);\n        if (existing) {\n            existing.push(value);\n        }\n        else {\n            this._entries.set(this.toKey(mimeType), [value]);\n        }\n    }\n    /**\n     * Set the entry for a given mime type.\n     *\n     * This replaces all existing entries for `mimeType`.\n     */\n    replace(mimeType, value) {\n        this._entries.set(this.toKey(mimeType), [value]);\n    }\n    /**\n     * Remove all entries for `mimeType`.\n     */\n    delete(mimeType) {\n        this._entries.delete(this.toKey(mimeType));\n    }\n    /**\n     * Iterate over all `[mime, item]` pairs in this data transfer.\n     *\n     * There may be multiple entries for each mime type.\n     */\n    *[Symbol.iterator]() {\n        for (const [mine, items] of this._entries) {\n            for (const item of items) {\n                yield [mine, item];\n            }\n        }\n    }\n    toKey(mimeType) {\n        return normalizeMimeType(mimeType);\n    }\n}\nfunction normalizeMimeType(mimeType) {\n    return mimeType.toLowerCase();\n}\nexport function matchesMimeType(pattern, mimeTypes) {\n    return matchesMimeType_normalized(normalizeMimeType(pattern), mimeTypes.map(normalizeMimeType));\n}\nfunction matchesMimeType_normalized(normalizedPattern, normalizedMimeTypes) {\n    // Anything wildcard\n    if (normalizedPattern === '*/*') {\n        return normalizedMimeTypes.length > 0;\n    }\n    // Exact match\n    if (normalizedMimeTypes.includes(normalizedPattern)) {\n        return true;\n    }\n    // Wildcard, such as `image/*`\n    const wildcard = normalizedPattern.match(/^([a-z]+)\\/([a-z]+|\\*)$/i);\n    if (!wildcard) {\n        return false;\n    }\n    const [_, type, subtype] = wildcard;\n    if (subtype === '*') {\n        return normalizedMimeTypes.some(mime => mime.startsWith(type + '/'));\n    }\n    return false;\n}\nexport const UriList = Object.freeze({\n    // http://amundsen.com/hypermedia/urilist/\n    create: (entries) => {\n        return distinct(entries.map(x => x.toString())).join('\\r\\n');\n    },\n    split: (str) => {\n        return str.split('\\r\\n');\n    },\n    parse: (str) => {\n        return UriList.split(str).filter(value => !value.startsWith('#'));\n    }\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}