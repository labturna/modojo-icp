{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function findLast(array, predicate) {\n  const idx = findLastIdx(array, predicate);\n  if (idx === -1) {\n    return undefined;\n  }\n  return array[idx];\n}\nexport function findLastIdx(array, predicate) {\n  let fromIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : array.length - 1;\n  for (let i = fromIndex; i >= 0; i--) {\n    const element = array[i];\n    if (predicate(element)) {\n      return i;\n    }\n  }\n  return -1;\n}\n/**\n * Finds the last item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n *\n * @returns `undefined` if no item matches, otherwise the last item that matches the predicate.\n */\nexport function findLastMonotonous(array, predicate) {\n  const idx = findLastIdxMonotonous(array, predicate);\n  return idx === -1 ? undefined : array[idx];\n}\n/**\n * Finds the last item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n *\n * @returns `startIdx - 1` if predicate is false for all items, otherwise the index of the last item that matches the predicate.\n */\nexport function findLastIdxMonotonous(array, predicate) {\n  let startIdx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let endIdxEx = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : array.length;\n  let i = startIdx;\n  let j = endIdxEx;\n  while (i < j) {\n    const k = Math.floor((i + j) / 2);\n    if (predicate(array[k])) {\n      i = k + 1;\n    } else {\n      j = k;\n    }\n  }\n  return i - 1;\n}\n/**\n * Finds the first item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[false, ..., false, true, ..., true]`!\n *\n * @returns `undefined` if no item matches, otherwise the first item that matches the predicate.\n */\nexport function findFirstMonotonous(array, predicate) {\n  const idx = findFirstIdxMonotonousOrArrLen(array, predicate);\n  return idx === array.length ? undefined : array[idx];\n}\n/**\n * Finds the first item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[false, ..., false, true, ..., true]`!\n *\n * @returns `endIdxEx` if predicate is false for all items, otherwise the index of the first item that matches the predicate.\n */\nexport function findFirstIdxMonotonousOrArrLen(array, predicate) {\n  let startIdx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let endIdxEx = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : array.length;\n  let i = startIdx;\n  let j = endIdxEx;\n  while (i < j) {\n    const k = Math.floor((i + j) / 2);\n    if (predicate(array[k])) {\n      j = k;\n    } else {\n      i = k + 1;\n    }\n  }\n  return i;\n}\n/**\n * Use this when\n * * You have a sorted array\n * * You query this array with a monotonous predicate to find the last item that has a certain property.\n * * You query this array multiple times with monotonous predicates that get weaker and weaker.\n */\nexport class MonotonousArray {\n  constructor(_array) {\n    this._array = _array;\n    this._findLastMonotonousLastIdx = 0;\n  }\n  /**\n   * The predicate must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n   * For subsequent calls, current predicate must be weaker than (or equal to) the previous predicate, i.e. more entries must be `true`.\n   */\n  findLastMonotonous(predicate) {\n    if (MonotonousArray.assertInvariants) {\n      if (this._prevFindLastPredicate) {\n        for (const item of this._array) {\n          if (this._prevFindLastPredicate(item) && !predicate(item)) {\n            throw new Error('MonotonousArray: current predicate must be weaker than (or equal to) the previous predicate.');\n          }\n        }\n      }\n      this._prevFindLastPredicate = predicate;\n    }\n    const idx = findLastIdxMonotonous(this._array, predicate, this._findLastMonotonousLastIdx);\n    this._findLastMonotonousLastIdx = idx + 1;\n    return idx === -1 ? undefined : this._array[idx];\n  }\n}\nMonotonousArray.assertInvariants = false;\n/**\n * Returns the first item that is equal to or greater than every other item.\n*/\nexport function findFirstMax(array, comparator) {\n  if (array.length === 0) {\n    return undefined;\n  }\n  let max = array[0];\n  for (let i = 1; i < array.length; i++) {\n    const item = array[i];\n    if (comparator(item, max) > 0) {\n      max = item;\n    }\n  }\n  return max;\n}\n/**\n * Returns the last item that is equal to or greater than every other item.\n*/\nexport function findLastMax(array, comparator) {\n  if (array.length === 0) {\n    return undefined;\n  }\n  let max = array[0];\n  for (let i = 1; i < array.length; i++) {\n    const item = array[i];\n    if (comparator(item, max) >= 0) {\n      max = item;\n    }\n  }\n  return max;\n}\n/**\n * Returns the first item that is equal to or less than every other item.\n*/\nexport function findFirstMin(array, comparator) {\n  return findFirstMax(array, (a, b) => -comparator(a, b));\n}\nexport function findMaxIdx(array, comparator) {\n  if (array.length === 0) {\n    return -1;\n  }\n  let maxIdx = 0;\n  for (let i = 1; i < array.length; i++) {\n    const item = array[i];\n    if (comparator(item, array[maxIdx]) > 0) {\n      maxIdx = i;\n    }\n  }\n  return maxIdx;\n}\n/**\n * Returns the first mapped value of the array which is not undefined.\n */\nexport function mapFindFirst(items, mapFn) {\n  for (const value of items) {\n    const mapped = mapFn(value);\n    if (mapped !== undefined) {\n      return mapped;\n    }\n  }\n  return undefined;\n}","map":{"version":3,"names":["findLast","array","predicate","idx","findLastIdx","undefined","fromIndex","arguments","length","i","element","findLastMonotonous","findLastIdxMonotonous","startIdx","endIdxEx","j","k","Math","floor","findFirstMonotonous","findFirstIdxMonotonousOrArrLen","MonotonousArray","constructor","_array","_findLastMonotonousLastIdx","assertInvariants","_prevFindLastPredicate","item","Error","findFirstMax","comparator","max","findLastMax","findFirstMin","a","b","findMaxIdx","maxIdx","mapFindFirst","items","mapFn","value","mapped"],"sources":["/home/arslan/modojo/node_modules/monaco-editor/esm/vs/base/common/arraysFind.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function findLast(array, predicate) {\n    const idx = findLastIdx(array, predicate);\n    if (idx === -1) {\n        return undefined;\n    }\n    return array[idx];\n}\nexport function findLastIdx(array, predicate, fromIndex = array.length - 1) {\n    for (let i = fromIndex; i >= 0; i--) {\n        const element = array[i];\n        if (predicate(element)) {\n            return i;\n        }\n    }\n    return -1;\n}\n/**\n * Finds the last item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n *\n * @returns `undefined` if no item matches, otherwise the last item that matches the predicate.\n */\nexport function findLastMonotonous(array, predicate) {\n    const idx = findLastIdxMonotonous(array, predicate);\n    return idx === -1 ? undefined : array[idx];\n}\n/**\n * Finds the last item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n *\n * @returns `startIdx - 1` if predicate is false for all items, otherwise the index of the last item that matches the predicate.\n */\nexport function findLastIdxMonotonous(array, predicate, startIdx = 0, endIdxEx = array.length) {\n    let i = startIdx;\n    let j = endIdxEx;\n    while (i < j) {\n        const k = Math.floor((i + j) / 2);\n        if (predicate(array[k])) {\n            i = k + 1;\n        }\n        else {\n            j = k;\n        }\n    }\n    return i - 1;\n}\n/**\n * Finds the first item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[false, ..., false, true, ..., true]`!\n *\n * @returns `undefined` if no item matches, otherwise the first item that matches the predicate.\n */\nexport function findFirstMonotonous(array, predicate) {\n    const idx = findFirstIdxMonotonousOrArrLen(array, predicate);\n    return idx === array.length ? undefined : array[idx];\n}\n/**\n * Finds the first item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[false, ..., false, true, ..., true]`!\n *\n * @returns `endIdxEx` if predicate is false for all items, otherwise the index of the first item that matches the predicate.\n */\nexport function findFirstIdxMonotonousOrArrLen(array, predicate, startIdx = 0, endIdxEx = array.length) {\n    let i = startIdx;\n    let j = endIdxEx;\n    while (i < j) {\n        const k = Math.floor((i + j) / 2);\n        if (predicate(array[k])) {\n            j = k;\n        }\n        else {\n            i = k + 1;\n        }\n    }\n    return i;\n}\n/**\n * Use this when\n * * You have a sorted array\n * * You query this array with a monotonous predicate to find the last item that has a certain property.\n * * You query this array multiple times with monotonous predicates that get weaker and weaker.\n */\nexport class MonotonousArray {\n    constructor(_array) {\n        this._array = _array;\n        this._findLastMonotonousLastIdx = 0;\n    }\n    /**\n     * The predicate must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n     * For subsequent calls, current predicate must be weaker than (or equal to) the previous predicate, i.e. more entries must be `true`.\n     */\n    findLastMonotonous(predicate) {\n        if (MonotonousArray.assertInvariants) {\n            if (this._prevFindLastPredicate) {\n                for (const item of this._array) {\n                    if (this._prevFindLastPredicate(item) && !predicate(item)) {\n                        throw new Error('MonotonousArray: current predicate must be weaker than (or equal to) the previous predicate.');\n                    }\n                }\n            }\n            this._prevFindLastPredicate = predicate;\n        }\n        const idx = findLastIdxMonotonous(this._array, predicate, this._findLastMonotonousLastIdx);\n        this._findLastMonotonousLastIdx = idx + 1;\n        return idx === -1 ? undefined : this._array[idx];\n    }\n}\nMonotonousArray.assertInvariants = false;\n/**\n * Returns the first item that is equal to or greater than every other item.\n*/\nexport function findFirstMax(array, comparator) {\n    if (array.length === 0) {\n        return undefined;\n    }\n    let max = array[0];\n    for (let i = 1; i < array.length; i++) {\n        const item = array[i];\n        if (comparator(item, max) > 0) {\n            max = item;\n        }\n    }\n    return max;\n}\n/**\n * Returns the last item that is equal to or greater than every other item.\n*/\nexport function findLastMax(array, comparator) {\n    if (array.length === 0) {\n        return undefined;\n    }\n    let max = array[0];\n    for (let i = 1; i < array.length; i++) {\n        const item = array[i];\n        if (comparator(item, max) >= 0) {\n            max = item;\n        }\n    }\n    return max;\n}\n/**\n * Returns the first item that is equal to or less than every other item.\n*/\nexport function findFirstMin(array, comparator) {\n    return findFirstMax(array, (a, b) => -comparator(a, b));\n}\nexport function findMaxIdx(array, comparator) {\n    if (array.length === 0) {\n        return -1;\n    }\n    let maxIdx = 0;\n    for (let i = 1; i < array.length; i++) {\n        const item = array[i];\n        if (comparator(item, array[maxIdx]) > 0) {\n            maxIdx = i;\n        }\n    }\n    return maxIdx;\n}\n/**\n * Returns the first mapped value of the array which is not undefined.\n */\nexport function mapFindFirst(items, mapFn) {\n    for (const value of items) {\n        const mapped = mapFn(value);\n        if (mapped !== undefined) {\n            return mapped;\n        }\n    }\n    return undefined;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}