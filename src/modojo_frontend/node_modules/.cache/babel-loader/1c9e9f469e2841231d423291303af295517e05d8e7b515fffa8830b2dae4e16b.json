{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertNever } from '../../../../base/common/assert.js';\nimport { DeferredPromise } from '../../../../base/common/async.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { SetMap } from '../../../../base/common/map.js';\nimport { onUnexpectedExternalError } from '../../../../base/common/errors.js';\nimport { Range } from '../../../common/core/range.js';\nimport { fixBracketsInLine } from '../../../common/model/bracketPairsTextModelPart/fixBrackets.js';\nimport { getReadonlyEmptyArray } from './utils.js';\nimport { SnippetParser, Text } from '../../snippet/browser/snippetParser.js';\nexport async function provideInlineCompletions(registry, position, model, context) {\n  let token = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : CancellationToken.None;\n  let languageConfigurationService = arguments.length > 5 ? arguments[5] : undefined;\n  // Important: Don't use position after the await calls, as the model could have been changed in the meantime!\n  const defaultReplaceRange = getDefaultRange(position, model);\n  const providers = registry.all(model);\n  const multiMap = new SetMap();\n  for (const provider of providers) {\n    if (provider.groupId) {\n      multiMap.add(provider.groupId, provider);\n    }\n  }\n  function getPreferredProviders(provider) {\n    if (!provider.yieldsToGroupIds) {\n      return [];\n    }\n    const result = [];\n    for (const groupId of provider.yieldsToGroupIds || []) {\n      const providers = multiMap.get(groupId);\n      for (const p of providers) {\n        result.push(p);\n      }\n    }\n    return result;\n  }\n  const states = new Map();\n  const seen = new Set();\n  function findPreferredProviderCircle(provider, stack) {\n    stack = [...stack, provider];\n    if (seen.has(provider)) {\n      return stack;\n    }\n    seen.add(provider);\n    try {\n      const preferred = getPreferredProviders(provider);\n      for (const p of preferred) {\n        const c = findPreferredProviderCircle(p, stack);\n        if (c) {\n          return c;\n        }\n      }\n    } finally {\n      seen.delete(provider);\n    }\n    return undefined;\n  }\n  function processProvider(provider) {\n    const state = states.get(provider);\n    if (state) {\n      return state;\n    }\n    const circle = findPreferredProviderCircle(provider, []);\n    if (circle) {\n      onUnexpectedExternalError(new Error(`Inline completions: cyclic yield-to dependency detected. Path: ${circle.map(s => s.toString ? s.toString() : '' + s).join(' -> ')}`));\n    }\n    const deferredPromise = new DeferredPromise();\n    states.set(provider, deferredPromise.p);\n    (async () => {\n      if (!circle) {\n        const preferred = getPreferredProviders(provider);\n        for (const p of preferred) {\n          const result = await processProvider(p);\n          if (result && result.items.length > 0) {\n            // Skip provider\n            return undefined;\n          }\n        }\n      }\n      try {\n        const completions = await provider.provideInlineCompletions(model, position, context, token);\n        return completions;\n      } catch (e) {\n        onUnexpectedExternalError(e);\n        return undefined;\n      }\n    })().then(c => deferredPromise.complete(c), e => deferredPromise.error(e));\n    return deferredPromise.p;\n  }\n  const providerResults = await Promise.all(providers.map(async provider => ({\n    provider,\n    completions: await processProvider(provider)\n  })));\n  const itemsByHash = new Map();\n  const lists = [];\n  for (const result of providerResults) {\n    const completions = result.completions;\n    if (!completions) {\n      continue;\n    }\n    const list = new InlineCompletionList(completions, result.provider);\n    lists.push(list);\n    for (const item of completions.items) {\n      const inlineCompletionItem = InlineCompletionItem.from(item, list, defaultReplaceRange, model, languageConfigurationService);\n      itemsByHash.set(inlineCompletionItem.hash(), inlineCompletionItem);\n    }\n  }\n  return new InlineCompletionProviderResult(Array.from(itemsByHash.values()), new Set(itemsByHash.keys()), lists);\n}\nexport class InlineCompletionProviderResult {\n  constructor(\n  /**\n   * Free of duplicates.\n   */\n  completions, hashs, providerResults) {\n    this.completions = completions;\n    this.hashs = hashs;\n    this.providerResults = providerResults;\n  }\n  has(item) {\n    return this.hashs.has(item.hash());\n  }\n  dispose() {\n    for (const result of this.providerResults) {\n      result.removeRef();\n    }\n  }\n}\n/**\n * A ref counted pointer to the computed `InlineCompletions` and the `InlineCompletionsProvider` that\n * computed them.\n */\nexport class InlineCompletionList {\n  constructor(inlineCompletions, provider) {\n    this.inlineCompletions = inlineCompletions;\n    this.provider = provider;\n    this.refCount = 1;\n  }\n  addRef() {\n    this.refCount++;\n  }\n  removeRef() {\n    this.refCount--;\n    if (this.refCount === 0) {\n      this.provider.freeInlineCompletions(this.inlineCompletions);\n    }\n  }\n}\nexport class InlineCompletionItem {\n  static from(inlineCompletion, source, defaultReplaceRange, textModel, languageConfigurationService) {\n    let insertText;\n    let snippetInfo;\n    let range = inlineCompletion.range ? Range.lift(inlineCompletion.range) : defaultReplaceRange;\n    if (typeof inlineCompletion.insertText === 'string') {\n      insertText = inlineCompletion.insertText;\n      if (languageConfigurationService && inlineCompletion.completeBracketPairs) {\n        insertText = closeBrackets(insertText, range.getStartPosition(), textModel, languageConfigurationService);\n        // Modify range depending on if brackets are added or removed\n        const diff = insertText.length - inlineCompletion.insertText.length;\n        if (diff !== 0) {\n          range = new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn + diff);\n        }\n      }\n      snippetInfo = undefined;\n    } else if ('snippet' in inlineCompletion.insertText) {\n      const preBracketCompletionLength = inlineCompletion.insertText.snippet.length;\n      if (languageConfigurationService && inlineCompletion.completeBracketPairs) {\n        inlineCompletion.insertText.snippet = closeBrackets(inlineCompletion.insertText.snippet, range.getStartPosition(), textModel, languageConfigurationService);\n        // Modify range depending on if brackets are added or removed\n        const diff = inlineCompletion.insertText.snippet.length - preBracketCompletionLength;\n        if (diff !== 0) {\n          range = new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn + diff);\n        }\n      }\n      const snippet = new SnippetParser().parse(inlineCompletion.insertText.snippet);\n      if (snippet.children.length === 1 && snippet.children[0] instanceof Text) {\n        insertText = snippet.children[0].value;\n        snippetInfo = undefined;\n      } else {\n        insertText = snippet.toString();\n        snippetInfo = {\n          snippet: inlineCompletion.insertText.snippet,\n          range: range\n        };\n      }\n    } else {\n      assertNever(inlineCompletion.insertText);\n    }\n    return new InlineCompletionItem(insertText, inlineCompletion.command, range, insertText, snippetInfo, inlineCompletion.additionalTextEdits || getReadonlyEmptyArray(), inlineCompletion, source);\n  }\n  constructor(filterText, command, range, insertText, snippetInfo, additionalTextEdits,\n  /**\n   * A reference to the original inline completion this inline completion has been constructed from.\n   * Used for event data to ensure referential equality.\n  */\n  sourceInlineCompletion,\n  /**\n   * A reference to the original inline completion list this inline completion has been constructed from.\n   * Used for event data to ensure referential equality.\n  */\n  source) {\n    this.filterText = filterText;\n    this.command = command;\n    this.range = range;\n    this.insertText = insertText;\n    this.snippetInfo = snippetInfo;\n    this.additionalTextEdits = additionalTextEdits;\n    this.sourceInlineCompletion = sourceInlineCompletion;\n    this.source = source;\n    filterText = filterText.replace(/\\r\\n|\\r/g, '\\n');\n    insertText = filterText.replace(/\\r\\n|\\r/g, '\\n');\n  }\n  withRange(updatedRange) {\n    return new InlineCompletionItem(this.filterText, this.command, updatedRange, this.insertText, this.snippetInfo, this.additionalTextEdits, this.sourceInlineCompletion, this.source);\n  }\n  hash() {\n    return JSON.stringify({\n      insertText: this.insertText,\n      range: this.range.toString()\n    });\n  }\n}\nfunction getDefaultRange(position, model) {\n  const word = model.getWordAtPosition(position);\n  const maxColumn = model.getLineMaxColumn(position.lineNumber);\n  // By default, always replace up until the end of the current line.\n  // This default might be subject to change!\n  return word ? new Range(position.lineNumber, word.startColumn, position.lineNumber, maxColumn) : Range.fromPositions(position, position.with(undefined, maxColumn));\n}\nfunction closeBrackets(text, position, model, languageConfigurationService) {\n  const lineStart = model.getLineContent(position.lineNumber).substring(0, position.column - 1);\n  const newLine = lineStart + text;\n  const newTokens = model.tokenization.tokenizeLineWithEdit(position, newLine.length - (position.column - 1), text);\n  const slicedTokens = newTokens === null || newTokens === void 0 ? void 0 : newTokens.sliceAndInflate(position.column - 1, newLine.length, 0);\n  if (!slicedTokens) {\n    return text;\n  }\n  const newText = fixBracketsInLine(slicedTokens, languageConfigurationService);\n  return newText;\n}","map":{"version":3,"names":["assertNever","DeferredPromise","CancellationToken","SetMap","onUnexpectedExternalError","Range","fixBracketsInLine","getReadonlyEmptyArray","SnippetParser","Text","provideInlineCompletions","registry","position","model","context","token","arguments","length","undefined","None","languageConfigurationService","defaultReplaceRange","getDefaultRange","providers","all","multiMap","provider","groupId","add","getPreferredProviders","yieldsToGroupIds","result","get","p","push","states","Map","seen","Set","findPreferredProviderCircle","stack","has","preferred","c","delete","processProvider","state","circle","Error","map","s","toString","join","deferredPromise","set","items","completions","e","then","complete","error","providerResults","Promise","itemsByHash","lists","list","InlineCompletionList","item","inlineCompletionItem","InlineCompletionItem","from","hash","InlineCompletionProviderResult","Array","values","keys","constructor","hashs","dispose","removeRef","inlineCompletions","refCount","addRef","freeInlineCompletions","inlineCompletion","source","textModel","insertText","snippetInfo","range","lift","completeBracketPairs","closeBrackets","getStartPosition","diff","startLineNumber","startColumn","endLineNumber","endColumn","preBracketCompletionLength","snippet","parse","children","value","command","additionalTextEdits","filterText","sourceInlineCompletion","replace","withRange","updatedRange","JSON","stringify","word","getWordAtPosition","maxColumn","getLineMaxColumn","lineNumber","fromPositions","with","text","lineStart","getLineContent","substring","column","newLine","newTokens","tokenization","tokenizeLineWithEdit","slicedTokens","sliceAndInflate","newText"],"sources":["/home/arslan/modojo/node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/provideInlineCompletions.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertNever } from '../../../../base/common/assert.js';\nimport { DeferredPromise } from '../../../../base/common/async.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { SetMap } from '../../../../base/common/map.js';\nimport { onUnexpectedExternalError } from '../../../../base/common/errors.js';\nimport { Range } from '../../../common/core/range.js';\nimport { fixBracketsInLine } from '../../../common/model/bracketPairsTextModelPart/fixBrackets.js';\nimport { getReadonlyEmptyArray } from './utils.js';\nimport { SnippetParser, Text } from '../../snippet/browser/snippetParser.js';\nexport async function provideInlineCompletions(registry, position, model, context, token = CancellationToken.None, languageConfigurationService) {\n    // Important: Don't use position after the await calls, as the model could have been changed in the meantime!\n    const defaultReplaceRange = getDefaultRange(position, model);\n    const providers = registry.all(model);\n    const multiMap = new SetMap();\n    for (const provider of providers) {\n        if (provider.groupId) {\n            multiMap.add(provider.groupId, provider);\n        }\n    }\n    function getPreferredProviders(provider) {\n        if (!provider.yieldsToGroupIds) {\n            return [];\n        }\n        const result = [];\n        for (const groupId of provider.yieldsToGroupIds || []) {\n            const providers = multiMap.get(groupId);\n            for (const p of providers) {\n                result.push(p);\n            }\n        }\n        return result;\n    }\n    const states = new Map();\n    const seen = new Set();\n    function findPreferredProviderCircle(provider, stack) {\n        stack = [...stack, provider];\n        if (seen.has(provider)) {\n            return stack;\n        }\n        seen.add(provider);\n        try {\n            const preferred = getPreferredProviders(provider);\n            for (const p of preferred) {\n                const c = findPreferredProviderCircle(p, stack);\n                if (c) {\n                    return c;\n                }\n            }\n        }\n        finally {\n            seen.delete(provider);\n        }\n        return undefined;\n    }\n    function processProvider(provider) {\n        const state = states.get(provider);\n        if (state) {\n            return state;\n        }\n        const circle = findPreferredProviderCircle(provider, []);\n        if (circle) {\n            onUnexpectedExternalError(new Error(`Inline completions: cyclic yield-to dependency detected. Path: ${circle.map(s => s.toString ? s.toString() : ('' + s)).join(' -> ')}`));\n        }\n        const deferredPromise = new DeferredPromise();\n        states.set(provider, deferredPromise.p);\n        (async () => {\n            if (!circle) {\n                const preferred = getPreferredProviders(provider);\n                for (const p of preferred) {\n                    const result = await processProvider(p);\n                    if (result && result.items.length > 0) {\n                        // Skip provider\n                        return undefined;\n                    }\n                }\n            }\n            try {\n                const completions = await provider.provideInlineCompletions(model, position, context, token);\n                return completions;\n            }\n            catch (e) {\n                onUnexpectedExternalError(e);\n                return undefined;\n            }\n        })().then(c => deferredPromise.complete(c), e => deferredPromise.error(e));\n        return deferredPromise.p;\n    }\n    const providerResults = await Promise.all(providers.map(async (provider) => ({ provider, completions: await processProvider(provider) })));\n    const itemsByHash = new Map();\n    const lists = [];\n    for (const result of providerResults) {\n        const completions = result.completions;\n        if (!completions) {\n            continue;\n        }\n        const list = new InlineCompletionList(completions, result.provider);\n        lists.push(list);\n        for (const item of completions.items) {\n            const inlineCompletionItem = InlineCompletionItem.from(item, list, defaultReplaceRange, model, languageConfigurationService);\n            itemsByHash.set(inlineCompletionItem.hash(), inlineCompletionItem);\n        }\n    }\n    return new InlineCompletionProviderResult(Array.from(itemsByHash.values()), new Set(itemsByHash.keys()), lists);\n}\nexport class InlineCompletionProviderResult {\n    constructor(\n    /**\n     * Free of duplicates.\n     */\n    completions, hashs, providerResults) {\n        this.completions = completions;\n        this.hashs = hashs;\n        this.providerResults = providerResults;\n    }\n    has(item) {\n        return this.hashs.has(item.hash());\n    }\n    dispose() {\n        for (const result of this.providerResults) {\n            result.removeRef();\n        }\n    }\n}\n/**\n * A ref counted pointer to the computed `InlineCompletions` and the `InlineCompletionsProvider` that\n * computed them.\n */\nexport class InlineCompletionList {\n    constructor(inlineCompletions, provider) {\n        this.inlineCompletions = inlineCompletions;\n        this.provider = provider;\n        this.refCount = 1;\n    }\n    addRef() {\n        this.refCount++;\n    }\n    removeRef() {\n        this.refCount--;\n        if (this.refCount === 0) {\n            this.provider.freeInlineCompletions(this.inlineCompletions);\n        }\n    }\n}\nexport class InlineCompletionItem {\n    static from(inlineCompletion, source, defaultReplaceRange, textModel, languageConfigurationService) {\n        let insertText;\n        let snippetInfo;\n        let range = inlineCompletion.range ? Range.lift(inlineCompletion.range) : defaultReplaceRange;\n        if (typeof inlineCompletion.insertText === 'string') {\n            insertText = inlineCompletion.insertText;\n            if (languageConfigurationService && inlineCompletion.completeBracketPairs) {\n                insertText = closeBrackets(insertText, range.getStartPosition(), textModel, languageConfigurationService);\n                // Modify range depending on if brackets are added or removed\n                const diff = insertText.length - inlineCompletion.insertText.length;\n                if (diff !== 0) {\n                    range = new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn + diff);\n                }\n            }\n            snippetInfo = undefined;\n        }\n        else if ('snippet' in inlineCompletion.insertText) {\n            const preBracketCompletionLength = inlineCompletion.insertText.snippet.length;\n            if (languageConfigurationService && inlineCompletion.completeBracketPairs) {\n                inlineCompletion.insertText.snippet = closeBrackets(inlineCompletion.insertText.snippet, range.getStartPosition(), textModel, languageConfigurationService);\n                // Modify range depending on if brackets are added or removed\n                const diff = inlineCompletion.insertText.snippet.length - preBracketCompletionLength;\n                if (diff !== 0) {\n                    range = new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn + diff);\n                }\n            }\n            const snippet = new SnippetParser().parse(inlineCompletion.insertText.snippet);\n            if (snippet.children.length === 1 && snippet.children[0] instanceof Text) {\n                insertText = snippet.children[0].value;\n                snippetInfo = undefined;\n            }\n            else {\n                insertText = snippet.toString();\n                snippetInfo = {\n                    snippet: inlineCompletion.insertText.snippet,\n                    range: range\n                };\n            }\n        }\n        else {\n            assertNever(inlineCompletion.insertText);\n        }\n        return new InlineCompletionItem(insertText, inlineCompletion.command, range, insertText, snippetInfo, inlineCompletion.additionalTextEdits || getReadonlyEmptyArray(), inlineCompletion, source);\n    }\n    constructor(filterText, command, range, insertText, snippetInfo, additionalTextEdits, \n    /**\n     * A reference to the original inline completion this inline completion has been constructed from.\n     * Used for event data to ensure referential equality.\n    */\n    sourceInlineCompletion, \n    /**\n     * A reference to the original inline completion list this inline completion has been constructed from.\n     * Used for event data to ensure referential equality.\n    */\n    source) {\n        this.filterText = filterText;\n        this.command = command;\n        this.range = range;\n        this.insertText = insertText;\n        this.snippetInfo = snippetInfo;\n        this.additionalTextEdits = additionalTextEdits;\n        this.sourceInlineCompletion = sourceInlineCompletion;\n        this.source = source;\n        filterText = filterText.replace(/\\r\\n|\\r/g, '\\n');\n        insertText = filterText.replace(/\\r\\n|\\r/g, '\\n');\n    }\n    withRange(updatedRange) {\n        return new InlineCompletionItem(this.filterText, this.command, updatedRange, this.insertText, this.snippetInfo, this.additionalTextEdits, this.sourceInlineCompletion, this.source);\n    }\n    hash() {\n        return JSON.stringify({ insertText: this.insertText, range: this.range.toString() });\n    }\n}\nfunction getDefaultRange(position, model) {\n    const word = model.getWordAtPosition(position);\n    const maxColumn = model.getLineMaxColumn(position.lineNumber);\n    // By default, always replace up until the end of the current line.\n    // This default might be subject to change!\n    return word\n        ? new Range(position.lineNumber, word.startColumn, position.lineNumber, maxColumn)\n        : Range.fromPositions(position, position.with(undefined, maxColumn));\n}\nfunction closeBrackets(text, position, model, languageConfigurationService) {\n    const lineStart = model.getLineContent(position.lineNumber).substring(0, position.column - 1);\n    const newLine = lineStart + text;\n    const newTokens = model.tokenization.tokenizeLineWithEdit(position, newLine.length - (position.column - 1), text);\n    const slicedTokens = newTokens === null || newTokens === void 0 ? void 0 : newTokens.sliceAndInflate(position.column - 1, newLine.length, 0);\n    if (!slicedTokens) {\n        return text;\n    }\n    const newText = fixBracketsInLine(slicedTokens, languageConfigurationService);\n    return newText;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}