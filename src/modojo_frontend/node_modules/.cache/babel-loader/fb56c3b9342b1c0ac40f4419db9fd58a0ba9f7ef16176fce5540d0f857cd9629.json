{"ast":null,"code":"import { Principal } from '@dfinity/principal';\nimport * as CanisterStatus from './canisterStatus/index';\nimport { HttpAgent } from './agent/http';\nimport { Actor } from './actor';\n/**\n * Retrieves the Candid interface for the specified canister.\n *\n * @param agent The agent to use for the request (usually an `HttpAgent`)\n * @param canisterId A string corresponding to the canister ID\n * @returns Candid source code\n */\nexport async function fetchCandid(canisterId, agent) {\n  if (!agent) {\n    // Create an anonymous `HttpAgent` (adapted from Candid UI)\n    agent = await HttpAgent.create();\n  }\n  // Attempt to use canister metadata\n  const status = await CanisterStatus.request({\n    agent,\n    canisterId: Principal.fromText(canisterId),\n    paths: ['candid']\n  });\n  const candid = status.get('candid');\n  if (candid) {\n    return candid;\n  }\n  // Use `__get_candid_interface_tmp_hack` for canisters without Candid metadata\n  const tmpHackInterface = _ref => {\n    let {\n      IDL\n    } = _ref;\n    return IDL.Service({\n      __get_candid_interface_tmp_hack: IDL.Func([], [IDL.Text], ['query'])\n    });\n  };\n  const actor = Actor.createActor(tmpHackInterface, {\n    agent,\n    canisterId\n  });\n  return await actor.__get_candid_interface_tmp_hack();\n}","map":{"version":3,"names":["Principal","CanisterStatus","HttpAgent","Actor","fetchCandid","canisterId","agent","create","status","request","fromText","paths","candid","get","tmpHackInterface","_ref","IDL","Service","__get_candid_interface_tmp_hack","Func","Text","actor","createActor"],"sources":["/home/arslan/modojo/node_modules/@dfinity/agent/src/fetch_candid.ts"],"sourcesContent":["import { Principal } from '@dfinity/principal';\nimport * as CanisterStatus from './canisterStatus/index';\nimport { IDL } from '@dfinity/candid';\nimport { HttpAgent } from './agent/http';\nimport { Actor, ActorSubclass } from './actor';\n\n/**\n * Retrieves the Candid interface for the specified canister.\n *\n * @param agent The agent to use for the request (usually an `HttpAgent`)\n * @param canisterId A string corresponding to the canister ID\n * @returns Candid source code\n */\nexport async function fetchCandid(canisterId: string, agent?: HttpAgent): Promise<string> {\n  if (!agent) {\n    // Create an anonymous `HttpAgent` (adapted from Candid UI)\n    agent = await HttpAgent.create();\n  }\n\n  // Attempt to use canister metadata\n  const status = await CanisterStatus.request({\n    agent,\n    canisterId: Principal.fromText(canisterId),\n    paths: ['candid'],\n  });\n  const candid = status.get('candid') as string | undefined;\n  if (candid) {\n    return candid;\n  }\n\n  // Use `__get_candid_interface_tmp_hack` for canisters without Candid metadata\n  const tmpHackInterface: IDL.InterfaceFactory = ({ IDL }) =>\n    IDL.Service({\n      __get_candid_interface_tmp_hack: IDL.Func([], [IDL.Text], ['query']),\n    });\n  const actor: ActorSubclass = Actor.createActor(tmpHackInterface, { agent, canisterId });\n  return (await actor.__get_candid_interface_tmp_hack()) as string;\n}\n"],"mappings":"AAAA,SAASA,SAAS,QAAQ,oBAAoB;AAC9C,OAAO,KAAKC,cAAc,MAAM,wBAAwB;AAExD,SAASC,SAAS,QAAQ,cAAc;AACxC,SAASC,KAAK,QAAuB,SAAS;AAE9C;;;;;;;AAOA,OAAO,eAAeC,WAAWA,CAACC,UAAkB,EAAEC,KAAiB;EACrE,IAAI,CAACA,KAAK,EAAE;IACV;IACAA,KAAK,GAAG,MAAMJ,SAAS,CAACK,MAAM,EAAE;;EAGlC;EACA,MAAMC,MAAM,GAAG,MAAMP,cAAc,CAACQ,OAAO,CAAC;IAC1CH,KAAK;IACLD,UAAU,EAAEL,SAAS,CAACU,QAAQ,CAACL,UAAU,CAAC;IAC1CM,KAAK,EAAE,CAAC,QAAQ;GACjB,CAAC;EACF,MAAMC,MAAM,GAAGJ,MAAM,CAACK,GAAG,CAAC,QAAQ,CAAuB;EACzD,IAAID,MAAM,EAAE;IACV,OAAOA,MAAM;;EAGf;EACA,MAAME,gBAAgB,GAAyBC,IAAA;IAAA,IAAC;MAAEC;IAAG,CAAE,GAAAD,IAAA;IAAA,OACrDC,GAAG,CAACC,OAAO,CAAC;MACVC,+BAA+B,EAAEF,GAAG,CAACG,IAAI,CAAC,EAAE,EAAE,CAACH,GAAG,CAACI,IAAI,CAAC,EAAE,CAAC,OAAO,CAAC;KACpE,CAAC;EAAA;EACJ,MAAMC,KAAK,GAAkBlB,KAAK,CAACmB,WAAW,CAACR,gBAAgB,EAAE;IAAER,KAAK;IAAED;EAAU,CAAE,CAAC;EACvF,OAAQ,MAAMgB,KAAK,CAACH,+BAA+B,EAAE;AACvD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}