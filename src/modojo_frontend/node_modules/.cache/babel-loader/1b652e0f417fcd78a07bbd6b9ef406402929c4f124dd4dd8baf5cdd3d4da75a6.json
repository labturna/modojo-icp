{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as extpath from './extpath.js';\nimport { Schemas } from './network.js';\nimport * as paths from './path.js';\nimport { isLinux, isWindows } from './platform.js';\nimport { compare as strCompare, equalsIgnoreCase } from './strings.js';\nimport { URI, uriToFsPath } from './uri.js';\nexport function originalFSPath(uri) {\n  return uriToFsPath(uri, true);\n}\nexport class ExtUri {\n  constructor(_ignorePathCasing) {\n    this._ignorePathCasing = _ignorePathCasing;\n  }\n  compare(uri1, uri2) {\n    let ignoreFragment = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (uri1 === uri2) {\n      return 0;\n    }\n    return strCompare(this.getComparisonKey(uri1, ignoreFragment), this.getComparisonKey(uri2, ignoreFragment));\n  }\n  isEqual(uri1, uri2) {\n    let ignoreFragment = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (uri1 === uri2) {\n      return true;\n    }\n    if (!uri1 || !uri2) {\n      return false;\n    }\n    return this.getComparisonKey(uri1, ignoreFragment) === this.getComparisonKey(uri2, ignoreFragment);\n  }\n  getComparisonKey(uri) {\n    let ignoreFragment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return uri.with({\n      path: this._ignorePathCasing(uri) ? uri.path.toLowerCase() : undefined,\n      fragment: ignoreFragment ? null : undefined\n    }).toString();\n  }\n  isEqualOrParent(base, parentCandidate) {\n    let ignoreFragment = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (base.scheme === parentCandidate.scheme) {\n      if (base.scheme === Schemas.file) {\n        return extpath.isEqualOrParent(originalFSPath(base), originalFSPath(parentCandidate), this._ignorePathCasing(base)) && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n      }\n      if (isEqualAuthority(base.authority, parentCandidate.authority)) {\n        return extpath.isEqualOrParent(base.path, parentCandidate.path, this._ignorePathCasing(base), '/') && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n      }\n    }\n    return false;\n  }\n  // --- path math\n  joinPath(resource) {\n    for (var _len = arguments.length, pathFragment = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      pathFragment[_key - 1] = arguments[_key];\n    }\n    return URI.joinPath(resource, ...pathFragment);\n  }\n  basenameOrAuthority(resource) {\n    return basename(resource) || resource.authority;\n  }\n  basename(resource) {\n    return paths.posix.basename(resource.path);\n  }\n  extname(resource) {\n    return paths.posix.extname(resource.path);\n  }\n  dirname(resource) {\n    if (resource.path.length === 0) {\n      return resource;\n    }\n    let dirname;\n    if (resource.scheme === Schemas.file) {\n      dirname = URI.file(paths.dirname(originalFSPath(resource))).path;\n    } else {\n      dirname = paths.posix.dirname(resource.path);\n      if (resource.authority && dirname.length && dirname.charCodeAt(0) !== 47 /* CharCode.Slash */) {\n        console.error(`dirname(\"${resource.toString})) resulted in a relative path`);\n        dirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash (\"/\") character\n      }\n    }\n    return resource.with({\n      path: dirname\n    });\n  }\n  normalizePath(resource) {\n    if (!resource.path.length) {\n      return resource;\n    }\n    let normalizedPath;\n    if (resource.scheme === Schemas.file) {\n      normalizedPath = URI.file(paths.normalize(originalFSPath(resource))).path;\n    } else {\n      normalizedPath = paths.posix.normalize(resource.path);\n    }\n    return resource.with({\n      path: normalizedPath\n    });\n  }\n  relativePath(from, to) {\n    if (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {\n      return undefined;\n    }\n    if (from.scheme === Schemas.file) {\n      const relativePath = paths.relative(originalFSPath(from), originalFSPath(to));\n      return isWindows ? extpath.toSlashes(relativePath) : relativePath;\n    }\n    let fromPath = from.path || '/';\n    const toPath = to.path || '/';\n    if (this._ignorePathCasing(from)) {\n      // make casing of fromPath match toPath\n      let i = 0;\n      for (const len = Math.min(fromPath.length, toPath.length); i < len; i++) {\n        if (fromPath.charCodeAt(i) !== toPath.charCodeAt(i)) {\n          if (fromPath.charAt(i).toLowerCase() !== toPath.charAt(i).toLowerCase()) {\n            break;\n          }\n        }\n      }\n      fromPath = toPath.substr(0, i) + fromPath.substr(i);\n    }\n    return paths.posix.relative(fromPath, toPath);\n  }\n  resolvePath(base, path) {\n    if (base.scheme === Schemas.file) {\n      const newURI = URI.file(paths.resolve(originalFSPath(base), path));\n      return base.with({\n        authority: newURI.authority,\n        path: newURI.path\n      });\n    }\n    path = extpath.toPosixPath(path); // we allow path to be a windows path\n    return base.with({\n      path: paths.posix.resolve(base.path, path)\n    });\n  }\n  // --- misc\n  isAbsolutePath(resource) {\n    return !!resource.path && resource.path[0] === '/';\n  }\n  isEqualAuthority(a1, a2) {\n    return a1 === a2 || a1 !== undefined && a2 !== undefined && equalsIgnoreCase(a1, a2);\n  }\n  hasTrailingPathSeparator(resource) {\n    let sep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : paths.sep;\n    if (resource.scheme === Schemas.file) {\n      const fsp = originalFSPath(resource);\n      return fsp.length > extpath.getRoot(fsp).length && fsp[fsp.length - 1] === sep;\n    } else {\n      const p = resource.path;\n      return p.length > 1 && p.charCodeAt(p.length - 1) === 47 /* CharCode.Slash */ && !/^[a-zA-Z]:(\\/$|\\\\$)/.test(resource.fsPath); // ignore the slash at offset 0\n    }\n  }\n  removeTrailingPathSeparator(resource) {\n    let sep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : paths.sep;\n    // Make sure that the path isn't a drive letter. A trailing separator there is not removable.\n    if (hasTrailingPathSeparator(resource, sep)) {\n      return resource.with({\n        path: resource.path.substr(0, resource.path.length - 1)\n      });\n    }\n    return resource;\n  }\n  addTrailingPathSeparator(resource) {\n    let sep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : paths.sep;\n    let isRootSep = false;\n    if (resource.scheme === Schemas.file) {\n      const fsp = originalFSPath(resource);\n      isRootSep = fsp !== undefined && fsp.length === extpath.getRoot(fsp).length && fsp[fsp.length - 1] === sep;\n    } else {\n      sep = '/';\n      const p = resource.path;\n      isRootSep = p.length === 1 && p.charCodeAt(p.length - 1) === 47 /* CharCode.Slash */;\n    }\n    if (!isRootSep && !hasTrailingPathSeparator(resource, sep)) {\n      return resource.with({\n        path: resource.path + '/'\n      });\n    }\n    return resource;\n  }\n}\n/**\n * Unbiased utility that takes uris \"as they are\". This means it can be interchanged with\n * uri#toString() usages. The following is true\n * ```\n * assertEqual(aUri.toString() === bUri.toString(), exturi.isEqual(aUri, bUri))\n * ```\n */\nexport const extUri = new ExtUri(() => false);\n/**\n * BIASED utility that _mostly_ ignored the case of urs paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriBiasedIgnorePathCase = new ExtUri(uri => {\n  // A file scheme resource is in the same platform as code, so ignore case for non linux platforms\n  // Resource can be from another platform. Lowering the case as an hack. Should come from File system provider\n  return uri.scheme === Schemas.file ? !isLinux : true;\n});\n/**\n * BIASED utility that always ignores the casing of uris paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriIgnorePathCase = new ExtUri(_ => true);\nexport const isEqual = extUri.isEqual.bind(extUri);\nexport const isEqualOrParent = extUri.isEqualOrParent.bind(extUri);\nexport const getComparisonKey = extUri.getComparisonKey.bind(extUri);\nexport const basenameOrAuthority = extUri.basenameOrAuthority.bind(extUri);\nexport const basename = extUri.basename.bind(extUri);\nexport const extname = extUri.extname.bind(extUri);\nexport const dirname = extUri.dirname.bind(extUri);\nexport const joinPath = extUri.joinPath.bind(extUri);\nexport const normalizePath = extUri.normalizePath.bind(extUri);\nexport const relativePath = extUri.relativePath.bind(extUri);\nexport const resolvePath = extUri.resolvePath.bind(extUri);\nexport const isAbsolutePath = extUri.isAbsolutePath.bind(extUri);\nexport const isEqualAuthority = extUri.isEqualAuthority.bind(extUri);\nexport const hasTrailingPathSeparator = extUri.hasTrailingPathSeparator.bind(extUri);\nexport const removeTrailingPathSeparator = extUri.removeTrailingPathSeparator.bind(extUri);\nexport const addTrailingPathSeparator = extUri.addTrailingPathSeparator.bind(extUri);\n/**\n * Data URI related helpers.\n */\nexport var DataUri;\n(function (DataUri) {\n  DataUri.META_DATA_LABEL = 'label';\n  DataUri.META_DATA_DESCRIPTION = 'description';\n  DataUri.META_DATA_SIZE = 'size';\n  DataUri.META_DATA_MIME = 'mime';\n  function parseMetaData(dataUri) {\n    const metadata = new Map();\n    // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n    // the metadata is: size:2313;label:SomeLabel;description:SomeDescription\n    const meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\n    meta.split(';').forEach(property => {\n      const [key, value] = property.split(':');\n      if (key && value) {\n        metadata.set(key, value);\n      }\n    });\n    // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n    // the mime is: image/png\n    const mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\n    if (mime) {\n      metadata.set(DataUri.META_DATA_MIME, mime);\n    }\n    return metadata;\n  }\n  DataUri.parseMetaData = parseMetaData;\n})(DataUri || (DataUri = {}));","map":{"version":3,"names":["extpath","Schemas","paths","isLinux","isWindows","compare","strCompare","equalsIgnoreCase","URI","uriToFsPath","originalFSPath","uri","ExtUri","constructor","_ignorePathCasing","uri1","uri2","ignoreFragment","arguments","length","undefined","getComparisonKey","isEqual","with","path","toLowerCase","fragment","toString","isEqualOrParent","base","parentCandidate","scheme","file","query","isEqualAuthority","authority","joinPath","resource","_len","pathFragment","Array","_key","basenameOrAuthority","basename","posix","extname","dirname","charCodeAt","console","error","normalizePath","normalizedPath","normalize","relativePath","from","to","relative","toSlashes","fromPath","toPath","i","len","Math","min","charAt","substr","resolvePath","newURI","resolve","toPosixPath","isAbsolutePath","a1","a2","hasTrailingPathSeparator","sep","fsp","getRoot","p","test","fsPath","removeTrailingPathSeparator","addTrailingPathSeparator","isRootSep","extUri","extUriBiasedIgnorePathCase","extUriIgnorePathCase","_","bind","DataUri","META_DATA_LABEL","META_DATA_DESCRIPTION","META_DATA_SIZE","META_DATA_MIME","parseMetaData","dataUri","metadata","Map","meta","substring","indexOf","lastIndexOf","split","forEach","property","key","value","set","mime"],"sources":["/home/arslan/modojo/node_modules/monaco-editor/esm/vs/base/common/resources.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as extpath from './extpath.js';\nimport { Schemas } from './network.js';\nimport * as paths from './path.js';\nimport { isLinux, isWindows } from './platform.js';\nimport { compare as strCompare, equalsIgnoreCase } from './strings.js';\nimport { URI, uriToFsPath } from './uri.js';\nexport function originalFSPath(uri) {\n    return uriToFsPath(uri, true);\n}\nexport class ExtUri {\n    constructor(_ignorePathCasing) {\n        this._ignorePathCasing = _ignorePathCasing;\n    }\n    compare(uri1, uri2, ignoreFragment = false) {\n        if (uri1 === uri2) {\n            return 0;\n        }\n        return strCompare(this.getComparisonKey(uri1, ignoreFragment), this.getComparisonKey(uri2, ignoreFragment));\n    }\n    isEqual(uri1, uri2, ignoreFragment = false) {\n        if (uri1 === uri2) {\n            return true;\n        }\n        if (!uri1 || !uri2) {\n            return false;\n        }\n        return this.getComparisonKey(uri1, ignoreFragment) === this.getComparisonKey(uri2, ignoreFragment);\n    }\n    getComparisonKey(uri, ignoreFragment = false) {\n        return uri.with({\n            path: this._ignorePathCasing(uri) ? uri.path.toLowerCase() : undefined,\n            fragment: ignoreFragment ? null : undefined\n        }).toString();\n    }\n    isEqualOrParent(base, parentCandidate, ignoreFragment = false) {\n        if (base.scheme === parentCandidate.scheme) {\n            if (base.scheme === Schemas.file) {\n                return extpath.isEqualOrParent(originalFSPath(base), originalFSPath(parentCandidate), this._ignorePathCasing(base)) && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n            }\n            if (isEqualAuthority(base.authority, parentCandidate.authority)) {\n                return extpath.isEqualOrParent(base.path, parentCandidate.path, this._ignorePathCasing(base), '/') && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n            }\n        }\n        return false;\n    }\n    // --- path math\n    joinPath(resource, ...pathFragment) {\n        return URI.joinPath(resource, ...pathFragment);\n    }\n    basenameOrAuthority(resource) {\n        return basename(resource) || resource.authority;\n    }\n    basename(resource) {\n        return paths.posix.basename(resource.path);\n    }\n    extname(resource) {\n        return paths.posix.extname(resource.path);\n    }\n    dirname(resource) {\n        if (resource.path.length === 0) {\n            return resource;\n        }\n        let dirname;\n        if (resource.scheme === Schemas.file) {\n            dirname = URI.file(paths.dirname(originalFSPath(resource))).path;\n        }\n        else {\n            dirname = paths.posix.dirname(resource.path);\n            if (resource.authority && dirname.length && dirname.charCodeAt(0) !== 47 /* CharCode.Slash */) {\n                console.error(`dirname(\"${resource.toString})) resulted in a relative path`);\n                dirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash (\"/\") character\n            }\n        }\n        return resource.with({\n            path: dirname\n        });\n    }\n    normalizePath(resource) {\n        if (!resource.path.length) {\n            return resource;\n        }\n        let normalizedPath;\n        if (resource.scheme === Schemas.file) {\n            normalizedPath = URI.file(paths.normalize(originalFSPath(resource))).path;\n        }\n        else {\n            normalizedPath = paths.posix.normalize(resource.path);\n        }\n        return resource.with({\n            path: normalizedPath\n        });\n    }\n    relativePath(from, to) {\n        if (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {\n            return undefined;\n        }\n        if (from.scheme === Schemas.file) {\n            const relativePath = paths.relative(originalFSPath(from), originalFSPath(to));\n            return isWindows ? extpath.toSlashes(relativePath) : relativePath;\n        }\n        let fromPath = from.path || '/';\n        const toPath = to.path || '/';\n        if (this._ignorePathCasing(from)) {\n            // make casing of fromPath match toPath\n            let i = 0;\n            for (const len = Math.min(fromPath.length, toPath.length); i < len; i++) {\n                if (fromPath.charCodeAt(i) !== toPath.charCodeAt(i)) {\n                    if (fromPath.charAt(i).toLowerCase() !== toPath.charAt(i).toLowerCase()) {\n                        break;\n                    }\n                }\n            }\n            fromPath = toPath.substr(0, i) + fromPath.substr(i);\n        }\n        return paths.posix.relative(fromPath, toPath);\n    }\n    resolvePath(base, path) {\n        if (base.scheme === Schemas.file) {\n            const newURI = URI.file(paths.resolve(originalFSPath(base), path));\n            return base.with({\n                authority: newURI.authority,\n                path: newURI.path\n            });\n        }\n        path = extpath.toPosixPath(path); // we allow path to be a windows path\n        return base.with({\n            path: paths.posix.resolve(base.path, path)\n        });\n    }\n    // --- misc\n    isAbsolutePath(resource) {\n        return !!resource.path && resource.path[0] === '/';\n    }\n    isEqualAuthority(a1, a2) {\n        return a1 === a2 || (a1 !== undefined && a2 !== undefined && equalsIgnoreCase(a1, a2));\n    }\n    hasTrailingPathSeparator(resource, sep = paths.sep) {\n        if (resource.scheme === Schemas.file) {\n            const fsp = originalFSPath(resource);\n            return fsp.length > extpath.getRoot(fsp).length && fsp[fsp.length - 1] === sep;\n        }\n        else {\n            const p = resource.path;\n            return (p.length > 1 && p.charCodeAt(p.length - 1) === 47 /* CharCode.Slash */) && !(/^[a-zA-Z]:(\\/$|\\\\$)/.test(resource.fsPath)); // ignore the slash at offset 0\n        }\n    }\n    removeTrailingPathSeparator(resource, sep = paths.sep) {\n        // Make sure that the path isn't a drive letter. A trailing separator there is not removable.\n        if (hasTrailingPathSeparator(resource, sep)) {\n            return resource.with({ path: resource.path.substr(0, resource.path.length - 1) });\n        }\n        return resource;\n    }\n    addTrailingPathSeparator(resource, sep = paths.sep) {\n        let isRootSep = false;\n        if (resource.scheme === Schemas.file) {\n            const fsp = originalFSPath(resource);\n            isRootSep = ((fsp !== undefined) && (fsp.length === extpath.getRoot(fsp).length) && (fsp[fsp.length - 1] === sep));\n        }\n        else {\n            sep = '/';\n            const p = resource.path;\n            isRootSep = p.length === 1 && p.charCodeAt(p.length - 1) === 47 /* CharCode.Slash */;\n        }\n        if (!isRootSep && !hasTrailingPathSeparator(resource, sep)) {\n            return resource.with({ path: resource.path + '/' });\n        }\n        return resource;\n    }\n}\n/**\n * Unbiased utility that takes uris \"as they are\". This means it can be interchanged with\n * uri#toString() usages. The following is true\n * ```\n * assertEqual(aUri.toString() === bUri.toString(), exturi.isEqual(aUri, bUri))\n * ```\n */\nexport const extUri = new ExtUri(() => false);\n/**\n * BIASED utility that _mostly_ ignored the case of urs paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriBiasedIgnorePathCase = new ExtUri(uri => {\n    // A file scheme resource is in the same platform as code, so ignore case for non linux platforms\n    // Resource can be from another platform. Lowering the case as an hack. Should come from File system provider\n    return uri.scheme === Schemas.file ? !isLinux : true;\n});\n/**\n * BIASED utility that always ignores the casing of uris paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriIgnorePathCase = new ExtUri(_ => true);\nexport const isEqual = extUri.isEqual.bind(extUri);\nexport const isEqualOrParent = extUri.isEqualOrParent.bind(extUri);\nexport const getComparisonKey = extUri.getComparisonKey.bind(extUri);\nexport const basenameOrAuthority = extUri.basenameOrAuthority.bind(extUri);\nexport const basename = extUri.basename.bind(extUri);\nexport const extname = extUri.extname.bind(extUri);\nexport const dirname = extUri.dirname.bind(extUri);\nexport const joinPath = extUri.joinPath.bind(extUri);\nexport const normalizePath = extUri.normalizePath.bind(extUri);\nexport const relativePath = extUri.relativePath.bind(extUri);\nexport const resolvePath = extUri.resolvePath.bind(extUri);\nexport const isAbsolutePath = extUri.isAbsolutePath.bind(extUri);\nexport const isEqualAuthority = extUri.isEqualAuthority.bind(extUri);\nexport const hasTrailingPathSeparator = extUri.hasTrailingPathSeparator.bind(extUri);\nexport const removeTrailingPathSeparator = extUri.removeTrailingPathSeparator.bind(extUri);\nexport const addTrailingPathSeparator = extUri.addTrailingPathSeparator.bind(extUri);\n/**\n * Data URI related helpers.\n */\nexport var DataUri;\n(function (DataUri) {\n    DataUri.META_DATA_LABEL = 'label';\n    DataUri.META_DATA_DESCRIPTION = 'description';\n    DataUri.META_DATA_SIZE = 'size';\n    DataUri.META_DATA_MIME = 'mime';\n    function parseMetaData(dataUri) {\n        const metadata = new Map();\n        // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n        // the metadata is: size:2313;label:SomeLabel;description:SomeDescription\n        const meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\n        meta.split(';').forEach(property => {\n            const [key, value] = property.split(':');\n            if (key && value) {\n                metadata.set(key, value);\n            }\n        });\n        // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n        // the mime is: image/png\n        const mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\n        if (mime) {\n            metadata.set(DataUri.META_DATA_MIME, mime);\n        }\n        return metadata;\n    }\n    DataUri.parseMetaData = parseMetaData;\n})(DataUri || (DataUri = {}));\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}