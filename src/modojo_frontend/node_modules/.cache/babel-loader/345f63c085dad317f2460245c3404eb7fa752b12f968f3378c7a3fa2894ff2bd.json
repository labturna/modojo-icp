{"ast":null,"code":"/**\n * Returns the last element of an array.\n * @param array The array.\n * @param n Which element from the end (default is zero).\n */\nexport function tail(array) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  return array[array.length - (1 + n)];\n}\nexport function tail2(arr) {\n  if (arr.length === 0) {\n    throw new Error('Invalid tail call');\n  }\n  return [arr.slice(0, arr.length - 1), arr[arr.length - 1]];\n}\nexport function equals(one, other) {\n  let itemEquals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : (a, b) => a === b;\n  if (one === other) {\n    return true;\n  }\n  if (!one || !other) {\n    return false;\n  }\n  if (one.length !== other.length) {\n    return false;\n  }\n  for (let i = 0, len = one.length; i < len; i++) {\n    if (!itemEquals(one[i], other[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n/**\n * Remove the element at `index` by replacing it with the last element. This is faster than `splice`\n * but changes the order of the array\n */\nexport function removeFastWithoutKeepingOrder(array, index) {\n  const last = array.length - 1;\n  if (index < last) {\n    array[index] = array[last];\n  }\n  array.pop();\n}\n/**\n * Performs a binary search algorithm over a sorted array.\n *\n * @param array The array being searched.\n * @param key The value we search for.\n * @param comparator A function that takes two array elements and returns zero\n *   if they are equal, a negative number if the first element precedes the\n *   second one in the sorting order, or a positive number if the second element\n *   precedes the first one.\n * @return See {@link binarySearch2}\n */\nexport function binarySearch(array, key, comparator) {\n  return binarySearch2(array.length, i => comparator(array[i], key));\n}\n/**\n * Performs a binary search algorithm over a sorted collection. Useful for cases\n * when we need to perform a binary search over something that isn't actually an\n * array, and converting data to an array would defeat the use of binary search\n * in the first place.\n *\n * @param length The collection length.\n * @param compareToKey A function that takes an index of an element in the\n *   collection and returns zero if the value at this index is equal to the\n *   search key, a negative number if the value precedes the search key in the\n *   sorting order, or a positive number if the search key precedes the value.\n * @return A non-negative index of an element, if found. If not found, the\n *   result is -(n+1) (or ~n, using bitwise notation), where n is the index\n *   where the key should be inserted to maintain the sorting order.\n */\nexport function binarySearch2(length, compareToKey) {\n  let low = 0,\n    high = length - 1;\n  while (low <= high) {\n    const mid = (low + high) / 2 | 0;\n    const comp = compareToKey(mid);\n    if (comp < 0) {\n      low = mid + 1;\n    } else if (comp > 0) {\n      high = mid - 1;\n    } else {\n      return mid;\n    }\n  }\n  return -(low + 1);\n}\nexport function quickSelect(nth, data, compare) {\n  nth = nth | 0;\n  if (nth >= data.length) {\n    throw new TypeError('invalid index');\n  }\n  const pivotValue = data[Math.floor(data.length * Math.random())];\n  const lower = [];\n  const higher = [];\n  const pivots = [];\n  for (const value of data) {\n    const val = compare(value, pivotValue);\n    if (val < 0) {\n      lower.push(value);\n    } else if (val > 0) {\n      higher.push(value);\n    } else {\n      pivots.push(value);\n    }\n  }\n  if (nth < lower.length) {\n    return quickSelect(nth, lower, compare);\n  } else if (nth < lower.length + pivots.length) {\n    return pivots[0];\n  } else {\n    return quickSelect(nth - (lower.length + pivots.length), higher, compare);\n  }\n}\nexport function groupBy(data, compare) {\n  const result = [];\n  let currentGroup = undefined;\n  for (const element of data.slice(0).sort(compare)) {\n    if (!currentGroup || compare(currentGroup[0], element) !== 0) {\n      currentGroup = [element];\n      result.push(currentGroup);\n    } else {\n      currentGroup.push(element);\n    }\n  }\n  return result;\n}\n/**\n * Splits the given items into a list of (non-empty) groups.\n * `shouldBeGrouped` is used to decide if two consecutive items should be in the same group.\n * The order of the items is preserved.\n */\nexport function* groupAdjacentBy(items, shouldBeGrouped) {\n  let currentGroup;\n  let last;\n  for (const item of items) {\n    if (last !== undefined && shouldBeGrouped(last, item)) {\n      currentGroup.push(item);\n    } else {\n      if (currentGroup) {\n        yield currentGroup;\n      }\n      currentGroup = [item];\n    }\n    last = item;\n  }\n  if (currentGroup) {\n    yield currentGroup;\n  }\n}\nexport function forEachAdjacent(arr, f) {\n  for (let i = 0; i <= arr.length; i++) {\n    f(i === 0 ? undefined : arr[i - 1], i === arr.length ? undefined : arr[i]);\n  }\n}\nexport function forEachWithNeighbors(arr, f) {\n  for (let i = 0; i < arr.length; i++) {\n    f(i === 0 ? undefined : arr[i - 1], arr[i], i + 1 === arr.length ? undefined : arr[i + 1]);\n  }\n}\n/**\n * @returns New array with all falsy values removed. The original array IS NOT modified.\n */\nexport function coalesce(array) {\n  return array.filter(e => !!e);\n}\n/**\n * Remove all falsy values from `array`. The original array IS modified.\n */\nexport function coalesceInPlace(array) {\n  let to = 0;\n  for (let i = 0; i < array.length; i++) {\n    if (!!array[i]) {\n      array[to] = array[i];\n      to += 1;\n    }\n  }\n  array.length = to;\n}\n/**\n * @returns false if the provided object is an array and not empty.\n */\nexport function isFalsyOrEmpty(obj) {\n  return !Array.isArray(obj) || obj.length === 0;\n}\nexport function isNonEmptyArray(obj) {\n  return Array.isArray(obj) && obj.length > 0;\n}\n/**\n * Removes duplicates from the given array. The optional keyFn allows to specify\n * how elements are checked for equality by returning an alternate value for each.\n */\nexport function distinct(array) {\n  let keyFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : value => value;\n  const seen = new Set();\n  return array.filter(element => {\n    const key = keyFn(element);\n    if (seen.has(key)) {\n      return false;\n    }\n    seen.add(key);\n    return true;\n  });\n}\nexport function firstOrDefault(array, notFoundValue) {\n  return array.length > 0 ? array[0] : notFoundValue;\n}\nexport function range(arg, to) {\n  let from = typeof to === 'number' ? arg : 0;\n  if (typeof to === 'number') {\n    from = arg;\n  } else {\n    from = 0;\n    to = arg;\n  }\n  const result = [];\n  if (from <= to) {\n    for (let i = from; i < to; i++) {\n      result.push(i);\n    }\n  } else {\n    for (let i = from; i > to; i--) {\n      result.push(i);\n    }\n  }\n  return result;\n}\n/**\n * Insert `insertArr` inside `target` at `insertIndex`.\n * Please don't touch unless you understand https://jsperf.com/inserting-an-array-within-an-array\n */\nexport function arrayInsert(target, insertIndex, insertArr) {\n  const before = target.slice(0, insertIndex);\n  const after = target.slice(insertIndex);\n  return before.concat(insertArr, after);\n}\n/**\n * Pushes an element to the start of the array, if found.\n */\nexport function pushToStart(arr, value) {\n  const index = arr.indexOf(value);\n  if (index > -1) {\n    arr.splice(index, 1);\n    arr.unshift(value);\n  }\n}\n/**\n * Pushes an element to the end of the array, if found.\n */\nexport function pushToEnd(arr, value) {\n  const index = arr.indexOf(value);\n  if (index > -1) {\n    arr.splice(index, 1);\n    arr.push(value);\n  }\n}\nexport function pushMany(arr, items) {\n  for (const item of items) {\n    arr.push(item);\n  }\n}\nexport function asArray(x) {\n  return Array.isArray(x) ? x : [x];\n}\n/**\n * Insert the new items in the array.\n * @param array The original array.\n * @param start The zero-based location in the array from which to start inserting elements.\n * @param newItems The items to be inserted\n */\nexport function insertInto(array, start, newItems) {\n  const startIdx = getActualStartIndex(array, start);\n  const originalLength = array.length;\n  const newItemsLength = newItems.length;\n  array.length = originalLength + newItemsLength;\n  // Move the items after the start index, start from the end so that we don't overwrite any value.\n  for (let i = originalLength - 1; i >= startIdx; i--) {\n    array[i + newItemsLength] = array[i];\n  }\n  for (let i = 0; i < newItemsLength; i++) {\n    array[i + startIdx] = newItems[i];\n  }\n}\n/**\n * Removes elements from an array and inserts new elements in their place, returning the deleted elements. Alternative to the native Array.splice method, it\n * can only support limited number of items due to the maximum call stack size limit.\n * @param array The original array.\n * @param start The zero-based location in the array from which to start removing elements.\n * @param deleteCount The number of elements to remove.\n * @returns An array containing the elements that were deleted.\n */\nexport function splice(array, start, deleteCount, newItems) {\n  const index = getActualStartIndex(array, start);\n  let result = array.splice(index, deleteCount);\n  if (result === undefined) {\n    // see https://bugs.webkit.org/show_bug.cgi?id=261140\n    result = [];\n  }\n  insertInto(array, index, newItems);\n  return result;\n}\n/**\n * Determine the actual start index (same logic as the native splice() or slice())\n * If greater than the length of the array, start will be set to the length of the array. In this case, no element will be deleted but the method will behave as an adding function, adding as many element as item[n*] provided.\n * If negative, it will begin that many elements from the end of the array. (In this case, the origin -1, meaning -n is the index of the nth last element, and is therefore equivalent to the index of array.length - n.) If array.length + start is less than 0, it will begin from index 0.\n * @param array The target array.\n * @param start The operation index.\n */\nfunction getActualStartIndex(array, start) {\n  return start < 0 ? Math.max(start + array.length, 0) : Math.min(start, array.length);\n}\nexport var CompareResult;\n(function (CompareResult) {\n  function isLessThan(result) {\n    return result < 0;\n  }\n  CompareResult.isLessThan = isLessThan;\n  function isLessThanOrEqual(result) {\n    return result <= 0;\n  }\n  CompareResult.isLessThanOrEqual = isLessThanOrEqual;\n  function isGreaterThan(result) {\n    return result > 0;\n  }\n  CompareResult.isGreaterThan = isGreaterThan;\n  function isNeitherLessOrGreaterThan(result) {\n    return result === 0;\n  }\n  CompareResult.isNeitherLessOrGreaterThan = isNeitherLessOrGreaterThan;\n  CompareResult.greaterThan = 1;\n  CompareResult.lessThan = -1;\n  CompareResult.neitherLessOrGreaterThan = 0;\n})(CompareResult || (CompareResult = {}));\nexport function compareBy(selector, comparator) {\n  return (a, b) => comparator(selector(a), selector(b));\n}\nexport function tieBreakComparators() {\n  for (var _len = arguments.length, comparators = new Array(_len), _key = 0; _key < _len; _key++) {\n    comparators[_key] = arguments[_key];\n  }\n  return (item1, item2) => {\n    for (const comparator of comparators) {\n      const result = comparator(item1, item2);\n      if (!CompareResult.isNeitherLessOrGreaterThan(result)) {\n        return result;\n      }\n    }\n    return CompareResult.neitherLessOrGreaterThan;\n  };\n}\n/**\n * The natural order on numbers.\n*/\nexport const numberComparator = (a, b) => a - b;\nexport const booleanComparator = (a, b) => numberComparator(a ? 1 : 0, b ? 1 : 0);\nexport function reverseOrder(comparator) {\n  return (a, b) => -comparator(a, b);\n}\nexport class ArrayQueue {\n  /**\n   * Constructs a queue that is backed by the given array. Runtime is O(1).\n  */\n  constructor(items) {\n    this.items = items;\n    this.firstIdx = 0;\n    this.lastIdx = this.items.length - 1;\n  }\n  get length() {\n    return this.lastIdx - this.firstIdx + 1;\n  }\n  /**\n   * Consumes elements from the beginning of the queue as long as the predicate returns true.\n   * If no elements were consumed, `null` is returned. Has a runtime of O(result.length).\n  */\n  takeWhile(predicate) {\n    // P(k) := k <= this.lastIdx && predicate(this.items[k])\n    // Find s := min { k | k >= this.firstIdx && !P(k) } and return this.data[this.firstIdx...s)\n    let startIdx = this.firstIdx;\n    while (startIdx < this.items.length && predicate(this.items[startIdx])) {\n      startIdx++;\n    }\n    const result = startIdx === this.firstIdx ? null : this.items.slice(this.firstIdx, startIdx);\n    this.firstIdx = startIdx;\n    return result;\n  }\n  /**\n   * Consumes elements from the end of the queue as long as the predicate returns true.\n   * If no elements were consumed, `null` is returned.\n   * The result has the same order as the underlying array!\n  */\n  takeFromEndWhile(predicate) {\n    // P(k) := this.firstIdx >= k && predicate(this.items[k])\n    // Find s := max { k | k <= this.lastIdx && !P(k) } and return this.data(s...this.lastIdx]\n    let endIdx = this.lastIdx;\n    while (endIdx >= 0 && predicate(this.items[endIdx])) {\n      endIdx--;\n    }\n    const result = endIdx === this.lastIdx ? null : this.items.slice(endIdx + 1, this.lastIdx + 1);\n    this.lastIdx = endIdx;\n    return result;\n  }\n  peek() {\n    if (this.length === 0) {\n      return undefined;\n    }\n    return this.items[this.firstIdx];\n  }\n  dequeue() {\n    const result = this.items[this.firstIdx];\n    this.firstIdx++;\n    return result;\n  }\n  takeCount(count) {\n    const result = this.items.slice(this.firstIdx, this.firstIdx + count);\n    this.firstIdx += count;\n    return result;\n  }\n}\n/**\n * This class is faster than an iterator and array for lazy computed data.\n*/\nexport class CallbackIterable {\n  constructor(\n  /**\n   * Calls the callback for every item.\n   * Stops when the callback returns false.\n  */\n  iterate) {\n    this.iterate = iterate;\n  }\n  toArray() {\n    const result = [];\n    this.iterate(item => {\n      result.push(item);\n      return true;\n    });\n    return result;\n  }\n  filter(predicate) {\n    return new CallbackIterable(cb => this.iterate(item => predicate(item) ? cb(item) : true));\n  }\n  map(mapFn) {\n    return new CallbackIterable(cb => this.iterate(item => cb(mapFn(item))));\n  }\n  findLast(predicate) {\n    let result;\n    this.iterate(item => {\n      if (predicate(item)) {\n        result = item;\n      }\n      return true;\n    });\n    return result;\n  }\n  findLastMaxBy(comparator) {\n    let result;\n    let first = true;\n    this.iterate(item => {\n      if (first || CompareResult.isGreaterThan(comparator(item, result))) {\n        first = false;\n        result = item;\n      }\n      return true;\n    });\n    return result;\n  }\n}\nCallbackIterable.empty = new CallbackIterable(_callback => {});\n/**\n * Represents a re-arrangement of items in an array.\n */\nexport class Permutation {\n  constructor(_indexMap) {\n    this._indexMap = _indexMap;\n  }\n  /**\n   * Returns a permutation that sorts the given array according to the given compare function.\n   */\n  static createSortPermutation(arr, compareFn) {\n    const sortIndices = Array.from(arr.keys()).sort((index1, index2) => compareFn(arr[index1], arr[index2]));\n    return new Permutation(sortIndices);\n  }\n  /**\n   * Returns a new array with the elements of the given array re-arranged according to this permutation.\n   */\n  apply(arr) {\n    return arr.map((_, index) => arr[this._indexMap[index]]);\n  }\n  /**\n   * Returns a new permutation that undoes the re-arrangement of this permutation.\n  */\n  inverse() {\n    const inverseIndexMap = this._indexMap.slice();\n    for (let i = 0; i < this._indexMap.length; i++) {\n      inverseIndexMap[this._indexMap[i]] = i;\n    }\n    return new Permutation(inverseIndexMap);\n  }\n}","map":{"version":3,"names":["tail","array","n","arguments","length","undefined","tail2","arr","Error","slice","equals","one","other","itemEquals","a","b","i","len","removeFastWithoutKeepingOrder","index","last","pop","binarySearch","key","comparator","binarySearch2","compareToKey","low","high","mid","comp","quickSelect","nth","data","compare","TypeError","pivotValue","Math","floor","random","lower","higher","pivots","value","val","push","groupBy","result","currentGroup","element","sort","groupAdjacentBy","items","shouldBeGrouped","item","forEachAdjacent","f","forEachWithNeighbors","coalesce","filter","e","coalesceInPlace","to","isFalsyOrEmpty","obj","Array","isArray","isNonEmptyArray","distinct","keyFn","seen","Set","has","add","firstOrDefault","notFoundValue","range","arg","from","arrayInsert","target","insertIndex","insertArr","before","after","concat","pushToStart","indexOf","splice","unshift","pushToEnd","pushMany","asArray","x","insertInto","start","newItems","startIdx","getActualStartIndex","originalLength","newItemsLength","deleteCount","max","min","CompareResult","isLessThan","isLessThanOrEqual","isGreaterThan","isNeitherLessOrGreaterThan","greaterThan","lessThan","neitherLessOrGreaterThan","compareBy","selector","tieBreakComparators","_len","comparators","_key","item1","item2","numberComparator","booleanComparator","reverseOrder","ArrayQueue","constructor","firstIdx","lastIdx","takeWhile","predicate","takeFromEndWhile","endIdx","peek","dequeue","takeCount","count","CallbackIterable","iterate","toArray","cb","map","mapFn","findLast","findLastMaxBy","first","empty","_callback","Permutation","_indexMap","createSortPermutation","compareFn","sortIndices","keys","index1","index2","apply","_","inverse","inverseIndexMap"],"sources":["/home/arslan/modojo/node_modules/monaco-editor/esm/vs/base/common/arrays.js"],"sourcesContent":["/**\n * Returns the last element of an array.\n * @param array The array.\n * @param n Which element from the end (default is zero).\n */\nexport function tail(array, n = 0) {\n    return array[array.length - (1 + n)];\n}\nexport function tail2(arr) {\n    if (arr.length === 0) {\n        throw new Error('Invalid tail call');\n    }\n    return [arr.slice(0, arr.length - 1), arr[arr.length - 1]];\n}\nexport function equals(one, other, itemEquals = (a, b) => a === b) {\n    if (one === other) {\n        return true;\n    }\n    if (!one || !other) {\n        return false;\n    }\n    if (one.length !== other.length) {\n        return false;\n    }\n    for (let i = 0, len = one.length; i < len; i++) {\n        if (!itemEquals(one[i], other[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Remove the element at `index` by replacing it with the last element. This is faster than `splice`\n * but changes the order of the array\n */\nexport function removeFastWithoutKeepingOrder(array, index) {\n    const last = array.length - 1;\n    if (index < last) {\n        array[index] = array[last];\n    }\n    array.pop();\n}\n/**\n * Performs a binary search algorithm over a sorted array.\n *\n * @param array The array being searched.\n * @param key The value we search for.\n * @param comparator A function that takes two array elements and returns zero\n *   if they are equal, a negative number if the first element precedes the\n *   second one in the sorting order, or a positive number if the second element\n *   precedes the first one.\n * @return See {@link binarySearch2}\n */\nexport function binarySearch(array, key, comparator) {\n    return binarySearch2(array.length, i => comparator(array[i], key));\n}\n/**\n * Performs a binary search algorithm over a sorted collection. Useful for cases\n * when we need to perform a binary search over something that isn't actually an\n * array, and converting data to an array would defeat the use of binary search\n * in the first place.\n *\n * @param length The collection length.\n * @param compareToKey A function that takes an index of an element in the\n *   collection and returns zero if the value at this index is equal to the\n *   search key, a negative number if the value precedes the search key in the\n *   sorting order, or a positive number if the search key precedes the value.\n * @return A non-negative index of an element, if found. If not found, the\n *   result is -(n+1) (or ~n, using bitwise notation), where n is the index\n *   where the key should be inserted to maintain the sorting order.\n */\nexport function binarySearch2(length, compareToKey) {\n    let low = 0, high = length - 1;\n    while (low <= high) {\n        const mid = ((low + high) / 2) | 0;\n        const comp = compareToKey(mid);\n        if (comp < 0) {\n            low = mid + 1;\n        }\n        else if (comp > 0) {\n            high = mid - 1;\n        }\n        else {\n            return mid;\n        }\n    }\n    return -(low + 1);\n}\nexport function quickSelect(nth, data, compare) {\n    nth = nth | 0;\n    if (nth >= data.length) {\n        throw new TypeError('invalid index');\n    }\n    const pivotValue = data[Math.floor(data.length * Math.random())];\n    const lower = [];\n    const higher = [];\n    const pivots = [];\n    for (const value of data) {\n        const val = compare(value, pivotValue);\n        if (val < 0) {\n            lower.push(value);\n        }\n        else if (val > 0) {\n            higher.push(value);\n        }\n        else {\n            pivots.push(value);\n        }\n    }\n    if (nth < lower.length) {\n        return quickSelect(nth, lower, compare);\n    }\n    else if (nth < lower.length + pivots.length) {\n        return pivots[0];\n    }\n    else {\n        return quickSelect(nth - (lower.length + pivots.length), higher, compare);\n    }\n}\nexport function groupBy(data, compare) {\n    const result = [];\n    let currentGroup = undefined;\n    for (const element of data.slice(0).sort(compare)) {\n        if (!currentGroup || compare(currentGroup[0], element) !== 0) {\n            currentGroup = [element];\n            result.push(currentGroup);\n        }\n        else {\n            currentGroup.push(element);\n        }\n    }\n    return result;\n}\n/**\n * Splits the given items into a list of (non-empty) groups.\n * `shouldBeGrouped` is used to decide if two consecutive items should be in the same group.\n * The order of the items is preserved.\n */\nexport function* groupAdjacentBy(items, shouldBeGrouped) {\n    let currentGroup;\n    let last;\n    for (const item of items) {\n        if (last !== undefined && shouldBeGrouped(last, item)) {\n            currentGroup.push(item);\n        }\n        else {\n            if (currentGroup) {\n                yield currentGroup;\n            }\n            currentGroup = [item];\n        }\n        last = item;\n    }\n    if (currentGroup) {\n        yield currentGroup;\n    }\n}\nexport function forEachAdjacent(arr, f) {\n    for (let i = 0; i <= arr.length; i++) {\n        f(i === 0 ? undefined : arr[i - 1], i === arr.length ? undefined : arr[i]);\n    }\n}\nexport function forEachWithNeighbors(arr, f) {\n    for (let i = 0; i < arr.length; i++) {\n        f(i === 0 ? undefined : arr[i - 1], arr[i], i + 1 === arr.length ? undefined : arr[i + 1]);\n    }\n}\n/**\n * @returns New array with all falsy values removed. The original array IS NOT modified.\n */\nexport function coalesce(array) {\n    return array.filter((e) => !!e);\n}\n/**\n * Remove all falsy values from `array`. The original array IS modified.\n */\nexport function coalesceInPlace(array) {\n    let to = 0;\n    for (let i = 0; i < array.length; i++) {\n        if (!!array[i]) {\n            array[to] = array[i];\n            to += 1;\n        }\n    }\n    array.length = to;\n}\n/**\n * @returns false if the provided object is an array and not empty.\n */\nexport function isFalsyOrEmpty(obj) {\n    return !Array.isArray(obj) || obj.length === 0;\n}\nexport function isNonEmptyArray(obj) {\n    return Array.isArray(obj) && obj.length > 0;\n}\n/**\n * Removes duplicates from the given array. The optional keyFn allows to specify\n * how elements are checked for equality by returning an alternate value for each.\n */\nexport function distinct(array, keyFn = value => value) {\n    const seen = new Set();\n    return array.filter(element => {\n        const key = keyFn(element);\n        if (seen.has(key)) {\n            return false;\n        }\n        seen.add(key);\n        return true;\n    });\n}\nexport function firstOrDefault(array, notFoundValue) {\n    return array.length > 0 ? array[0] : notFoundValue;\n}\nexport function range(arg, to) {\n    let from = typeof to === 'number' ? arg : 0;\n    if (typeof to === 'number') {\n        from = arg;\n    }\n    else {\n        from = 0;\n        to = arg;\n    }\n    const result = [];\n    if (from <= to) {\n        for (let i = from; i < to; i++) {\n            result.push(i);\n        }\n    }\n    else {\n        for (let i = from; i > to; i--) {\n            result.push(i);\n        }\n    }\n    return result;\n}\n/**\n * Insert `insertArr` inside `target` at `insertIndex`.\n * Please don't touch unless you understand https://jsperf.com/inserting-an-array-within-an-array\n */\nexport function arrayInsert(target, insertIndex, insertArr) {\n    const before = target.slice(0, insertIndex);\n    const after = target.slice(insertIndex);\n    return before.concat(insertArr, after);\n}\n/**\n * Pushes an element to the start of the array, if found.\n */\nexport function pushToStart(arr, value) {\n    const index = arr.indexOf(value);\n    if (index > -1) {\n        arr.splice(index, 1);\n        arr.unshift(value);\n    }\n}\n/**\n * Pushes an element to the end of the array, if found.\n */\nexport function pushToEnd(arr, value) {\n    const index = arr.indexOf(value);\n    if (index > -1) {\n        arr.splice(index, 1);\n        arr.push(value);\n    }\n}\nexport function pushMany(arr, items) {\n    for (const item of items) {\n        arr.push(item);\n    }\n}\nexport function asArray(x) {\n    return Array.isArray(x) ? x : [x];\n}\n/**\n * Insert the new items in the array.\n * @param array The original array.\n * @param start The zero-based location in the array from which to start inserting elements.\n * @param newItems The items to be inserted\n */\nexport function insertInto(array, start, newItems) {\n    const startIdx = getActualStartIndex(array, start);\n    const originalLength = array.length;\n    const newItemsLength = newItems.length;\n    array.length = originalLength + newItemsLength;\n    // Move the items after the start index, start from the end so that we don't overwrite any value.\n    for (let i = originalLength - 1; i >= startIdx; i--) {\n        array[i + newItemsLength] = array[i];\n    }\n    for (let i = 0; i < newItemsLength; i++) {\n        array[i + startIdx] = newItems[i];\n    }\n}\n/**\n * Removes elements from an array and inserts new elements in their place, returning the deleted elements. Alternative to the native Array.splice method, it\n * can only support limited number of items due to the maximum call stack size limit.\n * @param array The original array.\n * @param start The zero-based location in the array from which to start removing elements.\n * @param deleteCount The number of elements to remove.\n * @returns An array containing the elements that were deleted.\n */\nexport function splice(array, start, deleteCount, newItems) {\n    const index = getActualStartIndex(array, start);\n    let result = array.splice(index, deleteCount);\n    if (result === undefined) {\n        // see https://bugs.webkit.org/show_bug.cgi?id=261140\n        result = [];\n    }\n    insertInto(array, index, newItems);\n    return result;\n}\n/**\n * Determine the actual start index (same logic as the native splice() or slice())\n * If greater than the length of the array, start will be set to the length of the array. In this case, no element will be deleted but the method will behave as an adding function, adding as many element as item[n*] provided.\n * If negative, it will begin that many elements from the end of the array. (In this case, the origin -1, meaning -n is the index of the nth last element, and is therefore equivalent to the index of array.length - n.) If array.length + start is less than 0, it will begin from index 0.\n * @param array The target array.\n * @param start The operation index.\n */\nfunction getActualStartIndex(array, start) {\n    return start < 0 ? Math.max(start + array.length, 0) : Math.min(start, array.length);\n}\nexport var CompareResult;\n(function (CompareResult) {\n    function isLessThan(result) {\n        return result < 0;\n    }\n    CompareResult.isLessThan = isLessThan;\n    function isLessThanOrEqual(result) {\n        return result <= 0;\n    }\n    CompareResult.isLessThanOrEqual = isLessThanOrEqual;\n    function isGreaterThan(result) {\n        return result > 0;\n    }\n    CompareResult.isGreaterThan = isGreaterThan;\n    function isNeitherLessOrGreaterThan(result) {\n        return result === 0;\n    }\n    CompareResult.isNeitherLessOrGreaterThan = isNeitherLessOrGreaterThan;\n    CompareResult.greaterThan = 1;\n    CompareResult.lessThan = -1;\n    CompareResult.neitherLessOrGreaterThan = 0;\n})(CompareResult || (CompareResult = {}));\nexport function compareBy(selector, comparator) {\n    return (a, b) => comparator(selector(a), selector(b));\n}\nexport function tieBreakComparators(...comparators) {\n    return (item1, item2) => {\n        for (const comparator of comparators) {\n            const result = comparator(item1, item2);\n            if (!CompareResult.isNeitherLessOrGreaterThan(result)) {\n                return result;\n            }\n        }\n        return CompareResult.neitherLessOrGreaterThan;\n    };\n}\n/**\n * The natural order on numbers.\n*/\nexport const numberComparator = (a, b) => a - b;\nexport const booleanComparator = (a, b) => numberComparator(a ? 1 : 0, b ? 1 : 0);\nexport function reverseOrder(comparator) {\n    return (a, b) => -comparator(a, b);\n}\nexport class ArrayQueue {\n    /**\n     * Constructs a queue that is backed by the given array. Runtime is O(1).\n    */\n    constructor(items) {\n        this.items = items;\n        this.firstIdx = 0;\n        this.lastIdx = this.items.length - 1;\n    }\n    get length() {\n        return this.lastIdx - this.firstIdx + 1;\n    }\n    /**\n     * Consumes elements from the beginning of the queue as long as the predicate returns true.\n     * If no elements were consumed, `null` is returned. Has a runtime of O(result.length).\n    */\n    takeWhile(predicate) {\n        // P(k) := k <= this.lastIdx && predicate(this.items[k])\n        // Find s := min { k | k >= this.firstIdx && !P(k) } and return this.data[this.firstIdx...s)\n        let startIdx = this.firstIdx;\n        while (startIdx < this.items.length && predicate(this.items[startIdx])) {\n            startIdx++;\n        }\n        const result = startIdx === this.firstIdx ? null : this.items.slice(this.firstIdx, startIdx);\n        this.firstIdx = startIdx;\n        return result;\n    }\n    /**\n     * Consumes elements from the end of the queue as long as the predicate returns true.\n     * If no elements were consumed, `null` is returned.\n     * The result has the same order as the underlying array!\n    */\n    takeFromEndWhile(predicate) {\n        // P(k) := this.firstIdx >= k && predicate(this.items[k])\n        // Find s := max { k | k <= this.lastIdx && !P(k) } and return this.data(s...this.lastIdx]\n        let endIdx = this.lastIdx;\n        while (endIdx >= 0 && predicate(this.items[endIdx])) {\n            endIdx--;\n        }\n        const result = endIdx === this.lastIdx ? null : this.items.slice(endIdx + 1, this.lastIdx + 1);\n        this.lastIdx = endIdx;\n        return result;\n    }\n    peek() {\n        if (this.length === 0) {\n            return undefined;\n        }\n        return this.items[this.firstIdx];\n    }\n    dequeue() {\n        const result = this.items[this.firstIdx];\n        this.firstIdx++;\n        return result;\n    }\n    takeCount(count) {\n        const result = this.items.slice(this.firstIdx, this.firstIdx + count);\n        this.firstIdx += count;\n        return result;\n    }\n}\n/**\n * This class is faster than an iterator and array for lazy computed data.\n*/\nexport class CallbackIterable {\n    constructor(\n    /**\n     * Calls the callback for every item.\n     * Stops when the callback returns false.\n    */\n    iterate) {\n        this.iterate = iterate;\n    }\n    toArray() {\n        const result = [];\n        this.iterate(item => { result.push(item); return true; });\n        return result;\n    }\n    filter(predicate) {\n        return new CallbackIterable(cb => this.iterate(item => predicate(item) ? cb(item) : true));\n    }\n    map(mapFn) {\n        return new CallbackIterable(cb => this.iterate(item => cb(mapFn(item))));\n    }\n    findLast(predicate) {\n        let result;\n        this.iterate(item => {\n            if (predicate(item)) {\n                result = item;\n            }\n            return true;\n        });\n        return result;\n    }\n    findLastMaxBy(comparator) {\n        let result;\n        let first = true;\n        this.iterate(item => {\n            if (first || CompareResult.isGreaterThan(comparator(item, result))) {\n                first = false;\n                result = item;\n            }\n            return true;\n        });\n        return result;\n    }\n}\nCallbackIterable.empty = new CallbackIterable(_callback => { });\n/**\n * Represents a re-arrangement of items in an array.\n */\nexport class Permutation {\n    constructor(_indexMap) {\n        this._indexMap = _indexMap;\n    }\n    /**\n     * Returns a permutation that sorts the given array according to the given compare function.\n     */\n    static createSortPermutation(arr, compareFn) {\n        const sortIndices = Array.from(arr.keys()).sort((index1, index2) => compareFn(arr[index1], arr[index2]));\n        return new Permutation(sortIndices);\n    }\n    /**\n     * Returns a new array with the elements of the given array re-arranged according to this permutation.\n     */\n    apply(arr) {\n        return arr.map((_, index) => arr[this._indexMap[index]]);\n    }\n    /**\n     * Returns a new permutation that undoes the re-arrangement of this permutation.\n    */\n    inverse() {\n        const inverseIndexMap = this._indexMap.slice();\n        for (let i = 0; i < this._indexMap.length; i++) {\n            inverseIndexMap[this._indexMap[i]] = i;\n        }\n        return new Permutation(inverseIndexMap);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}