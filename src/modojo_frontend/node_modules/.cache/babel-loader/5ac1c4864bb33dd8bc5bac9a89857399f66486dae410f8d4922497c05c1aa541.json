{"ast":null,"code":"import { toHex } from '../utils/buffer';\nconst FIVE_MINUTES_IN_MSEC = 5 * 60 * 1000;\n/**\n * A best practices polling strategy: wait 2 seconds before the first poll, then 1 second\n * with an exponential backoff factor of 1.2. Timeout after 5 minutes.\n */\nexport function defaultStrategy() {\n  return chain(conditionalDelay(once(), 1000), backoff(1000, 1.2), timeout(FIVE_MINUTES_IN_MSEC));\n}\n/**\n * Predicate that returns true once.\n */\nexport function once() {\n  let first = true;\n  return async () => {\n    if (first) {\n      first = false;\n      return true;\n    }\n    return false;\n  };\n}\n/**\n * Delay the polling once.\n * @param condition A predicate that indicates when to delay.\n * @param timeInMsec The amount of time to delay.\n */\nexport function conditionalDelay(condition, timeInMsec) {\n  return async (canisterId, requestId, status) => {\n    if (await condition(canisterId, requestId, status)) {\n      return new Promise(resolve => setTimeout(resolve, timeInMsec));\n    }\n  };\n}\n/**\n * Error out after a maximum number of polling has been done.\n * @param count The maximum attempts to poll.\n */\nexport function maxAttempts(count) {\n  let attempts = count;\n  return async (canisterId, requestId, status) => {\n    if (--attempts <= 0) {\n      throw new Error(`Failed to retrieve a reply for request after ${count} attempts:\\n` + `  Request ID: ${toHex(requestId)}\\n` + `  Request status: ${status}\\n`);\n    }\n  };\n}\n/**\n * Throttle polling.\n * @param throttleInMsec Amount in millisecond to wait between each polling.\n */\nexport function throttle(throttleInMsec) {\n  return () => new Promise(resolve => setTimeout(resolve, throttleInMsec));\n}\n/**\n * Reject a call after a certain amount of time.\n * @param timeInMsec Time in milliseconds before the polling should be rejected.\n */\nexport function timeout(timeInMsec) {\n  const end = Date.now() + timeInMsec;\n  return async (canisterId, requestId, status) => {\n    if (Date.now() > end) {\n      throw new Error(`Request timed out after ${timeInMsec} msec:\\n` + `  Request ID: ${toHex(requestId)}\\n` + `  Request status: ${status}\\n`);\n    }\n  };\n}\n/**\n * A strategy that throttle, but using an exponential backoff strategy.\n * @param startingThrottleInMsec The throttle in milliseconds to start with.\n * @param backoffFactor The factor to multiple the throttle time between every poll. For\n *   example if using 2, the throttle will double between every run.\n */\nexport function backoff(startingThrottleInMsec, backoffFactor) {\n  let currentThrottling = startingThrottleInMsec;\n  return () => new Promise(resolve => setTimeout(() => {\n    currentThrottling *= backoffFactor;\n    resolve();\n  }, currentThrottling));\n}\n/**\n * Chain multiple polling strategy. This _chains_ the strategies, so if you pass in,\n * say, two throttling strategy of 1 second, it will result in a throttle of 2 seconds.\n * @param strategies A strategy list to chain.\n */\nexport function chain() {\n  for (var _len = arguments.length, strategies = new Array(_len), _key = 0; _key < _len; _key++) {\n    strategies[_key] = arguments[_key];\n  }\n  return async (canisterId, requestId, status) => {\n    for (const a of strategies) {\n      await a(canisterId, requestId, status);\n    }\n  };\n}","map":{"version":3,"names":["toHex","FIVE_MINUTES_IN_MSEC","defaultStrategy","chain","conditionalDelay","once","backoff","timeout","first","condition","timeInMsec","canisterId","requestId","status","Promise","resolve","setTimeout","maxAttempts","count","attempts","Error","throttle","throttleInMsec","end","Date","now","startingThrottleInMsec","backoffFactor","currentThrottling","_len","arguments","length","strategies","Array","_key","a"],"sources":["/home/arslan/modojo/node_modules/@dfinity/agent/src/polling/strategy.ts"],"sourcesContent":["import { Principal } from '@dfinity/principal';\nimport { RequestStatusResponseStatus } from '../agent';\nimport { toHex } from '../utils/buffer';\nimport { PollStrategy } from './index';\nimport { RequestId } from '../request_id';\n\nexport type Predicate<T> = (\n  canisterId: Principal,\n  requestId: RequestId,\n  status: RequestStatusResponseStatus,\n) => Promise<T>;\n\nconst FIVE_MINUTES_IN_MSEC = 5 * 60 * 1000;\n\n/**\n * A best practices polling strategy: wait 2 seconds before the first poll, then 1 second\n * with an exponential backoff factor of 1.2. Timeout after 5 minutes.\n */\nexport function defaultStrategy(): PollStrategy {\n  return chain(conditionalDelay(once(), 1000), backoff(1000, 1.2), timeout(FIVE_MINUTES_IN_MSEC));\n}\n\n/**\n * Predicate that returns true once.\n */\nexport function once(): Predicate<boolean> {\n  let first = true;\n  return async () => {\n    if (first) {\n      first = false;\n      return true;\n    }\n    return false;\n  };\n}\n\n/**\n * Delay the polling once.\n * @param condition A predicate that indicates when to delay.\n * @param timeInMsec The amount of time to delay.\n */\nexport function conditionalDelay(condition: Predicate<boolean>, timeInMsec: number): PollStrategy {\n  return async (\n    canisterId: Principal,\n    requestId: RequestId,\n    status: RequestStatusResponseStatus,\n  ) => {\n    if (await condition(canisterId, requestId, status)) {\n      return new Promise(resolve => setTimeout(resolve, timeInMsec));\n    }\n  };\n}\n\n/**\n * Error out after a maximum number of polling has been done.\n * @param count The maximum attempts to poll.\n */\nexport function maxAttempts(count: number): PollStrategy {\n  let attempts = count;\n  return async (\n    canisterId: Principal,\n    requestId: RequestId,\n    status: RequestStatusResponseStatus,\n  ) => {\n    if (--attempts <= 0) {\n      throw new Error(\n        `Failed to retrieve a reply for request after ${count} attempts:\\n` +\n          `  Request ID: ${toHex(requestId)}\\n` +\n          `  Request status: ${status}\\n`,\n      );\n    }\n  };\n}\n\n/**\n * Throttle polling.\n * @param throttleInMsec Amount in millisecond to wait between each polling.\n */\nexport function throttle(throttleInMsec: number): PollStrategy {\n  return () => new Promise(resolve => setTimeout(resolve, throttleInMsec));\n}\n\n/**\n * Reject a call after a certain amount of time.\n * @param timeInMsec Time in milliseconds before the polling should be rejected.\n */\nexport function timeout(timeInMsec: number): PollStrategy {\n  const end = Date.now() + timeInMsec;\n  return async (\n    canisterId: Principal,\n    requestId: RequestId,\n    status: RequestStatusResponseStatus,\n  ) => {\n    if (Date.now() > end) {\n      throw new Error(\n        `Request timed out after ${timeInMsec} msec:\\n` +\n          `  Request ID: ${toHex(requestId)}\\n` +\n          `  Request status: ${status}\\n`,\n      );\n    }\n  };\n}\n\n/**\n * A strategy that throttle, but using an exponential backoff strategy.\n * @param startingThrottleInMsec The throttle in milliseconds to start with.\n * @param backoffFactor The factor to multiple the throttle time between every poll. For\n *   example if using 2, the throttle will double between every run.\n */\nexport function backoff(startingThrottleInMsec: number, backoffFactor: number): PollStrategy {\n  let currentThrottling = startingThrottleInMsec;\n\n  return () =>\n    new Promise(resolve =>\n      setTimeout(() => {\n        currentThrottling *= backoffFactor;\n        resolve();\n      }, currentThrottling),\n    );\n}\n\n/**\n * Chain multiple polling strategy. This _chains_ the strategies, so if you pass in,\n * say, two throttling strategy of 1 second, it will result in a throttle of 2 seconds.\n * @param strategies A strategy list to chain.\n */\nexport function chain(...strategies: PollStrategy[]): PollStrategy {\n  return async (\n    canisterId: Principal,\n    requestId: RequestId,\n    status: RequestStatusResponseStatus,\n  ) => {\n    for (const a of strategies) {\n      await a(canisterId, requestId, status);\n    }\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}