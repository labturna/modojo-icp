{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { IntervalTimer, TimeoutTimer } from '../../../base/common/async.js';\nimport { illegalState } from '../../../base/common/errors.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { IME } from '../../../base/common/ime.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as nls from '../../../nls.js';\nimport { NoMatchingKb } from './keybindingResolver.js';\nconst HIGH_FREQ_COMMANDS = /^(cursor|delete|undo|redo|tab|editor\\.action\\.clipboard)/;\nexport class AbstractKeybindingService extends Disposable {\n  get onDidUpdateKeybindings() {\n    return this._onDidUpdateKeybindings ? this._onDidUpdateKeybindings.event : Event.None; // Sinon stubbing walks properties on prototype\n  }\n  get inChordMode() {\n    return this._currentChords.length > 0;\n  }\n  constructor(_contextKeyService, _commandService, _telemetryService, _notificationService, _logService) {\n    super();\n    this._contextKeyService = _contextKeyService;\n    this._commandService = _commandService;\n    this._telemetryService = _telemetryService;\n    this._notificationService = _notificationService;\n    this._logService = _logService;\n    this._onDidUpdateKeybindings = this._register(new Emitter());\n    this._currentChords = [];\n    this._currentChordChecker = new IntervalTimer();\n    this._currentChordStatusMessage = null;\n    this._ignoreSingleModifiers = KeybindingModifierSet.EMPTY;\n    this._currentSingleModifier = null;\n    this._currentSingleModifierClearTimeout = new TimeoutTimer();\n    this._currentlyDispatchingCommandId = null;\n    this._logging = false;\n  }\n  dispose() {\n    super.dispose();\n  }\n  _log(str) {\n    if (this._logging) {\n      this._logService.info(`[KeybindingService]: ${str}`);\n    }\n  }\n  getKeybindings() {\n    return this._getResolver().getKeybindings();\n  }\n  lookupKeybinding(commandId, context) {\n    const result = this._getResolver().lookupPrimaryKeybinding(commandId, context || this._contextKeyService);\n    if (!result) {\n      return undefined;\n    }\n    return result.resolvedKeybinding;\n  }\n  dispatchEvent(e, target) {\n    return this._dispatch(e, target);\n  }\n  // TODO@ulugbekna: update namings to align with `_doDispatch`\n  // TODO@ulugbekna: this fn doesn't seem to take into account single-modifier keybindings, eg `shift shift`\n  softDispatch(e, target) {\n    this._log(`/ Soft dispatching keyboard event`);\n    const keybinding = this.resolveKeyboardEvent(e);\n    if (keybinding.hasMultipleChords()) {\n      console.warn('keyboard event should not be mapped to multiple chords');\n      return NoMatchingKb;\n    }\n    const [firstChord] = keybinding.getDispatchChords();\n    if (firstChord === null) {\n      // cannot be dispatched, probably only modifier keys\n      this._log(`\\\\ Keyboard event cannot be dispatched`);\n      return NoMatchingKb;\n    }\n    const contextValue = this._contextKeyService.getContext(target);\n    const currentChords = this._currentChords.map(_ref => {\n      let {\n        keypress\n      } = _ref;\n      return keypress;\n    });\n    return this._getResolver().resolve(contextValue, currentChords, firstChord);\n  }\n  _scheduleLeaveChordMode() {\n    const chordLastInteractedTime = Date.now();\n    this._currentChordChecker.cancelAndSet(() => {\n      if (!this._documentHasFocus()) {\n        // Focus has been lost => leave chord mode\n        this._leaveChordMode();\n        return;\n      }\n      if (Date.now() - chordLastInteractedTime > 5000) {\n        // 5 seconds elapsed => leave chord mode\n        this._leaveChordMode();\n      }\n    }, 500);\n  }\n  _expectAnotherChord(firstChord, keypressLabel) {\n    this._currentChords.push({\n      keypress: firstChord,\n      label: keypressLabel\n    });\n    switch (this._currentChords.length) {\n      case 0:\n        throw illegalState('impossible');\n      case 1:\n        // TODO@ulugbekna: revise this message and the one below (at least, fix terminology)\n        this._currentChordStatusMessage = this._notificationService.status(nls.localize('first.chord', \"({0}) was pressed. Waiting for second key of chord...\", keypressLabel));\n        break;\n      default:\n        {\n          const fullKeypressLabel = this._currentChords.map(_ref2 => {\n            let {\n              label\n            } = _ref2;\n            return label;\n          }).join(', ');\n          this._currentChordStatusMessage = this._notificationService.status(nls.localize('next.chord', \"({0}) was pressed. Waiting for next key of chord...\", fullKeypressLabel));\n        }\n    }\n    this._scheduleLeaveChordMode();\n    if (IME.enabled) {\n      IME.disable();\n    }\n  }\n  _leaveChordMode() {\n    if (this._currentChordStatusMessage) {\n      this._currentChordStatusMessage.dispose();\n      this._currentChordStatusMessage = null;\n    }\n    this._currentChordChecker.cancel();\n    this._currentChords = [];\n    IME.enable();\n  }\n  _dispatch(e, target) {\n    return this._doDispatch(this.resolveKeyboardEvent(e), target, /*isSingleModiferChord*/false);\n  }\n  _singleModifierDispatch(e, target) {\n    const keybinding = this.resolveKeyboardEvent(e);\n    const [singleModifier] = keybinding.getSingleModifierDispatchChords();\n    if (singleModifier) {\n      if (this._ignoreSingleModifiers.has(singleModifier)) {\n        this._log(`+ Ignoring single modifier ${singleModifier} due to it being pressed together with other keys.`);\n        this._ignoreSingleModifiers = KeybindingModifierSet.EMPTY;\n        this._currentSingleModifierClearTimeout.cancel();\n        this._currentSingleModifier = null;\n        return false;\n      }\n      this._ignoreSingleModifiers = KeybindingModifierSet.EMPTY;\n      if (this._currentSingleModifier === null) {\n        // we have a valid `singleModifier`, store it for the next keyup, but clear it in 300ms\n        this._log(`+ Storing single modifier for possible chord ${singleModifier}.`);\n        this._currentSingleModifier = singleModifier;\n        this._currentSingleModifierClearTimeout.cancelAndSet(() => {\n          this._log(`+ Clearing single modifier due to 300ms elapsed.`);\n          this._currentSingleModifier = null;\n        }, 300);\n        return false;\n      }\n      if (singleModifier === this._currentSingleModifier) {\n        // bingo!\n        this._log(`/ Dispatching single modifier chord ${singleModifier} ${singleModifier}`);\n        this._currentSingleModifierClearTimeout.cancel();\n        this._currentSingleModifier = null;\n        return this._doDispatch(keybinding, target, /*isSingleModiferChord*/true);\n      }\n      this._log(`+ Clearing single modifier due to modifier mismatch: ${this._currentSingleModifier} ${singleModifier}`);\n      this._currentSingleModifierClearTimeout.cancel();\n      this._currentSingleModifier = null;\n      return false;\n    }\n    // When pressing a modifier and holding it pressed with any other modifier or key combination,\n    // the pressed modifiers should no longer be considered for single modifier dispatch.\n    const [firstChord] = keybinding.getChords();\n    this._ignoreSingleModifiers = new KeybindingModifierSet(firstChord);\n    if (this._currentSingleModifier !== null) {\n      this._log(`+ Clearing single modifier due to other key up.`);\n    }\n    this._currentSingleModifierClearTimeout.cancel();\n    this._currentSingleModifier = null;\n    return false;\n  }\n  _doDispatch(userKeypress, target) {\n    let isSingleModiferChord = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var _a;\n    let shouldPreventDefault = false;\n    if (userKeypress.hasMultipleChords()) {\n      // warn - because user can press a single chord at a time\n      console.warn('Unexpected keyboard event mapped to multiple chords');\n      return false;\n    }\n    let userPressedChord = null;\n    let currentChords = null;\n    if (isSingleModiferChord) {\n      // The keybinding is the second keypress of a single modifier chord, e.g. \"shift shift\".\n      // A single modifier can only occur when the same modifier is pressed in short sequence,\n      // hence we disregard `_currentChord` and use the same modifier instead.\n      const [dispatchKeyname] = userKeypress.getSingleModifierDispatchChords();\n      userPressedChord = dispatchKeyname;\n      currentChords = dispatchKeyname ? [dispatchKeyname] : []; // TODO@ulugbekna: in the `else` case we assign an empty array - make sure `resolve` can handle an empty array well\n    } else {\n      [userPressedChord] = userKeypress.getDispatchChords();\n      currentChords = this._currentChords.map(_ref3 => {\n        let {\n          keypress\n        } = _ref3;\n        return keypress;\n      });\n    }\n    if (userPressedChord === null) {\n      this._log(`\\\\ Keyboard event cannot be dispatched in keydown phase.`);\n      // cannot be dispatched, probably only modifier keys\n      return shouldPreventDefault;\n    }\n    const contextValue = this._contextKeyService.getContext(target);\n    const keypressLabel = userKeypress.getLabel();\n    const resolveResult = this._getResolver().resolve(contextValue, currentChords, userPressedChord);\n    switch (resolveResult.kind) {\n      case 0 /* ResultKind.NoMatchingKb */:\n        {\n          this._logService.trace('KeybindingService#dispatch', keypressLabel, `[ No matching keybinding ]`);\n          if (this.inChordMode) {\n            const currentChordsLabel = this._currentChords.map(_ref4 => {\n              let {\n                label\n              } = _ref4;\n              return label;\n            }).join(', ');\n            this._log(`+ Leaving multi-chord mode: Nothing bound to \"${currentChordsLabel}, ${keypressLabel}\".`);\n            this._notificationService.status(nls.localize('missing.chord', \"The key combination ({0}, {1}) is not a command.\", currentChordsLabel, keypressLabel), {\n              hideAfter: 10 * 1000 /* 10s */\n            });\n            this._leaveChordMode();\n            shouldPreventDefault = true;\n          }\n          return shouldPreventDefault;\n        }\n      case 1 /* ResultKind.MoreChordsNeeded */:\n        {\n          this._logService.trace('KeybindingService#dispatch', keypressLabel, `[ Several keybindings match - more chords needed ]`);\n          shouldPreventDefault = true;\n          this._expectAnotherChord(userPressedChord, keypressLabel);\n          this._log(this._currentChords.length === 1 ? `+ Entering multi-chord mode...` : `+ Continuing multi-chord mode...`);\n          return shouldPreventDefault;\n        }\n      case 2 /* ResultKind.KbFound */:\n        {\n          this._logService.trace('KeybindingService#dispatch', keypressLabel, `[ Will dispatch command ${resolveResult.commandId} ]`);\n          if (resolveResult.commandId === null || resolveResult.commandId === '') {\n            if (this.inChordMode) {\n              const currentChordsLabel = this._currentChords.map(_ref5 => {\n                let {\n                  label\n                } = _ref5;\n                return label;\n              }).join(', ');\n              this._log(`+ Leaving chord mode: Nothing bound to \"${currentChordsLabel}, ${keypressLabel}\".`);\n              this._notificationService.status(nls.localize('missing.chord', \"The key combination ({0}, {1}) is not a command.\", currentChordsLabel, keypressLabel), {\n                hideAfter: 10 * 1000 /* 10s */\n              });\n              this._leaveChordMode();\n              shouldPreventDefault = true;\n            }\n          } else {\n            if (this.inChordMode) {\n              this._leaveChordMode();\n            }\n            if (!resolveResult.isBubble) {\n              shouldPreventDefault = true;\n            }\n            this._log(`+ Invoking command ${resolveResult.commandId}.`);\n            this._currentlyDispatchingCommandId = resolveResult.commandId;\n            try {\n              if (typeof resolveResult.commandArgs === 'undefined') {\n                this._commandService.executeCommand(resolveResult.commandId).then(undefined, err => this._notificationService.warn(err));\n              } else {\n                this._commandService.executeCommand(resolveResult.commandId, resolveResult.commandArgs).then(undefined, err => this._notificationService.warn(err));\n              }\n            } finally {\n              this._currentlyDispatchingCommandId = null;\n            }\n            if (!HIGH_FREQ_COMMANDS.test(resolveResult.commandId)) {\n              this._telemetryService.publicLog2('workbenchActionExecuted', {\n                id: resolveResult.commandId,\n                from: 'keybinding',\n                detail: (_a = userKeypress.getUserSettingsLabel()) !== null && _a !== void 0 ? _a : undefined\n              });\n            }\n          }\n          return shouldPreventDefault;\n        }\n    }\n  }\n  mightProducePrintableCharacter(event) {\n    if (event.ctrlKey || event.metaKey) {\n      // ignore ctrl/cmd-combination but not shift/alt-combinatios\n      return false;\n    }\n    // weak check for certain ranges. this is properly implemented in a subclass\n    // with access to the KeyboardMapperFactory.\n    if (event.keyCode >= 31 /* KeyCode.KeyA */ && event.keyCode <= 56 /* KeyCode.KeyZ */ || event.keyCode >= 21 /* KeyCode.Digit0 */ && event.keyCode <= 30 /* KeyCode.Digit9 */) {\n      return true;\n    }\n    return false;\n  }\n}\nclass KeybindingModifierSet {\n  constructor(source) {\n    this._ctrlKey = source ? source.ctrlKey : false;\n    this._shiftKey = source ? source.shiftKey : false;\n    this._altKey = source ? source.altKey : false;\n    this._metaKey = source ? source.metaKey : false;\n  }\n  has(modifier) {\n    switch (modifier) {\n      case 'ctrl':\n        return this._ctrlKey;\n      case 'shift':\n        return this._shiftKey;\n      case 'alt':\n        return this._altKey;\n      case 'meta':\n        return this._metaKey;\n    }\n  }\n}\nKeybindingModifierSet.EMPTY = new KeybindingModifierSet(null);","map":{"version":3,"names":["IntervalTimer","TimeoutTimer","illegalState","Emitter","Event","IME","Disposable","nls","NoMatchingKb","HIGH_FREQ_COMMANDS","AbstractKeybindingService","onDidUpdateKeybindings","_onDidUpdateKeybindings","event","None","inChordMode","_currentChords","length","constructor","_contextKeyService","_commandService","_telemetryService","_notificationService","_logService","_register","_currentChordChecker","_currentChordStatusMessage","_ignoreSingleModifiers","KeybindingModifierSet","EMPTY","_currentSingleModifier","_currentSingleModifierClearTimeout","_currentlyDispatchingCommandId","_logging","dispose","_log","str","info","getKeybindings","_getResolver","lookupKeybinding","commandId","context","result","lookupPrimaryKeybinding","undefined","resolvedKeybinding","dispatchEvent","e","target","_dispatch","softDispatch","keybinding","resolveKeyboardEvent","hasMultipleChords","console","warn","firstChord","getDispatchChords","contextValue","getContext","currentChords","map","_ref","keypress","resolve","_scheduleLeaveChordMode","chordLastInteractedTime","Date","now","cancelAndSet","_documentHasFocus","_leaveChordMode","_expectAnotherChord","keypressLabel","push","label","status","localize","fullKeypressLabel","_ref2","join","enabled","disable","cancel","enable","_doDispatch","_singleModifierDispatch","singleModifier","getSingleModifierDispatchChords","has","getChords","userKeypress","isSingleModiferChord","arguments","_a","shouldPreventDefault","userPressedChord","dispatchKeyname","_ref3","getLabel","resolveResult","kind","trace","currentChordsLabel","_ref4","hideAfter","_ref5","isBubble","commandArgs","executeCommand","then","err","test","publicLog2","id","from","detail","getUserSettingsLabel","mightProducePrintableCharacter","ctrlKey","metaKey","keyCode","source","_ctrlKey","_shiftKey","shiftKey","_altKey","altKey","_metaKey","modifier"],"sources":["/home/arslan/modojo/node_modules/monaco-editor/esm/vs/platform/keybinding/common/abstractKeybindingService.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { IntervalTimer, TimeoutTimer } from '../../../base/common/async.js';\nimport { illegalState } from '../../../base/common/errors.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { IME } from '../../../base/common/ime.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as nls from '../../../nls.js';\nimport { NoMatchingKb } from './keybindingResolver.js';\nconst HIGH_FREQ_COMMANDS = /^(cursor|delete|undo|redo|tab|editor\\.action\\.clipboard)/;\nexport class AbstractKeybindingService extends Disposable {\n    get onDidUpdateKeybindings() {\n        return this._onDidUpdateKeybindings ? this._onDidUpdateKeybindings.event : Event.None; // Sinon stubbing walks properties on prototype\n    }\n    get inChordMode() {\n        return this._currentChords.length > 0;\n    }\n    constructor(_contextKeyService, _commandService, _telemetryService, _notificationService, _logService) {\n        super();\n        this._contextKeyService = _contextKeyService;\n        this._commandService = _commandService;\n        this._telemetryService = _telemetryService;\n        this._notificationService = _notificationService;\n        this._logService = _logService;\n        this._onDidUpdateKeybindings = this._register(new Emitter());\n        this._currentChords = [];\n        this._currentChordChecker = new IntervalTimer();\n        this._currentChordStatusMessage = null;\n        this._ignoreSingleModifiers = KeybindingModifierSet.EMPTY;\n        this._currentSingleModifier = null;\n        this._currentSingleModifierClearTimeout = new TimeoutTimer();\n        this._currentlyDispatchingCommandId = null;\n        this._logging = false;\n    }\n    dispose() {\n        super.dispose();\n    }\n    _log(str) {\n        if (this._logging) {\n            this._logService.info(`[KeybindingService]: ${str}`);\n        }\n    }\n    getKeybindings() {\n        return this._getResolver().getKeybindings();\n    }\n    lookupKeybinding(commandId, context) {\n        const result = this._getResolver().lookupPrimaryKeybinding(commandId, context || this._contextKeyService);\n        if (!result) {\n            return undefined;\n        }\n        return result.resolvedKeybinding;\n    }\n    dispatchEvent(e, target) {\n        return this._dispatch(e, target);\n    }\n    // TODO@ulugbekna: update namings to align with `_doDispatch`\n    // TODO@ulugbekna: this fn doesn't seem to take into account single-modifier keybindings, eg `shift shift`\n    softDispatch(e, target) {\n        this._log(`/ Soft dispatching keyboard event`);\n        const keybinding = this.resolveKeyboardEvent(e);\n        if (keybinding.hasMultipleChords()) {\n            console.warn('keyboard event should not be mapped to multiple chords');\n            return NoMatchingKb;\n        }\n        const [firstChord,] = keybinding.getDispatchChords();\n        if (firstChord === null) {\n            // cannot be dispatched, probably only modifier keys\n            this._log(`\\\\ Keyboard event cannot be dispatched`);\n            return NoMatchingKb;\n        }\n        const contextValue = this._contextKeyService.getContext(target);\n        const currentChords = this._currentChords.map((({ keypress }) => keypress));\n        return this._getResolver().resolve(contextValue, currentChords, firstChord);\n    }\n    _scheduleLeaveChordMode() {\n        const chordLastInteractedTime = Date.now();\n        this._currentChordChecker.cancelAndSet(() => {\n            if (!this._documentHasFocus()) {\n                // Focus has been lost => leave chord mode\n                this._leaveChordMode();\n                return;\n            }\n            if (Date.now() - chordLastInteractedTime > 5000) {\n                // 5 seconds elapsed => leave chord mode\n                this._leaveChordMode();\n            }\n        }, 500);\n    }\n    _expectAnotherChord(firstChord, keypressLabel) {\n        this._currentChords.push({ keypress: firstChord, label: keypressLabel });\n        switch (this._currentChords.length) {\n            case 0:\n                throw illegalState('impossible');\n            case 1:\n                // TODO@ulugbekna: revise this message and the one below (at least, fix terminology)\n                this._currentChordStatusMessage = this._notificationService.status(nls.localize('first.chord', \"({0}) was pressed. Waiting for second key of chord...\", keypressLabel));\n                break;\n            default: {\n                const fullKeypressLabel = this._currentChords.map(({ label }) => label).join(', ');\n                this._currentChordStatusMessage = this._notificationService.status(nls.localize('next.chord', \"({0}) was pressed. Waiting for next key of chord...\", fullKeypressLabel));\n            }\n        }\n        this._scheduleLeaveChordMode();\n        if (IME.enabled) {\n            IME.disable();\n        }\n    }\n    _leaveChordMode() {\n        if (this._currentChordStatusMessage) {\n            this._currentChordStatusMessage.dispose();\n            this._currentChordStatusMessage = null;\n        }\n        this._currentChordChecker.cancel();\n        this._currentChords = [];\n        IME.enable();\n    }\n    _dispatch(e, target) {\n        return this._doDispatch(this.resolveKeyboardEvent(e), target, /*isSingleModiferChord*/ false);\n    }\n    _singleModifierDispatch(e, target) {\n        const keybinding = this.resolveKeyboardEvent(e);\n        const [singleModifier,] = keybinding.getSingleModifierDispatchChords();\n        if (singleModifier) {\n            if (this._ignoreSingleModifiers.has(singleModifier)) {\n                this._log(`+ Ignoring single modifier ${singleModifier} due to it being pressed together with other keys.`);\n                this._ignoreSingleModifiers = KeybindingModifierSet.EMPTY;\n                this._currentSingleModifierClearTimeout.cancel();\n                this._currentSingleModifier = null;\n                return false;\n            }\n            this._ignoreSingleModifiers = KeybindingModifierSet.EMPTY;\n            if (this._currentSingleModifier === null) {\n                // we have a valid `singleModifier`, store it for the next keyup, but clear it in 300ms\n                this._log(`+ Storing single modifier for possible chord ${singleModifier}.`);\n                this._currentSingleModifier = singleModifier;\n                this._currentSingleModifierClearTimeout.cancelAndSet(() => {\n                    this._log(`+ Clearing single modifier due to 300ms elapsed.`);\n                    this._currentSingleModifier = null;\n                }, 300);\n                return false;\n            }\n            if (singleModifier === this._currentSingleModifier) {\n                // bingo!\n                this._log(`/ Dispatching single modifier chord ${singleModifier} ${singleModifier}`);\n                this._currentSingleModifierClearTimeout.cancel();\n                this._currentSingleModifier = null;\n                return this._doDispatch(keybinding, target, /*isSingleModiferChord*/ true);\n            }\n            this._log(`+ Clearing single modifier due to modifier mismatch: ${this._currentSingleModifier} ${singleModifier}`);\n            this._currentSingleModifierClearTimeout.cancel();\n            this._currentSingleModifier = null;\n            return false;\n        }\n        // When pressing a modifier and holding it pressed with any other modifier or key combination,\n        // the pressed modifiers should no longer be considered for single modifier dispatch.\n        const [firstChord,] = keybinding.getChords();\n        this._ignoreSingleModifiers = new KeybindingModifierSet(firstChord);\n        if (this._currentSingleModifier !== null) {\n            this._log(`+ Clearing single modifier due to other key up.`);\n        }\n        this._currentSingleModifierClearTimeout.cancel();\n        this._currentSingleModifier = null;\n        return false;\n    }\n    _doDispatch(userKeypress, target, isSingleModiferChord = false) {\n        var _a;\n        let shouldPreventDefault = false;\n        if (userKeypress.hasMultipleChords()) { // warn - because user can press a single chord at a time\n            console.warn('Unexpected keyboard event mapped to multiple chords');\n            return false;\n        }\n        let userPressedChord = null;\n        let currentChords = null;\n        if (isSingleModiferChord) {\n            // The keybinding is the second keypress of a single modifier chord, e.g. \"shift shift\".\n            // A single modifier can only occur when the same modifier is pressed in short sequence,\n            // hence we disregard `_currentChord` and use the same modifier instead.\n            const [dispatchKeyname,] = userKeypress.getSingleModifierDispatchChords();\n            userPressedChord = dispatchKeyname;\n            currentChords = dispatchKeyname ? [dispatchKeyname] : []; // TODO@ulugbekna: in the `else` case we assign an empty array - make sure `resolve` can handle an empty array well\n        }\n        else {\n            [userPressedChord,] = userKeypress.getDispatchChords();\n            currentChords = this._currentChords.map(({ keypress }) => keypress);\n        }\n        if (userPressedChord === null) {\n            this._log(`\\\\ Keyboard event cannot be dispatched in keydown phase.`);\n            // cannot be dispatched, probably only modifier keys\n            return shouldPreventDefault;\n        }\n        const contextValue = this._contextKeyService.getContext(target);\n        const keypressLabel = userKeypress.getLabel();\n        const resolveResult = this._getResolver().resolve(contextValue, currentChords, userPressedChord);\n        switch (resolveResult.kind) {\n            case 0 /* ResultKind.NoMatchingKb */: {\n                this._logService.trace('KeybindingService#dispatch', keypressLabel, `[ No matching keybinding ]`);\n                if (this.inChordMode) {\n                    const currentChordsLabel = this._currentChords.map(({ label }) => label).join(', ');\n                    this._log(`+ Leaving multi-chord mode: Nothing bound to \"${currentChordsLabel}, ${keypressLabel}\".`);\n                    this._notificationService.status(nls.localize('missing.chord', \"The key combination ({0}, {1}) is not a command.\", currentChordsLabel, keypressLabel), { hideAfter: 10 * 1000 /* 10s */ });\n                    this._leaveChordMode();\n                    shouldPreventDefault = true;\n                }\n                return shouldPreventDefault;\n            }\n            case 1 /* ResultKind.MoreChordsNeeded */: {\n                this._logService.trace('KeybindingService#dispatch', keypressLabel, `[ Several keybindings match - more chords needed ]`);\n                shouldPreventDefault = true;\n                this._expectAnotherChord(userPressedChord, keypressLabel);\n                this._log(this._currentChords.length === 1 ? `+ Entering multi-chord mode...` : `+ Continuing multi-chord mode...`);\n                return shouldPreventDefault;\n            }\n            case 2 /* ResultKind.KbFound */: {\n                this._logService.trace('KeybindingService#dispatch', keypressLabel, `[ Will dispatch command ${resolveResult.commandId} ]`);\n                if (resolveResult.commandId === null || resolveResult.commandId === '') {\n                    if (this.inChordMode) {\n                        const currentChordsLabel = this._currentChords.map(({ label }) => label).join(', ');\n                        this._log(`+ Leaving chord mode: Nothing bound to \"${currentChordsLabel}, ${keypressLabel}\".`);\n                        this._notificationService.status(nls.localize('missing.chord', \"The key combination ({0}, {1}) is not a command.\", currentChordsLabel, keypressLabel), { hideAfter: 10 * 1000 /* 10s */ });\n                        this._leaveChordMode();\n                        shouldPreventDefault = true;\n                    }\n                }\n                else {\n                    if (this.inChordMode) {\n                        this._leaveChordMode();\n                    }\n                    if (!resolveResult.isBubble) {\n                        shouldPreventDefault = true;\n                    }\n                    this._log(`+ Invoking command ${resolveResult.commandId}.`);\n                    this._currentlyDispatchingCommandId = resolveResult.commandId;\n                    try {\n                        if (typeof resolveResult.commandArgs === 'undefined') {\n                            this._commandService.executeCommand(resolveResult.commandId).then(undefined, err => this._notificationService.warn(err));\n                        }\n                        else {\n                            this._commandService.executeCommand(resolveResult.commandId, resolveResult.commandArgs).then(undefined, err => this._notificationService.warn(err));\n                        }\n                    }\n                    finally {\n                        this._currentlyDispatchingCommandId = null;\n                    }\n                    if (!HIGH_FREQ_COMMANDS.test(resolveResult.commandId)) {\n                        this._telemetryService.publicLog2('workbenchActionExecuted', { id: resolveResult.commandId, from: 'keybinding', detail: (_a = userKeypress.getUserSettingsLabel()) !== null && _a !== void 0 ? _a : undefined });\n                    }\n                }\n                return shouldPreventDefault;\n            }\n        }\n    }\n    mightProducePrintableCharacter(event) {\n        if (event.ctrlKey || event.metaKey) {\n            // ignore ctrl/cmd-combination but not shift/alt-combinatios\n            return false;\n        }\n        // weak check for certain ranges. this is properly implemented in a subclass\n        // with access to the KeyboardMapperFactory.\n        if ((event.keyCode >= 31 /* KeyCode.KeyA */ && event.keyCode <= 56 /* KeyCode.KeyZ */)\n            || (event.keyCode >= 21 /* KeyCode.Digit0 */ && event.keyCode <= 30 /* KeyCode.Digit9 */)) {\n            return true;\n        }\n        return false;\n    }\n}\nclass KeybindingModifierSet {\n    constructor(source) {\n        this._ctrlKey = source ? source.ctrlKey : false;\n        this._shiftKey = source ? source.shiftKey : false;\n        this._altKey = source ? source.altKey : false;\n        this._metaKey = source ? source.metaKey : false;\n    }\n    has(modifier) {\n        switch (modifier) {\n            case 'ctrl': return this._ctrlKey;\n            case 'shift': return this._shiftKey;\n            case 'alt': return this._altKey;\n            case 'meta': return this._metaKey;\n        }\n    }\n}\nKeybindingModifierSet.EMPTY = new KeybindingModifierSet(null);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}