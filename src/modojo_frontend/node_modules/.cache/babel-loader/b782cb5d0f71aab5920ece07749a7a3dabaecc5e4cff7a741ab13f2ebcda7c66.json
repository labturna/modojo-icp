{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../../../base/common/errors.js';\nimport { CursorColumns } from '../../../core/cursorColumns.js';\nimport { lengthAdd, lengthGetLineCount, lengthToObj, lengthZero } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\n/**\n * The base implementation for all AST nodes.\n*/\nclass BaseAstNode {\n  /**\n   * The length of the entire node, which should equal the sum of lengths of all children.\n  */\n  get length() {\n    return this._length;\n  }\n  constructor(length) {\n    this._length = length;\n  }\n}\n/**\n * Represents a bracket pair including its child (e.g. `{ ... }`).\n * Might be unclosed.\n * Immutable, if all children are immutable.\n*/\nexport class PairAstNode extends BaseAstNode {\n  static create(openingBracket, child, closingBracket) {\n    let length = openingBracket.length;\n    if (child) {\n      length = lengthAdd(length, child.length);\n    }\n    if (closingBracket) {\n      length = lengthAdd(length, closingBracket.length);\n    }\n    return new PairAstNode(length, openingBracket, child, closingBracket, child ? child.missingOpeningBracketIds : SmallImmutableSet.getEmpty());\n  }\n  get kind() {\n    return 2 /* AstNodeKind.Pair */;\n  }\n  get listHeight() {\n    return 0;\n  }\n  get childrenLength() {\n    return 3;\n  }\n  getChild(idx) {\n    switch (idx) {\n      case 0:\n        return this.openingBracket;\n      case 1:\n        return this.child;\n      case 2:\n        return this.closingBracket;\n    }\n    throw new Error('Invalid child index');\n  }\n  /**\n   * Avoid using this property, it allocates an array!\n  */\n  get children() {\n    const result = [];\n    result.push(this.openingBracket);\n    if (this.child) {\n      result.push(this.child);\n    }\n    if (this.closingBracket) {\n      result.push(this.closingBracket);\n    }\n    return result;\n  }\n  constructor(length, openingBracket, child, closingBracket, missingOpeningBracketIds) {\n    super(length);\n    this.openingBracket = openingBracket;\n    this.child = child;\n    this.closingBracket = closingBracket;\n    this.missingOpeningBracketIds = missingOpeningBracketIds;\n  }\n  canBeReused(openBracketIds) {\n    if (this.closingBracket === null) {\n      // Unclosed pair ast nodes only\n      // end at the end of the document\n      // or when a parent node is closed.\n      // This could be improved:\n      // Only return false if some next token is neither \"undefined\" nor a bracket that closes a parent.\n      return false;\n    }\n    if (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n      return false;\n    }\n    return true;\n  }\n  deepClone() {\n    return new PairAstNode(this.length, this.openingBracket.deepClone(), this.child && this.child.deepClone(), this.closingBracket && this.closingBracket.deepClone(), this.missingOpeningBracketIds);\n  }\n  computeMinIndentation(offset, textModel) {\n    return this.child ? this.child.computeMinIndentation(lengthAdd(offset, this.openingBracket.length), textModel) : Number.MAX_SAFE_INTEGER;\n  }\n}\nexport class ListAstNode extends BaseAstNode {\n  /**\n   * This method uses more memory-efficient list nodes that can only store 2 or 3 children.\n  */\n  static create23(item1, item2, item3) {\n    let immutable = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let length = item1.length;\n    let missingBracketIds = item1.missingOpeningBracketIds;\n    if (item1.listHeight !== item2.listHeight) {\n      throw new Error('Invalid list heights');\n    }\n    length = lengthAdd(length, item2.length);\n    missingBracketIds = missingBracketIds.merge(item2.missingOpeningBracketIds);\n    if (item3) {\n      if (item1.listHeight !== item3.listHeight) {\n        throw new Error('Invalid list heights');\n      }\n      length = lengthAdd(length, item3.length);\n      missingBracketIds = missingBracketIds.merge(item3.missingOpeningBracketIds);\n    }\n    return immutable ? new Immutable23ListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds) : new TwoThreeListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds);\n  }\n  static getEmpty() {\n    return new ImmutableArrayListAstNode(lengthZero, 0, [], SmallImmutableSet.getEmpty());\n  }\n  get kind() {\n    return 4 /* AstNodeKind.List */;\n  }\n  get missingOpeningBracketIds() {\n    return this._missingOpeningBracketIds;\n  }\n  /**\n   * Use ListAstNode.create.\n  */\n  constructor(length, listHeight, _missingOpeningBracketIds) {\n    super(length);\n    this.listHeight = listHeight;\n    this._missingOpeningBracketIds = _missingOpeningBracketIds;\n    this.cachedMinIndentation = -1;\n  }\n  throwIfImmutable() {\n    // NOOP\n  }\n  makeLastElementMutable() {\n    this.throwIfImmutable();\n    const childCount = this.childrenLength;\n    if (childCount === 0) {\n      return undefined;\n    }\n    const lastChild = this.getChild(childCount - 1);\n    const mutable = lastChild.kind === 4 /* AstNodeKind.List */ ? lastChild.toMutable() : lastChild;\n    if (lastChild !== mutable) {\n      this.setChild(childCount - 1, mutable);\n    }\n    return mutable;\n  }\n  makeFirstElementMutable() {\n    this.throwIfImmutable();\n    const childCount = this.childrenLength;\n    if (childCount === 0) {\n      return undefined;\n    }\n    const firstChild = this.getChild(0);\n    const mutable = firstChild.kind === 4 /* AstNodeKind.List */ ? firstChild.toMutable() : firstChild;\n    if (firstChild !== mutable) {\n      this.setChild(0, mutable);\n    }\n    return mutable;\n  }\n  canBeReused(openBracketIds) {\n    if (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n      return false;\n    }\n    if (this.childrenLength === 0) {\n      // Don't reuse empty lists.\n      return false;\n    }\n    let lastChild = this;\n    while (lastChild.kind === 4 /* AstNodeKind.List */) {\n      const lastLength = lastChild.childrenLength;\n      if (lastLength === 0) {\n        // Empty lists should never be contained in other lists.\n        throw new BugIndicatingError();\n      }\n      lastChild = lastChild.getChild(lastLength - 1);\n    }\n    return lastChild.canBeReused(openBracketIds);\n  }\n  handleChildrenChanged() {\n    this.throwIfImmutable();\n    const count = this.childrenLength;\n    let length = this.getChild(0).length;\n    let unopenedBrackets = this.getChild(0).missingOpeningBracketIds;\n    for (let i = 1; i < count; i++) {\n      const child = this.getChild(i);\n      length = lengthAdd(length, child.length);\n      unopenedBrackets = unopenedBrackets.merge(child.missingOpeningBracketIds);\n    }\n    this._length = length;\n    this._missingOpeningBracketIds = unopenedBrackets;\n    this.cachedMinIndentation = -1;\n  }\n  computeMinIndentation(offset, textModel) {\n    if (this.cachedMinIndentation !== -1) {\n      return this.cachedMinIndentation;\n    }\n    let minIndentation = Number.MAX_SAFE_INTEGER;\n    let childOffset = offset;\n    for (let i = 0; i < this.childrenLength; i++) {\n      const child = this.getChild(i);\n      if (child) {\n        minIndentation = Math.min(minIndentation, child.computeMinIndentation(childOffset, textModel));\n        childOffset = lengthAdd(childOffset, child.length);\n      }\n    }\n    this.cachedMinIndentation = minIndentation;\n    return minIndentation;\n  }\n}\nclass TwoThreeListAstNode extends ListAstNode {\n  get childrenLength() {\n    return this._item3 !== null ? 3 : 2;\n  }\n  getChild(idx) {\n    switch (idx) {\n      case 0:\n        return this._item1;\n      case 1:\n        return this._item2;\n      case 2:\n        return this._item3;\n    }\n    throw new Error('Invalid child index');\n  }\n  setChild(idx, node) {\n    switch (idx) {\n      case 0:\n        this._item1 = node;\n        return;\n      case 1:\n        this._item2 = node;\n        return;\n      case 2:\n        this._item3 = node;\n        return;\n    }\n    throw new Error('Invalid child index');\n  }\n  get children() {\n    return this._item3 ? [this._item1, this._item2, this._item3] : [this._item1, this._item2];\n  }\n  get item1() {\n    return this._item1;\n  }\n  get item2() {\n    return this._item2;\n  }\n  get item3() {\n    return this._item3;\n  }\n  constructor(length, listHeight, _item1, _item2, _item3, missingOpeningBracketIds) {\n    super(length, listHeight, missingOpeningBracketIds);\n    this._item1 = _item1;\n    this._item2 = _item2;\n    this._item3 = _item3;\n  }\n  deepClone() {\n    return new TwoThreeListAstNode(this.length, this.listHeight, this._item1.deepClone(), this._item2.deepClone(), this._item3 ? this._item3.deepClone() : null, this.missingOpeningBracketIds);\n  }\n  appendChildOfSameHeight(node) {\n    if (this._item3) {\n      throw new Error('Cannot append to a full (2,3) tree node');\n    }\n    this.throwIfImmutable();\n    this._item3 = node;\n    this.handleChildrenChanged();\n  }\n  unappendChild() {\n    if (!this._item3) {\n      throw new Error('Cannot remove from a non-full (2,3) tree node');\n    }\n    this.throwIfImmutable();\n    const result = this._item3;\n    this._item3 = null;\n    this.handleChildrenChanged();\n    return result;\n  }\n  prependChildOfSameHeight(node) {\n    if (this._item3) {\n      throw new Error('Cannot prepend to a full (2,3) tree node');\n    }\n    this.throwIfImmutable();\n    this._item3 = this._item2;\n    this._item2 = this._item1;\n    this._item1 = node;\n    this.handleChildrenChanged();\n  }\n  unprependChild() {\n    if (!this._item3) {\n      throw new Error('Cannot remove from a non-full (2,3) tree node');\n    }\n    this.throwIfImmutable();\n    const result = this._item1;\n    this._item1 = this._item2;\n    this._item2 = this._item3;\n    this._item3 = null;\n    this.handleChildrenChanged();\n    return result;\n  }\n  toMutable() {\n    return this;\n  }\n}\n/**\n * Immutable, if all children are immutable.\n*/\nclass Immutable23ListAstNode extends TwoThreeListAstNode {\n  toMutable() {\n    return new TwoThreeListAstNode(this.length, this.listHeight, this.item1, this.item2, this.item3, this.missingOpeningBracketIds);\n  }\n  throwIfImmutable() {\n    throw new Error('this instance is immutable');\n  }\n}\n/**\n * For debugging.\n*/\nclass ArrayListAstNode extends ListAstNode {\n  get childrenLength() {\n    return this._children.length;\n  }\n  getChild(idx) {\n    return this._children[idx];\n  }\n  setChild(idx, child) {\n    this._children[idx] = child;\n  }\n  get children() {\n    return this._children;\n  }\n  constructor(length, listHeight, _children, missingOpeningBracketIds) {\n    super(length, listHeight, missingOpeningBracketIds);\n    this._children = _children;\n  }\n  deepClone() {\n    const children = new Array(this._children.length);\n    for (let i = 0; i < this._children.length; i++) {\n      children[i] = this._children[i].deepClone();\n    }\n    return new ArrayListAstNode(this.length, this.listHeight, children, this.missingOpeningBracketIds);\n  }\n  appendChildOfSameHeight(node) {\n    this.throwIfImmutable();\n    this._children.push(node);\n    this.handleChildrenChanged();\n  }\n  unappendChild() {\n    this.throwIfImmutable();\n    const item = this._children.pop();\n    this.handleChildrenChanged();\n    return item;\n  }\n  prependChildOfSameHeight(node) {\n    this.throwIfImmutable();\n    this._children.unshift(node);\n    this.handleChildrenChanged();\n  }\n  unprependChild() {\n    this.throwIfImmutable();\n    const item = this._children.shift();\n    this.handleChildrenChanged();\n    return item;\n  }\n  toMutable() {\n    return this;\n  }\n}\n/**\n * Immutable, if all children are immutable.\n*/\nclass ImmutableArrayListAstNode extends ArrayListAstNode {\n  toMutable() {\n    return new ArrayListAstNode(this.length, this.listHeight, [...this.children], this.missingOpeningBracketIds);\n  }\n  throwIfImmutable() {\n    throw new Error('this instance is immutable');\n  }\n}\nconst emptyArray = [];\nclass ImmutableLeafAstNode extends BaseAstNode {\n  get listHeight() {\n    return 0;\n  }\n  get childrenLength() {\n    return 0;\n  }\n  getChild(idx) {\n    return null;\n  }\n  get children() {\n    return emptyArray;\n  }\n  deepClone() {\n    return this;\n  }\n}\nexport class TextAstNode extends ImmutableLeafAstNode {\n  get kind() {\n    return 0 /* AstNodeKind.Text */;\n  }\n  get missingOpeningBracketIds() {\n    return SmallImmutableSet.getEmpty();\n  }\n  canBeReused(_openedBracketIds) {\n    return true;\n  }\n  computeMinIndentation(offset, textModel) {\n    const start = lengthToObj(offset);\n    // Text ast nodes don't have partial indentation (ensured by the tokenizer).\n    // Thus, if this text node does not start at column 0, the first line cannot have any indentation at all.\n    const startLineNumber = (start.columnCount === 0 ? start.lineCount : start.lineCount + 1) + 1;\n    const endLineNumber = lengthGetLineCount(lengthAdd(offset, this.length)) + 1;\n    let result = Number.MAX_SAFE_INTEGER;\n    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n      const firstNonWsColumn = textModel.getLineFirstNonWhitespaceColumn(lineNumber);\n      const lineContent = textModel.getLineContent(lineNumber);\n      if (firstNonWsColumn === 0) {\n        continue;\n      }\n      const visibleColumn = CursorColumns.visibleColumnFromColumn(lineContent, firstNonWsColumn, textModel.getOptions().tabSize);\n      result = Math.min(result, visibleColumn);\n    }\n    return result;\n  }\n}\nexport class BracketAstNode extends ImmutableLeafAstNode {\n  static create(length, bracketInfo, bracketIds) {\n    const node = new BracketAstNode(length, bracketInfo, bracketIds);\n    return node;\n  }\n  get kind() {\n    return 1 /* AstNodeKind.Bracket */;\n  }\n  get missingOpeningBracketIds() {\n    return SmallImmutableSet.getEmpty();\n  }\n  constructor(length, bracketInfo,\n  /**\n   * In case of a opening bracket, this is the id of the opening bracket.\n   * In case of a closing bracket, this contains the ids of all opening brackets it can close.\n  */\n  bracketIds) {\n    super(length);\n    this.bracketInfo = bracketInfo;\n    this.bracketIds = bracketIds;\n  }\n  get text() {\n    return this.bracketInfo.bracketText;\n  }\n  get languageId() {\n    return this.bracketInfo.languageId;\n  }\n  canBeReused(_openedBracketIds) {\n    // These nodes could be reused,\n    // but not in a general way.\n    // Their parent may be reused.\n    return false;\n  }\n  computeMinIndentation(offset, textModel) {\n    return Number.MAX_SAFE_INTEGER;\n  }\n}\nexport class InvalidBracketAstNode extends ImmutableLeafAstNode {\n  get kind() {\n    return 3 /* AstNodeKind.UnexpectedClosingBracket */;\n  }\n  constructor(closingBrackets, length) {\n    super(length);\n    this.missingOpeningBracketIds = closingBrackets;\n  }\n  canBeReused(openedBracketIds) {\n    return !openedBracketIds.intersects(this.missingOpeningBracketIds);\n  }\n  computeMinIndentation(offset, textModel) {\n    return Number.MAX_SAFE_INTEGER;\n  }\n}","map":{"version":3,"names":["BugIndicatingError","CursorColumns","lengthAdd","lengthGetLineCount","lengthToObj","lengthZero","SmallImmutableSet","BaseAstNode","length","_length","constructor","PairAstNode","create","openingBracket","child","closingBracket","missingOpeningBracketIds","getEmpty","kind","listHeight","childrenLength","getChild","idx","Error","children","result","push","canBeReused","openBracketIds","intersects","deepClone","computeMinIndentation","offset","textModel","Number","MAX_SAFE_INTEGER","ListAstNode","create23","item1","item2","item3","immutable","arguments","undefined","missingBracketIds","merge","Immutable23ListAstNode","TwoThreeListAstNode","ImmutableArrayListAstNode","_missingOpeningBracketIds","cachedMinIndentation","throwIfImmutable","makeLastElementMutable","childCount","lastChild","mutable","toMutable","setChild","makeFirstElementMutable","firstChild","lastLength","handleChildrenChanged","count","unopenedBrackets","i","minIndentation","childOffset","Math","min","_item3","_item1","_item2","node","appendChildOfSameHeight","unappendChild","prependChildOfSameHeight","unprependChild","ArrayListAstNode","_children","Array","item","pop","unshift","shift","emptyArray","ImmutableLeafAstNode","TextAstNode","_openedBracketIds","start","startLineNumber","columnCount","lineCount","endLineNumber","lineNumber","firstNonWsColumn","getLineFirstNonWhitespaceColumn","lineContent","getLineContent","visibleColumn","visibleColumnFromColumn","getOptions","tabSize","BracketAstNode","bracketInfo","bracketIds","text","bracketText","languageId","InvalidBracketAstNode","closingBrackets","openedBracketIds"],"sources":["/home/arslan/modojo/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/ast.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../../../base/common/errors.js';\nimport { CursorColumns } from '../../../core/cursorColumns.js';\nimport { lengthAdd, lengthGetLineCount, lengthToObj, lengthZero } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\n/**\n * The base implementation for all AST nodes.\n*/\nclass BaseAstNode {\n    /**\n     * The length of the entire node, which should equal the sum of lengths of all children.\n    */\n    get length() {\n        return this._length;\n    }\n    constructor(length) {\n        this._length = length;\n    }\n}\n/**\n * Represents a bracket pair including its child (e.g. `{ ... }`).\n * Might be unclosed.\n * Immutable, if all children are immutable.\n*/\nexport class PairAstNode extends BaseAstNode {\n    static create(openingBracket, child, closingBracket) {\n        let length = openingBracket.length;\n        if (child) {\n            length = lengthAdd(length, child.length);\n        }\n        if (closingBracket) {\n            length = lengthAdd(length, closingBracket.length);\n        }\n        return new PairAstNode(length, openingBracket, child, closingBracket, child ? child.missingOpeningBracketIds : SmallImmutableSet.getEmpty());\n    }\n    get kind() {\n        return 2 /* AstNodeKind.Pair */;\n    }\n    get listHeight() {\n        return 0;\n    }\n    get childrenLength() {\n        return 3;\n    }\n    getChild(idx) {\n        switch (idx) {\n            case 0: return this.openingBracket;\n            case 1: return this.child;\n            case 2: return this.closingBracket;\n        }\n        throw new Error('Invalid child index');\n    }\n    /**\n     * Avoid using this property, it allocates an array!\n    */\n    get children() {\n        const result = [];\n        result.push(this.openingBracket);\n        if (this.child) {\n            result.push(this.child);\n        }\n        if (this.closingBracket) {\n            result.push(this.closingBracket);\n        }\n        return result;\n    }\n    constructor(length, openingBracket, child, closingBracket, missingOpeningBracketIds) {\n        super(length);\n        this.openingBracket = openingBracket;\n        this.child = child;\n        this.closingBracket = closingBracket;\n        this.missingOpeningBracketIds = missingOpeningBracketIds;\n    }\n    canBeReused(openBracketIds) {\n        if (this.closingBracket === null) {\n            // Unclosed pair ast nodes only\n            // end at the end of the document\n            // or when a parent node is closed.\n            // This could be improved:\n            // Only return false if some next token is neither \"undefined\" nor a bracket that closes a parent.\n            return false;\n        }\n        if (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n            return false;\n        }\n        return true;\n    }\n    deepClone() {\n        return new PairAstNode(this.length, this.openingBracket.deepClone(), this.child && this.child.deepClone(), this.closingBracket && this.closingBracket.deepClone(), this.missingOpeningBracketIds);\n    }\n    computeMinIndentation(offset, textModel) {\n        return this.child ? this.child.computeMinIndentation(lengthAdd(offset, this.openingBracket.length), textModel) : Number.MAX_SAFE_INTEGER;\n    }\n}\nexport class ListAstNode extends BaseAstNode {\n    /**\n     * This method uses more memory-efficient list nodes that can only store 2 or 3 children.\n    */\n    static create23(item1, item2, item3, immutable = false) {\n        let length = item1.length;\n        let missingBracketIds = item1.missingOpeningBracketIds;\n        if (item1.listHeight !== item2.listHeight) {\n            throw new Error('Invalid list heights');\n        }\n        length = lengthAdd(length, item2.length);\n        missingBracketIds = missingBracketIds.merge(item2.missingOpeningBracketIds);\n        if (item3) {\n            if (item1.listHeight !== item3.listHeight) {\n                throw new Error('Invalid list heights');\n            }\n            length = lengthAdd(length, item3.length);\n            missingBracketIds = missingBracketIds.merge(item3.missingOpeningBracketIds);\n        }\n        return immutable\n            ? new Immutable23ListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds)\n            : new TwoThreeListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds);\n    }\n    static getEmpty() {\n        return new ImmutableArrayListAstNode(lengthZero, 0, [], SmallImmutableSet.getEmpty());\n    }\n    get kind() {\n        return 4 /* AstNodeKind.List */;\n    }\n    get missingOpeningBracketIds() {\n        return this._missingOpeningBracketIds;\n    }\n    /**\n     * Use ListAstNode.create.\n    */\n    constructor(length, listHeight, _missingOpeningBracketIds) {\n        super(length);\n        this.listHeight = listHeight;\n        this._missingOpeningBracketIds = _missingOpeningBracketIds;\n        this.cachedMinIndentation = -1;\n    }\n    throwIfImmutable() {\n        // NOOP\n    }\n    makeLastElementMutable() {\n        this.throwIfImmutable();\n        const childCount = this.childrenLength;\n        if (childCount === 0) {\n            return undefined;\n        }\n        const lastChild = this.getChild(childCount - 1);\n        const mutable = lastChild.kind === 4 /* AstNodeKind.List */ ? lastChild.toMutable() : lastChild;\n        if (lastChild !== mutable) {\n            this.setChild(childCount - 1, mutable);\n        }\n        return mutable;\n    }\n    makeFirstElementMutable() {\n        this.throwIfImmutable();\n        const childCount = this.childrenLength;\n        if (childCount === 0) {\n            return undefined;\n        }\n        const firstChild = this.getChild(0);\n        const mutable = firstChild.kind === 4 /* AstNodeKind.List */ ? firstChild.toMutable() : firstChild;\n        if (firstChild !== mutable) {\n            this.setChild(0, mutable);\n        }\n        return mutable;\n    }\n    canBeReused(openBracketIds) {\n        if (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n            return false;\n        }\n        if (this.childrenLength === 0) {\n            // Don't reuse empty lists.\n            return false;\n        }\n        let lastChild = this;\n        while (lastChild.kind === 4 /* AstNodeKind.List */) {\n            const lastLength = lastChild.childrenLength;\n            if (lastLength === 0) {\n                // Empty lists should never be contained in other lists.\n                throw new BugIndicatingError();\n            }\n            lastChild = lastChild.getChild(lastLength - 1);\n        }\n        return lastChild.canBeReused(openBracketIds);\n    }\n    handleChildrenChanged() {\n        this.throwIfImmutable();\n        const count = this.childrenLength;\n        let length = this.getChild(0).length;\n        let unopenedBrackets = this.getChild(0).missingOpeningBracketIds;\n        for (let i = 1; i < count; i++) {\n            const child = this.getChild(i);\n            length = lengthAdd(length, child.length);\n            unopenedBrackets = unopenedBrackets.merge(child.missingOpeningBracketIds);\n        }\n        this._length = length;\n        this._missingOpeningBracketIds = unopenedBrackets;\n        this.cachedMinIndentation = -1;\n    }\n    computeMinIndentation(offset, textModel) {\n        if (this.cachedMinIndentation !== -1) {\n            return this.cachedMinIndentation;\n        }\n        let minIndentation = Number.MAX_SAFE_INTEGER;\n        let childOffset = offset;\n        for (let i = 0; i < this.childrenLength; i++) {\n            const child = this.getChild(i);\n            if (child) {\n                minIndentation = Math.min(minIndentation, child.computeMinIndentation(childOffset, textModel));\n                childOffset = lengthAdd(childOffset, child.length);\n            }\n        }\n        this.cachedMinIndentation = minIndentation;\n        return minIndentation;\n    }\n}\nclass TwoThreeListAstNode extends ListAstNode {\n    get childrenLength() {\n        return this._item3 !== null ? 3 : 2;\n    }\n    getChild(idx) {\n        switch (idx) {\n            case 0: return this._item1;\n            case 1: return this._item2;\n            case 2: return this._item3;\n        }\n        throw new Error('Invalid child index');\n    }\n    setChild(idx, node) {\n        switch (idx) {\n            case 0:\n                this._item1 = node;\n                return;\n            case 1:\n                this._item2 = node;\n                return;\n            case 2:\n                this._item3 = node;\n                return;\n        }\n        throw new Error('Invalid child index');\n    }\n    get children() {\n        return this._item3 ? [this._item1, this._item2, this._item3] : [this._item1, this._item2];\n    }\n    get item1() {\n        return this._item1;\n    }\n    get item2() {\n        return this._item2;\n    }\n    get item3() {\n        return this._item3;\n    }\n    constructor(length, listHeight, _item1, _item2, _item3, missingOpeningBracketIds) {\n        super(length, listHeight, missingOpeningBracketIds);\n        this._item1 = _item1;\n        this._item2 = _item2;\n        this._item3 = _item3;\n    }\n    deepClone() {\n        return new TwoThreeListAstNode(this.length, this.listHeight, this._item1.deepClone(), this._item2.deepClone(), this._item3 ? this._item3.deepClone() : null, this.missingOpeningBracketIds);\n    }\n    appendChildOfSameHeight(node) {\n        if (this._item3) {\n            throw new Error('Cannot append to a full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        this._item3 = node;\n        this.handleChildrenChanged();\n    }\n    unappendChild() {\n        if (!this._item3) {\n            throw new Error('Cannot remove from a non-full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        const result = this._item3;\n        this._item3 = null;\n        this.handleChildrenChanged();\n        return result;\n    }\n    prependChildOfSameHeight(node) {\n        if (this._item3) {\n            throw new Error('Cannot prepend to a full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        this._item3 = this._item2;\n        this._item2 = this._item1;\n        this._item1 = node;\n        this.handleChildrenChanged();\n    }\n    unprependChild() {\n        if (!this._item3) {\n            throw new Error('Cannot remove from a non-full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        const result = this._item1;\n        this._item1 = this._item2;\n        this._item2 = this._item3;\n        this._item3 = null;\n        this.handleChildrenChanged();\n        return result;\n    }\n    toMutable() {\n        return this;\n    }\n}\n/**\n * Immutable, if all children are immutable.\n*/\nclass Immutable23ListAstNode extends TwoThreeListAstNode {\n    toMutable() {\n        return new TwoThreeListAstNode(this.length, this.listHeight, this.item1, this.item2, this.item3, this.missingOpeningBracketIds);\n    }\n    throwIfImmutable() {\n        throw new Error('this instance is immutable');\n    }\n}\n/**\n * For debugging.\n*/\nclass ArrayListAstNode extends ListAstNode {\n    get childrenLength() {\n        return this._children.length;\n    }\n    getChild(idx) {\n        return this._children[idx];\n    }\n    setChild(idx, child) {\n        this._children[idx] = child;\n    }\n    get children() {\n        return this._children;\n    }\n    constructor(length, listHeight, _children, missingOpeningBracketIds) {\n        super(length, listHeight, missingOpeningBracketIds);\n        this._children = _children;\n    }\n    deepClone() {\n        const children = new Array(this._children.length);\n        for (let i = 0; i < this._children.length; i++) {\n            children[i] = this._children[i].deepClone();\n        }\n        return new ArrayListAstNode(this.length, this.listHeight, children, this.missingOpeningBracketIds);\n    }\n    appendChildOfSameHeight(node) {\n        this.throwIfImmutable();\n        this._children.push(node);\n        this.handleChildrenChanged();\n    }\n    unappendChild() {\n        this.throwIfImmutable();\n        const item = this._children.pop();\n        this.handleChildrenChanged();\n        return item;\n    }\n    prependChildOfSameHeight(node) {\n        this.throwIfImmutable();\n        this._children.unshift(node);\n        this.handleChildrenChanged();\n    }\n    unprependChild() {\n        this.throwIfImmutable();\n        const item = this._children.shift();\n        this.handleChildrenChanged();\n        return item;\n    }\n    toMutable() {\n        return this;\n    }\n}\n/**\n * Immutable, if all children are immutable.\n*/\nclass ImmutableArrayListAstNode extends ArrayListAstNode {\n    toMutable() {\n        return new ArrayListAstNode(this.length, this.listHeight, [...this.children], this.missingOpeningBracketIds);\n    }\n    throwIfImmutable() {\n        throw new Error('this instance is immutable');\n    }\n}\nconst emptyArray = [];\nclass ImmutableLeafAstNode extends BaseAstNode {\n    get listHeight() {\n        return 0;\n    }\n    get childrenLength() {\n        return 0;\n    }\n    getChild(idx) {\n        return null;\n    }\n    get children() {\n        return emptyArray;\n    }\n    deepClone() {\n        return this;\n    }\n}\nexport class TextAstNode extends ImmutableLeafAstNode {\n    get kind() {\n        return 0 /* AstNodeKind.Text */;\n    }\n    get missingOpeningBracketIds() {\n        return SmallImmutableSet.getEmpty();\n    }\n    canBeReused(_openedBracketIds) {\n        return true;\n    }\n    computeMinIndentation(offset, textModel) {\n        const start = lengthToObj(offset);\n        // Text ast nodes don't have partial indentation (ensured by the tokenizer).\n        // Thus, if this text node does not start at column 0, the first line cannot have any indentation at all.\n        const startLineNumber = (start.columnCount === 0 ? start.lineCount : start.lineCount + 1) + 1;\n        const endLineNumber = lengthGetLineCount(lengthAdd(offset, this.length)) + 1;\n        let result = Number.MAX_SAFE_INTEGER;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const firstNonWsColumn = textModel.getLineFirstNonWhitespaceColumn(lineNumber);\n            const lineContent = textModel.getLineContent(lineNumber);\n            if (firstNonWsColumn === 0) {\n                continue;\n            }\n            const visibleColumn = CursorColumns.visibleColumnFromColumn(lineContent, firstNonWsColumn, textModel.getOptions().tabSize);\n            result = Math.min(result, visibleColumn);\n        }\n        return result;\n    }\n}\nexport class BracketAstNode extends ImmutableLeafAstNode {\n    static create(length, bracketInfo, bracketIds) {\n        const node = new BracketAstNode(length, bracketInfo, bracketIds);\n        return node;\n    }\n    get kind() {\n        return 1 /* AstNodeKind.Bracket */;\n    }\n    get missingOpeningBracketIds() {\n        return SmallImmutableSet.getEmpty();\n    }\n    constructor(length, bracketInfo, \n    /**\n     * In case of a opening bracket, this is the id of the opening bracket.\n     * In case of a closing bracket, this contains the ids of all opening brackets it can close.\n    */\n    bracketIds) {\n        super(length);\n        this.bracketInfo = bracketInfo;\n        this.bracketIds = bracketIds;\n    }\n    get text() {\n        return this.bracketInfo.bracketText;\n    }\n    get languageId() {\n        return this.bracketInfo.languageId;\n    }\n    canBeReused(_openedBracketIds) {\n        // These nodes could be reused,\n        // but not in a general way.\n        // Their parent may be reused.\n        return false;\n    }\n    computeMinIndentation(offset, textModel) {\n        return Number.MAX_SAFE_INTEGER;\n    }\n}\nexport class InvalidBracketAstNode extends ImmutableLeafAstNode {\n    get kind() {\n        return 3 /* AstNodeKind.UnexpectedClosingBracket */;\n    }\n    constructor(closingBrackets, length) {\n        super(length);\n        this.missingOpeningBracketIds = closingBrackets;\n    }\n    canBeReused(openedBracketIds) {\n        return !openedBracketIds.intersects(this.missingOpeningBracketIds);\n    }\n    computeMinIndentation(offset, textModel) {\n        return Number.MAX_SAFE_INTEGER;\n    }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,kBAAkB,QAAQ,sCAAsC;AACzE,SAASC,aAAa,QAAQ,gCAAgC;AAC9D,SAASC,SAAS,EAAEC,kBAAkB,EAAEC,WAAW,EAAEC,UAAU,QAAQ,aAAa;AACpF,SAASC,iBAAiB,QAAQ,wBAAwB;AAC1D;AACA;AACA;AACA,MAAMC,WAAW,CAAC;EACd;AACJ;AACA;EACI,IAAIC,MAAMA,CAAA,EAAG;IACT,OAAO,IAAI,CAACC,OAAO;EACvB;EACAC,WAAWA,CAACF,MAAM,EAAE;IAChB,IAAI,CAACC,OAAO,GAAGD,MAAM;EACzB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMG,WAAW,SAASJ,WAAW,CAAC;EACzC,OAAOK,MAAMA,CAACC,cAAc,EAAEC,KAAK,EAAEC,cAAc,EAAE;IACjD,IAAIP,MAAM,GAAGK,cAAc,CAACL,MAAM;IAClC,IAAIM,KAAK,EAAE;MACPN,MAAM,GAAGN,SAAS,CAACM,MAAM,EAAEM,KAAK,CAACN,MAAM,CAAC;IAC5C;IACA,IAAIO,cAAc,EAAE;MAChBP,MAAM,GAAGN,SAAS,CAACM,MAAM,EAAEO,cAAc,CAACP,MAAM,CAAC;IACrD;IACA,OAAO,IAAIG,WAAW,CAACH,MAAM,EAAEK,cAAc,EAAEC,KAAK,EAAEC,cAAc,EAAED,KAAK,GAAGA,KAAK,CAACE,wBAAwB,GAAGV,iBAAiB,CAACW,QAAQ,CAAC,CAAC,CAAC;EAChJ;EACA,IAAIC,IAAIA,CAAA,EAAG;IACP,OAAO,CAAC,CAAC;EACb;EACA,IAAIC,UAAUA,CAAA,EAAG;IACb,OAAO,CAAC;EACZ;EACA,IAAIC,cAAcA,CAAA,EAAG;IACjB,OAAO,CAAC;EACZ;EACAC,QAAQA,CAACC,GAAG,EAAE;IACV,QAAQA,GAAG;MACP,KAAK,CAAC;QAAE,OAAO,IAAI,CAACT,cAAc;MAClC,KAAK,CAAC;QAAE,OAAO,IAAI,CAACC,KAAK;MACzB,KAAK,CAAC;QAAE,OAAO,IAAI,CAACC,cAAc;IACtC;IACA,MAAM,IAAIQ,KAAK,CAAC,qBAAqB,CAAC;EAC1C;EACA;AACJ;AACA;EACI,IAAIC,QAAQA,CAAA,EAAG;IACX,MAAMC,MAAM,GAAG,EAAE;IACjBA,MAAM,CAACC,IAAI,CAAC,IAAI,CAACb,cAAc,CAAC;IAChC,IAAI,IAAI,CAACC,KAAK,EAAE;MACZW,MAAM,CAACC,IAAI,CAAC,IAAI,CAACZ,KAAK,CAAC;IAC3B;IACA,IAAI,IAAI,CAACC,cAAc,EAAE;MACrBU,MAAM,CAACC,IAAI,CAAC,IAAI,CAACX,cAAc,CAAC;IACpC;IACA,OAAOU,MAAM;EACjB;EACAf,WAAWA,CAACF,MAAM,EAAEK,cAAc,EAAEC,KAAK,EAAEC,cAAc,EAAEC,wBAAwB,EAAE;IACjF,KAAK,CAACR,MAAM,CAAC;IACb,IAAI,CAACK,cAAc,GAAGA,cAAc;IACpC,IAAI,CAACC,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACC,cAAc,GAAGA,cAAc;IACpC,IAAI,CAACC,wBAAwB,GAAGA,wBAAwB;EAC5D;EACAW,WAAWA,CAACC,cAAc,EAAE;IACxB,IAAI,IAAI,CAACb,cAAc,KAAK,IAAI,EAAE;MAC9B;MACA;MACA;MACA;MACA;MACA,OAAO,KAAK;IAChB;IACA,IAAIa,cAAc,CAACC,UAAU,CAAC,IAAI,CAACb,wBAAwB,CAAC,EAAE;MAC1D,OAAO,KAAK;IAChB;IACA,OAAO,IAAI;EACf;EACAc,SAASA,CAAA,EAAG;IACR,OAAO,IAAInB,WAAW,CAAC,IAAI,CAACH,MAAM,EAAE,IAAI,CAACK,cAAc,CAACiB,SAAS,CAAC,CAAC,EAAE,IAAI,CAAChB,KAAK,IAAI,IAAI,CAACA,KAAK,CAACgB,SAAS,CAAC,CAAC,EAAE,IAAI,CAACf,cAAc,IAAI,IAAI,CAACA,cAAc,CAACe,SAAS,CAAC,CAAC,EAAE,IAAI,CAACd,wBAAwB,CAAC;EACrM;EACAe,qBAAqBA,CAACC,MAAM,EAAEC,SAAS,EAAE;IACrC,OAAO,IAAI,CAACnB,KAAK,GAAG,IAAI,CAACA,KAAK,CAACiB,qBAAqB,CAAC7B,SAAS,CAAC8B,MAAM,EAAE,IAAI,CAACnB,cAAc,CAACL,MAAM,CAAC,EAAEyB,SAAS,CAAC,GAAGC,MAAM,CAACC,gBAAgB;EAC5I;AACJ;AACA,OAAO,MAAMC,WAAW,SAAS7B,WAAW,CAAC;EACzC;AACJ;AACA;EACI,OAAO8B,QAAQA,CAACC,KAAK,EAAEC,KAAK,EAAEC,KAAK,EAAqB;IAAA,IAAnBC,SAAS,GAAAC,SAAA,CAAAlC,MAAA,QAAAkC,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,KAAK;IAClD,IAAIlC,MAAM,GAAG8B,KAAK,CAAC9B,MAAM;IACzB,IAAIoC,iBAAiB,GAAGN,KAAK,CAACtB,wBAAwB;IACtD,IAAIsB,KAAK,CAACnB,UAAU,KAAKoB,KAAK,CAACpB,UAAU,EAAE;MACvC,MAAM,IAAII,KAAK,CAAC,sBAAsB,CAAC;IAC3C;IACAf,MAAM,GAAGN,SAAS,CAACM,MAAM,EAAE+B,KAAK,CAAC/B,MAAM,CAAC;IACxCoC,iBAAiB,GAAGA,iBAAiB,CAACC,KAAK,CAACN,KAAK,CAACvB,wBAAwB,CAAC;IAC3E,IAAIwB,KAAK,EAAE;MACP,IAAIF,KAAK,CAACnB,UAAU,KAAKqB,KAAK,CAACrB,UAAU,EAAE;QACvC,MAAM,IAAII,KAAK,CAAC,sBAAsB,CAAC;MAC3C;MACAf,MAAM,GAAGN,SAAS,CAACM,MAAM,EAAEgC,KAAK,CAAChC,MAAM,CAAC;MACxCoC,iBAAiB,GAAGA,iBAAiB,CAACC,KAAK,CAACL,KAAK,CAACxB,wBAAwB,CAAC;IAC/E;IACA,OAAOyB,SAAS,GACV,IAAIK,sBAAsB,CAACtC,MAAM,EAAE8B,KAAK,CAACnB,UAAU,GAAG,CAAC,EAAEmB,KAAK,EAAEC,KAAK,EAAEC,KAAK,EAAEI,iBAAiB,CAAC,GAChG,IAAIG,mBAAmB,CAACvC,MAAM,EAAE8B,KAAK,CAACnB,UAAU,GAAG,CAAC,EAAEmB,KAAK,EAAEC,KAAK,EAAEC,KAAK,EAAEI,iBAAiB,CAAC;EACvG;EACA,OAAO3B,QAAQA,CAAA,EAAG;IACd,OAAO,IAAI+B,yBAAyB,CAAC3C,UAAU,EAAE,CAAC,EAAE,EAAE,EAAEC,iBAAiB,CAACW,QAAQ,CAAC,CAAC,CAAC;EACzF;EACA,IAAIC,IAAIA,CAAA,EAAG;IACP,OAAO,CAAC,CAAC;EACb;EACA,IAAIF,wBAAwBA,CAAA,EAAG;IAC3B,OAAO,IAAI,CAACiC,yBAAyB;EACzC;EACA;AACJ;AACA;EACIvC,WAAWA,CAACF,MAAM,EAAEW,UAAU,EAAE8B,yBAAyB,EAAE;IACvD,KAAK,CAACzC,MAAM,CAAC;IACb,IAAI,CAACW,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAAC8B,yBAAyB,GAAGA,yBAAyB;IAC1D,IAAI,CAACC,oBAAoB,GAAG,CAAC,CAAC;EAClC;EACAC,gBAAgBA,CAAA,EAAG;IACf;EAAA;EAEJC,sBAAsBA,CAAA,EAAG;IACrB,IAAI,CAACD,gBAAgB,CAAC,CAAC;IACvB,MAAME,UAAU,GAAG,IAAI,CAACjC,cAAc;IACtC,IAAIiC,UAAU,KAAK,CAAC,EAAE;MAClB,OAAOV,SAAS;IACpB;IACA,MAAMW,SAAS,GAAG,IAAI,CAACjC,QAAQ,CAACgC,UAAU,GAAG,CAAC,CAAC;IAC/C,MAAME,OAAO,GAAGD,SAAS,CAACpC,IAAI,KAAK,CAAC,CAAC,yBAAyBoC,SAAS,CAACE,SAAS,CAAC,CAAC,GAAGF,SAAS;IAC/F,IAAIA,SAAS,KAAKC,OAAO,EAAE;MACvB,IAAI,CAACE,QAAQ,CAACJ,UAAU,GAAG,CAAC,EAAEE,OAAO,CAAC;IAC1C;IACA,OAAOA,OAAO;EAClB;EACAG,uBAAuBA,CAAA,EAAG;IACtB,IAAI,CAACP,gBAAgB,CAAC,CAAC;IACvB,MAAME,UAAU,GAAG,IAAI,CAACjC,cAAc;IACtC,IAAIiC,UAAU,KAAK,CAAC,EAAE;MAClB,OAAOV,SAAS;IACpB;IACA,MAAMgB,UAAU,GAAG,IAAI,CAACtC,QAAQ,CAAC,CAAC,CAAC;IACnC,MAAMkC,OAAO,GAAGI,UAAU,CAACzC,IAAI,KAAK,CAAC,CAAC,yBAAyByC,UAAU,CAACH,SAAS,CAAC,CAAC,GAAGG,UAAU;IAClG,IAAIA,UAAU,KAAKJ,OAAO,EAAE;MACxB,IAAI,CAACE,QAAQ,CAAC,CAAC,EAAEF,OAAO,CAAC;IAC7B;IACA,OAAOA,OAAO;EAClB;EACA5B,WAAWA,CAACC,cAAc,EAAE;IACxB,IAAIA,cAAc,CAACC,UAAU,CAAC,IAAI,CAACb,wBAAwB,CAAC,EAAE;MAC1D,OAAO,KAAK;IAChB;IACA,IAAI,IAAI,CAACI,cAAc,KAAK,CAAC,EAAE;MAC3B;MACA,OAAO,KAAK;IAChB;IACA,IAAIkC,SAAS,GAAG,IAAI;IACpB,OAAOA,SAAS,CAACpC,IAAI,KAAK,CAAC,CAAC,wBAAwB;MAChD,MAAM0C,UAAU,GAAGN,SAAS,CAAClC,cAAc;MAC3C,IAAIwC,UAAU,KAAK,CAAC,EAAE;QAClB;QACA,MAAM,IAAI5D,kBAAkB,CAAC,CAAC;MAClC;MACAsD,SAAS,GAAGA,SAAS,CAACjC,QAAQ,CAACuC,UAAU,GAAG,CAAC,CAAC;IAClD;IACA,OAAON,SAAS,CAAC3B,WAAW,CAACC,cAAc,CAAC;EAChD;EACAiC,qBAAqBA,CAAA,EAAG;IACpB,IAAI,CAACV,gBAAgB,CAAC,CAAC;IACvB,MAAMW,KAAK,GAAG,IAAI,CAAC1C,cAAc;IACjC,IAAIZ,MAAM,GAAG,IAAI,CAACa,QAAQ,CAAC,CAAC,CAAC,CAACb,MAAM;IACpC,IAAIuD,gBAAgB,GAAG,IAAI,CAAC1C,QAAQ,CAAC,CAAC,CAAC,CAACL,wBAAwB;IAChE,KAAK,IAAIgD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,KAAK,EAAEE,CAAC,EAAE,EAAE;MAC5B,MAAMlD,KAAK,GAAG,IAAI,CAACO,QAAQ,CAAC2C,CAAC,CAAC;MAC9BxD,MAAM,GAAGN,SAAS,CAACM,MAAM,EAAEM,KAAK,CAACN,MAAM,CAAC;MACxCuD,gBAAgB,GAAGA,gBAAgB,CAAClB,KAAK,CAAC/B,KAAK,CAACE,wBAAwB,CAAC;IAC7E;IACA,IAAI,CAACP,OAAO,GAAGD,MAAM;IACrB,IAAI,CAACyC,yBAAyB,GAAGc,gBAAgB;IACjD,IAAI,CAACb,oBAAoB,GAAG,CAAC,CAAC;EAClC;EACAnB,qBAAqBA,CAACC,MAAM,EAAEC,SAAS,EAAE;IACrC,IAAI,IAAI,CAACiB,oBAAoB,KAAK,CAAC,CAAC,EAAE;MAClC,OAAO,IAAI,CAACA,oBAAoB;IACpC;IACA,IAAIe,cAAc,GAAG/B,MAAM,CAACC,gBAAgB;IAC5C,IAAI+B,WAAW,GAAGlC,MAAM;IACxB,KAAK,IAAIgC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAC5C,cAAc,EAAE4C,CAAC,EAAE,EAAE;MAC1C,MAAMlD,KAAK,GAAG,IAAI,CAACO,QAAQ,CAAC2C,CAAC,CAAC;MAC9B,IAAIlD,KAAK,EAAE;QACPmD,cAAc,GAAGE,IAAI,CAACC,GAAG,CAACH,cAAc,EAAEnD,KAAK,CAACiB,qBAAqB,CAACmC,WAAW,EAAEjC,SAAS,CAAC,CAAC;QAC9FiC,WAAW,GAAGhE,SAAS,CAACgE,WAAW,EAAEpD,KAAK,CAACN,MAAM,CAAC;MACtD;IACJ;IACA,IAAI,CAAC0C,oBAAoB,GAAGe,cAAc;IAC1C,OAAOA,cAAc;EACzB;AACJ;AACA,MAAMlB,mBAAmB,SAASX,WAAW,CAAC;EAC1C,IAAIhB,cAAcA,CAAA,EAAG;IACjB,OAAO,IAAI,CAACiD,MAAM,KAAK,IAAI,GAAG,CAAC,GAAG,CAAC;EACvC;EACAhD,QAAQA,CAACC,GAAG,EAAE;IACV,QAAQA,GAAG;MACP,KAAK,CAAC;QAAE,OAAO,IAAI,CAACgD,MAAM;MAC1B,KAAK,CAAC;QAAE,OAAO,IAAI,CAACC,MAAM;MAC1B,KAAK,CAAC;QAAE,OAAO,IAAI,CAACF,MAAM;IAC9B;IACA,MAAM,IAAI9C,KAAK,CAAC,qBAAqB,CAAC;EAC1C;EACAkC,QAAQA,CAACnC,GAAG,EAAEkD,IAAI,EAAE;IAChB,QAAQlD,GAAG;MACP,KAAK,CAAC;QACF,IAAI,CAACgD,MAAM,GAAGE,IAAI;QAClB;MACJ,KAAK,CAAC;QACF,IAAI,CAACD,MAAM,GAAGC,IAAI;QAClB;MACJ,KAAK,CAAC;QACF,IAAI,CAACH,MAAM,GAAGG,IAAI;QAClB;IACR;IACA,MAAM,IAAIjD,KAAK,CAAC,qBAAqB,CAAC;EAC1C;EACA,IAAIC,QAAQA,CAAA,EAAG;IACX,OAAO,IAAI,CAAC6C,MAAM,GAAG,CAAC,IAAI,CAACC,MAAM,EAAE,IAAI,CAACC,MAAM,EAAE,IAAI,CAACF,MAAM,CAAC,GAAG,CAAC,IAAI,CAACC,MAAM,EAAE,IAAI,CAACC,MAAM,CAAC;EAC7F;EACA,IAAIjC,KAAKA,CAAA,EAAG;IACR,OAAO,IAAI,CAACgC,MAAM;EACtB;EACA,IAAI/B,KAAKA,CAAA,EAAG;IACR,OAAO,IAAI,CAACgC,MAAM;EACtB;EACA,IAAI/B,KAAKA,CAAA,EAAG;IACR,OAAO,IAAI,CAAC6B,MAAM;EACtB;EACA3D,WAAWA,CAACF,MAAM,EAAEW,UAAU,EAAEmD,MAAM,EAAEC,MAAM,EAAEF,MAAM,EAAErD,wBAAwB,EAAE;IAC9E,KAAK,CAACR,MAAM,EAAEW,UAAU,EAAEH,wBAAwB,CAAC;IACnD,IAAI,CAACsD,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACF,MAAM,GAAGA,MAAM;EACxB;EACAvC,SAASA,CAAA,EAAG;IACR,OAAO,IAAIiB,mBAAmB,CAAC,IAAI,CAACvC,MAAM,EAAE,IAAI,CAACW,UAAU,EAAE,IAAI,CAACmD,MAAM,CAACxC,SAAS,CAAC,CAAC,EAAE,IAAI,CAACyC,MAAM,CAACzC,SAAS,CAAC,CAAC,EAAE,IAAI,CAACuC,MAAM,GAAG,IAAI,CAACA,MAAM,CAACvC,SAAS,CAAC,CAAC,GAAG,IAAI,EAAE,IAAI,CAACd,wBAAwB,CAAC;EAC/L;EACAyD,uBAAuBA,CAACD,IAAI,EAAE;IAC1B,IAAI,IAAI,CAACH,MAAM,EAAE;MACb,MAAM,IAAI9C,KAAK,CAAC,yCAAyC,CAAC;IAC9D;IACA,IAAI,CAAC4B,gBAAgB,CAAC,CAAC;IACvB,IAAI,CAACkB,MAAM,GAAGG,IAAI;IAClB,IAAI,CAACX,qBAAqB,CAAC,CAAC;EAChC;EACAa,aAAaA,CAAA,EAAG;IACZ,IAAI,CAAC,IAAI,CAACL,MAAM,EAAE;MACd,MAAM,IAAI9C,KAAK,CAAC,+CAA+C,CAAC;IACpE;IACA,IAAI,CAAC4B,gBAAgB,CAAC,CAAC;IACvB,MAAM1B,MAAM,GAAG,IAAI,CAAC4C,MAAM;IAC1B,IAAI,CAACA,MAAM,GAAG,IAAI;IAClB,IAAI,CAACR,qBAAqB,CAAC,CAAC;IAC5B,OAAOpC,MAAM;EACjB;EACAkD,wBAAwBA,CAACH,IAAI,EAAE;IAC3B,IAAI,IAAI,CAACH,MAAM,EAAE;MACb,MAAM,IAAI9C,KAAK,CAAC,0CAA0C,CAAC;IAC/D;IACA,IAAI,CAAC4B,gBAAgB,CAAC,CAAC;IACvB,IAAI,CAACkB,MAAM,GAAG,IAAI,CAACE,MAAM;IACzB,IAAI,CAACA,MAAM,GAAG,IAAI,CAACD,MAAM;IACzB,IAAI,CAACA,MAAM,GAAGE,IAAI;IAClB,IAAI,CAACX,qBAAqB,CAAC,CAAC;EAChC;EACAe,cAAcA,CAAA,EAAG;IACb,IAAI,CAAC,IAAI,CAACP,MAAM,EAAE;MACd,MAAM,IAAI9C,KAAK,CAAC,+CAA+C,CAAC;IACpE;IACA,IAAI,CAAC4B,gBAAgB,CAAC,CAAC;IACvB,MAAM1B,MAAM,GAAG,IAAI,CAAC6C,MAAM;IAC1B,IAAI,CAACA,MAAM,GAAG,IAAI,CAACC,MAAM;IACzB,IAAI,CAACA,MAAM,GAAG,IAAI,CAACF,MAAM;IACzB,IAAI,CAACA,MAAM,GAAG,IAAI;IAClB,IAAI,CAACR,qBAAqB,CAAC,CAAC;IAC5B,OAAOpC,MAAM;EACjB;EACA+B,SAASA,CAAA,EAAG;IACR,OAAO,IAAI;EACf;AACJ;AACA;AACA;AACA;AACA,MAAMV,sBAAsB,SAASC,mBAAmB,CAAC;EACrDS,SAASA,CAAA,EAAG;IACR,OAAO,IAAIT,mBAAmB,CAAC,IAAI,CAACvC,MAAM,EAAE,IAAI,CAACW,UAAU,EAAE,IAAI,CAACmB,KAAK,EAAE,IAAI,CAACC,KAAK,EAAE,IAAI,CAACC,KAAK,EAAE,IAAI,CAACxB,wBAAwB,CAAC;EACnI;EACAmC,gBAAgBA,CAAA,EAAG;IACf,MAAM,IAAI5B,KAAK,CAAC,4BAA4B,CAAC;EACjD;AACJ;AACA;AACA;AACA;AACA,MAAMsD,gBAAgB,SAASzC,WAAW,CAAC;EACvC,IAAIhB,cAAcA,CAAA,EAAG;IACjB,OAAO,IAAI,CAAC0D,SAAS,CAACtE,MAAM;EAChC;EACAa,QAAQA,CAACC,GAAG,EAAE;IACV,OAAO,IAAI,CAACwD,SAAS,CAACxD,GAAG,CAAC;EAC9B;EACAmC,QAAQA,CAACnC,GAAG,EAAER,KAAK,EAAE;IACjB,IAAI,CAACgE,SAAS,CAACxD,GAAG,CAAC,GAAGR,KAAK;EAC/B;EACA,IAAIU,QAAQA,CAAA,EAAG;IACX,OAAO,IAAI,CAACsD,SAAS;EACzB;EACApE,WAAWA,CAACF,MAAM,EAAEW,UAAU,EAAE2D,SAAS,EAAE9D,wBAAwB,EAAE;IACjE,KAAK,CAACR,MAAM,EAAEW,UAAU,EAAEH,wBAAwB,CAAC;IACnD,IAAI,CAAC8D,SAAS,GAAGA,SAAS;EAC9B;EACAhD,SAASA,CAAA,EAAG;IACR,MAAMN,QAAQ,GAAG,IAAIuD,KAAK,CAAC,IAAI,CAACD,SAAS,CAACtE,MAAM,CAAC;IACjD,KAAK,IAAIwD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACc,SAAS,CAACtE,MAAM,EAAEwD,CAAC,EAAE,EAAE;MAC5CxC,QAAQ,CAACwC,CAAC,CAAC,GAAG,IAAI,CAACc,SAAS,CAACd,CAAC,CAAC,CAAClC,SAAS,CAAC,CAAC;IAC/C;IACA,OAAO,IAAI+C,gBAAgB,CAAC,IAAI,CAACrE,MAAM,EAAE,IAAI,CAACW,UAAU,EAAEK,QAAQ,EAAE,IAAI,CAACR,wBAAwB,CAAC;EACtG;EACAyD,uBAAuBA,CAACD,IAAI,EAAE;IAC1B,IAAI,CAACrB,gBAAgB,CAAC,CAAC;IACvB,IAAI,CAAC2B,SAAS,CAACpD,IAAI,CAAC8C,IAAI,CAAC;IACzB,IAAI,CAACX,qBAAqB,CAAC,CAAC;EAChC;EACAa,aAAaA,CAAA,EAAG;IACZ,IAAI,CAACvB,gBAAgB,CAAC,CAAC;IACvB,MAAM6B,IAAI,GAAG,IAAI,CAACF,SAAS,CAACG,GAAG,CAAC,CAAC;IACjC,IAAI,CAACpB,qBAAqB,CAAC,CAAC;IAC5B,OAAOmB,IAAI;EACf;EACAL,wBAAwBA,CAACH,IAAI,EAAE;IAC3B,IAAI,CAACrB,gBAAgB,CAAC,CAAC;IACvB,IAAI,CAAC2B,SAAS,CAACI,OAAO,CAACV,IAAI,CAAC;IAC5B,IAAI,CAACX,qBAAqB,CAAC,CAAC;EAChC;EACAe,cAAcA,CAAA,EAAG;IACb,IAAI,CAACzB,gBAAgB,CAAC,CAAC;IACvB,MAAM6B,IAAI,GAAG,IAAI,CAACF,SAAS,CAACK,KAAK,CAAC,CAAC;IACnC,IAAI,CAACtB,qBAAqB,CAAC,CAAC;IAC5B,OAAOmB,IAAI;EACf;EACAxB,SAASA,CAAA,EAAG;IACR,OAAO,IAAI;EACf;AACJ;AACA;AACA;AACA;AACA,MAAMR,yBAAyB,SAAS6B,gBAAgB,CAAC;EACrDrB,SAASA,CAAA,EAAG;IACR,OAAO,IAAIqB,gBAAgB,CAAC,IAAI,CAACrE,MAAM,EAAE,IAAI,CAACW,UAAU,EAAE,CAAC,GAAG,IAAI,CAACK,QAAQ,CAAC,EAAE,IAAI,CAACR,wBAAwB,CAAC;EAChH;EACAmC,gBAAgBA,CAAA,EAAG;IACf,MAAM,IAAI5B,KAAK,CAAC,4BAA4B,CAAC;EACjD;AACJ;AACA,MAAM6D,UAAU,GAAG,EAAE;AACrB,MAAMC,oBAAoB,SAAS9E,WAAW,CAAC;EAC3C,IAAIY,UAAUA,CAAA,EAAG;IACb,OAAO,CAAC;EACZ;EACA,IAAIC,cAAcA,CAAA,EAAG;IACjB,OAAO,CAAC;EACZ;EACAC,QAAQA,CAACC,GAAG,EAAE;IACV,OAAO,IAAI;EACf;EACA,IAAIE,QAAQA,CAAA,EAAG;IACX,OAAO4D,UAAU;EACrB;EACAtD,SAASA,CAAA,EAAG;IACR,OAAO,IAAI;EACf;AACJ;AACA,OAAO,MAAMwD,WAAW,SAASD,oBAAoB,CAAC;EAClD,IAAInE,IAAIA,CAAA,EAAG;IACP,OAAO,CAAC,CAAC;EACb;EACA,IAAIF,wBAAwBA,CAAA,EAAG;IAC3B,OAAOV,iBAAiB,CAACW,QAAQ,CAAC,CAAC;EACvC;EACAU,WAAWA,CAAC4D,iBAAiB,EAAE;IAC3B,OAAO,IAAI;EACf;EACAxD,qBAAqBA,CAACC,MAAM,EAAEC,SAAS,EAAE;IACrC,MAAMuD,KAAK,GAAGpF,WAAW,CAAC4B,MAAM,CAAC;IACjC;IACA;IACA,MAAMyD,eAAe,GAAG,CAACD,KAAK,CAACE,WAAW,KAAK,CAAC,GAAGF,KAAK,CAACG,SAAS,GAAGH,KAAK,CAACG,SAAS,GAAG,CAAC,IAAI,CAAC;IAC7F,MAAMC,aAAa,GAAGzF,kBAAkB,CAACD,SAAS,CAAC8B,MAAM,EAAE,IAAI,CAACxB,MAAM,CAAC,CAAC,GAAG,CAAC;IAC5E,IAAIiB,MAAM,GAAGS,MAAM,CAACC,gBAAgB;IACpC,KAAK,IAAI0D,UAAU,GAAGJ,eAAe,EAAEI,UAAU,IAAID,aAAa,EAAEC,UAAU,EAAE,EAAE;MAC9E,MAAMC,gBAAgB,GAAG7D,SAAS,CAAC8D,+BAA+B,CAACF,UAAU,CAAC;MAC9E,MAAMG,WAAW,GAAG/D,SAAS,CAACgE,cAAc,CAACJ,UAAU,CAAC;MACxD,IAAIC,gBAAgB,KAAK,CAAC,EAAE;QACxB;MACJ;MACA,MAAMI,aAAa,GAAGjG,aAAa,CAACkG,uBAAuB,CAACH,WAAW,EAAEF,gBAAgB,EAAE7D,SAAS,CAACmE,UAAU,CAAC,CAAC,CAACC,OAAO,CAAC;MAC1H5E,MAAM,GAAG0C,IAAI,CAACC,GAAG,CAAC3C,MAAM,EAAEyE,aAAa,CAAC;IAC5C;IACA,OAAOzE,MAAM;EACjB;AACJ;AACA,OAAO,MAAM6E,cAAc,SAASjB,oBAAoB,CAAC;EACrD,OAAOzE,MAAMA,CAACJ,MAAM,EAAE+F,WAAW,EAAEC,UAAU,EAAE;IAC3C,MAAMhC,IAAI,GAAG,IAAI8B,cAAc,CAAC9F,MAAM,EAAE+F,WAAW,EAAEC,UAAU,CAAC;IAChE,OAAOhC,IAAI;EACf;EACA,IAAItD,IAAIA,CAAA,EAAG;IACP,OAAO,CAAC,CAAC;EACb;EACA,IAAIF,wBAAwBA,CAAA,EAAG;IAC3B,OAAOV,iBAAiB,CAACW,QAAQ,CAAC,CAAC;EACvC;EACAP,WAAWA,CAACF,MAAM,EAAE+F,WAAW;EAC/B;AACJ;AACA;AACA;EACIC,UAAU,EAAE;IACR,KAAK,CAAChG,MAAM,CAAC;IACb,IAAI,CAAC+F,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACC,UAAU,GAAGA,UAAU;EAChC;EACA,IAAIC,IAAIA,CAAA,EAAG;IACP,OAAO,IAAI,CAACF,WAAW,CAACG,WAAW;EACvC;EACA,IAAIC,UAAUA,CAAA,EAAG;IACb,OAAO,IAAI,CAACJ,WAAW,CAACI,UAAU;EACtC;EACAhF,WAAWA,CAAC4D,iBAAiB,EAAE;IAC3B;IACA;IACA;IACA,OAAO,KAAK;EAChB;EACAxD,qBAAqBA,CAACC,MAAM,EAAEC,SAAS,EAAE;IACrC,OAAOC,MAAM,CAACC,gBAAgB;EAClC;AACJ;AACA,OAAO,MAAMyE,qBAAqB,SAASvB,oBAAoB,CAAC;EAC5D,IAAInE,IAAIA,CAAA,EAAG;IACP,OAAO,CAAC,CAAC;EACb;EACAR,WAAWA,CAACmG,eAAe,EAAErG,MAAM,EAAE;IACjC,KAAK,CAACA,MAAM,CAAC;IACb,IAAI,CAACQ,wBAAwB,GAAG6F,eAAe;EACnD;EACAlF,WAAWA,CAACmF,gBAAgB,EAAE;IAC1B,OAAO,CAACA,gBAAgB,CAACjF,UAAU,CAAC,IAAI,CAACb,wBAAwB,CAAC;EACtE;EACAe,qBAAqBA,CAACC,MAAM,EAAEC,SAAS,EAAE;IACrC,OAAOC,MAAM,CAACC,gBAAgB;EAClC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}