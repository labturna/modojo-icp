{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertNever } from '../../base/common/assert.js';\nimport { Position } from './core/position.js';\nimport { InjectedTextCursorStops } from './model.js';\n/**\n * *input*:\n * ```\n * xxxxxxxxxxxxxxxxxxxxxxxxxxx\n * ```\n *\n * -> Applying injections `[i...i]`, *inputWithInjections*:\n * ```\n * xxxxxx[iiiiiiiiii]xxxxxxxxxxxxxxxxx[ii]xxxx\n * ```\n *\n * -> breaking at offsets `|` in `xxxxxx[iiiiiii|iii]xxxxxxxxxxx|xxxxxx[ii]xxxx|`:\n * ```\n * xxxxxx[iiiiiii\n * iii]xxxxxxxxxxx\n * xxxxxx[ii]xxxx\n * ```\n *\n * -> applying wrappedTextIndentLength, *output*:\n * ```\n * xxxxxx[iiiiiii\n *    iii]xxxxxxxxxxx\n *    xxxxxx[ii]xxxx\n * ```\n */\nexport class ModelLineProjectionData {\n  constructor(injectionOffsets,\n  /**\n   * `injectionOptions.length` must equal `injectionOffsets.length`\n   */\n  injectionOptions,\n  /**\n   * Refers to offsets after applying injections to the source.\n   * The last break offset indicates the length of the source after applying injections.\n   */\n  breakOffsets,\n  /**\n   * Refers to offsets after applying injections\n   */\n  breakOffsetsVisibleColumn, wrappedTextIndentLength) {\n    this.injectionOffsets = injectionOffsets;\n    this.injectionOptions = injectionOptions;\n    this.breakOffsets = breakOffsets;\n    this.breakOffsetsVisibleColumn = breakOffsetsVisibleColumn;\n    this.wrappedTextIndentLength = wrappedTextIndentLength;\n  }\n  getOutputLineCount() {\n    return this.breakOffsets.length;\n  }\n  getMinOutputOffset(outputLineIndex) {\n    if (outputLineIndex > 0) {\n      return this.wrappedTextIndentLength;\n    }\n    return 0;\n  }\n  getLineLength(outputLineIndex) {\n    // These offsets refer to model text with injected text.\n    const startOffset = outputLineIndex > 0 ? this.breakOffsets[outputLineIndex - 1] : 0;\n    const endOffset = this.breakOffsets[outputLineIndex];\n    let lineLength = endOffset - startOffset;\n    if (outputLineIndex > 0) {\n      lineLength += this.wrappedTextIndentLength;\n    }\n    return lineLength;\n  }\n  getMaxOutputOffset(outputLineIndex) {\n    return this.getLineLength(outputLineIndex);\n  }\n  translateToInputOffset(outputLineIndex, outputOffset) {\n    if (outputLineIndex > 0) {\n      outputOffset = Math.max(0, outputOffset - this.wrappedTextIndentLength);\n    }\n    const offsetInInputWithInjection = outputLineIndex === 0 ? outputOffset : this.breakOffsets[outputLineIndex - 1] + outputOffset;\n    let offsetInInput = offsetInInputWithInjection;\n    if (this.injectionOffsets !== null) {\n      for (let i = 0; i < this.injectionOffsets.length; i++) {\n        if (offsetInInput > this.injectionOffsets[i]) {\n          if (offsetInInput < this.injectionOffsets[i] + this.injectionOptions[i].content.length) {\n            // `inputOffset` is within injected text\n            offsetInInput = this.injectionOffsets[i];\n          } else {\n            offsetInInput -= this.injectionOptions[i].content.length;\n          }\n        } else {\n          break;\n        }\n      }\n    }\n    return offsetInInput;\n  }\n  translateToOutputPosition(inputOffset) {\n    let affinity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n    let inputOffsetInInputWithInjection = inputOffset;\n    if (this.injectionOffsets !== null) {\n      for (let i = 0; i < this.injectionOffsets.length; i++) {\n        if (inputOffset < this.injectionOffsets[i]) {\n          break;\n        }\n        if (affinity !== 1 /* PositionAffinity.Right */ && inputOffset === this.injectionOffsets[i]) {\n          break;\n        }\n        inputOffsetInInputWithInjection += this.injectionOptions[i].content.length;\n      }\n    }\n    return this.offsetInInputWithInjectionsToOutputPosition(inputOffsetInInputWithInjection, affinity);\n  }\n  offsetInInputWithInjectionsToOutputPosition(offsetInInputWithInjections) {\n    let affinity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n    let low = 0;\n    let high = this.breakOffsets.length - 1;\n    let mid = 0;\n    let midStart = 0;\n    while (low <= high) {\n      mid = low + (high - low) / 2 | 0;\n      const midStop = this.breakOffsets[mid];\n      midStart = mid > 0 ? this.breakOffsets[mid - 1] : 0;\n      if (affinity === 0 /* PositionAffinity.Left */) {\n        if (offsetInInputWithInjections <= midStart) {\n          high = mid - 1;\n        } else if (offsetInInputWithInjections > midStop) {\n          low = mid + 1;\n        } else {\n          break;\n        }\n      } else {\n        if (offsetInInputWithInjections < midStart) {\n          high = mid - 1;\n        } else if (offsetInInputWithInjections >= midStop) {\n          low = mid + 1;\n        } else {\n          break;\n        }\n      }\n    }\n    let outputOffset = offsetInInputWithInjections - midStart;\n    if (mid > 0) {\n      outputOffset += this.wrappedTextIndentLength;\n    }\n    return new OutputPosition(mid, outputOffset);\n  }\n  normalizeOutputPosition(outputLineIndex, outputOffset, affinity) {\n    if (this.injectionOffsets !== null) {\n      const offsetInInputWithInjections = this.outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset);\n      const normalizedOffsetInUnwrappedLine = this.normalizeOffsetInInputWithInjectionsAroundInjections(offsetInInputWithInjections, affinity);\n      if (normalizedOffsetInUnwrappedLine !== offsetInInputWithInjections) {\n        // injected text caused a change\n        return this.offsetInInputWithInjectionsToOutputPosition(normalizedOffsetInUnwrappedLine, affinity);\n      }\n    }\n    if (affinity === 0 /* PositionAffinity.Left */) {\n      if (outputLineIndex > 0 && outputOffset === this.getMinOutputOffset(outputLineIndex)) {\n        return new OutputPosition(outputLineIndex - 1, this.getMaxOutputOffset(outputLineIndex - 1));\n      }\n    } else if (affinity === 1 /* PositionAffinity.Right */) {\n      const maxOutputLineIndex = this.getOutputLineCount() - 1;\n      if (outputLineIndex < maxOutputLineIndex && outputOffset === this.getMaxOutputOffset(outputLineIndex)) {\n        return new OutputPosition(outputLineIndex + 1, this.getMinOutputOffset(outputLineIndex + 1));\n      }\n    }\n    return new OutputPosition(outputLineIndex, outputOffset);\n  }\n  outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset) {\n    if (outputLineIndex > 0) {\n      outputOffset = Math.max(0, outputOffset - this.wrappedTextIndentLength);\n    }\n    const result = (outputLineIndex > 0 ? this.breakOffsets[outputLineIndex - 1] : 0) + outputOffset;\n    return result;\n  }\n  normalizeOffsetInInputWithInjectionsAroundInjections(offsetInInputWithInjections, affinity) {\n    const injectedText = this.getInjectedTextAtOffset(offsetInInputWithInjections);\n    if (!injectedText) {\n      return offsetInInputWithInjections;\n    }\n    if (affinity === 2 /* PositionAffinity.None */) {\n      if (offsetInInputWithInjections === injectedText.offsetInInputWithInjections + injectedText.length && hasRightCursorStop(this.injectionOptions[injectedText.injectedTextIndex].cursorStops)) {\n        return injectedText.offsetInInputWithInjections + injectedText.length;\n      } else {\n        let result = injectedText.offsetInInputWithInjections;\n        if (hasLeftCursorStop(this.injectionOptions[injectedText.injectedTextIndex].cursorStops)) {\n          return result;\n        }\n        let index = injectedText.injectedTextIndex - 1;\n        while (index >= 0 && this.injectionOffsets[index] === this.injectionOffsets[injectedText.injectedTextIndex]) {\n          if (hasRightCursorStop(this.injectionOptions[index].cursorStops)) {\n            break;\n          }\n          result -= this.injectionOptions[index].content.length;\n          if (hasLeftCursorStop(this.injectionOptions[index].cursorStops)) {\n            break;\n          }\n          index--;\n        }\n        return result;\n      }\n    } else if (affinity === 1 /* PositionAffinity.Right */ || affinity === 4 /* PositionAffinity.RightOfInjectedText */) {\n      let result = injectedText.offsetInInputWithInjections + injectedText.length;\n      let index = injectedText.injectedTextIndex;\n      // traverse all injected text that touch each other\n      while (index + 1 < this.injectionOffsets.length && this.injectionOffsets[index + 1] === this.injectionOffsets[index]) {\n        result += this.injectionOptions[index + 1].content.length;\n        index++;\n      }\n      return result;\n    } else if (affinity === 0 /* PositionAffinity.Left */ || affinity === 3 /* PositionAffinity.LeftOfInjectedText */) {\n      // affinity is left\n      let result = injectedText.offsetInInputWithInjections;\n      let index = injectedText.injectedTextIndex;\n      // traverse all injected text that touch each other\n      while (index - 1 >= 0 && this.injectionOffsets[index - 1] === this.injectionOffsets[index]) {\n        result -= this.injectionOptions[index - 1].content.length;\n        index--;\n      }\n      return result;\n    }\n    assertNever(affinity);\n  }\n  getInjectedText(outputLineIndex, outputOffset) {\n    const offset = this.outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset);\n    const injectedText = this.getInjectedTextAtOffset(offset);\n    if (!injectedText) {\n      return null;\n    }\n    return {\n      options: this.injectionOptions[injectedText.injectedTextIndex]\n    };\n  }\n  getInjectedTextAtOffset(offsetInInputWithInjections) {\n    const injectionOffsets = this.injectionOffsets;\n    const injectionOptions = this.injectionOptions;\n    if (injectionOffsets !== null) {\n      let totalInjectedTextLengthBefore = 0;\n      for (let i = 0; i < injectionOffsets.length; i++) {\n        const length = injectionOptions[i].content.length;\n        const injectedTextStartOffsetInInputWithInjections = injectionOffsets[i] + totalInjectedTextLengthBefore;\n        const injectedTextEndOffsetInInputWithInjections = injectionOffsets[i] + totalInjectedTextLengthBefore + length;\n        if (injectedTextStartOffsetInInputWithInjections > offsetInInputWithInjections) {\n          // Injected text starts later.\n          break; // All later injected texts have an even larger offset.\n        }\n        if (offsetInInputWithInjections <= injectedTextEndOffsetInInputWithInjections) {\n          // Injected text ends after or with the given position (but also starts with or before it).\n          return {\n            injectedTextIndex: i,\n            offsetInInputWithInjections: injectedTextStartOffsetInInputWithInjections,\n            length\n          };\n        }\n        totalInjectedTextLengthBefore += length;\n      }\n    }\n    return undefined;\n  }\n}\nfunction hasRightCursorStop(cursorStop) {\n  if (cursorStop === null || cursorStop === undefined) {\n    return true;\n  }\n  return cursorStop === InjectedTextCursorStops.Right || cursorStop === InjectedTextCursorStops.Both;\n}\nfunction hasLeftCursorStop(cursorStop) {\n  if (cursorStop === null || cursorStop === undefined) {\n    return true;\n  }\n  return cursorStop === InjectedTextCursorStops.Left || cursorStop === InjectedTextCursorStops.Both;\n}\nexport class InjectedText {\n  constructor(options) {\n    this.options = options;\n  }\n}\nexport class OutputPosition {\n  constructor(outputLineIndex, outputOffset) {\n    this.outputLineIndex = outputLineIndex;\n    this.outputOffset = outputOffset;\n  }\n  toString() {\n    return `${this.outputLineIndex}:${this.outputOffset}`;\n  }\n  toPosition(baseLineNumber) {\n    return new Position(baseLineNumber + this.outputLineIndex, this.outputOffset + 1);\n  }\n}","map":{"version":3,"names":["assertNever","Position","InjectedTextCursorStops","ModelLineProjectionData","constructor","injectionOffsets","injectionOptions","breakOffsets","breakOffsetsVisibleColumn","wrappedTextIndentLength","getOutputLineCount","length","getMinOutputOffset","outputLineIndex","getLineLength","startOffset","endOffset","lineLength","getMaxOutputOffset","translateToInputOffset","outputOffset","Math","max","offsetInInputWithInjection","offsetInInput","i","content","translateToOutputPosition","inputOffset","affinity","arguments","undefined","inputOffsetInInputWithInjection","offsetInInputWithInjectionsToOutputPosition","offsetInInputWithInjections","low","high","mid","midStart","midStop","OutputPosition","normalizeOutputPosition","outputPositionToOffsetInInputWithInjections","normalizedOffsetInUnwrappedLine","normalizeOffsetInInputWithInjectionsAroundInjections","maxOutputLineIndex","result","injectedText","getInjectedTextAtOffset","hasRightCursorStop","injectedTextIndex","cursorStops","hasLeftCursorStop","index","getInjectedText","offset","options","totalInjectedTextLengthBefore","injectedTextStartOffsetInInputWithInjections","injectedTextEndOffsetInInputWithInjections","cursorStop","Right","Both","Left","InjectedText","toString","toPosition","baseLineNumber"],"sources":["/home/arslan/modojo/node_modules/monaco-editor/esm/vs/editor/common/modelLineProjectionData.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertNever } from '../../base/common/assert.js';\nimport { Position } from './core/position.js';\nimport { InjectedTextCursorStops } from './model.js';\n/**\n * *input*:\n * ```\n * xxxxxxxxxxxxxxxxxxxxxxxxxxx\n * ```\n *\n * -> Applying injections `[i...i]`, *inputWithInjections*:\n * ```\n * xxxxxx[iiiiiiiiii]xxxxxxxxxxxxxxxxx[ii]xxxx\n * ```\n *\n * -> breaking at offsets `|` in `xxxxxx[iiiiiii|iii]xxxxxxxxxxx|xxxxxx[ii]xxxx|`:\n * ```\n * xxxxxx[iiiiiii\n * iii]xxxxxxxxxxx\n * xxxxxx[ii]xxxx\n * ```\n *\n * -> applying wrappedTextIndentLength, *output*:\n * ```\n * xxxxxx[iiiiiii\n *    iii]xxxxxxxxxxx\n *    xxxxxx[ii]xxxx\n * ```\n */\nexport class ModelLineProjectionData {\n    constructor(injectionOffsets, \n    /**\n     * `injectionOptions.length` must equal `injectionOffsets.length`\n     */\n    injectionOptions, \n    /**\n     * Refers to offsets after applying injections to the source.\n     * The last break offset indicates the length of the source after applying injections.\n     */\n    breakOffsets, \n    /**\n     * Refers to offsets after applying injections\n     */\n    breakOffsetsVisibleColumn, wrappedTextIndentLength) {\n        this.injectionOffsets = injectionOffsets;\n        this.injectionOptions = injectionOptions;\n        this.breakOffsets = breakOffsets;\n        this.breakOffsetsVisibleColumn = breakOffsetsVisibleColumn;\n        this.wrappedTextIndentLength = wrappedTextIndentLength;\n    }\n    getOutputLineCount() {\n        return this.breakOffsets.length;\n    }\n    getMinOutputOffset(outputLineIndex) {\n        if (outputLineIndex > 0) {\n            return this.wrappedTextIndentLength;\n        }\n        return 0;\n    }\n    getLineLength(outputLineIndex) {\n        // These offsets refer to model text with injected text.\n        const startOffset = outputLineIndex > 0 ? this.breakOffsets[outputLineIndex - 1] : 0;\n        const endOffset = this.breakOffsets[outputLineIndex];\n        let lineLength = endOffset - startOffset;\n        if (outputLineIndex > 0) {\n            lineLength += this.wrappedTextIndentLength;\n        }\n        return lineLength;\n    }\n    getMaxOutputOffset(outputLineIndex) {\n        return this.getLineLength(outputLineIndex);\n    }\n    translateToInputOffset(outputLineIndex, outputOffset) {\n        if (outputLineIndex > 0) {\n            outputOffset = Math.max(0, outputOffset - this.wrappedTextIndentLength);\n        }\n        const offsetInInputWithInjection = outputLineIndex === 0 ? outputOffset : this.breakOffsets[outputLineIndex - 1] + outputOffset;\n        let offsetInInput = offsetInInputWithInjection;\n        if (this.injectionOffsets !== null) {\n            for (let i = 0; i < this.injectionOffsets.length; i++) {\n                if (offsetInInput > this.injectionOffsets[i]) {\n                    if (offsetInInput < this.injectionOffsets[i] + this.injectionOptions[i].content.length) {\n                        // `inputOffset` is within injected text\n                        offsetInInput = this.injectionOffsets[i];\n                    }\n                    else {\n                        offsetInInput -= this.injectionOptions[i].content.length;\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        return offsetInInput;\n    }\n    translateToOutputPosition(inputOffset, affinity = 2 /* PositionAffinity.None */) {\n        let inputOffsetInInputWithInjection = inputOffset;\n        if (this.injectionOffsets !== null) {\n            for (let i = 0; i < this.injectionOffsets.length; i++) {\n                if (inputOffset < this.injectionOffsets[i]) {\n                    break;\n                }\n                if (affinity !== 1 /* PositionAffinity.Right */ && inputOffset === this.injectionOffsets[i]) {\n                    break;\n                }\n                inputOffsetInInputWithInjection += this.injectionOptions[i].content.length;\n            }\n        }\n        return this.offsetInInputWithInjectionsToOutputPosition(inputOffsetInInputWithInjection, affinity);\n    }\n    offsetInInputWithInjectionsToOutputPosition(offsetInInputWithInjections, affinity = 2 /* PositionAffinity.None */) {\n        let low = 0;\n        let high = this.breakOffsets.length - 1;\n        let mid = 0;\n        let midStart = 0;\n        while (low <= high) {\n            mid = low + ((high - low) / 2) | 0;\n            const midStop = this.breakOffsets[mid];\n            midStart = mid > 0 ? this.breakOffsets[mid - 1] : 0;\n            if (affinity === 0 /* PositionAffinity.Left */) {\n                if (offsetInInputWithInjections <= midStart) {\n                    high = mid - 1;\n                }\n                else if (offsetInInputWithInjections > midStop) {\n                    low = mid + 1;\n                }\n                else {\n                    break;\n                }\n            }\n            else {\n                if (offsetInInputWithInjections < midStart) {\n                    high = mid - 1;\n                }\n                else if (offsetInInputWithInjections >= midStop) {\n                    low = mid + 1;\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        let outputOffset = offsetInInputWithInjections - midStart;\n        if (mid > 0) {\n            outputOffset += this.wrappedTextIndentLength;\n        }\n        return new OutputPosition(mid, outputOffset);\n    }\n    normalizeOutputPosition(outputLineIndex, outputOffset, affinity) {\n        if (this.injectionOffsets !== null) {\n            const offsetInInputWithInjections = this.outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset);\n            const normalizedOffsetInUnwrappedLine = this.normalizeOffsetInInputWithInjectionsAroundInjections(offsetInInputWithInjections, affinity);\n            if (normalizedOffsetInUnwrappedLine !== offsetInInputWithInjections) {\n                // injected text caused a change\n                return this.offsetInInputWithInjectionsToOutputPosition(normalizedOffsetInUnwrappedLine, affinity);\n            }\n        }\n        if (affinity === 0 /* PositionAffinity.Left */) {\n            if (outputLineIndex > 0 && outputOffset === this.getMinOutputOffset(outputLineIndex)) {\n                return new OutputPosition(outputLineIndex - 1, this.getMaxOutputOffset(outputLineIndex - 1));\n            }\n        }\n        else if (affinity === 1 /* PositionAffinity.Right */) {\n            const maxOutputLineIndex = this.getOutputLineCount() - 1;\n            if (outputLineIndex < maxOutputLineIndex && outputOffset === this.getMaxOutputOffset(outputLineIndex)) {\n                return new OutputPosition(outputLineIndex + 1, this.getMinOutputOffset(outputLineIndex + 1));\n            }\n        }\n        return new OutputPosition(outputLineIndex, outputOffset);\n    }\n    outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset) {\n        if (outputLineIndex > 0) {\n            outputOffset = Math.max(0, outputOffset - this.wrappedTextIndentLength);\n        }\n        const result = (outputLineIndex > 0 ? this.breakOffsets[outputLineIndex - 1] : 0) + outputOffset;\n        return result;\n    }\n    normalizeOffsetInInputWithInjectionsAroundInjections(offsetInInputWithInjections, affinity) {\n        const injectedText = this.getInjectedTextAtOffset(offsetInInputWithInjections);\n        if (!injectedText) {\n            return offsetInInputWithInjections;\n        }\n        if (affinity === 2 /* PositionAffinity.None */) {\n            if (offsetInInputWithInjections === injectedText.offsetInInputWithInjections + injectedText.length\n                && hasRightCursorStop(this.injectionOptions[injectedText.injectedTextIndex].cursorStops)) {\n                return injectedText.offsetInInputWithInjections + injectedText.length;\n            }\n            else {\n                let result = injectedText.offsetInInputWithInjections;\n                if (hasLeftCursorStop(this.injectionOptions[injectedText.injectedTextIndex].cursorStops)) {\n                    return result;\n                }\n                let index = injectedText.injectedTextIndex - 1;\n                while (index >= 0 && this.injectionOffsets[index] === this.injectionOffsets[injectedText.injectedTextIndex]) {\n                    if (hasRightCursorStop(this.injectionOptions[index].cursorStops)) {\n                        break;\n                    }\n                    result -= this.injectionOptions[index].content.length;\n                    if (hasLeftCursorStop(this.injectionOptions[index].cursorStops)) {\n                        break;\n                    }\n                    index--;\n                }\n                return result;\n            }\n        }\n        else if (affinity === 1 /* PositionAffinity.Right */ || affinity === 4 /* PositionAffinity.RightOfInjectedText */) {\n            let result = injectedText.offsetInInputWithInjections + injectedText.length;\n            let index = injectedText.injectedTextIndex;\n            // traverse all injected text that touch each other\n            while (index + 1 < this.injectionOffsets.length && this.injectionOffsets[index + 1] === this.injectionOffsets[index]) {\n                result += this.injectionOptions[index + 1].content.length;\n                index++;\n            }\n            return result;\n        }\n        else if (affinity === 0 /* PositionAffinity.Left */ || affinity === 3 /* PositionAffinity.LeftOfInjectedText */) {\n            // affinity is left\n            let result = injectedText.offsetInInputWithInjections;\n            let index = injectedText.injectedTextIndex;\n            // traverse all injected text that touch each other\n            while (index - 1 >= 0 && this.injectionOffsets[index - 1] === this.injectionOffsets[index]) {\n                result -= this.injectionOptions[index - 1].content.length;\n                index--;\n            }\n            return result;\n        }\n        assertNever(affinity);\n    }\n    getInjectedText(outputLineIndex, outputOffset) {\n        const offset = this.outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset);\n        const injectedText = this.getInjectedTextAtOffset(offset);\n        if (!injectedText) {\n            return null;\n        }\n        return {\n            options: this.injectionOptions[injectedText.injectedTextIndex]\n        };\n    }\n    getInjectedTextAtOffset(offsetInInputWithInjections) {\n        const injectionOffsets = this.injectionOffsets;\n        const injectionOptions = this.injectionOptions;\n        if (injectionOffsets !== null) {\n            let totalInjectedTextLengthBefore = 0;\n            for (let i = 0; i < injectionOffsets.length; i++) {\n                const length = injectionOptions[i].content.length;\n                const injectedTextStartOffsetInInputWithInjections = injectionOffsets[i] + totalInjectedTextLengthBefore;\n                const injectedTextEndOffsetInInputWithInjections = injectionOffsets[i] + totalInjectedTextLengthBefore + length;\n                if (injectedTextStartOffsetInInputWithInjections > offsetInInputWithInjections) {\n                    // Injected text starts later.\n                    break; // All later injected texts have an even larger offset.\n                }\n                if (offsetInInputWithInjections <= injectedTextEndOffsetInInputWithInjections) {\n                    // Injected text ends after or with the given position (but also starts with or before it).\n                    return {\n                        injectedTextIndex: i,\n                        offsetInInputWithInjections: injectedTextStartOffsetInInputWithInjections,\n                        length\n                    };\n                }\n                totalInjectedTextLengthBefore += length;\n            }\n        }\n        return undefined;\n    }\n}\nfunction hasRightCursorStop(cursorStop) {\n    if (cursorStop === null || cursorStop === undefined) {\n        return true;\n    }\n    return cursorStop === InjectedTextCursorStops.Right || cursorStop === InjectedTextCursorStops.Both;\n}\nfunction hasLeftCursorStop(cursorStop) {\n    if (cursorStop === null || cursorStop === undefined) {\n        return true;\n    }\n    return cursorStop === InjectedTextCursorStops.Left || cursorStop === InjectedTextCursorStops.Both;\n}\nexport class InjectedText {\n    constructor(options) {\n        this.options = options;\n    }\n}\nexport class OutputPosition {\n    constructor(outputLineIndex, outputOffset) {\n        this.outputLineIndex = outputLineIndex;\n        this.outputOffset = outputOffset;\n    }\n    toString() {\n        return `${this.outputLineIndex}:${this.outputOffset}`;\n    }\n    toPosition(baseLineNumber) {\n        return new Position(baseLineNumber + this.outputLineIndex, this.outputOffset + 1);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}