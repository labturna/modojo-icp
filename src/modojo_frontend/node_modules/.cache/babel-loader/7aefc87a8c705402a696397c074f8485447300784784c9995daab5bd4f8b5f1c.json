{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { quickSelect } from '../../../../base/common/arrays.js';\nimport { anyScore, fuzzyScore, FuzzyScore, fuzzyScoreGracefulAggressive, FuzzyScoreOptions } from '../../../../base/common/filters.js';\nimport { compareIgnoreCase } from '../../../../base/common/strings.js';\nexport class LineContext {\n  constructor(leadingLineContent, characterCountDelta) {\n    this.leadingLineContent = leadingLineContent;\n    this.characterCountDelta = characterCountDelta;\n  }\n}\n/**\n * Sorted, filtered completion view model\n * */\nexport class CompletionModel {\n  constructor(items, column, lineContext, wordDistance, options, snippetSuggestions) {\n    let fuzzyScoreOptions = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : FuzzyScoreOptions.default;\n    let clipboardText = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : undefined;\n    this.clipboardText = clipboardText;\n    this._snippetCompareFn = CompletionModel._compareCompletionItems;\n    this._items = items;\n    this._column = column;\n    this._wordDistance = wordDistance;\n    this._options = options;\n    this._refilterKind = 1 /* Refilter.All */;\n    this._lineContext = lineContext;\n    this._fuzzyScoreOptions = fuzzyScoreOptions;\n    if (snippetSuggestions === 'top') {\n      this._snippetCompareFn = CompletionModel._compareCompletionItemsSnippetsUp;\n    } else if (snippetSuggestions === 'bottom') {\n      this._snippetCompareFn = CompletionModel._compareCompletionItemsSnippetsDown;\n    }\n  }\n  get lineContext() {\n    return this._lineContext;\n  }\n  set lineContext(value) {\n    if (this._lineContext.leadingLineContent !== value.leadingLineContent || this._lineContext.characterCountDelta !== value.characterCountDelta) {\n      this._refilterKind = this._lineContext.characterCountDelta < value.characterCountDelta && this._filteredItems ? 2 /* Refilter.Incr */ : 1 /* Refilter.All */;\n      this._lineContext = value;\n    }\n  }\n  get items() {\n    this._ensureCachedState();\n    return this._filteredItems;\n  }\n  getItemsByProvider() {\n    this._ensureCachedState();\n    return this._itemsByProvider;\n  }\n  getIncompleteProvider() {\n    this._ensureCachedState();\n    const result = new Set();\n    for (const [provider, items] of this.getItemsByProvider()) {\n      if (items.length > 0 && items[0].container.incomplete) {\n        result.add(provider);\n      }\n    }\n    return result;\n  }\n  get stats() {\n    this._ensureCachedState();\n    return this._stats;\n  }\n  _ensureCachedState() {\n    if (this._refilterKind !== 0 /* Refilter.Nothing */) {\n      this._createCachedState();\n    }\n  }\n  _createCachedState() {\n    this._itemsByProvider = new Map();\n    const labelLengths = [];\n    const {\n      leadingLineContent,\n      characterCountDelta\n    } = this._lineContext;\n    let word = '';\n    let wordLow = '';\n    // incrementally filter less\n    const source = this._refilterKind === 1 /* Refilter.All */ ? this._items : this._filteredItems;\n    const target = [];\n    // picks a score function based on the number of\n    // items that we have to score/filter and based on the\n    // user-configuration\n    const scoreFn = !this._options.filterGraceful || source.length > 2000 ? fuzzyScore : fuzzyScoreGracefulAggressive;\n    for (let i = 0; i < source.length; i++) {\n      const item = source[i];\n      if (item.isInvalid) {\n        continue; // SKIP invalid items\n      }\n      // keep all items by their provider\n      const arr = this._itemsByProvider.get(item.provider);\n      if (arr) {\n        arr.push(item);\n      } else {\n        this._itemsByProvider.set(item.provider, [item]);\n      }\n      // 'word' is that remainder of the current line that we\n      // filter and score against. In theory each suggestion uses a\n      // different word, but in practice not - that's why we cache\n      const overwriteBefore = item.position.column - item.editStart.column;\n      const wordLen = overwriteBefore + characterCountDelta - (item.position.column - this._column);\n      if (word.length !== wordLen) {\n        word = wordLen === 0 ? '' : leadingLineContent.slice(-wordLen);\n        wordLow = word.toLowerCase();\n      }\n      // remember the word against which this item was\n      // scored\n      item.word = word;\n      if (wordLen === 0) {\n        // when there is nothing to score against, don't\n        // event try to do. Use a const rank and rely on\n        // the fallback-sort using the initial sort order.\n        // use a score of `-100` because that is out of the\n        // bound of values `fuzzyScore` will return\n        item.score = FuzzyScore.Default;\n      } else {\n        // skip word characters that are whitespace until\n        // we have hit the replace range (overwriteBefore)\n        let wordPos = 0;\n        while (wordPos < overwriteBefore) {\n          const ch = word.charCodeAt(wordPos);\n          if (ch === 32 /* CharCode.Space */ || ch === 9 /* CharCode.Tab */) {\n            wordPos += 1;\n          } else {\n            break;\n          }\n        }\n        if (wordPos >= wordLen) {\n          // the wordPos at which scoring starts is the whole word\n          // and therefore the same rules as not having a word apply\n          item.score = FuzzyScore.Default;\n        } else if (typeof item.completion.filterText === 'string') {\n          // when there is a `filterText` it must match the `word`.\n          // if it matches we check with the label to compute highlights\n          // and if that doesn't yield a result we have no highlights,\n          // despite having the match\n          const match = scoreFn(word, wordLow, wordPos, item.completion.filterText, item.filterTextLow, 0, this._fuzzyScoreOptions);\n          if (!match) {\n            continue; // NO match\n          }\n          if (compareIgnoreCase(item.completion.filterText, item.textLabel) === 0) {\n            // filterText and label are actually the same -> use good highlights\n            item.score = match;\n          } else {\n            // re-run the scorer on the label in the hope of a result BUT use the rank\n            // of the filterText-match\n            item.score = anyScore(word, wordLow, wordPos, item.textLabel, item.labelLow, 0);\n            item.score[0] = match[0]; // use score from filterText\n          }\n        } else {\n          // by default match `word` against the `label`\n          const match = scoreFn(word, wordLow, wordPos, item.textLabel, item.labelLow, 0, this._fuzzyScoreOptions);\n          if (!match) {\n            continue; // NO match\n          }\n          item.score = match;\n        }\n      }\n      item.idx = i;\n      item.distance = this._wordDistance.distance(item.position, item.completion);\n      target.push(item);\n      // update stats\n      labelLengths.push(item.textLabel.length);\n    }\n    this._filteredItems = target.sort(this._snippetCompareFn);\n    this._refilterKind = 0 /* Refilter.Nothing */;\n    this._stats = {\n      pLabelLen: labelLengths.length ? quickSelect(labelLengths.length - .85, labelLengths, (a, b) => a - b) : 0\n    };\n  }\n  static _compareCompletionItems(a, b) {\n    if (a.score[0] > b.score[0]) {\n      return -1;\n    } else if (a.score[0] < b.score[0]) {\n      return 1;\n    } else if (a.distance < b.distance) {\n      return -1;\n    } else if (a.distance > b.distance) {\n      return 1;\n    } else if (a.idx < b.idx) {\n      return -1;\n    } else if (a.idx > b.idx) {\n      return 1;\n    } else {\n      return 0;\n    }\n  }\n  static _compareCompletionItemsSnippetsDown(a, b) {\n    if (a.completion.kind !== b.completion.kind) {\n      if (a.completion.kind === 27 /* CompletionItemKind.Snippet */) {\n        return 1;\n      } else if (b.completion.kind === 27 /* CompletionItemKind.Snippet */) {\n        return -1;\n      }\n    }\n    return CompletionModel._compareCompletionItems(a, b);\n  }\n  static _compareCompletionItemsSnippetsUp(a, b) {\n    if (a.completion.kind !== b.completion.kind) {\n      if (a.completion.kind === 27 /* CompletionItemKind.Snippet */) {\n        return -1;\n      } else if (b.completion.kind === 27 /* CompletionItemKind.Snippet */) {\n        return 1;\n      }\n    }\n    return CompletionModel._compareCompletionItems(a, b);\n  }\n}","map":{"version":3,"names":["quickSelect","anyScore","fuzzyScore","FuzzyScore","fuzzyScoreGracefulAggressive","FuzzyScoreOptions","compareIgnoreCase","LineContext","constructor","leadingLineContent","characterCountDelta","CompletionModel","items","column","lineContext","wordDistance","options","snippetSuggestions","fuzzyScoreOptions","arguments","length","undefined","default","clipboardText","_snippetCompareFn","_compareCompletionItems","_items","_column","_wordDistance","_options","_refilterKind","_lineContext","_fuzzyScoreOptions","_compareCompletionItemsSnippetsUp","_compareCompletionItemsSnippetsDown","value","_filteredItems","_ensureCachedState","getItemsByProvider","_itemsByProvider","getIncompleteProvider","result","Set","provider","container","incomplete","add","stats","_stats","_createCachedState","Map","labelLengths","word","wordLow","source","target","scoreFn","filterGraceful","i","item","isInvalid","arr","get","push","set","overwriteBefore","position","editStart","wordLen","slice","toLowerCase","score","Default","wordPos","ch","charCodeAt","completion","filterText","match","filterTextLow","textLabel","labelLow","idx","distance","sort","pLabelLen","a","b","kind"],"sources":["/home/arslan/modojo/node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/completionModel.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { quickSelect } from '../../../../base/common/arrays.js';\nimport { anyScore, fuzzyScore, FuzzyScore, fuzzyScoreGracefulAggressive, FuzzyScoreOptions } from '../../../../base/common/filters.js';\nimport { compareIgnoreCase } from '../../../../base/common/strings.js';\nexport class LineContext {\n    constructor(leadingLineContent, characterCountDelta) {\n        this.leadingLineContent = leadingLineContent;\n        this.characterCountDelta = characterCountDelta;\n    }\n}\n/**\n * Sorted, filtered completion view model\n * */\nexport class CompletionModel {\n    constructor(items, column, lineContext, wordDistance, options, snippetSuggestions, fuzzyScoreOptions = FuzzyScoreOptions.default, clipboardText = undefined) {\n        this.clipboardText = clipboardText;\n        this._snippetCompareFn = CompletionModel._compareCompletionItems;\n        this._items = items;\n        this._column = column;\n        this._wordDistance = wordDistance;\n        this._options = options;\n        this._refilterKind = 1 /* Refilter.All */;\n        this._lineContext = lineContext;\n        this._fuzzyScoreOptions = fuzzyScoreOptions;\n        if (snippetSuggestions === 'top') {\n            this._snippetCompareFn = CompletionModel._compareCompletionItemsSnippetsUp;\n        }\n        else if (snippetSuggestions === 'bottom') {\n            this._snippetCompareFn = CompletionModel._compareCompletionItemsSnippetsDown;\n        }\n    }\n    get lineContext() {\n        return this._lineContext;\n    }\n    set lineContext(value) {\n        if (this._lineContext.leadingLineContent !== value.leadingLineContent\n            || this._lineContext.characterCountDelta !== value.characterCountDelta) {\n            this._refilterKind = this._lineContext.characterCountDelta < value.characterCountDelta && this._filteredItems ? 2 /* Refilter.Incr */ : 1 /* Refilter.All */;\n            this._lineContext = value;\n        }\n    }\n    get items() {\n        this._ensureCachedState();\n        return this._filteredItems;\n    }\n    getItemsByProvider() {\n        this._ensureCachedState();\n        return this._itemsByProvider;\n    }\n    getIncompleteProvider() {\n        this._ensureCachedState();\n        const result = new Set();\n        for (const [provider, items] of this.getItemsByProvider()) {\n            if (items.length > 0 && items[0].container.incomplete) {\n                result.add(provider);\n            }\n        }\n        return result;\n    }\n    get stats() {\n        this._ensureCachedState();\n        return this._stats;\n    }\n    _ensureCachedState() {\n        if (this._refilterKind !== 0 /* Refilter.Nothing */) {\n            this._createCachedState();\n        }\n    }\n    _createCachedState() {\n        this._itemsByProvider = new Map();\n        const labelLengths = [];\n        const { leadingLineContent, characterCountDelta } = this._lineContext;\n        let word = '';\n        let wordLow = '';\n        // incrementally filter less\n        const source = this._refilterKind === 1 /* Refilter.All */ ? this._items : this._filteredItems;\n        const target = [];\n        // picks a score function based on the number of\n        // items that we have to score/filter and based on the\n        // user-configuration\n        const scoreFn = (!this._options.filterGraceful || source.length > 2000) ? fuzzyScore : fuzzyScoreGracefulAggressive;\n        for (let i = 0; i < source.length; i++) {\n            const item = source[i];\n            if (item.isInvalid) {\n                continue; // SKIP invalid items\n            }\n            // keep all items by their provider\n            const arr = this._itemsByProvider.get(item.provider);\n            if (arr) {\n                arr.push(item);\n            }\n            else {\n                this._itemsByProvider.set(item.provider, [item]);\n            }\n            // 'word' is that remainder of the current line that we\n            // filter and score against. In theory each suggestion uses a\n            // different word, but in practice not - that's why we cache\n            const overwriteBefore = item.position.column - item.editStart.column;\n            const wordLen = overwriteBefore + characterCountDelta - (item.position.column - this._column);\n            if (word.length !== wordLen) {\n                word = wordLen === 0 ? '' : leadingLineContent.slice(-wordLen);\n                wordLow = word.toLowerCase();\n            }\n            // remember the word against which this item was\n            // scored\n            item.word = word;\n            if (wordLen === 0) {\n                // when there is nothing to score against, don't\n                // event try to do. Use a const rank and rely on\n                // the fallback-sort using the initial sort order.\n                // use a score of `-100` because that is out of the\n                // bound of values `fuzzyScore` will return\n                item.score = FuzzyScore.Default;\n            }\n            else {\n                // skip word characters that are whitespace until\n                // we have hit the replace range (overwriteBefore)\n                let wordPos = 0;\n                while (wordPos < overwriteBefore) {\n                    const ch = word.charCodeAt(wordPos);\n                    if (ch === 32 /* CharCode.Space */ || ch === 9 /* CharCode.Tab */) {\n                        wordPos += 1;\n                    }\n                    else {\n                        break;\n                    }\n                }\n                if (wordPos >= wordLen) {\n                    // the wordPos at which scoring starts is the whole word\n                    // and therefore the same rules as not having a word apply\n                    item.score = FuzzyScore.Default;\n                }\n                else if (typeof item.completion.filterText === 'string') {\n                    // when there is a `filterText` it must match the `word`.\n                    // if it matches we check with the label to compute highlights\n                    // and if that doesn't yield a result we have no highlights,\n                    // despite having the match\n                    const match = scoreFn(word, wordLow, wordPos, item.completion.filterText, item.filterTextLow, 0, this._fuzzyScoreOptions);\n                    if (!match) {\n                        continue; // NO match\n                    }\n                    if (compareIgnoreCase(item.completion.filterText, item.textLabel) === 0) {\n                        // filterText and label are actually the same -> use good highlights\n                        item.score = match;\n                    }\n                    else {\n                        // re-run the scorer on the label in the hope of a result BUT use the rank\n                        // of the filterText-match\n                        item.score = anyScore(word, wordLow, wordPos, item.textLabel, item.labelLow, 0);\n                        item.score[0] = match[0]; // use score from filterText\n                    }\n                }\n                else {\n                    // by default match `word` against the `label`\n                    const match = scoreFn(word, wordLow, wordPos, item.textLabel, item.labelLow, 0, this._fuzzyScoreOptions);\n                    if (!match) {\n                        continue; // NO match\n                    }\n                    item.score = match;\n                }\n            }\n            item.idx = i;\n            item.distance = this._wordDistance.distance(item.position, item.completion);\n            target.push(item);\n            // update stats\n            labelLengths.push(item.textLabel.length);\n        }\n        this._filteredItems = target.sort(this._snippetCompareFn);\n        this._refilterKind = 0 /* Refilter.Nothing */;\n        this._stats = {\n            pLabelLen: labelLengths.length ?\n                quickSelect(labelLengths.length - .85, labelLengths, (a, b) => a - b)\n                : 0\n        };\n    }\n    static _compareCompletionItems(a, b) {\n        if (a.score[0] > b.score[0]) {\n            return -1;\n        }\n        else if (a.score[0] < b.score[0]) {\n            return 1;\n        }\n        else if (a.distance < b.distance) {\n            return -1;\n        }\n        else if (a.distance > b.distance) {\n            return 1;\n        }\n        else if (a.idx < b.idx) {\n            return -1;\n        }\n        else if (a.idx > b.idx) {\n            return 1;\n        }\n        else {\n            return 0;\n        }\n    }\n    static _compareCompletionItemsSnippetsDown(a, b) {\n        if (a.completion.kind !== b.completion.kind) {\n            if (a.completion.kind === 27 /* CompletionItemKind.Snippet */) {\n                return 1;\n            }\n            else if (b.completion.kind === 27 /* CompletionItemKind.Snippet */) {\n                return -1;\n            }\n        }\n        return CompletionModel._compareCompletionItems(a, b);\n    }\n    static _compareCompletionItemsSnippetsUp(a, b) {\n        if (a.completion.kind !== b.completion.kind) {\n            if (a.completion.kind === 27 /* CompletionItemKind.Snippet */) {\n                return -1;\n            }\n            else if (b.completion.kind === 27 /* CompletionItemKind.Snippet */) {\n                return 1;\n            }\n        }\n        return CompletionModel._compareCompletionItems(a, b);\n    }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,WAAW,QAAQ,mCAAmC;AAC/D,SAASC,QAAQ,EAAEC,UAAU,EAAEC,UAAU,EAAEC,4BAA4B,EAAEC,iBAAiB,QAAQ,oCAAoC;AACtI,SAASC,iBAAiB,QAAQ,oCAAoC;AACtE,OAAO,MAAMC,WAAW,CAAC;EACrBC,WAAWA,CAACC,kBAAkB,EAAEC,mBAAmB,EAAE;IACjD,IAAI,CAACD,kBAAkB,GAAGA,kBAAkB;IAC5C,IAAI,CAACC,mBAAmB,GAAGA,mBAAmB;EAClD;AACJ;AACA;AACA;AACA;AACA,OAAO,MAAMC,eAAe,CAAC;EACzBH,WAAWA,CAACI,KAAK,EAAEC,MAAM,EAAEC,WAAW,EAAEC,YAAY,EAAEC,OAAO,EAAEC,kBAAkB,EAA4E;IAAA,IAA1EC,iBAAiB,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGd,iBAAiB,CAACiB,OAAO;IAAA,IAAEC,aAAa,GAAAJ,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGE,SAAS;IACvJ,IAAI,CAACE,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACC,iBAAiB,GAAGb,eAAe,CAACc,uBAAuB;IAChE,IAAI,CAACC,MAAM,GAAGd,KAAK;IACnB,IAAI,CAACe,OAAO,GAAGd,MAAM;IACrB,IAAI,CAACe,aAAa,GAAGb,YAAY;IACjC,IAAI,CAACc,QAAQ,GAAGb,OAAO;IACvB,IAAI,CAACc,aAAa,GAAG,CAAC,CAAC;IACvB,IAAI,CAACC,YAAY,GAAGjB,WAAW;IAC/B,IAAI,CAACkB,kBAAkB,GAAGd,iBAAiB;IAC3C,IAAID,kBAAkB,KAAK,KAAK,EAAE;MAC9B,IAAI,CAACO,iBAAiB,GAAGb,eAAe,CAACsB,iCAAiC;IAC9E,CAAC,MACI,IAAIhB,kBAAkB,KAAK,QAAQ,EAAE;MACtC,IAAI,CAACO,iBAAiB,GAAGb,eAAe,CAACuB,mCAAmC;IAChF;EACJ;EACA,IAAIpB,WAAWA,CAAA,EAAG;IACd,OAAO,IAAI,CAACiB,YAAY;EAC5B;EACA,IAAIjB,WAAWA,CAACqB,KAAK,EAAE;IACnB,IAAI,IAAI,CAACJ,YAAY,CAACtB,kBAAkB,KAAK0B,KAAK,CAAC1B,kBAAkB,IAC9D,IAAI,CAACsB,YAAY,CAACrB,mBAAmB,KAAKyB,KAAK,CAACzB,mBAAmB,EAAE;MACxE,IAAI,CAACoB,aAAa,GAAG,IAAI,CAACC,YAAY,CAACrB,mBAAmB,GAAGyB,KAAK,CAACzB,mBAAmB,IAAI,IAAI,CAAC0B,cAAc,GAAG,CAAC,CAAC,sBAAsB,CAAC,CAAC;MAC1I,IAAI,CAACL,YAAY,GAAGI,KAAK;IAC7B;EACJ;EACA,IAAIvB,KAAKA,CAAA,EAAG;IACR,IAAI,CAACyB,kBAAkB,CAAC,CAAC;IACzB,OAAO,IAAI,CAACD,cAAc;EAC9B;EACAE,kBAAkBA,CAAA,EAAG;IACjB,IAAI,CAACD,kBAAkB,CAAC,CAAC;IACzB,OAAO,IAAI,CAACE,gBAAgB;EAChC;EACAC,qBAAqBA,CAAA,EAAG;IACpB,IAAI,CAACH,kBAAkB,CAAC,CAAC;IACzB,MAAMI,MAAM,GAAG,IAAIC,GAAG,CAAC,CAAC;IACxB,KAAK,MAAM,CAACC,QAAQ,EAAE/B,KAAK,CAAC,IAAI,IAAI,CAAC0B,kBAAkB,CAAC,CAAC,EAAE;MACvD,IAAI1B,KAAK,CAACQ,MAAM,GAAG,CAAC,IAAIR,KAAK,CAAC,CAAC,CAAC,CAACgC,SAAS,CAACC,UAAU,EAAE;QACnDJ,MAAM,CAACK,GAAG,CAACH,QAAQ,CAAC;MACxB;IACJ;IACA,OAAOF,MAAM;EACjB;EACA,IAAIM,KAAKA,CAAA,EAAG;IACR,IAAI,CAACV,kBAAkB,CAAC,CAAC;IACzB,OAAO,IAAI,CAACW,MAAM;EACtB;EACAX,kBAAkBA,CAAA,EAAG;IACjB,IAAI,IAAI,CAACP,aAAa,KAAK,CAAC,CAAC,wBAAwB;MACjD,IAAI,CAACmB,kBAAkB,CAAC,CAAC;IAC7B;EACJ;EACAA,kBAAkBA,CAAA,EAAG;IACjB,IAAI,CAACV,gBAAgB,GAAG,IAAIW,GAAG,CAAC,CAAC;IACjC,MAAMC,YAAY,GAAG,EAAE;IACvB,MAAM;MAAE1C,kBAAkB;MAAEC;IAAoB,CAAC,GAAG,IAAI,CAACqB,YAAY;IACrE,IAAIqB,IAAI,GAAG,EAAE;IACb,IAAIC,OAAO,GAAG,EAAE;IAChB;IACA,MAAMC,MAAM,GAAG,IAAI,CAACxB,aAAa,KAAK,CAAC,CAAC,qBAAqB,IAAI,CAACJ,MAAM,GAAG,IAAI,CAACU,cAAc;IAC9F,MAAMmB,MAAM,GAAG,EAAE;IACjB;IACA;IACA;IACA,MAAMC,OAAO,GAAI,CAAC,IAAI,CAAC3B,QAAQ,CAAC4B,cAAc,IAAIH,MAAM,CAAClC,MAAM,GAAG,IAAI,GAAIlB,UAAU,GAAGE,4BAA4B;IACnH,KAAK,IAAIsD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,MAAM,CAAClC,MAAM,EAAEsC,CAAC,EAAE,EAAE;MACpC,MAAMC,IAAI,GAAGL,MAAM,CAACI,CAAC,CAAC;MACtB,IAAIC,IAAI,CAACC,SAAS,EAAE;QAChB,SAAS,CAAC;MACd;MACA;MACA,MAAMC,GAAG,GAAG,IAAI,CAACtB,gBAAgB,CAACuB,GAAG,CAACH,IAAI,CAAChB,QAAQ,CAAC;MACpD,IAAIkB,GAAG,EAAE;QACLA,GAAG,CAACE,IAAI,CAACJ,IAAI,CAAC;MAClB,CAAC,MACI;QACD,IAAI,CAACpB,gBAAgB,CAACyB,GAAG,CAACL,IAAI,CAAChB,QAAQ,EAAE,CAACgB,IAAI,CAAC,CAAC;MACpD;MACA;MACA;MACA;MACA,MAAMM,eAAe,GAAGN,IAAI,CAACO,QAAQ,CAACrD,MAAM,GAAG8C,IAAI,CAACQ,SAAS,CAACtD,MAAM;MACpE,MAAMuD,OAAO,GAAGH,eAAe,GAAGvD,mBAAmB,IAAIiD,IAAI,CAACO,QAAQ,CAACrD,MAAM,GAAG,IAAI,CAACc,OAAO,CAAC;MAC7F,IAAIyB,IAAI,CAAChC,MAAM,KAAKgD,OAAO,EAAE;QACzBhB,IAAI,GAAGgB,OAAO,KAAK,CAAC,GAAG,EAAE,GAAG3D,kBAAkB,CAAC4D,KAAK,CAAC,CAACD,OAAO,CAAC;QAC9Df,OAAO,GAAGD,IAAI,CAACkB,WAAW,CAAC,CAAC;MAChC;MACA;MACA;MACAX,IAAI,CAACP,IAAI,GAAGA,IAAI;MAChB,IAAIgB,OAAO,KAAK,CAAC,EAAE;QACf;QACA;QACA;QACA;QACA;QACAT,IAAI,CAACY,KAAK,GAAGpE,UAAU,CAACqE,OAAO;MACnC,CAAC,MACI;QACD;QACA;QACA,IAAIC,OAAO,GAAG,CAAC;QACf,OAAOA,OAAO,GAAGR,eAAe,EAAE;UAC9B,MAAMS,EAAE,GAAGtB,IAAI,CAACuB,UAAU,CAACF,OAAO,CAAC;UACnC,IAAIC,EAAE,KAAK,EAAE,CAAC,wBAAwBA,EAAE,KAAK,CAAC,CAAC,oBAAoB;YAC/DD,OAAO,IAAI,CAAC;UAChB,CAAC,MACI;YACD;UACJ;QACJ;QACA,IAAIA,OAAO,IAAIL,OAAO,EAAE;UACpB;UACA;UACAT,IAAI,CAACY,KAAK,GAAGpE,UAAU,CAACqE,OAAO;QACnC,CAAC,MACI,IAAI,OAAOb,IAAI,CAACiB,UAAU,CAACC,UAAU,KAAK,QAAQ,EAAE;UACrD;UACA;UACA;UACA;UACA,MAAMC,KAAK,GAAGtB,OAAO,CAACJ,IAAI,EAAEC,OAAO,EAAEoB,OAAO,EAAEd,IAAI,CAACiB,UAAU,CAACC,UAAU,EAAElB,IAAI,CAACoB,aAAa,EAAE,CAAC,EAAE,IAAI,CAAC/C,kBAAkB,CAAC;UACzH,IAAI,CAAC8C,KAAK,EAAE;YACR,SAAS,CAAC;UACd;UACA,IAAIxE,iBAAiB,CAACqD,IAAI,CAACiB,UAAU,CAACC,UAAU,EAAElB,IAAI,CAACqB,SAAS,CAAC,KAAK,CAAC,EAAE;YACrE;YACArB,IAAI,CAACY,KAAK,GAAGO,KAAK;UACtB,CAAC,MACI;YACD;YACA;YACAnB,IAAI,CAACY,KAAK,GAAGtE,QAAQ,CAACmD,IAAI,EAAEC,OAAO,EAAEoB,OAAO,EAAEd,IAAI,CAACqB,SAAS,EAAErB,IAAI,CAACsB,QAAQ,EAAE,CAAC,CAAC;YAC/EtB,IAAI,CAACY,KAAK,CAAC,CAAC,CAAC,GAAGO,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;UAC9B;QACJ,CAAC,MACI;UACD;UACA,MAAMA,KAAK,GAAGtB,OAAO,CAACJ,IAAI,EAAEC,OAAO,EAAEoB,OAAO,EAAEd,IAAI,CAACqB,SAAS,EAAErB,IAAI,CAACsB,QAAQ,EAAE,CAAC,EAAE,IAAI,CAACjD,kBAAkB,CAAC;UACxG,IAAI,CAAC8C,KAAK,EAAE;YACR,SAAS,CAAC;UACd;UACAnB,IAAI,CAACY,KAAK,GAAGO,KAAK;QACtB;MACJ;MACAnB,IAAI,CAACuB,GAAG,GAAGxB,CAAC;MACZC,IAAI,CAACwB,QAAQ,GAAG,IAAI,CAACvD,aAAa,CAACuD,QAAQ,CAACxB,IAAI,CAACO,QAAQ,EAAEP,IAAI,CAACiB,UAAU,CAAC;MAC3ErB,MAAM,CAACQ,IAAI,CAACJ,IAAI,CAAC;MACjB;MACAR,YAAY,CAACY,IAAI,CAACJ,IAAI,CAACqB,SAAS,CAAC5D,MAAM,CAAC;IAC5C;IACA,IAAI,CAACgB,cAAc,GAAGmB,MAAM,CAAC6B,IAAI,CAAC,IAAI,CAAC5D,iBAAiB,CAAC;IACzD,IAAI,CAACM,aAAa,GAAG,CAAC,CAAC;IACvB,IAAI,CAACkB,MAAM,GAAG;MACVqC,SAAS,EAAElC,YAAY,CAAC/B,MAAM,GAC1BpB,WAAW,CAACmD,YAAY,CAAC/B,MAAM,GAAG,GAAG,EAAE+B,YAAY,EAAE,CAACmC,CAAC,EAAEC,CAAC,KAAKD,CAAC,GAAGC,CAAC,CAAC,GACnE;IACV,CAAC;EACL;EACA,OAAO9D,uBAAuBA,CAAC6D,CAAC,EAAEC,CAAC,EAAE;IACjC,IAAID,CAAC,CAACf,KAAK,CAAC,CAAC,CAAC,GAAGgB,CAAC,CAAChB,KAAK,CAAC,CAAC,CAAC,EAAE;MACzB,OAAO,CAAC,CAAC;IACb,CAAC,MACI,IAAIe,CAAC,CAACf,KAAK,CAAC,CAAC,CAAC,GAAGgB,CAAC,CAAChB,KAAK,CAAC,CAAC,CAAC,EAAE;MAC9B,OAAO,CAAC;IACZ,CAAC,MACI,IAAIe,CAAC,CAACH,QAAQ,GAAGI,CAAC,CAACJ,QAAQ,EAAE;MAC9B,OAAO,CAAC,CAAC;IACb,CAAC,MACI,IAAIG,CAAC,CAACH,QAAQ,GAAGI,CAAC,CAACJ,QAAQ,EAAE;MAC9B,OAAO,CAAC;IACZ,CAAC,MACI,IAAIG,CAAC,CAACJ,GAAG,GAAGK,CAAC,CAACL,GAAG,EAAE;MACpB,OAAO,CAAC,CAAC;IACb,CAAC,MACI,IAAII,CAAC,CAACJ,GAAG,GAAGK,CAAC,CAACL,GAAG,EAAE;MACpB,OAAO,CAAC;IACZ,CAAC,MACI;MACD,OAAO,CAAC;IACZ;EACJ;EACA,OAAOhD,mCAAmCA,CAACoD,CAAC,EAAEC,CAAC,EAAE;IAC7C,IAAID,CAAC,CAACV,UAAU,CAACY,IAAI,KAAKD,CAAC,CAACX,UAAU,CAACY,IAAI,EAAE;MACzC,IAAIF,CAAC,CAACV,UAAU,CAACY,IAAI,KAAK,EAAE,CAAC,kCAAkC;QAC3D,OAAO,CAAC;MACZ,CAAC,MACI,IAAID,CAAC,CAACX,UAAU,CAACY,IAAI,KAAK,EAAE,CAAC,kCAAkC;QAChE,OAAO,CAAC,CAAC;MACb;IACJ;IACA,OAAO7E,eAAe,CAACc,uBAAuB,CAAC6D,CAAC,EAAEC,CAAC,CAAC;EACxD;EACA,OAAOtD,iCAAiCA,CAACqD,CAAC,EAAEC,CAAC,EAAE;IAC3C,IAAID,CAAC,CAACV,UAAU,CAACY,IAAI,KAAKD,CAAC,CAACX,UAAU,CAACY,IAAI,EAAE;MACzC,IAAIF,CAAC,CAACV,UAAU,CAACY,IAAI,KAAK,EAAE,CAAC,kCAAkC;QAC3D,OAAO,CAAC,CAAC;MACb,CAAC,MACI,IAAID,CAAC,CAACX,UAAU,CAACY,IAAI,KAAK,EAAE,CAAC,kCAAkC;QAChE,OAAO,CAAC;MACZ;IACJ;IACA,OAAO7E,eAAe,CAACc,uBAAuB,CAAC6D,CAAC,EAAEC,CAAC,CAAC;EACxD;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}