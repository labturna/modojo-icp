{"ast":null,"code":"'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\nconst Decoder = require('./decoder');\nconst utils = require('./utils');\n\n/**\n * Output the diagnostic format from a stream of CBOR bytes.\n *\n */\nclass Diagnose extends Decoder {\n  createTag(tagNumber, value) {\n    return `${tagNumber}(${value})`;\n  }\n  createInt(val) {\n    return super.createInt(val).toString();\n  }\n  createInt32(f, g) {\n    return super.createInt32(f, g).toString();\n  }\n  createInt64(f1, f2, g1, g2) {\n    return super.createInt64(f1, f2, g1, g2).toString();\n  }\n  createInt32Neg(f, g) {\n    return super.createInt32Neg(f, g).toString();\n  }\n  createInt64Neg(f1, f2, g1, g2) {\n    return super.createInt64Neg(f1, f2, g1, g2).toString();\n  }\n  createTrue() {\n    return 'true';\n  }\n  createFalse() {\n    return 'false';\n  }\n  createFloat(val) {\n    const fl = super.createFloat(val);\n    if (utils.isNegativeZero(val)) {\n      return '-0_1';\n    }\n    return `${fl}_1`;\n  }\n  createFloatSingle(a, b, c, d) {\n    const fl = super.createFloatSingle(a, b, c, d);\n    return `${fl}_2`;\n  }\n  createFloatDouble(a, b, c, d, e, f, g, h) {\n    const fl = super.createFloatDouble(a, b, c, d, e, f, g, h);\n    return `${fl}_3`;\n  }\n  createByteString(raw, len) {\n    const val = raw.join(', ');\n    if (len === -1) {\n      return `(_ ${val})`;\n    }\n    return `h'${val}`;\n  }\n  createByteStringFromHeap(start, end) {\n    const val = Buffer.from(super.createByteStringFromHeap(start, end)).toString('hex');\n    return `h'${val}'`;\n  }\n  createInfinity() {\n    return 'Infinity_1';\n  }\n  createInfinityNeg() {\n    return '-Infinity_1';\n  }\n  createNaN() {\n    return 'NaN_1';\n  }\n  createNaNNeg() {\n    return '-NaN_1';\n  }\n  createNull() {\n    return 'null';\n  }\n  createUndefined() {\n    return 'undefined';\n  }\n  createSimpleUnassigned(val) {\n    return `simple(${val})`;\n  }\n  createArray(arr, len) {\n    const val = super.createArray(arr, len);\n    if (len === -1) {\n      // indefinite\n      return `[_ ${val.join(', ')}]`;\n    }\n    return `[${val.join(', ')}]`;\n  }\n  createMap(map, len) {\n    const val = super.createMap(map);\n    const list = Array.from(val.keys()).reduce(collectObject(val), '');\n    if (len === -1) {\n      return `{_ ${list}}`;\n    }\n    return `{${list}}`;\n  }\n  createObject(obj, len) {\n    const val = super.createObject(obj);\n    const map = Object.keys(val).reduce(collectObject(val), '');\n    if (len === -1) {\n      return `{_ ${map}}`;\n    }\n    return `{${map}}`;\n  }\n  createUtf8String(raw, len) {\n    const val = raw.join(', ');\n    if (len === -1) {\n      return `(_ ${val})`;\n    }\n    return `\"${val}\"`;\n  }\n  createUtf8StringFromHeap(start, end) {\n    const val = Buffer.from(super.createUtf8StringFromHeap(start, end)).toString('utf8');\n    return `\"${val}\"`;\n  }\n  static diagnose(input, enc) {\n    if (typeof input === 'string') {\n      input = Buffer.from(input, enc || 'hex');\n    }\n    const dec = new Diagnose();\n    return dec.decodeFirst(input);\n  }\n}\nmodule.exports = Diagnose;\nfunction collectObject(val) {\n  return (acc, key) => {\n    if (acc) {\n      return `${acc}, ${key}: ${val[key]}`;\n    }\n    return `${key}: ${val[key]}`;\n  };\n}","map":{"version":3,"names":["Buffer","require","Decoder","utils","Diagnose","createTag","tagNumber","value","createInt","val","toString","createInt32","f","g","createInt64","f1","f2","g1","g2","createInt32Neg","createInt64Neg","createTrue","createFalse","createFloat","fl","isNegativeZero","createFloatSingle","a","b","c","d","createFloatDouble","e","h","createByteString","raw","len","join","createByteStringFromHeap","start","end","from","createInfinity","createInfinityNeg","createNaN","createNaNNeg","createNull","createUndefined","createSimpleUnassigned","createArray","arr","createMap","map","list","Array","keys","reduce","collectObject","createObject","obj","Object","createUtf8String","createUtf8StringFromHeap","diagnose","input","enc","dec","decodeFirst","module","exports","acc","key"],"sources":["/home/arslan/modojo/node_modules/borc/src/diagnose.js"],"sourcesContent":["'use strict'\n\nconst { Buffer } = require('buffer')\nconst Decoder = require('./decoder')\nconst utils = require('./utils')\n\n/**\n * Output the diagnostic format from a stream of CBOR bytes.\n *\n */\nclass Diagnose extends Decoder {\n  createTag (tagNumber, value) {\n    return `${tagNumber}(${value})`\n  }\n\n  createInt (val) {\n    return super.createInt(val).toString()\n  }\n\n  createInt32 (f, g) {\n    return super.createInt32(f, g).toString()\n  }\n\n  createInt64 (f1, f2, g1, g2) {\n    return super.createInt64(f1, f2, g1, g2).toString()\n  }\n\n  createInt32Neg (f, g) {\n    return super.createInt32Neg(f, g).toString()\n  }\n\n  createInt64Neg (f1, f2, g1, g2) {\n    return super.createInt64Neg(f1, f2, g1, g2).toString()\n  }\n\n  createTrue () {\n    return 'true'\n  }\n\n  createFalse () {\n    return 'false'\n  }\n\n  createFloat (val) {\n    const fl = super.createFloat(val)\n    if (utils.isNegativeZero(val)) {\n      return '-0_1'\n    }\n\n    return `${fl}_1`\n  }\n\n  createFloatSingle (a, b, c, d) {\n    const fl = super.createFloatSingle(a, b, c, d)\n    return `${fl}_2`\n  }\n\n  createFloatDouble (a, b, c, d, e, f, g, h) {\n    const fl = super.createFloatDouble(a, b, c, d, e, f, g, h)\n    return `${fl}_3`\n  }\n\n  createByteString (raw, len) {\n    const val = raw.join(', ')\n\n    if (len === -1) {\n      return `(_ ${val})`\n    }\n    return `h'${val}`\n  }\n\n  createByteStringFromHeap (start, end) {\n    const val = (Buffer.from(\n      super.createByteStringFromHeap(start, end)\n    )).toString('hex')\n\n    return `h'${val}'`\n  }\n\n  createInfinity () {\n    return 'Infinity_1'\n  }\n\n  createInfinityNeg () {\n    return '-Infinity_1'\n  }\n\n  createNaN () {\n    return 'NaN_1'\n  }\n\n  createNaNNeg () {\n    return '-NaN_1'\n  }\n\n  createNull () {\n    return 'null'\n  }\n\n  createUndefined () {\n    return 'undefined'\n  }\n\n  createSimpleUnassigned (val) {\n    return `simple(${val})`\n  }\n\n  createArray (arr, len) {\n    const val = super.createArray(arr, len)\n\n    if (len === -1) {\n      // indefinite\n      return `[_ ${val.join(', ')}]`\n    }\n\n    return `[${val.join(', ')}]`\n  }\n\n  createMap (map, len) {\n    const val = super.createMap(map)\n    const list = Array.from(val.keys())\n      .reduce(collectObject(val), '')\n\n    if (len === -1) {\n      return `{_ ${list}}`\n    }\n\n    return `{${list}}`\n  }\n\n  createObject (obj, len) {\n    const val = super.createObject(obj)\n    const map = Object.keys(val)\n      .reduce(collectObject(val), '')\n\n    if (len === -1) {\n      return `{_ ${map}}`\n    }\n\n    return `{${map}}`\n  }\n\n  createUtf8String (raw, len) {\n    const val = raw.join(', ')\n\n    if (len === -1) {\n      return `(_ ${val})`\n    }\n\n    return `\"${val}\"`\n  }\n\n  createUtf8StringFromHeap (start, end) {\n    const val = (Buffer.from(\n      super.createUtf8StringFromHeap(start, end)\n    )).toString('utf8')\n\n    return `\"${val}\"`\n  }\n\n  static diagnose (input, enc) {\n    if (typeof input === 'string') {\n      input = Buffer.from(input, enc || 'hex')\n    }\n\n    const dec = new Diagnose()\n    return dec.decodeFirst(input)\n  }\n}\n\nmodule.exports = Diagnose\n\nfunction collectObject (val) {\n  return (acc, key) => {\n    if (acc) {\n      return `${acc}, ${key}: ${val[key]}`\n    }\n    return `${key}: ${val[key]}`\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}