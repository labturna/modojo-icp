{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertFn } from '../assert.js';\nimport { strictEquals } from '../equals.js';\nimport { DisposableStore } from '../lifecycle.js';\nimport { BaseObservable, _setDerivedOpts } from './base.js';\nimport { DebugNameData } from './debugName.js';\nimport { getLogger } from './logging.js';\nexport function derived(computeFnOrOwner, computeFn) {\n  if (computeFn !== undefined) {\n    return new Derived(new DebugNameData(computeFnOrOwner, undefined, computeFn), computeFn, undefined, undefined, undefined, strictEquals);\n  }\n  return new Derived(new DebugNameData(undefined, undefined, computeFnOrOwner), computeFnOrOwner, undefined, undefined, undefined, strictEquals);\n}\nexport function derivedWithSetter(owner, computeFn, setter) {\n  return new DerivedWithSetter(new DebugNameData(owner, undefined, computeFn), computeFn, undefined, undefined, undefined, strictEquals, setter);\n}\nexport function derivedOpts(options, computeFn) {\n  var _a;\n  return new Derived(new DebugNameData(options.owner, options.debugName, options.debugReferenceFn), computeFn, undefined, undefined, options.onLastObserverRemoved, (_a = options.equalsFn) !== null && _a !== void 0 ? _a : strictEquals);\n}\n_setDerivedOpts(derivedOpts);\n/**\n * Represents an observable that is derived from other observables.\n * The value is only recomputed when absolutely needed.\n *\n * {@link computeFn} should start with a JS Doc using `@description` to name the derived.\n *\n * Use `createEmptyChangeSummary` to create a \"change summary\" that can collect the changes.\n * Use `handleChange` to add a reported change to the change summary.\n * The compute function is given the last change summary.\n * The change summary is discarded after the compute function was called.\n *\n * @see derived\n */\nexport function derivedHandleChanges(options, computeFn) {\n  var _a;\n  return new Derived(new DebugNameData(options.owner, options.debugName, undefined), computeFn, options.createEmptyChangeSummary, options.handleChange, undefined, (_a = options.equalityComparer) !== null && _a !== void 0 ? _a : strictEquals);\n}\nexport function derivedWithStore(computeFnOrOwner, computeFnOrUndefined) {\n  let computeFn;\n  let owner;\n  if (computeFnOrUndefined === undefined) {\n    computeFn = computeFnOrOwner;\n    owner = undefined;\n  } else {\n    owner = computeFnOrOwner;\n    computeFn = computeFnOrUndefined;\n  }\n  const store = new DisposableStore();\n  return new Derived(new DebugNameData(owner, undefined, computeFn), r => {\n    store.clear();\n    return computeFn(r, store);\n  }, undefined, undefined, () => store.dispose(), strictEquals);\n}\nexport function derivedDisposable(computeFnOrOwner, computeFnOrUndefined) {\n  let computeFn;\n  let owner;\n  if (computeFnOrUndefined === undefined) {\n    computeFn = computeFnOrOwner;\n    owner = undefined;\n  } else {\n    owner = computeFnOrOwner;\n    computeFn = computeFnOrUndefined;\n  }\n  const store = new DisposableStore();\n  return new Derived(new DebugNameData(owner, undefined, computeFn), r => {\n    store.clear();\n    const result = computeFn(r);\n    if (result) {\n      store.add(result);\n    }\n    return result;\n  }, undefined, undefined, () => store.dispose(), strictEquals);\n}\nexport class Derived extends BaseObservable {\n  get debugName() {\n    var _a;\n    return (_a = this._debugNameData.getDebugName(this)) !== null && _a !== void 0 ? _a : '(anonymous)';\n  }\n  constructor(_debugNameData, _computeFn, createChangeSummary, _handleChange) {\n    let _handleLastObserverRemoved = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;\n    let _equalityComparator = arguments.length > 5 ? arguments[5] : undefined;\n    var _a, _b;\n    super();\n    this._debugNameData = _debugNameData;\n    this._computeFn = _computeFn;\n    this.createChangeSummary = createChangeSummary;\n    this._handleChange = _handleChange;\n    this._handleLastObserverRemoved = _handleLastObserverRemoved;\n    this._equalityComparator = _equalityComparator;\n    this.state = 0 /* DerivedState.initial */;\n    this.value = undefined;\n    this.updateCount = 0;\n    this.dependencies = new Set();\n    this.dependenciesToBeRemoved = new Set();\n    this.changeSummary = undefined;\n    this.changeSummary = (_a = this.createChangeSummary) === null || _a === void 0 ? void 0 : _a.call(this);\n    (_b = getLogger()) === null || _b === void 0 ? void 0 : _b.handleDerivedCreated(this);\n  }\n  onLastObserverRemoved() {\n    var _a;\n    /**\n     * We are not tracking changes anymore, thus we have to assume\n     * that our cache is invalid.\n     */\n    this.state = 0 /* DerivedState.initial */;\n    this.value = undefined;\n    for (const d of this.dependencies) {\n      d.removeObserver(this);\n    }\n    this.dependencies.clear();\n    (_a = this._handleLastObserverRemoved) === null || _a === void 0 ? void 0 : _a.call(this);\n  }\n  get() {\n    var _a;\n    if (this.observers.size === 0) {\n      // Without observers, we don't know when to clean up stuff.\n      // Thus, we don't cache anything to prevent memory leaks.\n      const result = this._computeFn(this, (_a = this.createChangeSummary) === null || _a === void 0 ? void 0 : _a.call(this));\n      // Clear new dependencies\n      this.onLastObserverRemoved();\n      return result;\n    } else {\n      do {\n        // We might not get a notification for a dependency that changed while it is updating,\n        // thus we also have to ask all our depedencies if they changed in this case.\n        if (this.state === 1 /* DerivedState.dependenciesMightHaveChanged */) {\n          for (const d of this.dependencies) {\n            /** might call {@link handleChange} indirectly, which could make us stale */\n            d.reportChanges();\n            if (this.state === 2 /* DerivedState.stale */) {\n              // The other dependencies will refresh on demand, so early break\n              break;\n            }\n          }\n        }\n        // We called report changes of all dependencies.\n        // If we are still not stale, we can assume to be up to date again.\n        if (this.state === 1 /* DerivedState.dependenciesMightHaveChanged */) {\n          this.state = 3 /* DerivedState.upToDate */;\n        }\n        this._recomputeIfNeeded();\n        // In case recomputation changed one of our dependencies, we need to recompute again.\n      } while (this.state !== 3 /* DerivedState.upToDate */);\n      return this.value;\n    }\n  }\n  _recomputeIfNeeded() {\n    var _a, _b;\n    if (this.state === 3 /* DerivedState.upToDate */) {\n      return;\n    }\n    const emptySet = this.dependenciesToBeRemoved;\n    this.dependenciesToBeRemoved = this.dependencies;\n    this.dependencies = emptySet;\n    const hadValue = this.state !== 0 /* DerivedState.initial */;\n    const oldValue = this.value;\n    this.state = 3 /* DerivedState.upToDate */;\n    const changeSummary = this.changeSummary;\n    this.changeSummary = (_a = this.createChangeSummary) === null || _a === void 0 ? void 0 : _a.call(this);\n    try {\n      /** might call {@link handleChange} indirectly, which could invalidate us */\n      this.value = this._computeFn(this, changeSummary);\n    } finally {\n      // We don't want our observed observables to think that they are (not even temporarily) not being observed.\n      // Thus, we only unsubscribe from observables that are definitely not read anymore.\n      for (const o of this.dependenciesToBeRemoved) {\n        o.removeObserver(this);\n      }\n      this.dependenciesToBeRemoved.clear();\n    }\n    const didChange = hadValue && !this._equalityComparator(oldValue, this.value);\n    (_b = getLogger()) === null || _b === void 0 ? void 0 : _b.handleDerivedRecomputed(this, {\n      oldValue,\n      newValue: this.value,\n      change: undefined,\n      didChange,\n      hadValue\n    });\n    if (didChange) {\n      for (const r of this.observers) {\n        r.handleChange(this, undefined);\n      }\n    }\n  }\n  toString() {\n    return `LazyDerived<${this.debugName}>`;\n  }\n  // IObserver Implementation\n  beginUpdate(_observable) {\n    this.updateCount++;\n    const propagateBeginUpdate = this.updateCount === 1;\n    if (this.state === 3 /* DerivedState.upToDate */) {\n      this.state = 1 /* DerivedState.dependenciesMightHaveChanged */;\n      // If we propagate begin update, that will already signal a possible change.\n      if (!propagateBeginUpdate) {\n        for (const r of this.observers) {\n          r.handlePossibleChange(this);\n        }\n      }\n    }\n    if (propagateBeginUpdate) {\n      for (const r of this.observers) {\n        r.beginUpdate(this); // This signals a possible change\n      }\n    }\n  }\n  endUpdate(_observable) {\n    this.updateCount--;\n    if (this.updateCount === 0) {\n      // End update could change the observer list.\n      const observers = [...this.observers];\n      for (const r of observers) {\n        r.endUpdate(this);\n      }\n    }\n    assertFn(() => this.updateCount >= 0);\n  }\n  handlePossibleChange(observable) {\n    // In all other states, observers already know that we might have changed.\n    if (this.state === 3 /* DerivedState.upToDate */ && this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n      this.state = 1 /* DerivedState.dependenciesMightHaveChanged */;\n      for (const r of this.observers) {\n        r.handlePossibleChange(this);\n      }\n    }\n  }\n  handleChange(observable, change) {\n    if (this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n      const shouldReact = this._handleChange ? this._handleChange({\n        changedObservable: observable,\n        change,\n        didChange: o => o === observable\n      }, this.changeSummary) : true;\n      const wasUpToDate = this.state === 3 /* DerivedState.upToDate */;\n      if (shouldReact && (this.state === 1 /* DerivedState.dependenciesMightHaveChanged */ || wasUpToDate)) {\n        this.state = 2 /* DerivedState.stale */;\n        if (wasUpToDate) {\n          for (const r of this.observers) {\n            r.handlePossibleChange(this);\n          }\n        }\n      }\n    }\n  }\n  // IReader Implementation\n  readObservable(observable) {\n    // Subscribe before getting the value to enable caching\n    observable.addObserver(this);\n    /** This might call {@link handleChange} indirectly, which could invalidate us */\n    const value = observable.get();\n    // Which is why we only add the observable to the dependencies now.\n    this.dependencies.add(observable);\n    this.dependenciesToBeRemoved.delete(observable);\n    return value;\n  }\n  addObserver(observer) {\n    const shouldCallBeginUpdate = !this.observers.has(observer) && this.updateCount > 0;\n    super.addObserver(observer);\n    if (shouldCallBeginUpdate) {\n      observer.beginUpdate(this);\n    }\n  }\n  removeObserver(observer) {\n    const shouldCallEndUpdate = this.observers.has(observer) && this.updateCount > 0;\n    super.removeObserver(observer);\n    if (shouldCallEndUpdate) {\n      // Calling end update after removing the observer makes sure endUpdate cannot be called twice here.\n      observer.endUpdate(this);\n    }\n  }\n}\nexport class DerivedWithSetter extends Derived {\n  constructor(debugNameData, computeFn, createChangeSummary, handleChange) {\n    let handleLastObserverRemoved = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;\n    let equalityComparator = arguments.length > 5 ? arguments[5] : undefined;\n    let set = arguments.length > 6 ? arguments[6] : undefined;\n    super(debugNameData, computeFn, createChangeSummary, handleChange, handleLastObserverRemoved, equalityComparator);\n    this.set = set;\n  }\n}","map":{"version":3,"names":["assertFn","strictEquals","DisposableStore","BaseObservable","_setDerivedOpts","DebugNameData","getLogger","derived","computeFnOrOwner","computeFn","undefined","Derived","derivedWithSetter","owner","setter","DerivedWithSetter","derivedOpts","options","_a","debugName","debugReferenceFn","onLastObserverRemoved","equalsFn","derivedHandleChanges","createEmptyChangeSummary","handleChange","equalityComparer","derivedWithStore","computeFnOrUndefined","store","r","clear","dispose","derivedDisposable","result","add","_debugNameData","getDebugName","constructor","_computeFn","createChangeSummary","_handleChange","_handleLastObserverRemoved","arguments","length","_equalityComparator","_b","state","value","updateCount","dependencies","Set","dependenciesToBeRemoved","changeSummary","call","handleDerivedCreated","d","removeObserver","get","observers","size","reportChanges","_recomputeIfNeeded","emptySet","hadValue","oldValue","o","didChange","handleDerivedRecomputed","newValue","change","toString","beginUpdate","_observable","propagateBeginUpdate","handlePossibleChange","endUpdate","observable","has","shouldReact","changedObservable","wasUpToDate","readObservable","addObserver","delete","observer","shouldCallBeginUpdate","shouldCallEndUpdate","debugNameData","handleLastObserverRemoved","equalityComparator","set"],"sources":["/home/arslan/modojo/node_modules/monaco-editor/esm/vs/base/common/observableInternal/derived.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertFn } from '../assert.js';\nimport { strictEquals } from '../equals.js';\nimport { DisposableStore } from '../lifecycle.js';\nimport { BaseObservable, _setDerivedOpts } from './base.js';\nimport { DebugNameData } from './debugName.js';\nimport { getLogger } from './logging.js';\nexport function derived(computeFnOrOwner, computeFn) {\n    if (computeFn !== undefined) {\n        return new Derived(new DebugNameData(computeFnOrOwner, undefined, computeFn), computeFn, undefined, undefined, undefined, strictEquals);\n    }\n    return new Derived(new DebugNameData(undefined, undefined, computeFnOrOwner), computeFnOrOwner, undefined, undefined, undefined, strictEquals);\n}\nexport function derivedWithSetter(owner, computeFn, setter) {\n    return new DerivedWithSetter(new DebugNameData(owner, undefined, computeFn), computeFn, undefined, undefined, undefined, strictEquals, setter);\n}\nexport function derivedOpts(options, computeFn) {\n    var _a;\n    return new Derived(new DebugNameData(options.owner, options.debugName, options.debugReferenceFn), computeFn, undefined, undefined, options.onLastObserverRemoved, (_a = options.equalsFn) !== null && _a !== void 0 ? _a : strictEquals);\n}\n_setDerivedOpts(derivedOpts);\n/**\n * Represents an observable that is derived from other observables.\n * The value is only recomputed when absolutely needed.\n *\n * {@link computeFn} should start with a JS Doc using `@description` to name the derived.\n *\n * Use `createEmptyChangeSummary` to create a \"change summary\" that can collect the changes.\n * Use `handleChange` to add a reported change to the change summary.\n * The compute function is given the last change summary.\n * The change summary is discarded after the compute function was called.\n *\n * @see derived\n */\nexport function derivedHandleChanges(options, computeFn) {\n    var _a;\n    return new Derived(new DebugNameData(options.owner, options.debugName, undefined), computeFn, options.createEmptyChangeSummary, options.handleChange, undefined, (_a = options.equalityComparer) !== null && _a !== void 0 ? _a : strictEquals);\n}\nexport function derivedWithStore(computeFnOrOwner, computeFnOrUndefined) {\n    let computeFn;\n    let owner;\n    if (computeFnOrUndefined === undefined) {\n        computeFn = computeFnOrOwner;\n        owner = undefined;\n    }\n    else {\n        owner = computeFnOrOwner;\n        computeFn = computeFnOrUndefined;\n    }\n    const store = new DisposableStore();\n    return new Derived(new DebugNameData(owner, undefined, computeFn), r => {\n        store.clear();\n        return computeFn(r, store);\n    }, undefined, undefined, () => store.dispose(), strictEquals);\n}\nexport function derivedDisposable(computeFnOrOwner, computeFnOrUndefined) {\n    let computeFn;\n    let owner;\n    if (computeFnOrUndefined === undefined) {\n        computeFn = computeFnOrOwner;\n        owner = undefined;\n    }\n    else {\n        owner = computeFnOrOwner;\n        computeFn = computeFnOrUndefined;\n    }\n    const store = new DisposableStore();\n    return new Derived(new DebugNameData(owner, undefined, computeFn), r => {\n        store.clear();\n        const result = computeFn(r);\n        if (result) {\n            store.add(result);\n        }\n        return result;\n    }, undefined, undefined, () => store.dispose(), strictEquals);\n}\nexport class Derived extends BaseObservable {\n    get debugName() {\n        var _a;\n        return (_a = this._debugNameData.getDebugName(this)) !== null && _a !== void 0 ? _a : '(anonymous)';\n    }\n    constructor(_debugNameData, _computeFn, createChangeSummary, _handleChange, _handleLastObserverRemoved = undefined, _equalityComparator) {\n        var _a, _b;\n        super();\n        this._debugNameData = _debugNameData;\n        this._computeFn = _computeFn;\n        this.createChangeSummary = createChangeSummary;\n        this._handleChange = _handleChange;\n        this._handleLastObserverRemoved = _handleLastObserverRemoved;\n        this._equalityComparator = _equalityComparator;\n        this.state = 0 /* DerivedState.initial */;\n        this.value = undefined;\n        this.updateCount = 0;\n        this.dependencies = new Set();\n        this.dependenciesToBeRemoved = new Set();\n        this.changeSummary = undefined;\n        this.changeSummary = (_a = this.createChangeSummary) === null || _a === void 0 ? void 0 : _a.call(this);\n        (_b = getLogger()) === null || _b === void 0 ? void 0 : _b.handleDerivedCreated(this);\n    }\n    onLastObserverRemoved() {\n        var _a;\n        /**\n         * We are not tracking changes anymore, thus we have to assume\n         * that our cache is invalid.\n         */\n        this.state = 0 /* DerivedState.initial */;\n        this.value = undefined;\n        for (const d of this.dependencies) {\n            d.removeObserver(this);\n        }\n        this.dependencies.clear();\n        (_a = this._handleLastObserverRemoved) === null || _a === void 0 ? void 0 : _a.call(this);\n    }\n    get() {\n        var _a;\n        if (this.observers.size === 0) {\n            // Without observers, we don't know when to clean up stuff.\n            // Thus, we don't cache anything to prevent memory leaks.\n            const result = this._computeFn(this, (_a = this.createChangeSummary) === null || _a === void 0 ? void 0 : _a.call(this));\n            // Clear new dependencies\n            this.onLastObserverRemoved();\n            return result;\n        }\n        else {\n            do {\n                // We might not get a notification for a dependency that changed while it is updating,\n                // thus we also have to ask all our depedencies if they changed in this case.\n                if (this.state === 1 /* DerivedState.dependenciesMightHaveChanged */) {\n                    for (const d of this.dependencies) {\n                        /** might call {@link handleChange} indirectly, which could make us stale */\n                        d.reportChanges();\n                        if (this.state === 2 /* DerivedState.stale */) {\n                            // The other dependencies will refresh on demand, so early break\n                            break;\n                        }\n                    }\n                }\n                // We called report changes of all dependencies.\n                // If we are still not stale, we can assume to be up to date again.\n                if (this.state === 1 /* DerivedState.dependenciesMightHaveChanged */) {\n                    this.state = 3 /* DerivedState.upToDate */;\n                }\n                this._recomputeIfNeeded();\n                // In case recomputation changed one of our dependencies, we need to recompute again.\n            } while (this.state !== 3 /* DerivedState.upToDate */);\n            return this.value;\n        }\n    }\n    _recomputeIfNeeded() {\n        var _a, _b;\n        if (this.state === 3 /* DerivedState.upToDate */) {\n            return;\n        }\n        const emptySet = this.dependenciesToBeRemoved;\n        this.dependenciesToBeRemoved = this.dependencies;\n        this.dependencies = emptySet;\n        const hadValue = this.state !== 0 /* DerivedState.initial */;\n        const oldValue = this.value;\n        this.state = 3 /* DerivedState.upToDate */;\n        const changeSummary = this.changeSummary;\n        this.changeSummary = (_a = this.createChangeSummary) === null || _a === void 0 ? void 0 : _a.call(this);\n        try {\n            /** might call {@link handleChange} indirectly, which could invalidate us */\n            this.value = this._computeFn(this, changeSummary);\n        }\n        finally {\n            // We don't want our observed observables to think that they are (not even temporarily) not being observed.\n            // Thus, we only unsubscribe from observables that are definitely not read anymore.\n            for (const o of this.dependenciesToBeRemoved) {\n                o.removeObserver(this);\n            }\n            this.dependenciesToBeRemoved.clear();\n        }\n        const didChange = hadValue && !(this._equalityComparator(oldValue, this.value));\n        (_b = getLogger()) === null || _b === void 0 ? void 0 : _b.handleDerivedRecomputed(this, {\n            oldValue,\n            newValue: this.value,\n            change: undefined,\n            didChange,\n            hadValue,\n        });\n        if (didChange) {\n            for (const r of this.observers) {\n                r.handleChange(this, undefined);\n            }\n        }\n    }\n    toString() {\n        return `LazyDerived<${this.debugName}>`;\n    }\n    // IObserver Implementation\n    beginUpdate(_observable) {\n        this.updateCount++;\n        const propagateBeginUpdate = this.updateCount === 1;\n        if (this.state === 3 /* DerivedState.upToDate */) {\n            this.state = 1 /* DerivedState.dependenciesMightHaveChanged */;\n            // If we propagate begin update, that will already signal a possible change.\n            if (!propagateBeginUpdate) {\n                for (const r of this.observers) {\n                    r.handlePossibleChange(this);\n                }\n            }\n        }\n        if (propagateBeginUpdate) {\n            for (const r of this.observers) {\n                r.beginUpdate(this); // This signals a possible change\n            }\n        }\n    }\n    endUpdate(_observable) {\n        this.updateCount--;\n        if (this.updateCount === 0) {\n            // End update could change the observer list.\n            const observers = [...this.observers];\n            for (const r of observers) {\n                r.endUpdate(this);\n            }\n        }\n        assertFn(() => this.updateCount >= 0);\n    }\n    handlePossibleChange(observable) {\n        // In all other states, observers already know that we might have changed.\n        if (this.state === 3 /* DerivedState.upToDate */ && this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n            this.state = 1 /* DerivedState.dependenciesMightHaveChanged */;\n            for (const r of this.observers) {\n                r.handlePossibleChange(this);\n            }\n        }\n    }\n    handleChange(observable, change) {\n        if (this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n            const shouldReact = this._handleChange ? this._handleChange({\n                changedObservable: observable,\n                change,\n                didChange: (o) => o === observable,\n            }, this.changeSummary) : true;\n            const wasUpToDate = this.state === 3 /* DerivedState.upToDate */;\n            if (shouldReact && (this.state === 1 /* DerivedState.dependenciesMightHaveChanged */ || wasUpToDate)) {\n                this.state = 2 /* DerivedState.stale */;\n                if (wasUpToDate) {\n                    for (const r of this.observers) {\n                        r.handlePossibleChange(this);\n                    }\n                }\n            }\n        }\n    }\n    // IReader Implementation\n    readObservable(observable) {\n        // Subscribe before getting the value to enable caching\n        observable.addObserver(this);\n        /** This might call {@link handleChange} indirectly, which could invalidate us */\n        const value = observable.get();\n        // Which is why we only add the observable to the dependencies now.\n        this.dependencies.add(observable);\n        this.dependenciesToBeRemoved.delete(observable);\n        return value;\n    }\n    addObserver(observer) {\n        const shouldCallBeginUpdate = !this.observers.has(observer) && this.updateCount > 0;\n        super.addObserver(observer);\n        if (shouldCallBeginUpdate) {\n            observer.beginUpdate(this);\n        }\n    }\n    removeObserver(observer) {\n        const shouldCallEndUpdate = this.observers.has(observer) && this.updateCount > 0;\n        super.removeObserver(observer);\n        if (shouldCallEndUpdate) {\n            // Calling end update after removing the observer makes sure endUpdate cannot be called twice here.\n            observer.endUpdate(this);\n        }\n    }\n}\nexport class DerivedWithSetter extends Derived {\n    constructor(debugNameData, computeFn, createChangeSummary, handleChange, handleLastObserverRemoved = undefined, equalityComparator, set) {\n        super(debugNameData, computeFn, createChangeSummary, handleChange, handleLastObserverRemoved, equalityComparator);\n        this.set = set;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}