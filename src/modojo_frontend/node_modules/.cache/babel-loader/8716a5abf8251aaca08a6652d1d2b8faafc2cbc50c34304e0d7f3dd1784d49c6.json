{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { OffsetRange } from './offsetRange.js';\nimport { Range } from './range.js';\nimport { findFirstIdxMonotonousOrArrLen, findLastIdxMonotonous, findLastMonotonous } from '../../../base/common/arraysFind.js';\n/**\n * A range of lines (1-based).\n */\nexport class LineRange {\n  static fromRangeInclusive(range) {\n    return new LineRange(range.startLineNumber, range.endLineNumber + 1);\n  }\n  /**\n   * @param lineRanges An array of sorted line ranges.\n   */\n  static joinMany(lineRanges) {\n    if (lineRanges.length === 0) {\n      return [];\n    }\n    let result = new LineRangeSet(lineRanges[0].slice());\n    for (let i = 1; i < lineRanges.length; i++) {\n      result = result.getUnion(new LineRangeSet(lineRanges[i].slice()));\n    }\n    return result.ranges;\n  }\n  static join(lineRanges) {\n    if (lineRanges.length === 0) {\n      throw new BugIndicatingError('lineRanges cannot be empty');\n    }\n    let startLineNumber = lineRanges[0].startLineNumber;\n    let endLineNumberExclusive = lineRanges[0].endLineNumberExclusive;\n    for (let i = 1; i < lineRanges.length; i++) {\n      startLineNumber = Math.min(startLineNumber, lineRanges[i].startLineNumber);\n      endLineNumberExclusive = Math.max(endLineNumberExclusive, lineRanges[i].endLineNumberExclusive);\n    }\n    return new LineRange(startLineNumber, endLineNumberExclusive);\n  }\n  static ofLength(startLineNumber, length) {\n    return new LineRange(startLineNumber, startLineNumber + length);\n  }\n  /**\n   * @internal\n   */\n  static deserialize(lineRange) {\n    return new LineRange(lineRange[0], lineRange[1]);\n  }\n  constructor(startLineNumber, endLineNumberExclusive) {\n    if (startLineNumber > endLineNumberExclusive) {\n      throw new BugIndicatingError(`startLineNumber ${startLineNumber} cannot be after endLineNumberExclusive ${endLineNumberExclusive}`);\n    }\n    this.startLineNumber = startLineNumber;\n    this.endLineNumberExclusive = endLineNumberExclusive;\n  }\n  /**\n   * Indicates if this line range contains the given line number.\n   */\n  contains(lineNumber) {\n    return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;\n  }\n  /**\n   * Indicates if this line range is empty.\n   */\n  get isEmpty() {\n    return this.startLineNumber === this.endLineNumberExclusive;\n  }\n  /**\n   * Moves this line range by the given offset of line numbers.\n   */\n  delta(offset) {\n    return new LineRange(this.startLineNumber + offset, this.endLineNumberExclusive + offset);\n  }\n  deltaLength(offset) {\n    return new LineRange(this.startLineNumber, this.endLineNumberExclusive + offset);\n  }\n  /**\n   * The number of lines this line range spans.\n   */\n  get length() {\n    return this.endLineNumberExclusive - this.startLineNumber;\n  }\n  /**\n   * Creates a line range that combines this and the given line range.\n   */\n  join(other) {\n    return new LineRange(Math.min(this.startLineNumber, other.startLineNumber), Math.max(this.endLineNumberExclusive, other.endLineNumberExclusive));\n  }\n  toString() {\n    return `[${this.startLineNumber},${this.endLineNumberExclusive})`;\n  }\n  /**\n   * The resulting range is empty if the ranges do not intersect, but touch.\n   * If the ranges don't even touch, the result is undefined.\n   */\n  intersect(other) {\n    const startLineNumber = Math.max(this.startLineNumber, other.startLineNumber);\n    const endLineNumberExclusive = Math.min(this.endLineNumberExclusive, other.endLineNumberExclusive);\n    if (startLineNumber <= endLineNumberExclusive) {\n      return new LineRange(startLineNumber, endLineNumberExclusive);\n    }\n    return undefined;\n  }\n  intersectsStrict(other) {\n    return this.startLineNumber < other.endLineNumberExclusive && other.startLineNumber < this.endLineNumberExclusive;\n  }\n  overlapOrTouch(other) {\n    return this.startLineNumber <= other.endLineNumberExclusive && other.startLineNumber <= this.endLineNumberExclusive;\n  }\n  equals(b) {\n    return this.startLineNumber === b.startLineNumber && this.endLineNumberExclusive === b.endLineNumberExclusive;\n  }\n  toInclusiveRange() {\n    if (this.isEmpty) {\n      return null;\n    }\n    return new Range(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);\n  }\n  /**\n   * @deprecated Using this function is discouraged because it might lead to bugs: The end position is not guaranteed to be a valid position!\n  */\n  toExclusiveRange() {\n    return new Range(this.startLineNumber, 1, this.endLineNumberExclusive, 1);\n  }\n  mapToLineArray(f) {\n    const result = [];\n    for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n      result.push(f(lineNumber));\n    }\n    return result;\n  }\n  forEach(f) {\n    for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n      f(lineNumber);\n    }\n  }\n  /**\n   * @internal\n   */\n  serialize() {\n    return [this.startLineNumber, this.endLineNumberExclusive];\n  }\n  includes(lineNumber) {\n    return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;\n  }\n  /**\n   * Converts this 1-based line range to a 0-based offset range (subtracts 1!).\n   * @internal\n   */\n  toOffsetRange() {\n    return new OffsetRange(this.startLineNumber - 1, this.endLineNumberExclusive - 1);\n  }\n}\nexport class LineRangeSet {\n  constructor() {\n    let _normalizedRanges = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    this._normalizedRanges = _normalizedRanges;\n  }\n  get ranges() {\n    return this._normalizedRanges;\n  }\n  addRange(range) {\n    if (range.length === 0) {\n      return;\n    }\n    // Idea: Find joinRange such that:\n    // replaceRange = _normalizedRanges.replaceRange(joinRange, range.joinAll(joinRange.map(idx => this._normalizedRanges[idx])))\n    // idx of first element that touches range or that is after range\n    const joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber);\n    // idx of element after { last element that touches range or that is before range }\n    const joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;\n    if (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n      // If there is no element that touches range, then joinRangeStartIdx === joinRangeEndIdxExclusive and that value is the index of the element after range\n      this._normalizedRanges.splice(joinRangeStartIdx, 0, range);\n    } else if (joinRangeStartIdx === joinRangeEndIdxExclusive - 1) {\n      // Else, there is an element that touches range and in this case it is both the first and last element. Thus we can replace it\n      const joinRange = this._normalizedRanges[joinRangeStartIdx];\n      this._normalizedRanges[joinRangeStartIdx] = joinRange.join(range);\n    } else {\n      // First and last element are different - we need to replace the entire range\n      const joinRange = this._normalizedRanges[joinRangeStartIdx].join(this._normalizedRanges[joinRangeEndIdxExclusive - 1]).join(range);\n      this._normalizedRanges.splice(joinRangeStartIdx, joinRangeEndIdxExclusive - joinRangeStartIdx, joinRange);\n    }\n  }\n  contains(lineNumber) {\n    const rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, r => r.startLineNumber <= lineNumber);\n    return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > lineNumber;\n  }\n  intersects(range) {\n    const rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, r => r.startLineNumber < range.endLineNumberExclusive);\n    return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > range.startLineNumber;\n  }\n  getUnion(other) {\n    if (this._normalizedRanges.length === 0) {\n      return other;\n    }\n    if (other._normalizedRanges.length === 0) {\n      return this;\n    }\n    const result = [];\n    let i1 = 0;\n    let i2 = 0;\n    let current = null;\n    while (i1 < this._normalizedRanges.length || i2 < other._normalizedRanges.length) {\n      let next = null;\n      if (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {\n        const lineRange1 = this._normalizedRanges[i1];\n        const lineRange2 = other._normalizedRanges[i2];\n        if (lineRange1.startLineNumber < lineRange2.startLineNumber) {\n          next = lineRange1;\n          i1++;\n        } else {\n          next = lineRange2;\n          i2++;\n        }\n      } else if (i1 < this._normalizedRanges.length) {\n        next = this._normalizedRanges[i1];\n        i1++;\n      } else {\n        next = other._normalizedRanges[i2];\n        i2++;\n      }\n      if (current === null) {\n        current = next;\n      } else {\n        if (current.endLineNumberExclusive >= next.startLineNumber) {\n          // merge\n          current = new LineRange(current.startLineNumber, Math.max(current.endLineNumberExclusive, next.endLineNumberExclusive));\n        } else {\n          // push\n          result.push(current);\n          current = next;\n        }\n      }\n    }\n    if (current !== null) {\n      result.push(current);\n    }\n    return new LineRangeSet(result);\n  }\n  /**\n   * Subtracts all ranges in this set from `range` and returns the result.\n   */\n  subtractFrom(range) {\n    // idx of first element that touches range or that is after range\n    const joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber);\n    // idx of element after { last element that touches range or that is before range }\n    const joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;\n    if (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n      return new LineRangeSet([range]);\n    }\n    const result = [];\n    let startLineNumber = range.startLineNumber;\n    for (let i = joinRangeStartIdx; i < joinRangeEndIdxExclusive; i++) {\n      const r = this._normalizedRanges[i];\n      if (r.startLineNumber > startLineNumber) {\n        result.push(new LineRange(startLineNumber, r.startLineNumber));\n      }\n      startLineNumber = r.endLineNumberExclusive;\n    }\n    if (startLineNumber < range.endLineNumberExclusive) {\n      result.push(new LineRange(startLineNumber, range.endLineNumberExclusive));\n    }\n    return new LineRangeSet(result);\n  }\n  toString() {\n    return this._normalizedRanges.map(r => r.toString()).join(', ');\n  }\n  getIntersection(other) {\n    const result = [];\n    let i1 = 0;\n    let i2 = 0;\n    while (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {\n      const r1 = this._normalizedRanges[i1];\n      const r2 = other._normalizedRanges[i2];\n      const i = r1.intersect(r2);\n      if (i && !i.isEmpty) {\n        result.push(i);\n      }\n      if (r1.endLineNumberExclusive < r2.endLineNumberExclusive) {\n        i1++;\n      } else {\n        i2++;\n      }\n    }\n    return new LineRangeSet(result);\n  }\n  getWithDelta(value) {\n    return new LineRangeSet(this._normalizedRanges.map(r => r.delta(value)));\n  }\n}","map":{"version":3,"names":["BugIndicatingError","OffsetRange","Range","findFirstIdxMonotonousOrArrLen","findLastIdxMonotonous","findLastMonotonous","LineRange","fromRangeInclusive","range","startLineNumber","endLineNumber","joinMany","lineRanges","length","result","LineRangeSet","slice","i","getUnion","ranges","join","endLineNumberExclusive","Math","min","max","ofLength","deserialize","lineRange","constructor","contains","lineNumber","isEmpty","delta","offset","deltaLength","other","toString","intersect","undefined","intersectsStrict","overlapOrTouch","equals","b","toInclusiveRange","Number","MAX_SAFE_INTEGER","toExclusiveRange","mapToLineArray","f","push","forEach","serialize","includes","toOffsetRange","_normalizedRanges","arguments","addRange","joinRangeStartIdx","r","joinRangeEndIdxExclusive","splice","joinRange","rangeThatStartsBeforeEnd","intersects","i1","i2","current","next","lineRange1","lineRange2","subtractFrom","map","getIntersection","r1","r2","getWithDelta","value"],"sources":["/home/arslan/modojo/node_modules/monaco-editor/esm/vs/editor/common/core/lineRange.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { OffsetRange } from './offsetRange.js';\nimport { Range } from './range.js';\nimport { findFirstIdxMonotonousOrArrLen, findLastIdxMonotonous, findLastMonotonous } from '../../../base/common/arraysFind.js';\n/**\n * A range of lines (1-based).\n */\nexport class LineRange {\n    static fromRangeInclusive(range) {\n        return new LineRange(range.startLineNumber, range.endLineNumber + 1);\n    }\n    /**\n     * @param lineRanges An array of sorted line ranges.\n     */\n    static joinMany(lineRanges) {\n        if (lineRanges.length === 0) {\n            return [];\n        }\n        let result = new LineRangeSet(lineRanges[0].slice());\n        for (let i = 1; i < lineRanges.length; i++) {\n            result = result.getUnion(new LineRangeSet(lineRanges[i].slice()));\n        }\n        return result.ranges;\n    }\n    static join(lineRanges) {\n        if (lineRanges.length === 0) {\n            throw new BugIndicatingError('lineRanges cannot be empty');\n        }\n        let startLineNumber = lineRanges[0].startLineNumber;\n        let endLineNumberExclusive = lineRanges[0].endLineNumberExclusive;\n        for (let i = 1; i < lineRanges.length; i++) {\n            startLineNumber = Math.min(startLineNumber, lineRanges[i].startLineNumber);\n            endLineNumberExclusive = Math.max(endLineNumberExclusive, lineRanges[i].endLineNumberExclusive);\n        }\n        return new LineRange(startLineNumber, endLineNumberExclusive);\n    }\n    static ofLength(startLineNumber, length) {\n        return new LineRange(startLineNumber, startLineNumber + length);\n    }\n    /**\n     * @internal\n     */\n    static deserialize(lineRange) {\n        return new LineRange(lineRange[0], lineRange[1]);\n    }\n    constructor(startLineNumber, endLineNumberExclusive) {\n        if (startLineNumber > endLineNumberExclusive) {\n            throw new BugIndicatingError(`startLineNumber ${startLineNumber} cannot be after endLineNumberExclusive ${endLineNumberExclusive}`);\n        }\n        this.startLineNumber = startLineNumber;\n        this.endLineNumberExclusive = endLineNumberExclusive;\n    }\n    /**\n     * Indicates if this line range contains the given line number.\n     */\n    contains(lineNumber) {\n        return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;\n    }\n    /**\n     * Indicates if this line range is empty.\n     */\n    get isEmpty() {\n        return this.startLineNumber === this.endLineNumberExclusive;\n    }\n    /**\n     * Moves this line range by the given offset of line numbers.\n     */\n    delta(offset) {\n        return new LineRange(this.startLineNumber + offset, this.endLineNumberExclusive + offset);\n    }\n    deltaLength(offset) {\n        return new LineRange(this.startLineNumber, this.endLineNumberExclusive + offset);\n    }\n    /**\n     * The number of lines this line range spans.\n     */\n    get length() {\n        return this.endLineNumberExclusive - this.startLineNumber;\n    }\n    /**\n     * Creates a line range that combines this and the given line range.\n     */\n    join(other) {\n        return new LineRange(Math.min(this.startLineNumber, other.startLineNumber), Math.max(this.endLineNumberExclusive, other.endLineNumberExclusive));\n    }\n    toString() {\n        return `[${this.startLineNumber},${this.endLineNumberExclusive})`;\n    }\n    /**\n     * The resulting range is empty if the ranges do not intersect, but touch.\n     * If the ranges don't even touch, the result is undefined.\n     */\n    intersect(other) {\n        const startLineNumber = Math.max(this.startLineNumber, other.startLineNumber);\n        const endLineNumberExclusive = Math.min(this.endLineNumberExclusive, other.endLineNumberExclusive);\n        if (startLineNumber <= endLineNumberExclusive) {\n            return new LineRange(startLineNumber, endLineNumberExclusive);\n        }\n        return undefined;\n    }\n    intersectsStrict(other) {\n        return this.startLineNumber < other.endLineNumberExclusive && other.startLineNumber < this.endLineNumberExclusive;\n    }\n    overlapOrTouch(other) {\n        return this.startLineNumber <= other.endLineNumberExclusive && other.startLineNumber <= this.endLineNumberExclusive;\n    }\n    equals(b) {\n        return this.startLineNumber === b.startLineNumber && this.endLineNumberExclusive === b.endLineNumberExclusive;\n    }\n    toInclusiveRange() {\n        if (this.isEmpty) {\n            return null;\n        }\n        return new Range(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);\n    }\n    /**\n     * @deprecated Using this function is discouraged because it might lead to bugs: The end position is not guaranteed to be a valid position!\n    */\n    toExclusiveRange() {\n        return new Range(this.startLineNumber, 1, this.endLineNumberExclusive, 1);\n    }\n    mapToLineArray(f) {\n        const result = [];\n        for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n            result.push(f(lineNumber));\n        }\n        return result;\n    }\n    forEach(f) {\n        for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n            f(lineNumber);\n        }\n    }\n    /**\n     * @internal\n     */\n    serialize() {\n        return [this.startLineNumber, this.endLineNumberExclusive];\n    }\n    includes(lineNumber) {\n        return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;\n    }\n    /**\n     * Converts this 1-based line range to a 0-based offset range (subtracts 1!).\n     * @internal\n     */\n    toOffsetRange() {\n        return new OffsetRange(this.startLineNumber - 1, this.endLineNumberExclusive - 1);\n    }\n}\nexport class LineRangeSet {\n    constructor(\n    /**\n     * Sorted by start line number.\n     * No two line ranges are touching or intersecting.\n     */\n    _normalizedRanges = []) {\n        this._normalizedRanges = _normalizedRanges;\n    }\n    get ranges() {\n        return this._normalizedRanges;\n    }\n    addRange(range) {\n        if (range.length === 0) {\n            return;\n        }\n        // Idea: Find joinRange such that:\n        // replaceRange = _normalizedRanges.replaceRange(joinRange, range.joinAll(joinRange.map(idx => this._normalizedRanges[idx])))\n        // idx of first element that touches range or that is after range\n        const joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber);\n        // idx of element after { last element that touches range or that is before range }\n        const joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;\n        if (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n            // If there is no element that touches range, then joinRangeStartIdx === joinRangeEndIdxExclusive and that value is the index of the element after range\n            this._normalizedRanges.splice(joinRangeStartIdx, 0, range);\n        }\n        else if (joinRangeStartIdx === joinRangeEndIdxExclusive - 1) {\n            // Else, there is an element that touches range and in this case it is both the first and last element. Thus we can replace it\n            const joinRange = this._normalizedRanges[joinRangeStartIdx];\n            this._normalizedRanges[joinRangeStartIdx] = joinRange.join(range);\n        }\n        else {\n            // First and last element are different - we need to replace the entire range\n            const joinRange = this._normalizedRanges[joinRangeStartIdx].join(this._normalizedRanges[joinRangeEndIdxExclusive - 1]).join(range);\n            this._normalizedRanges.splice(joinRangeStartIdx, joinRangeEndIdxExclusive - joinRangeStartIdx, joinRange);\n        }\n    }\n    contains(lineNumber) {\n        const rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, r => r.startLineNumber <= lineNumber);\n        return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > lineNumber;\n    }\n    intersects(range) {\n        const rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, r => r.startLineNumber < range.endLineNumberExclusive);\n        return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > range.startLineNumber;\n    }\n    getUnion(other) {\n        if (this._normalizedRanges.length === 0) {\n            return other;\n        }\n        if (other._normalizedRanges.length === 0) {\n            return this;\n        }\n        const result = [];\n        let i1 = 0;\n        let i2 = 0;\n        let current = null;\n        while (i1 < this._normalizedRanges.length || i2 < other._normalizedRanges.length) {\n            let next = null;\n            if (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {\n                const lineRange1 = this._normalizedRanges[i1];\n                const lineRange2 = other._normalizedRanges[i2];\n                if (lineRange1.startLineNumber < lineRange2.startLineNumber) {\n                    next = lineRange1;\n                    i1++;\n                }\n                else {\n                    next = lineRange2;\n                    i2++;\n                }\n            }\n            else if (i1 < this._normalizedRanges.length) {\n                next = this._normalizedRanges[i1];\n                i1++;\n            }\n            else {\n                next = other._normalizedRanges[i2];\n                i2++;\n            }\n            if (current === null) {\n                current = next;\n            }\n            else {\n                if (current.endLineNumberExclusive >= next.startLineNumber) {\n                    // merge\n                    current = new LineRange(current.startLineNumber, Math.max(current.endLineNumberExclusive, next.endLineNumberExclusive));\n                }\n                else {\n                    // push\n                    result.push(current);\n                    current = next;\n                }\n            }\n        }\n        if (current !== null) {\n            result.push(current);\n        }\n        return new LineRangeSet(result);\n    }\n    /**\n     * Subtracts all ranges in this set from `range` and returns the result.\n     */\n    subtractFrom(range) {\n        // idx of first element that touches range or that is after range\n        const joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber);\n        // idx of element after { last element that touches range or that is before range }\n        const joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;\n        if (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n            return new LineRangeSet([range]);\n        }\n        const result = [];\n        let startLineNumber = range.startLineNumber;\n        for (let i = joinRangeStartIdx; i < joinRangeEndIdxExclusive; i++) {\n            const r = this._normalizedRanges[i];\n            if (r.startLineNumber > startLineNumber) {\n                result.push(new LineRange(startLineNumber, r.startLineNumber));\n            }\n            startLineNumber = r.endLineNumberExclusive;\n        }\n        if (startLineNumber < range.endLineNumberExclusive) {\n            result.push(new LineRange(startLineNumber, range.endLineNumberExclusive));\n        }\n        return new LineRangeSet(result);\n    }\n    toString() {\n        return this._normalizedRanges.map(r => r.toString()).join(', ');\n    }\n    getIntersection(other) {\n        const result = [];\n        let i1 = 0;\n        let i2 = 0;\n        while (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {\n            const r1 = this._normalizedRanges[i1];\n            const r2 = other._normalizedRanges[i2];\n            const i = r1.intersect(r2);\n            if (i && !i.isEmpty) {\n                result.push(i);\n            }\n            if (r1.endLineNumberExclusive < r2.endLineNumberExclusive) {\n                i1++;\n            }\n            else {\n                i2++;\n            }\n        }\n        return new LineRangeSet(result);\n    }\n    getWithDelta(value) {\n        return new LineRangeSet(this._normalizedRanges.map(r => r.delta(value)));\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}