{"ast":null,"code":"var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _ExpirableMap_inner, _ExpirableMap_expirationTime, _a, _b;\n/**\n * A map that expires entries after a given time.\n * Defaults to 10 minutes.\n */\nexport class ExpirableMap {\n  /**\n   * Create a new ExpirableMap.\n   * @param {ExpirableMapOptions<any, any>} options - options for the map.\n   * @param {Iterable<[any, any]>} options.source - an optional source of entries to initialize the map with.\n   * @param {number} options.expirationTime - the time in milliseconds after which entries will expire.\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // Internals\n    _ExpirableMap_inner.set(this, void 0);\n    _ExpirableMap_expirationTime.set(this, void 0);\n    this[_a] = this.entries.bind(this);\n    this[_b] = 'ExpirableMap';\n    const {\n      source = [],\n      expirationTime = 10 * 60 * 1000\n    } = options;\n    const currentTime = Date.now();\n    __classPrivateFieldSet(this, _ExpirableMap_inner, new Map([...source].map(_ref => {\n      let [key, value] = _ref;\n      return [key, {\n        value,\n        timestamp: currentTime\n      }];\n    })), \"f\");\n    __classPrivateFieldSet(this, _ExpirableMap_expirationTime, expirationTime, \"f\");\n  }\n  /**\n   * Prune removes all expired entries.\n   */\n  prune() {\n    const currentTime = Date.now();\n    for (const [key, entry] of __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").entries()) {\n      if (currentTime - entry.timestamp > __classPrivateFieldGet(this, _ExpirableMap_expirationTime, \"f\")) {\n        __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").delete(key);\n      }\n    }\n    return this;\n  }\n  // Implementing the Map interface\n  /**\n   * Set the value for the given key. Prunes expired entries.\n   * @param key for the entry\n   * @param value of the entry\n   * @returns this\n   */\n  set(key, value) {\n    this.prune();\n    const entry = {\n      value,\n      timestamp: Date.now()\n    };\n    __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").set(key, entry);\n    return this;\n  }\n  /**\n   * Get the value associated with the key, if it exists and has not expired.\n   * @param key K\n   * @returns the value associated with the key, or undefined if the key is not present or has expired.\n   */\n  get(key) {\n    const entry = __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").get(key);\n    if (entry === undefined) {\n      return undefined;\n    }\n    if (Date.now() - entry.timestamp > __classPrivateFieldGet(this, _ExpirableMap_expirationTime, \"f\")) {\n      __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").delete(key);\n      return undefined;\n    }\n    return entry.value;\n  }\n  /**\n   * Clear all entries.\n   */\n  clear() {\n    __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").clear();\n  }\n  /**\n   * Entries returns the entries of the map, without the expiration time.\n   * @returns an iterator over the entries of the map.\n   */\n  entries() {\n    const iterator = __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").entries();\n    const generator = function* () {\n      for (const [key, value] of iterator) {\n        yield [key, value.value];\n      }\n    };\n    return generator();\n  }\n  /**\n   * Values returns the values of the map, without the expiration time.\n   * @returns an iterator over the values of the map.\n   */\n  values() {\n    const iterator = __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").values();\n    const generator = function* () {\n      for (const value of iterator) {\n        yield value.value;\n      }\n    };\n    return generator();\n  }\n  /**\n   * Keys returns the keys of the map\n   * @returns an iterator over the keys of the map.\n   */\n  keys() {\n    return __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").keys();\n  }\n  /**\n   * forEach calls the callbackfn on each entry of the map.\n   * @param callbackfn to call on each entry\n   * @param thisArg to use as this when calling the callbackfn\n   */\n  forEach(callbackfn, thisArg) {\n    for (const [key, value] of __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").entries()) {\n      callbackfn.call(thisArg, value.value, key, this);\n    }\n  }\n  /**\n   * has returns true if the key exists and has not expired.\n   * @param key K\n   * @returns true if the key exists and has not expired.\n   */\n  has(key) {\n    return __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").has(key);\n  }\n  /**\n   * delete the entry for the given key.\n   * @param key K\n   * @returns true if the key existed and has been deleted.\n   */\n  delete(key) {\n    return __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").delete(key);\n  }\n  /**\n   * get size of the map.\n   * @returns the size of the map.\n   */\n  get size() {\n    return __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").size;\n  }\n}\n_ExpirableMap_inner = new WeakMap(), _ExpirableMap_expirationTime = new WeakMap(), _a = Symbol.iterator, _b = Symbol.toStringTag;","map":{"version":3,"names":["ExpirableMap","constructor","options","arguments","length","undefined","_ExpirableMap_inner","set","_ExpirableMap_expirationTime","_a","entries","bind","_b","source","expirationTime","currentTime","Date","now","__classPrivateFieldSet","Map","map","_ref","key","value","timestamp","prune","entry","__classPrivateFieldGet","delete","get","clear","iterator","generator","values","keys","forEach","callbackfn","thisArg","call","has","size","Symbol","toStringTag"],"sources":["/home/arslan/modojo/node_modules/@dfinity/agent/src/utils/expirableMap.ts"],"sourcesContent":["export type ExpirableMapOptions<K, V> = {\n  source?: Iterable<[K, V]>;\n  expirationTime?: number;\n};\n\n/**\n * A map that expires entries after a given time.\n * Defaults to 10 minutes.\n */\nexport class ExpirableMap<K, V> implements Map<K, V> {\n  // Internals\n  #inner: Map<K, { value: V; timestamp: number }>;\n  #expirationTime: number;\n\n  [Symbol.iterator]: () => IterableIterator<[K, V]> = this.entries.bind(this);\n  [Symbol.toStringTag] = 'ExpirableMap';\n\n  /**\n   * Create a new ExpirableMap.\n   * @param {ExpirableMapOptions<any, any>} options - options for the map.\n   * @param {Iterable<[any, any]>} options.source - an optional source of entries to initialize the map with.\n   * @param {number} options.expirationTime - the time in milliseconds after which entries will expire.\n   */\n  constructor(options: ExpirableMapOptions<K, V> = {}) {\n    const { source = [], expirationTime = 10 * 60 * 1000 } = options;\n    const currentTime = Date.now();\n    this.#inner = new Map(\n      [...source].map(([key, value]) => [key, { value, timestamp: currentTime }]),\n    );\n    this.#expirationTime = expirationTime;\n  }\n\n  /**\n   * Prune removes all expired entries.\n   */\n  prune() {\n    const currentTime = Date.now();\n    for (const [key, entry] of this.#inner.entries()) {\n      if (currentTime - entry.timestamp > this.#expirationTime) {\n        this.#inner.delete(key);\n      }\n    }\n    return this;\n  }\n\n  // Implementing the Map interface\n\n  /**\n   * Set the value for the given key. Prunes expired entries.\n   * @param key for the entry\n   * @param value of the entry\n   * @returns this\n   */\n  set(key: K, value: V) {\n    this.prune();\n    const entry = {\n      value,\n      timestamp: Date.now(),\n    };\n    this.#inner.set(key, entry);\n\n    return this;\n  }\n\n  /**\n   * Get the value associated with the key, if it exists and has not expired.\n   * @param key K\n   * @returns the value associated with the key, or undefined if the key is not present or has expired.\n   */\n  get(key: K) {\n    const entry = this.#inner.get(key);\n    if (entry === undefined) {\n      return undefined;\n    }\n    if (Date.now() - entry.timestamp > this.#expirationTime) {\n      this.#inner.delete(key);\n      return undefined;\n    }\n    return entry.value;\n  }\n\n  /**\n   * Clear all entries.\n   */\n  clear() {\n    this.#inner.clear();\n  }\n\n  /**\n   * Entries returns the entries of the map, without the expiration time.\n   * @returns an iterator over the entries of the map.\n   */\n  entries(): IterableIterator<[K, V]> {\n    const iterator = this.#inner.entries();\n    const generator = function* () {\n      for (const [key, value] of iterator) {\n        yield [key, value.value] as [K, V];\n      }\n    };\n    return generator();\n  }\n\n  /**\n   * Values returns the values of the map, without the expiration time.\n   * @returns an iterator over the values of the map.\n   */\n  values(): IterableIterator<V> {\n    const iterator = this.#inner.values();\n    const generator = function* () {\n      for (const value of iterator) {\n        yield value.value;\n      }\n    };\n    return generator();\n  }\n\n  /**\n   * Keys returns the keys of the map\n   * @returns an iterator over the keys of the map.\n   */\n  keys(): IterableIterator<K> {\n    return this.#inner.keys();\n  }\n\n  /**\n   * forEach calls the callbackfn on each entry of the map.\n   * @param callbackfn to call on each entry\n   * @param thisArg to use as this when calling the callbackfn\n   */\n  forEach(callbackfn: (value: V, key: K, map: Map<K, V>) => void, thisArg?: ExpirableMap<K, V>) {\n    for (const [key, value] of this.#inner.entries()) {\n      callbackfn.call(thisArg, value.value, key, this);\n    }\n  }\n\n  /**\n   * has returns true if the key exists and has not expired.\n   * @param key K\n   * @returns true if the key exists and has not expired.\n   */\n  has(key: K): boolean {\n    return this.#inner.has(key);\n  }\n\n  /**\n   * delete the entry for the given key.\n   * @param key K\n   * @returns true if the key existed and has been deleted.\n   */\n  delete(key: K) {\n    return this.#inner.delete(key);\n  }\n\n  /**\n   * get size of the map.\n   * @returns the size of the map.\n   */\n  get size() {\n    return this.#inner.size;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}