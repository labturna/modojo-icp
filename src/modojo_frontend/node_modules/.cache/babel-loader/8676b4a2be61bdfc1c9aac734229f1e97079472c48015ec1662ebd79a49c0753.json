{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LRUCache } from '../../../base/common/map.js';\nimport { CharacterClassifier } from './characterClassifier.js';\nexport class WordCharacterClassifier extends CharacterClassifier {\n  constructor(wordSeparators, intlSegmenterLocales) {\n    super(0 /* WordCharacterClass.Regular */);\n    this._segmenter = null;\n    this._cachedLine = null;\n    this._cachedSegments = [];\n    this.intlSegmenterLocales = intlSegmenterLocales;\n    if (this.intlSegmenterLocales.length > 0) {\n      this._segmenter = new Intl.Segmenter(this.intlSegmenterLocales, {\n        granularity: 'word'\n      });\n    } else {\n      this._segmenter = null;\n    }\n    for (let i = 0, len = wordSeparators.length; i < len; i++) {\n      this.set(wordSeparators.charCodeAt(i), 2 /* WordCharacterClass.WordSeparator */);\n    }\n    this.set(32 /* CharCode.Space */, 1 /* WordCharacterClass.Whitespace */);\n    this.set(9 /* CharCode.Tab */, 1 /* WordCharacterClass.Whitespace */);\n  }\n  findPrevIntlWordBeforeOrAtOffset(line, offset) {\n    let candidate = null;\n    for (const segment of this._getIntlSegmenterWordsOnLine(line)) {\n      if (segment.index > offset) {\n        break;\n      }\n      candidate = segment;\n    }\n    return candidate;\n  }\n  findNextIntlWordAtOrAfterOffset(lineContent, offset) {\n    for (const segment of this._getIntlSegmenterWordsOnLine(lineContent)) {\n      if (segment.index < offset) {\n        continue;\n      }\n      return segment;\n    }\n    return null;\n  }\n  _getIntlSegmenterWordsOnLine(line) {\n    if (!this._segmenter) {\n      return [];\n    }\n    // Check if the line has changed from the previous call\n    if (this._cachedLine === line) {\n      return this._cachedSegments;\n    }\n    // Update the cache with the new line\n    this._cachedLine = line;\n    this._cachedSegments = this._filterWordSegments(this._segmenter.segment(line));\n    return this._cachedSegments;\n  }\n  _filterWordSegments(segments) {\n    const result = [];\n    for (const segment of segments) {\n      if (this._isWordLike(segment)) {\n        result.push(segment);\n      }\n    }\n    return result;\n  }\n  _isWordLike(segment) {\n    if (segment.isWordLike) {\n      return true;\n    }\n    return false;\n  }\n}\nconst wordClassifierCache = new LRUCache(10);\nexport function getMapForWordSeparators(wordSeparators, intlSegmenterLocales) {\n  const key = `${wordSeparators}/${intlSegmenterLocales.join(',')}`;\n  let result = wordClassifierCache.get(key);\n  if (!result) {\n    result = new WordCharacterClassifier(wordSeparators, intlSegmenterLocales);\n    wordClassifierCache.set(key, result);\n  }\n  return result;\n}","map":{"version":3,"names":["LRUCache","CharacterClassifier","WordCharacterClassifier","constructor","wordSeparators","intlSegmenterLocales","_segmenter","_cachedLine","_cachedSegments","length","Intl","Segmenter","granularity","i","len","set","charCodeAt","findPrevIntlWordBeforeOrAtOffset","line","offset","candidate","segment","_getIntlSegmenterWordsOnLine","index","findNextIntlWordAtOrAfterOffset","lineContent","_filterWordSegments","segments","result","_isWordLike","push","isWordLike","wordClassifierCache","getMapForWordSeparators","key","join","get"],"sources":["/home/arslan/modojo/node_modules/monaco-editor/esm/vs/editor/common/core/wordCharacterClassifier.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LRUCache } from '../../../base/common/map.js';\nimport { CharacterClassifier } from './characterClassifier.js';\nexport class WordCharacterClassifier extends CharacterClassifier {\n    constructor(wordSeparators, intlSegmenterLocales) {\n        super(0 /* WordCharacterClass.Regular */);\n        this._segmenter = null;\n        this._cachedLine = null;\n        this._cachedSegments = [];\n        this.intlSegmenterLocales = intlSegmenterLocales;\n        if (this.intlSegmenterLocales.length > 0) {\n            this._segmenter = new Intl.Segmenter(this.intlSegmenterLocales, { granularity: 'word' });\n        }\n        else {\n            this._segmenter = null;\n        }\n        for (let i = 0, len = wordSeparators.length; i < len; i++) {\n            this.set(wordSeparators.charCodeAt(i), 2 /* WordCharacterClass.WordSeparator */);\n        }\n        this.set(32 /* CharCode.Space */, 1 /* WordCharacterClass.Whitespace */);\n        this.set(9 /* CharCode.Tab */, 1 /* WordCharacterClass.Whitespace */);\n    }\n    findPrevIntlWordBeforeOrAtOffset(line, offset) {\n        let candidate = null;\n        for (const segment of this._getIntlSegmenterWordsOnLine(line)) {\n            if (segment.index > offset) {\n                break;\n            }\n            candidate = segment;\n        }\n        return candidate;\n    }\n    findNextIntlWordAtOrAfterOffset(lineContent, offset) {\n        for (const segment of this._getIntlSegmenterWordsOnLine(lineContent)) {\n            if (segment.index < offset) {\n                continue;\n            }\n            return segment;\n        }\n        return null;\n    }\n    _getIntlSegmenterWordsOnLine(line) {\n        if (!this._segmenter) {\n            return [];\n        }\n        // Check if the line has changed from the previous call\n        if (this._cachedLine === line) {\n            return this._cachedSegments;\n        }\n        // Update the cache with the new line\n        this._cachedLine = line;\n        this._cachedSegments = this._filterWordSegments(this._segmenter.segment(line));\n        return this._cachedSegments;\n    }\n    _filterWordSegments(segments) {\n        const result = [];\n        for (const segment of segments) {\n            if (this._isWordLike(segment)) {\n                result.push(segment);\n            }\n        }\n        return result;\n    }\n    _isWordLike(segment) {\n        if (segment.isWordLike) {\n            return true;\n        }\n        return false;\n    }\n}\nconst wordClassifierCache = new LRUCache(10);\nexport function getMapForWordSeparators(wordSeparators, intlSegmenterLocales) {\n    const key = `${wordSeparators}/${intlSegmenterLocales.join(',')}`;\n    let result = wordClassifierCache.get(key);\n    if (!result) {\n        result = new WordCharacterClassifier(wordSeparators, intlSegmenterLocales);\n        wordClassifierCache.set(key, result);\n    }\n    return result;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}