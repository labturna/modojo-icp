{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport var Iterable;\n(function (Iterable) {\n  function is(thing) {\n    return thing && typeof thing === 'object' && typeof thing[Symbol.iterator] === 'function';\n  }\n  Iterable.is = is;\n  const _empty = Object.freeze([]);\n  function empty() {\n    return _empty;\n  }\n  Iterable.empty = empty;\n  function* single(element) {\n    yield element;\n  }\n  Iterable.single = single;\n  function wrap(iterableOrElement) {\n    if (is(iterableOrElement)) {\n      return iterableOrElement;\n    } else {\n      return single(iterableOrElement);\n    }\n  }\n  Iterable.wrap = wrap;\n  function from(iterable) {\n    return iterable || _empty;\n  }\n  Iterable.from = from;\n  function* reverse(array) {\n    for (let i = array.length - 1; i >= 0; i--) {\n      yield array[i];\n    }\n  }\n  Iterable.reverse = reverse;\n  function isEmpty(iterable) {\n    return !iterable || iterable[Symbol.iterator]().next().done === true;\n  }\n  Iterable.isEmpty = isEmpty;\n  function first(iterable) {\n    return iterable[Symbol.iterator]().next().value;\n  }\n  Iterable.first = first;\n  function some(iterable, predicate) {\n    for (const element of iterable) {\n      if (predicate(element)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  Iterable.some = some;\n  function find(iterable, predicate) {\n    for (const element of iterable) {\n      if (predicate(element)) {\n        return element;\n      }\n    }\n    return undefined;\n  }\n  Iterable.find = find;\n  function* filter(iterable, predicate) {\n    for (const element of iterable) {\n      if (predicate(element)) {\n        yield element;\n      }\n    }\n  }\n  Iterable.filter = filter;\n  function* map(iterable, fn) {\n    let index = 0;\n    for (const element of iterable) {\n      yield fn(element, index++);\n    }\n  }\n  Iterable.map = map;\n  function* concat() {\n    for (var _len = arguments.length, iterables = new Array(_len), _key = 0; _key < _len; _key++) {\n      iterables[_key] = arguments[_key];\n    }\n    for (const iterable of iterables) {\n      yield* iterable;\n    }\n  }\n  Iterable.concat = concat;\n  function reduce(iterable, reducer, initialValue) {\n    let value = initialValue;\n    for (const element of iterable) {\n      value = reducer(value, element);\n    }\n    return value;\n  }\n  Iterable.reduce = reduce;\n  /**\n   * Returns an iterable slice of the array, with the same semantics as `array.slice()`.\n   */\n  function slice(arr, from) {\n    let to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;\n    return function* () {\n      if (from < 0) {\n        from += arr.length;\n      }\n      if (to < 0) {\n        to += arr.length;\n      } else if (to > arr.length) {\n        to = arr.length;\n      }\n      for (; from < to; from++) {\n        yield arr[from];\n      }\n    }();\n  }\n  Iterable.slice = slice;\n  /**\n   * Consumes `atMost` elements from iterable and returns the consumed elements,\n   * and an iterable for the rest of the elements.\n   */\n  function consume(iterable) {\n    let atMost = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.POSITIVE_INFINITY;\n    const consumed = [];\n    if (atMost === 0) {\n      return [consumed, iterable];\n    }\n    const iterator = iterable[Symbol.iterator]();\n    for (let i = 0; i < atMost; i++) {\n      const next = iterator.next();\n      if (next.done) {\n        return [consumed, Iterable.empty()];\n      }\n      consumed.push(next.value);\n    }\n    return [consumed, {\n      [Symbol.iterator]() {\n        return iterator;\n      }\n    }];\n  }\n  Iterable.consume = consume;\n  async function asyncToArray(iterable) {\n    const result = [];\n    for await (const item of iterable) {\n      result.push(item);\n    }\n    return Promise.resolve(result);\n  }\n  Iterable.asyncToArray = asyncToArray;\n})(Iterable || (Iterable = {}));","map":{"version":3,"names":["Iterable","is","thing","Symbol","iterator","_empty","Object","freeze","empty","single","element","wrap","iterableOrElement","from","iterable","reverse","array","i","length","isEmpty","next","done","first","value","some","predicate","find","undefined","filter","map","fn","index","concat","_len","arguments","iterables","Array","_key","reduce","reducer","initialValue","slice","arr","to","consume","atMost","Number","POSITIVE_INFINITY","consumed","push","asyncToArray","result","item","Promise","resolve"],"sources":["/home/arslan/modojo/node_modules/monaco-editor/esm/vs/base/common/iterator.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport var Iterable;\n(function (Iterable) {\n    function is(thing) {\n        return thing && typeof thing === 'object' && typeof thing[Symbol.iterator] === 'function';\n    }\n    Iterable.is = is;\n    const _empty = Object.freeze([]);\n    function empty() {\n        return _empty;\n    }\n    Iterable.empty = empty;\n    function* single(element) {\n        yield element;\n    }\n    Iterable.single = single;\n    function wrap(iterableOrElement) {\n        if (is(iterableOrElement)) {\n            return iterableOrElement;\n        }\n        else {\n            return single(iterableOrElement);\n        }\n    }\n    Iterable.wrap = wrap;\n    function from(iterable) {\n        return iterable || _empty;\n    }\n    Iterable.from = from;\n    function* reverse(array) {\n        for (let i = array.length - 1; i >= 0; i--) {\n            yield array[i];\n        }\n    }\n    Iterable.reverse = reverse;\n    function isEmpty(iterable) {\n        return !iterable || iterable[Symbol.iterator]().next().done === true;\n    }\n    Iterable.isEmpty = isEmpty;\n    function first(iterable) {\n        return iterable[Symbol.iterator]().next().value;\n    }\n    Iterable.first = first;\n    function some(iterable, predicate) {\n        for (const element of iterable) {\n            if (predicate(element)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    Iterable.some = some;\n    function find(iterable, predicate) {\n        for (const element of iterable) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return undefined;\n    }\n    Iterable.find = find;\n    function* filter(iterable, predicate) {\n        for (const element of iterable) {\n            if (predicate(element)) {\n                yield element;\n            }\n        }\n    }\n    Iterable.filter = filter;\n    function* map(iterable, fn) {\n        let index = 0;\n        for (const element of iterable) {\n            yield fn(element, index++);\n        }\n    }\n    Iterable.map = map;\n    function* concat(...iterables) {\n        for (const iterable of iterables) {\n            yield* iterable;\n        }\n    }\n    Iterable.concat = concat;\n    function reduce(iterable, reducer, initialValue) {\n        let value = initialValue;\n        for (const element of iterable) {\n            value = reducer(value, element);\n        }\n        return value;\n    }\n    Iterable.reduce = reduce;\n    /**\n     * Returns an iterable slice of the array, with the same semantics as `array.slice()`.\n     */\n    function* slice(arr, from, to = arr.length) {\n        if (from < 0) {\n            from += arr.length;\n        }\n        if (to < 0) {\n            to += arr.length;\n        }\n        else if (to > arr.length) {\n            to = arr.length;\n        }\n        for (; from < to; from++) {\n            yield arr[from];\n        }\n    }\n    Iterable.slice = slice;\n    /**\n     * Consumes `atMost` elements from iterable and returns the consumed elements,\n     * and an iterable for the rest of the elements.\n     */\n    function consume(iterable, atMost = Number.POSITIVE_INFINITY) {\n        const consumed = [];\n        if (atMost === 0) {\n            return [consumed, iterable];\n        }\n        const iterator = iterable[Symbol.iterator]();\n        for (let i = 0; i < atMost; i++) {\n            const next = iterator.next();\n            if (next.done) {\n                return [consumed, Iterable.empty()];\n            }\n            consumed.push(next.value);\n        }\n        return [consumed, { [Symbol.iterator]() { return iterator; } }];\n    }\n    Iterable.consume = consume;\n    async function asyncToArray(iterable) {\n        const result = [];\n        for await (const item of iterable) {\n            result.push(item);\n        }\n        return Promise.resolve(result);\n    }\n    Iterable.asyncToArray = asyncToArray;\n})(Iterable || (Iterable = {}));\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}