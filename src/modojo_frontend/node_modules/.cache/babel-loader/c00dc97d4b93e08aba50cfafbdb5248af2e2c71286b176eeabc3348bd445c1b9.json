{"ast":null,"code":"var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _ExponentialBackoff_currentInterval, _ExponentialBackoff_randomizationFactor, _ExponentialBackoff_multiplier, _ExponentialBackoff_maxInterval, _ExponentialBackoff_startTime, _ExponentialBackoff_maxElapsedTime, _ExponentialBackoff_maxIterations, _ExponentialBackoff_date, _ExponentialBackoff_count;\nconst RANDOMIZATION_FACTOR = 0.5;\nconst MULTIPLIER = 1.5;\nconst INITIAL_INTERVAL_MSEC = 500;\nconst MAX_INTERVAL_MSEC = 60000;\nconst MAX_ELAPSED_TIME_MSEC = 900000;\nconst MAX_ITERATIONS = 10;\n/**\n * Exponential backoff strategy.\n */\nexport class ExponentialBackoff {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ExponentialBackoff.default;\n    _ExponentialBackoff_currentInterval.set(this, void 0);\n    _ExponentialBackoff_randomizationFactor.set(this, void 0);\n    _ExponentialBackoff_multiplier.set(this, void 0);\n    _ExponentialBackoff_maxInterval.set(this, void 0);\n    _ExponentialBackoff_startTime.set(this, void 0);\n    _ExponentialBackoff_maxElapsedTime.set(this, void 0);\n    _ExponentialBackoff_maxIterations.set(this, void 0);\n    _ExponentialBackoff_date.set(this, void 0);\n    _ExponentialBackoff_count.set(this, 0);\n    const {\n      initialInterval = INITIAL_INTERVAL_MSEC,\n      randomizationFactor = RANDOMIZATION_FACTOR,\n      multiplier = MULTIPLIER,\n      maxInterval = MAX_INTERVAL_MSEC,\n      maxElapsedTime = MAX_ELAPSED_TIME_MSEC,\n      maxIterations = MAX_ITERATIONS,\n      date = Date\n    } = options;\n    __classPrivateFieldSet(this, _ExponentialBackoff_currentInterval, initialInterval, \"f\");\n    __classPrivateFieldSet(this, _ExponentialBackoff_randomizationFactor, randomizationFactor, \"f\");\n    __classPrivateFieldSet(this, _ExponentialBackoff_multiplier, multiplier, \"f\");\n    __classPrivateFieldSet(this, _ExponentialBackoff_maxInterval, maxInterval, \"f\");\n    __classPrivateFieldSet(this, _ExponentialBackoff_date, date, \"f\");\n    __classPrivateFieldSet(this, _ExponentialBackoff_startTime, date.now(), \"f\");\n    __classPrivateFieldSet(this, _ExponentialBackoff_maxElapsedTime, maxElapsedTime, \"f\");\n    __classPrivateFieldSet(this, _ExponentialBackoff_maxIterations, maxIterations, \"f\");\n  }\n  get ellapsedTimeInMsec() {\n    return __classPrivateFieldGet(this, _ExponentialBackoff_date, \"f\").now() - __classPrivateFieldGet(this, _ExponentialBackoff_startTime, \"f\");\n  }\n  get currentInterval() {\n    return __classPrivateFieldGet(this, _ExponentialBackoff_currentInterval, \"f\");\n  }\n  get count() {\n    return __classPrivateFieldGet(this, _ExponentialBackoff_count, \"f\");\n  }\n  get randomValueFromInterval() {\n    const delta = __classPrivateFieldGet(this, _ExponentialBackoff_randomizationFactor, \"f\") * __classPrivateFieldGet(this, _ExponentialBackoff_currentInterval, \"f\");\n    const min = __classPrivateFieldGet(this, _ExponentialBackoff_currentInterval, \"f\") - delta;\n    const max = __classPrivateFieldGet(this, _ExponentialBackoff_currentInterval, \"f\") + delta;\n    return Math.random() * (max - min) + min;\n  }\n  incrementCurrentInterval() {\n    var _a;\n    __classPrivateFieldSet(this, _ExponentialBackoff_currentInterval, Math.min(__classPrivateFieldGet(this, _ExponentialBackoff_currentInterval, \"f\") * __classPrivateFieldGet(this, _ExponentialBackoff_multiplier, \"f\"), __classPrivateFieldGet(this, _ExponentialBackoff_maxInterval, \"f\")), \"f\");\n    __classPrivateFieldSet(this, _ExponentialBackoff_count, (_a = __classPrivateFieldGet(this, _ExponentialBackoff_count, \"f\"), _a++, _a), \"f\");\n    return __classPrivateFieldGet(this, _ExponentialBackoff_currentInterval, \"f\");\n  }\n  next() {\n    if (this.ellapsedTimeInMsec >= __classPrivateFieldGet(this, _ExponentialBackoff_maxElapsedTime, \"f\") || __classPrivateFieldGet(this, _ExponentialBackoff_count, \"f\") >= __classPrivateFieldGet(this, _ExponentialBackoff_maxIterations, \"f\")) {\n      return null;\n    } else {\n      this.incrementCurrentInterval();\n      return this.randomValueFromInterval;\n    }\n  }\n}\n_ExponentialBackoff_currentInterval = new WeakMap(), _ExponentialBackoff_randomizationFactor = new WeakMap(), _ExponentialBackoff_multiplier = new WeakMap(), _ExponentialBackoff_maxInterval = new WeakMap(), _ExponentialBackoff_startTime = new WeakMap(), _ExponentialBackoff_maxElapsedTime = new WeakMap(), _ExponentialBackoff_maxIterations = new WeakMap(), _ExponentialBackoff_date = new WeakMap(), _ExponentialBackoff_count = new WeakMap();\nExponentialBackoff.default = {\n  initialInterval: INITIAL_INTERVAL_MSEC,\n  randomizationFactor: RANDOMIZATION_FACTOR,\n  multiplier: MULTIPLIER,\n  maxInterval: MAX_INTERVAL_MSEC,\n  // 1 minute\n  maxElapsedTime: MAX_ELAPSED_TIME_MSEC,\n  maxIterations: MAX_ITERATIONS,\n  date: Date\n};\n/**\n * Utility function to create an exponential backoff iterator.\n * @param options - for the exponential backoff\n * @returns an iterator that yields the next delay in the exponential backoff\n * @yields the next delay in the exponential backoff\n */\nexport function exponentialBackoff() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ExponentialBackoff.default;\n  return function* () {\n    const backoff = new ExponentialBackoff(options);\n    let next = backoff.next();\n    while (next) {\n      yield next;\n      next = backoff.next();\n    }\n  }();\n}","map":{"version":3,"names":["RANDOMIZATION_FACTOR","MULTIPLIER","INITIAL_INTERVAL_MSEC","MAX_INTERVAL_MSEC","MAX_ELAPSED_TIME_MSEC","MAX_ITERATIONS","ExponentialBackoff","constructor","options","arguments","length","undefined","default","_ExponentialBackoff_currentInterval","set","_ExponentialBackoff_randomizationFactor","_ExponentialBackoff_multiplier","_ExponentialBackoff_maxInterval","_ExponentialBackoff_startTime","_ExponentialBackoff_maxElapsedTime","_ExponentialBackoff_maxIterations","_ExponentialBackoff_date","_ExponentialBackoff_count","initialInterval","randomizationFactor","multiplier","maxInterval","maxElapsedTime","maxIterations","date","Date","__classPrivateFieldSet","now","ellapsedTimeInMsec","__classPrivateFieldGet","currentInterval","count","randomValueFromInterval","delta","min","max","Math","random","incrementCurrentInterval","_a","next","exponentialBackoff","backoff"],"sources":["/home/arslan/modojo/node_modules/@dfinity/agent/src/polling/backoff.ts"],"sourcesContent":["const RANDOMIZATION_FACTOR = 0.5;\nconst MULTIPLIER = 1.5;\nconst INITIAL_INTERVAL_MSEC = 500;\nconst MAX_INTERVAL_MSEC = 60_000;\nconst MAX_ELAPSED_TIME_MSEC = 900_000;\nconst MAX_ITERATIONS = 10;\n\nexport type BackoffStrategy = {\n  next: () => number | null;\n  currentInterval?: number;\n  count?: number;\n  ellapsedTimeInMsec?: number;\n};\n\nexport type BackoffStrategyArgs = {\n  maxIterations?: number;\n  maxElapsedTime?: number;\n};\n\nexport type BackoffStrategyFactory = (args?: BackoffStrategyArgs) => BackoffStrategy;\n\n// export type BackoffStrategyGenerator = Generator<number, void, unknown>;\n\nexport type ExponentialBackoffOptions = {\n  initialInterval?: number;\n  randomizationFactor?: number;\n  multiplier?: number;\n  maxInterval?: number;\n  maxElapsedTime?: number;\n  maxIterations?: number;\n  date?: DateConstructor;\n};\n\n/**\n * Exponential backoff strategy.\n */\nexport class ExponentialBackoff {\n  #currentInterval: number;\n  #randomizationFactor: number;\n  #multiplier: number;\n  #maxInterval: number;\n  #startTime: number;\n  #maxElapsedTime: number;\n  #maxIterations: number;\n  #date: DateConstructor;\n  #count = 0;\n\n  static default = {\n    initialInterval: INITIAL_INTERVAL_MSEC,\n    randomizationFactor: RANDOMIZATION_FACTOR,\n    multiplier: MULTIPLIER,\n    maxInterval: MAX_INTERVAL_MSEC,\n    // 1 minute\n    maxElapsedTime: MAX_ELAPSED_TIME_MSEC,\n    maxIterations: MAX_ITERATIONS,\n    date: Date,\n  };\n\n  constructor(options: ExponentialBackoffOptions = ExponentialBackoff.default) {\n    const {\n      initialInterval = INITIAL_INTERVAL_MSEC,\n      randomizationFactor = RANDOMIZATION_FACTOR,\n      multiplier = MULTIPLIER,\n      maxInterval = MAX_INTERVAL_MSEC,\n      maxElapsedTime = MAX_ELAPSED_TIME_MSEC,\n      maxIterations = MAX_ITERATIONS,\n      date = Date,\n    } = options;\n    this.#currentInterval = initialInterval;\n    this.#randomizationFactor = randomizationFactor;\n    this.#multiplier = multiplier;\n    this.#maxInterval = maxInterval;\n    this.#date = date;\n    this.#startTime = date.now();\n    this.#maxElapsedTime = maxElapsedTime;\n    this.#maxIterations = maxIterations;\n  }\n\n  get ellapsedTimeInMsec() {\n    return this.#date.now() - this.#startTime;\n  }\n\n  get currentInterval() {\n    return this.#currentInterval;\n  }\n\n  get count() {\n    return this.#count;\n  }\n\n  get randomValueFromInterval() {\n    const delta = this.#randomizationFactor * this.#currentInterval;\n    const min = this.#currentInterval - delta;\n    const max = this.#currentInterval + delta;\n    return Math.random() * (max - min) + min;\n  }\n\n  public incrementCurrentInterval() {\n    this.#currentInterval = Math.min(this.#currentInterval * this.#multiplier, this.#maxInterval);\n    this.#count++;\n\n    return this.#currentInterval;\n  }\n\n  public next() {\n    if (this.ellapsedTimeInMsec >= this.#maxElapsedTime || this.#count >= this.#maxIterations) {\n      return null;\n    } else {\n      this.incrementCurrentInterval();\n      return this.randomValueFromInterval;\n    }\n  }\n}\n/**\n * Utility function to create an exponential backoff iterator.\n * @param options - for the exponential backoff\n * @returns an iterator that yields the next delay in the exponential backoff\n * @yields the next delay in the exponential backoff\n */\nexport function* exponentialBackoff(\n  options: ExponentialBackoffOptions = ExponentialBackoff.default,\n) {\n  const backoff = new ExponentialBackoff(options);\n\n  let next = backoff.next();\n  while (next) {\n    yield next;\n    next = backoff.next();\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}