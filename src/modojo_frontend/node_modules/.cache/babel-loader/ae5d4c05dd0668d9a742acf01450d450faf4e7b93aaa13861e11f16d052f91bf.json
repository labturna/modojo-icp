{"ast":null,"code":"var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _Ed25519PublicKey_rawKey, _Ed25519PublicKey_derKey, _Ed25519KeyIdentity_publicKey, _Ed25519KeyIdentity_privateKey;\nimport { bufEquals } from '@dfinity/agent';\nimport { SignIdentity, uint8ToBuf, ED25519_OID, unwrapDER, wrapDER, fromHex, toHex, bufFromBufLike } from '@dfinity/agent';\nimport { ed25519 } from '@noble/curves/ed25519';\nfunction isObject(value) {\n  return value !== null && typeof value === 'object';\n}\nexport class Ed25519PublicKey {\n  // `fromRaw` and `fromDer` should be used for instantiation, not this constructor.\n  constructor(key) {\n    _Ed25519PublicKey_rawKey.set(this, void 0);\n    _Ed25519PublicKey_derKey.set(this, void 0);\n    if (key.byteLength !== Ed25519PublicKey.RAW_KEY_LENGTH) {\n      throw new Error('An Ed25519 public key must be exactly 32bytes long');\n    }\n    __classPrivateFieldSet(this, _Ed25519PublicKey_rawKey, key, \"f\");\n    __classPrivateFieldSet(this, _Ed25519PublicKey_derKey, Ed25519PublicKey.derEncode(key), \"f\");\n  }\n  /**\n   * Construct Ed25519PublicKey from an existing PublicKey\n   * @param {unknown} maybeKey - existing PublicKey, ArrayBuffer, DerEncodedPublicKey, or hex string\n   * @returns {Ed25519PublicKey} Instance of Ed25519PublicKey\n   */\n  static from(maybeKey) {\n    if (typeof maybeKey === 'string') {\n      const key = fromHex(maybeKey);\n      return this.fromRaw(key);\n    } else if (isObject(maybeKey)) {\n      const key = maybeKey;\n      if (isObject(key) && Object.hasOwnProperty.call(key, '__derEncodedPublicKey__')) {\n        return this.fromDer(key);\n      } else if (ArrayBuffer.isView(key)) {\n        const view = key;\n        return this.fromRaw(bufFromBufLike(view.buffer));\n      } else if (key instanceof ArrayBuffer) {\n        return this.fromRaw(key);\n      } else if ('rawKey' in key) {\n        return this.fromRaw(key.rawKey);\n      } else if ('derKey' in key) {\n        return this.fromDer(key.derKey);\n      } else if ('toDer' in key) {\n        return this.fromDer(key.toDer());\n      }\n    }\n    throw new Error('Cannot construct Ed25519PublicKey from the provided key.');\n  }\n  static fromRaw(rawKey) {\n    return new Ed25519PublicKey(rawKey);\n  }\n  static fromDer(derKey) {\n    return new Ed25519PublicKey(this.derDecode(derKey));\n  }\n  static derEncode(publicKey) {\n    const key = wrapDER(publicKey, ED25519_OID).buffer;\n    key.__derEncodedPublicKey__ = undefined;\n    return key;\n  }\n  static derDecode(key) {\n    const unwrapped = unwrapDER(key, ED25519_OID);\n    if (unwrapped.length !== this.RAW_KEY_LENGTH) {\n      throw new Error('An Ed25519 public key must be exactly 32bytes long');\n    }\n    return unwrapped;\n  }\n  get rawKey() {\n    return __classPrivateFieldGet(this, _Ed25519PublicKey_rawKey, \"f\");\n  }\n  get derKey() {\n    return __classPrivateFieldGet(this, _Ed25519PublicKey_derKey, \"f\");\n  }\n  toDer() {\n    return this.derKey;\n  }\n  toRaw() {\n    return this.rawKey;\n  }\n}\n_Ed25519PublicKey_rawKey = new WeakMap(), _Ed25519PublicKey_derKey = new WeakMap();\n// The length of Ed25519 public keys is always 32 bytes.\nEd25519PublicKey.RAW_KEY_LENGTH = 32;\n/**\n * Ed25519KeyIdentity is an implementation of SignIdentity that uses Ed25519 keys. This class is used to sign and verify messages for an agent.\n */\nexport class Ed25519KeyIdentity extends SignIdentity {\n  // `fromRaw` and `fromDer` should be used for instantiation, not this constructor.\n  constructor(publicKey, privateKey) {\n    super();\n    _Ed25519KeyIdentity_publicKey.set(this, void 0);\n    _Ed25519KeyIdentity_privateKey.set(this, void 0);\n    __classPrivateFieldSet(this, _Ed25519KeyIdentity_publicKey, Ed25519PublicKey.from(publicKey), \"f\");\n    __classPrivateFieldSet(this, _Ed25519KeyIdentity_privateKey, new Uint8Array(privateKey), \"f\");\n  }\n  /**\n   * Generate a new Ed25519KeyIdentity.\n   * @param seed a 32-byte seed for the private key. If not provided, a random seed will be generated.\n   * @returns Ed25519KeyIdentity\n   */\n  static generate(seed) {\n    if (seed && seed.length !== 32) {\n      throw new Error('Ed25519 Seed needs to be 32 bytes long.');\n    }\n    if (!seed) seed = ed25519.utils.randomPrivateKey();\n    // Check if the seed is all zeros\n    if (bufEquals(seed, new Uint8Array(new Array(32).fill(0)))) {\n      console.warn('Seed is all zeros. This is not a secure seed. Please provide a seed with sufficient entropy if this is a production environment.');\n    }\n    const sk = new Uint8Array(32);\n    for (let i = 0; i < 32; i++) sk[i] = new Uint8Array(seed)[i];\n    const pk = ed25519.getPublicKey(sk);\n    return Ed25519KeyIdentity.fromKeyPair(pk, sk);\n  }\n  static fromParsedJson(obj) {\n    const [publicKeyDer, privateKeyRaw] = obj;\n    return new Ed25519KeyIdentity(Ed25519PublicKey.fromDer(fromHex(publicKeyDer)), fromHex(privateKeyRaw));\n  }\n  static fromJSON(json) {\n    const parsed = JSON.parse(json);\n    if (Array.isArray(parsed)) {\n      if (typeof parsed[0] === 'string' && typeof parsed[1] === 'string') {\n        return this.fromParsedJson([parsed[0], parsed[1]]);\n      } else {\n        throw new Error('Deserialization error: JSON must have at least 2 items.');\n      }\n    }\n    throw new Error(`Deserialization error: Invalid JSON type for string: ${JSON.stringify(json)}`);\n  }\n  static fromKeyPair(publicKey, privateKey) {\n    return new Ed25519KeyIdentity(Ed25519PublicKey.fromRaw(publicKey), privateKey);\n  }\n  static fromSecretKey(secretKey) {\n    const publicKey = ed25519.getPublicKey(new Uint8Array(secretKey));\n    return Ed25519KeyIdentity.fromKeyPair(publicKey, secretKey);\n  }\n  /**\n   * Serialize this key to JSON.\n   */\n  toJSON() {\n    return [toHex(__classPrivateFieldGet(this, _Ed25519KeyIdentity_publicKey, \"f\").toDer()), toHex(__classPrivateFieldGet(this, _Ed25519KeyIdentity_privateKey, \"f\"))];\n  }\n  /**\n   * Return a copy of the key pair.\n   */\n  getKeyPair() {\n    return {\n      secretKey: __classPrivateFieldGet(this, _Ed25519KeyIdentity_privateKey, \"f\"),\n      publicKey: __classPrivateFieldGet(this, _Ed25519KeyIdentity_publicKey, \"f\")\n    };\n  }\n  /**\n   * Return the public key.\n   */\n  getPublicKey() {\n    return __classPrivateFieldGet(this, _Ed25519KeyIdentity_publicKey, \"f\");\n  }\n  /**\n   * Signs a blob of data, with this identity's private key.\n   * @param challenge - challenge to sign with this identity's secretKey, producing a signature\n   */\n  async sign(challenge) {\n    const blob = new Uint8Array(challenge);\n    // Some implementations of Ed25519 private keys append a public key to the end of the private key. We only want the private key.\n    const signature = uint8ToBuf(ed25519.sign(blob, __classPrivateFieldGet(this, _Ed25519KeyIdentity_privateKey, \"f\").slice(0, 32)));\n    // add { __signature__: void; } to the signature to make it compatible with the agent\n    Object.defineProperty(signature, '__signature__', {\n      enumerable: false,\n      value: undefined\n    });\n    return signature;\n  }\n  /**\n   * Verify\n   * @param sig - signature to verify\n   * @param msg - message to verify\n   * @param pk - public key\n   * @returns - true if the signature is valid, false otherwise\n   */\n  static verify(sig, msg, pk) {\n    const [signature, message, publicKey] = [sig, msg, pk].map(x => {\n      if (typeof x === 'string') {\n        x = fromHex(x);\n      }\n      if (x instanceof Uint8Array) {\n        x = x.buffer;\n      }\n      return new Uint8Array(x);\n    });\n    return ed25519.verify(message, signature, publicKey);\n  }\n}\n_Ed25519KeyIdentity_publicKey = new WeakMap(), _Ed25519KeyIdentity_privateKey = new WeakMap();","map":{"version":3,"names":["bufEquals","SignIdentity","uint8ToBuf","ED25519_OID","unwrapDER","wrapDER","fromHex","toHex","bufFromBufLike","ed25519","isObject","value","Ed25519PublicKey","constructor","key","_Ed25519PublicKey_rawKey","set","_Ed25519PublicKey_derKey","byteLength","RAW_KEY_LENGTH","Error","__classPrivateFieldSet","derEncode","from","maybeKey","fromRaw","Object","hasOwnProperty","call","fromDer","ArrayBuffer","isView","view","buffer","rawKey","derKey","toDer","derDecode","publicKey","__derEncodedPublicKey__","undefined","unwrapped","length","__classPrivateFieldGet","toRaw","Ed25519KeyIdentity","privateKey","_Ed25519KeyIdentity_publicKey","_Ed25519KeyIdentity_privateKey","Uint8Array","generate","seed","utils","randomPrivateKey","Array","fill","console","warn","sk","i","pk","getPublicKey","fromKeyPair","fromParsedJson","obj","publicKeyDer","privateKeyRaw","fromJSON","json","parsed","JSON","parse","isArray","stringify","fromSecretKey","secretKey","toJSON","getKeyPair","sign","challenge","blob","signature","slice","defineProperty","enumerable","verify","sig","msg","message","map","x"],"sources":["/home/arslan/modojo/node_modules/@dfinity/identity/src/identity/ed25519.ts"],"sourcesContent":["import { bufEquals } from '@dfinity/agent';\nimport {\n  DerEncodedPublicKey,\n  KeyPair,\n  PublicKey,\n  Signature,\n  SignIdentity,\n  uint8ToBuf,\n  ED25519_OID,\n  unwrapDER,\n  wrapDER,\n  fromHex,\n  toHex,\n  bufFromBufLike,\n} from '@dfinity/agent';\nimport { ed25519 } from '@noble/curves/ed25519';\n\ndeclare type KeyLike = PublicKey | DerEncodedPublicKey | ArrayBuffer | ArrayBufferView;\n\nfunction isObject(value: unknown) {\n  return value !== null && typeof value === 'object';\n}\n\nexport class Ed25519PublicKey implements PublicKey {\n  /**\n   * Construct Ed25519PublicKey from an existing PublicKey\n   * @param {unknown} maybeKey - existing PublicKey, ArrayBuffer, DerEncodedPublicKey, or hex string\n   * @returns {Ed25519PublicKey} Instance of Ed25519PublicKey\n   */\n  public static from(maybeKey: unknown): Ed25519PublicKey {\n    if (typeof maybeKey === 'string') {\n      const key = fromHex(maybeKey);\n      return this.fromRaw(key);\n    } else if (isObject(maybeKey)) {\n      const key = maybeKey as KeyLike;\n      if (isObject(key) && Object.hasOwnProperty.call(key, '__derEncodedPublicKey__')) {\n        return this.fromDer(key as DerEncodedPublicKey);\n      } else if (ArrayBuffer.isView(key)) {\n        const view = key as ArrayBufferView;\n        return this.fromRaw(bufFromBufLike(view.buffer));\n      } else if (key instanceof ArrayBuffer) {\n        return this.fromRaw(key);\n      } else if ('rawKey' in key) {\n        return this.fromRaw(key.rawKey as ArrayBuffer);\n      } else if ('derKey' in key) {\n        return this.fromDer(key.derKey as DerEncodedPublicKey);\n      } else if ('toDer' in key) {\n        return this.fromDer(key.toDer() as ArrayBuffer);\n      }\n    }\n    throw new Error('Cannot construct Ed25519PublicKey from the provided key.');\n  }\n\n  public static fromRaw(rawKey: ArrayBuffer): Ed25519PublicKey {\n    return new Ed25519PublicKey(rawKey);\n  }\n\n  public static fromDer(derKey: DerEncodedPublicKey): Ed25519PublicKey {\n    return new Ed25519PublicKey(this.derDecode(derKey));\n  }\n\n  // The length of Ed25519 public keys is always 32 bytes.\n  private static RAW_KEY_LENGTH = 32;\n\n  private static derEncode(publicKey: ArrayBuffer): DerEncodedPublicKey {\n    const key = wrapDER(publicKey, ED25519_OID).buffer as DerEncodedPublicKey;\n    key.__derEncodedPublicKey__ = undefined;\n    return key;\n  }\n\n  private static derDecode(key: DerEncodedPublicKey): ArrayBuffer {\n    const unwrapped = unwrapDER(key, ED25519_OID);\n    if (unwrapped.length !== this.RAW_KEY_LENGTH) {\n      throw new Error('An Ed25519 public key must be exactly 32bytes long');\n    }\n    return unwrapped;\n  }\n\n  #rawKey: ArrayBuffer;\n\n  public get rawKey(): ArrayBuffer {\n    return this.#rawKey;\n  }\n\n  #derKey: DerEncodedPublicKey;\n\n  public get derKey(): DerEncodedPublicKey {\n    return this.#derKey;\n  }\n\n  // `fromRaw` and `fromDer` should be used for instantiation, not this constructor.\n  private constructor(key: ArrayBuffer) {\n    if (key.byteLength !== Ed25519PublicKey.RAW_KEY_LENGTH) {\n      throw new Error('An Ed25519 public key must be exactly 32bytes long');\n    }\n    this.#rawKey = key;\n    this.#derKey = Ed25519PublicKey.derEncode(key);\n  }\n\n  public toDer(): DerEncodedPublicKey {\n    return this.derKey;\n  }\n\n  public toRaw(): ArrayBuffer {\n    return this.rawKey;\n  }\n}\n\n/**\n * Ed25519KeyIdentity is an implementation of SignIdentity that uses Ed25519 keys. This class is used to sign and verify messages for an agent.\n */\nexport class Ed25519KeyIdentity extends SignIdentity {\n  /**\n   * Generate a new Ed25519KeyIdentity.\n   * @param seed a 32-byte seed for the private key. If not provided, a random seed will be generated.\n   * @returns Ed25519KeyIdentity\n   */\n  public static generate(seed?: Uint8Array): Ed25519KeyIdentity {\n\n    if (seed && seed.length !== 32) {\n      throw new Error('Ed25519 Seed needs to be 32 bytes long.');\n    }\n    if (!seed) seed = ed25519.utils.randomPrivateKey();\n    // Check if the seed is all zeros\n    if(bufEquals(seed, new Uint8Array(new Array(32).fill(0)))) {\n      console.warn('Seed is all zeros. This is not a secure seed. Please provide a seed with sufficient entropy if this is a production environment.');\n    }\n    const sk = new Uint8Array(32);\n    for (let i = 0; i < 32; i++) sk[i] = new Uint8Array(seed)[i];\n\n    const pk = ed25519.getPublicKey(sk);\n    return Ed25519KeyIdentity.fromKeyPair(pk, sk);\n  }\n\n  public static fromParsedJson(obj: JsonnableEd25519KeyIdentity): Ed25519KeyIdentity {\n    const [publicKeyDer, privateKeyRaw] = obj;\n    return new Ed25519KeyIdentity(\n      Ed25519PublicKey.fromDer(fromHex(publicKeyDer) as DerEncodedPublicKey),\n      fromHex(privateKeyRaw),\n    );\n  }\n\n  public static fromJSON(json: string): Ed25519KeyIdentity {\n    const parsed = JSON.parse(json);\n    if (Array.isArray(parsed)) {\n      if (typeof parsed[0] === 'string' && typeof parsed[1] === 'string') {\n        return this.fromParsedJson([parsed[0], parsed[1]]);\n      } else {\n        throw new Error('Deserialization error: JSON must have at least 2 items.');\n      }\n    }\n    throw new Error(`Deserialization error: Invalid JSON type for string: ${JSON.stringify(json)}`);\n  }\n\n  public static fromKeyPair(publicKey: ArrayBuffer, privateKey: ArrayBuffer): Ed25519KeyIdentity {\n    return new Ed25519KeyIdentity(Ed25519PublicKey.fromRaw(publicKey), privateKey);\n  }\n\n  public static fromSecretKey(secretKey: ArrayBuffer): Ed25519KeyIdentity {\n    const publicKey = ed25519.getPublicKey(new Uint8Array(secretKey));\n    return Ed25519KeyIdentity.fromKeyPair(publicKey, secretKey);\n  }\n\n  #publicKey: Ed25519PublicKey;\n  #privateKey: Uint8Array;\n\n  // `fromRaw` and `fromDer` should be used for instantiation, not this constructor.\n  protected constructor(publicKey: PublicKey, privateKey: ArrayBuffer) {\n    super();\n    this.#publicKey = Ed25519PublicKey.from(publicKey);\n    this.#privateKey = new Uint8Array(privateKey);\n  }\n\n  /**\n   * Serialize this key to JSON.\n   */\n  public toJSON(): JsonnableEd25519KeyIdentity {\n    return [toHex(this.#publicKey.toDer()), toHex(this.#privateKey)];\n  }\n\n  /**\n   * Return a copy of the key pair.\n   */\n  public getKeyPair(): KeyPair {\n    return {\n      secretKey: this.#privateKey,\n      publicKey: this.#publicKey,\n    };\n  }\n\n  /**\n   * Return the public key.\n   */\n  public getPublicKey(): Required<PublicKey> {\n    return this.#publicKey;\n  }\n\n  /**\n   * Signs a blob of data, with this identity's private key.\n   * @param challenge - challenge to sign with this identity's secretKey, producing a signature\n   */\n  public async sign(challenge: ArrayBuffer): Promise<Signature> {\n    const blob = new Uint8Array(challenge);\n    // Some implementations of Ed25519 private keys append a public key to the end of the private key. We only want the private key.\n    const signature = uint8ToBuf(ed25519.sign(blob, this.#privateKey.slice(0, 32)));\n    // add { __signature__: void; } to the signature to make it compatible with the agent\n\n    Object.defineProperty(signature, '__signature__', {\n      enumerable: false,\n      value: undefined,\n    });\n\n    return signature as Signature;\n  }\n\n  /**\n   * Verify\n   * @param sig - signature to verify\n   * @param msg - message to verify\n   * @param pk - public key\n   * @returns - true if the signature is valid, false otherwise\n   */\n  public static verify(\n    sig: ArrayBuffer | Uint8Array | string,\n    msg: ArrayBuffer | Uint8Array | string,\n    pk: ArrayBuffer | Uint8Array | string,\n  ) {\n    const [signature, message, publicKey] = [sig, msg, pk].map(x => {\n      if (typeof x === 'string') {\n        x = fromHex(x);\n      }\n      if (x instanceof Uint8Array) {\n        x = x.buffer;\n      }\n      return new Uint8Array(x);\n    });\n    return ed25519.verify(message, signature, publicKey);\n  }\n}\n\ntype PublicKeyHex = string;\ntype SecretKeyHex = string;\nexport type JsonnableEd25519KeyIdentity = [PublicKeyHex, SecretKeyHex];\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}