{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LcsDiff } from '../../../../base/common/diff/diff.js';\nimport { commonPrefixLength, getLeadingWhitespace } from '../../../../base/common/strings.js';\nimport { Range } from '../../../common/core/range.js';\nimport { TextLength } from '../../../common/core/textLength.js';\nimport { SingleTextEdit } from '../../../common/core/textEdit.js';\nimport { GhostText, GhostTextPart } from './ghostText.js';\nexport function singleTextRemoveCommonPrefix(edit, model, validModelRange) {\n  const modelRange = validModelRange ? edit.range.intersectRanges(validModelRange) : edit.range;\n  if (!modelRange) {\n    return edit;\n  }\n  const valueToReplace = model.getValueInRange(modelRange, 1 /* EndOfLinePreference.LF */);\n  const commonPrefixLen = commonPrefixLength(valueToReplace, edit.text);\n  const start = TextLength.ofText(valueToReplace.substring(0, commonPrefixLen)).addToPosition(edit.range.getStartPosition());\n  const text = edit.text.substring(commonPrefixLen);\n  const range = Range.fromPositions(start, edit.range.getEndPosition());\n  return new SingleTextEdit(range, text);\n}\nexport function singleTextEditAugments(edit, base) {\n  // The augmented completion must replace the base range, but can replace even more\n  return edit.text.startsWith(base.text) && rangeExtends(edit.range, base.range);\n}\n/**\n * @param previewSuffixLength Sets where to split `inlineCompletion.text`.\n * \tIf the text is `hello` and the suffix length is 2, the non-preview part is `hel` and the preview-part is `lo`.\n*/\nexport function computeGhostText(edit, model, mode, cursorPosition) {\n  let previewSuffixLength = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  let e = singleTextRemoveCommonPrefix(edit, model);\n  if (e.range.endLineNumber !== e.range.startLineNumber) {\n    // This edit might span multiple lines, but the first lines must be a common prefix.\n    return undefined;\n  }\n  const sourceLine = model.getLineContent(e.range.startLineNumber);\n  const sourceIndentationLength = getLeadingWhitespace(sourceLine).length;\n  const suggestionTouchesIndentation = e.range.startColumn - 1 <= sourceIndentationLength;\n  if (suggestionTouchesIndentation) {\n    // source:      ··········[······abc]\n    //                         ^^^^^^^^^ inlineCompletion.range\n    //              ^^^^^^^^^^ ^^^^^^ sourceIndentationLength\n    //                         ^^^^^^ replacedIndentation.length\n    //                               ^^^ rangeThatDoesNotReplaceIndentation\n    // inlineCompletion.text: '··foo'\n    //                         ^^ suggestionAddedIndentationLength\n    const suggestionAddedIndentationLength = getLeadingWhitespace(e.text).length;\n    const replacedIndentation = sourceLine.substring(e.range.startColumn - 1, sourceIndentationLength);\n    const [startPosition, endPosition] = [e.range.getStartPosition(), e.range.getEndPosition()];\n    const newStartPosition = startPosition.column + replacedIndentation.length <= endPosition.column ? startPosition.delta(0, replacedIndentation.length) : endPosition;\n    const rangeThatDoesNotReplaceIndentation = Range.fromPositions(newStartPosition, endPosition);\n    const suggestionWithoutIndentationChange = e.text.startsWith(replacedIndentation)\n    // Adds more indentation without changing existing indentation: We can add ghost text for this\n    ? e.text.substring(replacedIndentation.length)\n    // Changes or removes existing indentation. Only add ghost text for the non-indentation part.\n    : e.text.substring(suggestionAddedIndentationLength);\n    e = new SingleTextEdit(rangeThatDoesNotReplaceIndentation, suggestionWithoutIndentationChange);\n  }\n  // This is a single line string\n  const valueToBeReplaced = model.getValueInRange(e.range);\n  const changes = cachingDiff(valueToBeReplaced, e.text);\n  if (!changes) {\n    // No ghost text in case the diff would be too slow to compute\n    return undefined;\n  }\n  const lineNumber = e.range.startLineNumber;\n  const parts = new Array();\n  if (mode === 'prefix') {\n    const filteredChanges = changes.filter(c => c.originalLength === 0);\n    if (filteredChanges.length > 1 || filteredChanges.length === 1 && filteredChanges[0].originalStart !== valueToBeReplaced.length) {\n      // Prefixes only have a single change.\n      return undefined;\n    }\n  }\n  const previewStartInCompletionText = e.text.length - previewSuffixLength;\n  for (const c of changes) {\n    const insertColumn = e.range.startColumn + c.originalStart + c.originalLength;\n    if (mode === 'subwordSmart' && cursorPosition && cursorPosition.lineNumber === e.range.startLineNumber && insertColumn < cursorPosition.column) {\n      // No ghost text before cursor\n      return undefined;\n    }\n    if (c.originalLength > 0) {\n      return undefined;\n    }\n    if (c.modifiedLength === 0) {\n      continue;\n    }\n    const modifiedEnd = c.modifiedStart + c.modifiedLength;\n    const nonPreviewTextEnd = Math.max(c.modifiedStart, Math.min(modifiedEnd, previewStartInCompletionText));\n    const nonPreviewText = e.text.substring(c.modifiedStart, nonPreviewTextEnd);\n    const italicText = e.text.substring(nonPreviewTextEnd, Math.max(c.modifiedStart, modifiedEnd));\n    if (nonPreviewText.length > 0) {\n      parts.push(new GhostTextPart(insertColumn, nonPreviewText, false));\n    }\n    if (italicText.length > 0) {\n      parts.push(new GhostTextPart(insertColumn, italicText, true));\n    }\n  }\n  return new GhostText(lineNumber, parts);\n}\nfunction rangeExtends(extendingRange, rangeToExtend) {\n  return rangeToExtend.getStartPosition().equals(extendingRange.getStartPosition()) && rangeToExtend.getEndPosition().isBeforeOrEqual(extendingRange.getEndPosition());\n}\nlet lastRequest = undefined;\nfunction cachingDiff(originalValue, newValue) {\n  if ((lastRequest === null || lastRequest === void 0 ? void 0 : lastRequest.originalValue) === originalValue && (lastRequest === null || lastRequest === void 0 ? void 0 : lastRequest.newValue) === newValue) {\n    return lastRequest === null || lastRequest === void 0 ? void 0 : lastRequest.changes;\n  } else {\n    let changes = smartDiff(originalValue, newValue, true);\n    if (changes) {\n      const deletedChars = deletedCharacters(changes);\n      if (deletedChars > 0) {\n        // For performance reasons, don't compute diff if there is nothing to improve\n        const newChanges = smartDiff(originalValue, newValue, false);\n        if (newChanges && deletedCharacters(newChanges) < deletedChars) {\n          // Disabling smartness seems to be better here\n          changes = newChanges;\n        }\n      }\n    }\n    lastRequest = {\n      originalValue,\n      newValue,\n      changes\n    };\n    return changes;\n  }\n}\nfunction deletedCharacters(changes) {\n  let sum = 0;\n  for (const c of changes) {\n    sum += c.originalLength;\n  }\n  return sum;\n}\n/**\n * When matching `if ()` with `if (f() = 1) { g(); }`,\n * align it like this:        `if (       )`\n * Not like this:\t\t\t  `if (  )`\n * Also not like this:\t\t  `if (             )`.\n *\n * The parenthesis are preprocessed to ensure that they match correctly.\n */\nfunction smartDiff(originalValue, newValue, smartBracketMatching) {\n  if (originalValue.length > 5000 || newValue.length > 5000) {\n    // We don't want to work on strings that are too big\n    return undefined;\n  }\n  function getMaxCharCode(val) {\n    let maxCharCode = 0;\n    for (let i = 0, len = val.length; i < len; i++) {\n      const charCode = val.charCodeAt(i);\n      if (charCode > maxCharCode) {\n        maxCharCode = charCode;\n      }\n    }\n    return maxCharCode;\n  }\n  const maxCharCode = Math.max(getMaxCharCode(originalValue), getMaxCharCode(newValue));\n  function getUniqueCharCode(id) {\n    if (id < 0) {\n      throw new Error('unexpected');\n    }\n    return maxCharCode + id + 1;\n  }\n  function getElements(source) {\n    let level = 0;\n    let group = 0;\n    const characters = new Int32Array(source.length);\n    for (let i = 0, len = source.length; i < len; i++) {\n      // TODO support more brackets\n      if (smartBracketMatching && source[i] === '(') {\n        const id = group * 100 + level;\n        characters[i] = getUniqueCharCode(2 * id);\n        level++;\n      } else if (smartBracketMatching && source[i] === ')') {\n        level = Math.max(level - 1, 0);\n        const id = group * 100 + level;\n        characters[i] = getUniqueCharCode(2 * id + 1);\n        if (level === 0) {\n          group++;\n        }\n      } else {\n        characters[i] = source.charCodeAt(i);\n      }\n    }\n    return characters;\n  }\n  const elements1 = getElements(originalValue);\n  const elements2 = getElements(newValue);\n  return new LcsDiff({\n    getElements: () => elements1\n  }, {\n    getElements: () => elements2\n  }).ComputeDiff(false).changes;\n}","map":{"version":3,"names":["LcsDiff","commonPrefixLength","getLeadingWhitespace","Range","TextLength","SingleTextEdit","GhostText","GhostTextPart","singleTextRemoveCommonPrefix","edit","model","validModelRange","modelRange","range","intersectRanges","valueToReplace","getValueInRange","commonPrefixLen","text","start","ofText","substring","addToPosition","getStartPosition","fromPositions","getEndPosition","singleTextEditAugments","base","startsWith","rangeExtends","computeGhostText","mode","cursorPosition","previewSuffixLength","arguments","length","undefined","e","endLineNumber","startLineNumber","sourceLine","getLineContent","sourceIndentationLength","suggestionTouchesIndentation","startColumn","suggestionAddedIndentationLength","replacedIndentation","startPosition","endPosition","newStartPosition","column","delta","rangeThatDoesNotReplaceIndentation","suggestionWithoutIndentationChange","valueToBeReplaced","changes","cachingDiff","lineNumber","parts","Array","filteredChanges","filter","c","originalLength","originalStart","previewStartInCompletionText","insertColumn","modifiedLength","modifiedEnd","modifiedStart","nonPreviewTextEnd","Math","max","min","nonPreviewText","italicText","push","extendingRange","rangeToExtend","equals","isBeforeOrEqual","lastRequest","originalValue","newValue","smartDiff","deletedChars","deletedCharacters","newChanges","sum","smartBracketMatching","getMaxCharCode","val","maxCharCode","i","len","charCode","charCodeAt","getUniqueCharCode","id","Error","getElements","source","level","group","characters","Int32Array","elements1","elements2","ComputeDiff"],"sources":["/home/arslan/modojo/node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/singleTextEdit.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LcsDiff } from '../../../../base/common/diff/diff.js';\nimport { commonPrefixLength, getLeadingWhitespace } from '../../../../base/common/strings.js';\nimport { Range } from '../../../common/core/range.js';\nimport { TextLength } from '../../../common/core/textLength.js';\nimport { SingleTextEdit } from '../../../common/core/textEdit.js';\nimport { GhostText, GhostTextPart } from './ghostText.js';\nexport function singleTextRemoveCommonPrefix(edit, model, validModelRange) {\n    const modelRange = validModelRange ? edit.range.intersectRanges(validModelRange) : edit.range;\n    if (!modelRange) {\n        return edit;\n    }\n    const valueToReplace = model.getValueInRange(modelRange, 1 /* EndOfLinePreference.LF */);\n    const commonPrefixLen = commonPrefixLength(valueToReplace, edit.text);\n    const start = TextLength.ofText(valueToReplace.substring(0, commonPrefixLen)).addToPosition(edit.range.getStartPosition());\n    const text = edit.text.substring(commonPrefixLen);\n    const range = Range.fromPositions(start, edit.range.getEndPosition());\n    return new SingleTextEdit(range, text);\n}\nexport function singleTextEditAugments(edit, base) {\n    // The augmented completion must replace the base range, but can replace even more\n    return edit.text.startsWith(base.text) && rangeExtends(edit.range, base.range);\n}\n/**\n * @param previewSuffixLength Sets where to split `inlineCompletion.text`.\n * \tIf the text is `hello` and the suffix length is 2, the non-preview part is `hel` and the preview-part is `lo`.\n*/\nexport function computeGhostText(edit, model, mode, cursorPosition, previewSuffixLength = 0) {\n    let e = singleTextRemoveCommonPrefix(edit, model);\n    if (e.range.endLineNumber !== e.range.startLineNumber) {\n        // This edit might span multiple lines, but the first lines must be a common prefix.\n        return undefined;\n    }\n    const sourceLine = model.getLineContent(e.range.startLineNumber);\n    const sourceIndentationLength = getLeadingWhitespace(sourceLine).length;\n    const suggestionTouchesIndentation = e.range.startColumn - 1 <= sourceIndentationLength;\n    if (suggestionTouchesIndentation) {\n        // source:      ··········[······abc]\n        //                         ^^^^^^^^^ inlineCompletion.range\n        //              ^^^^^^^^^^ ^^^^^^ sourceIndentationLength\n        //                         ^^^^^^ replacedIndentation.length\n        //                               ^^^ rangeThatDoesNotReplaceIndentation\n        // inlineCompletion.text: '··foo'\n        //                         ^^ suggestionAddedIndentationLength\n        const suggestionAddedIndentationLength = getLeadingWhitespace(e.text).length;\n        const replacedIndentation = sourceLine.substring(e.range.startColumn - 1, sourceIndentationLength);\n        const [startPosition, endPosition] = [e.range.getStartPosition(), e.range.getEndPosition()];\n        const newStartPosition = startPosition.column + replacedIndentation.length <= endPosition.column\n            ? startPosition.delta(0, replacedIndentation.length)\n            : endPosition;\n        const rangeThatDoesNotReplaceIndentation = Range.fromPositions(newStartPosition, endPosition);\n        const suggestionWithoutIndentationChange = e.text.startsWith(replacedIndentation)\n            // Adds more indentation without changing existing indentation: We can add ghost text for this\n            ? e.text.substring(replacedIndentation.length)\n            // Changes or removes existing indentation. Only add ghost text for the non-indentation part.\n            : e.text.substring(suggestionAddedIndentationLength);\n        e = new SingleTextEdit(rangeThatDoesNotReplaceIndentation, suggestionWithoutIndentationChange);\n    }\n    // This is a single line string\n    const valueToBeReplaced = model.getValueInRange(e.range);\n    const changes = cachingDiff(valueToBeReplaced, e.text);\n    if (!changes) {\n        // No ghost text in case the diff would be too slow to compute\n        return undefined;\n    }\n    const lineNumber = e.range.startLineNumber;\n    const parts = new Array();\n    if (mode === 'prefix') {\n        const filteredChanges = changes.filter(c => c.originalLength === 0);\n        if (filteredChanges.length > 1 || filteredChanges.length === 1 && filteredChanges[0].originalStart !== valueToBeReplaced.length) {\n            // Prefixes only have a single change.\n            return undefined;\n        }\n    }\n    const previewStartInCompletionText = e.text.length - previewSuffixLength;\n    for (const c of changes) {\n        const insertColumn = e.range.startColumn + c.originalStart + c.originalLength;\n        if (mode === 'subwordSmart' && cursorPosition && cursorPosition.lineNumber === e.range.startLineNumber && insertColumn < cursorPosition.column) {\n            // No ghost text before cursor\n            return undefined;\n        }\n        if (c.originalLength > 0) {\n            return undefined;\n        }\n        if (c.modifiedLength === 0) {\n            continue;\n        }\n        const modifiedEnd = c.modifiedStart + c.modifiedLength;\n        const nonPreviewTextEnd = Math.max(c.modifiedStart, Math.min(modifiedEnd, previewStartInCompletionText));\n        const nonPreviewText = e.text.substring(c.modifiedStart, nonPreviewTextEnd);\n        const italicText = e.text.substring(nonPreviewTextEnd, Math.max(c.modifiedStart, modifiedEnd));\n        if (nonPreviewText.length > 0) {\n            parts.push(new GhostTextPart(insertColumn, nonPreviewText, false));\n        }\n        if (italicText.length > 0) {\n            parts.push(new GhostTextPart(insertColumn, italicText, true));\n        }\n    }\n    return new GhostText(lineNumber, parts);\n}\nfunction rangeExtends(extendingRange, rangeToExtend) {\n    return rangeToExtend.getStartPosition().equals(extendingRange.getStartPosition())\n        && rangeToExtend.getEndPosition().isBeforeOrEqual(extendingRange.getEndPosition());\n}\nlet lastRequest = undefined;\nfunction cachingDiff(originalValue, newValue) {\n    if ((lastRequest === null || lastRequest === void 0 ? void 0 : lastRequest.originalValue) === originalValue && (lastRequest === null || lastRequest === void 0 ? void 0 : lastRequest.newValue) === newValue) {\n        return lastRequest === null || lastRequest === void 0 ? void 0 : lastRequest.changes;\n    }\n    else {\n        let changes = smartDiff(originalValue, newValue, true);\n        if (changes) {\n            const deletedChars = deletedCharacters(changes);\n            if (deletedChars > 0) {\n                // For performance reasons, don't compute diff if there is nothing to improve\n                const newChanges = smartDiff(originalValue, newValue, false);\n                if (newChanges && deletedCharacters(newChanges) < deletedChars) {\n                    // Disabling smartness seems to be better here\n                    changes = newChanges;\n                }\n            }\n        }\n        lastRequest = {\n            originalValue,\n            newValue,\n            changes\n        };\n        return changes;\n    }\n}\nfunction deletedCharacters(changes) {\n    let sum = 0;\n    for (const c of changes) {\n        sum += c.originalLength;\n    }\n    return sum;\n}\n/**\n * When matching `if ()` with `if (f() = 1) { g(); }`,\n * align it like this:        `if (       )`\n * Not like this:\t\t\t  `if (  )`\n * Also not like this:\t\t  `if (             )`.\n *\n * The parenthesis are preprocessed to ensure that they match correctly.\n */\nfunction smartDiff(originalValue, newValue, smartBracketMatching) {\n    if (originalValue.length > 5000 || newValue.length > 5000) {\n        // We don't want to work on strings that are too big\n        return undefined;\n    }\n    function getMaxCharCode(val) {\n        let maxCharCode = 0;\n        for (let i = 0, len = val.length; i < len; i++) {\n            const charCode = val.charCodeAt(i);\n            if (charCode > maxCharCode) {\n                maxCharCode = charCode;\n            }\n        }\n        return maxCharCode;\n    }\n    const maxCharCode = Math.max(getMaxCharCode(originalValue), getMaxCharCode(newValue));\n    function getUniqueCharCode(id) {\n        if (id < 0) {\n            throw new Error('unexpected');\n        }\n        return maxCharCode + id + 1;\n    }\n    function getElements(source) {\n        let level = 0;\n        let group = 0;\n        const characters = new Int32Array(source.length);\n        for (let i = 0, len = source.length; i < len; i++) {\n            // TODO support more brackets\n            if (smartBracketMatching && source[i] === '(') {\n                const id = group * 100 + level;\n                characters[i] = getUniqueCharCode(2 * id);\n                level++;\n            }\n            else if (smartBracketMatching && source[i] === ')') {\n                level = Math.max(level - 1, 0);\n                const id = group * 100 + level;\n                characters[i] = getUniqueCharCode(2 * id + 1);\n                if (level === 0) {\n                    group++;\n                }\n            }\n            else {\n                characters[i] = source.charCodeAt(i);\n            }\n        }\n        return characters;\n    }\n    const elements1 = getElements(originalValue);\n    const elements2 = getElements(newValue);\n    return new LcsDiff({ getElements: () => elements1 }, { getElements: () => elements2 }).ComputeDiff(false).changes;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}