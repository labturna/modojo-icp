{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Disposable, isDisposable } from '../../../base/common/lifecycle.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport Severity from '../../../base/common/severity.js';\nimport * as nls from '../../../nls.js';\nimport { IDialogService } from '../../dialogs/common/dialogs.js';\nimport { registerSingleton } from '../../instantiation/common/extensions.js';\nimport { INotificationService } from '../../notification/common/notification.js';\nimport { IUndoRedoService, ResourceEditStackSnapshot, UndoRedoGroup, UndoRedoSource } from './undoRedo.js';\nconst DEBUG = false;\nfunction getResourceLabel(resource) {\n  return resource.scheme === Schemas.file ? resource.fsPath : resource.path;\n}\nlet stackElementCounter = 0;\nclass ResourceStackElement {\n  constructor(actual, resourceLabel, strResource, groupId, groupOrder, sourceId, sourceOrder) {\n    this.id = ++stackElementCounter;\n    this.type = 0 /* UndoRedoElementType.Resource */;\n    this.actual = actual;\n    this.label = actual.label;\n    this.confirmBeforeUndo = actual.confirmBeforeUndo || false;\n    this.resourceLabel = resourceLabel;\n    this.strResource = strResource;\n    this.resourceLabels = [this.resourceLabel];\n    this.strResources = [this.strResource];\n    this.groupId = groupId;\n    this.groupOrder = groupOrder;\n    this.sourceId = sourceId;\n    this.sourceOrder = sourceOrder;\n    this.isValid = true;\n  }\n  setValid(isValid) {\n    this.isValid = isValid;\n  }\n  toString() {\n    return `[id:${this.id}] [group:${this.groupId}] [${this.isValid ? '  VALID' : 'INVALID'}] ${this.actual.constructor.name} - ${this.actual}`;\n  }\n}\nclass ResourceReasonPair {\n  constructor(resourceLabel, reason) {\n    this.resourceLabel = resourceLabel;\n    this.reason = reason;\n  }\n}\nclass RemovedResources {\n  constructor() {\n    this.elements = new Map();\n  }\n  createMessage() {\n    const externalRemoval = [];\n    const noParallelUniverses = [];\n    for (const [, element] of this.elements) {\n      const dest = element.reason === 0 /* RemovedResourceReason.ExternalRemoval */ ? externalRemoval : noParallelUniverses;\n      dest.push(element.resourceLabel);\n    }\n    const messages = [];\n    if (externalRemoval.length > 0) {\n      messages.push(nls.localize({\n        key: 'externalRemoval',\n        comment: ['{0} is a list of filenames']\n      }, \"The following files have been closed and modified on disk: {0}.\", externalRemoval.join(', ')));\n    }\n    if (noParallelUniverses.length > 0) {\n      messages.push(nls.localize({\n        key: 'noParallelUniverses',\n        comment: ['{0} is a list of filenames']\n      }, \"The following files have been modified in an incompatible way: {0}.\", noParallelUniverses.join(', ')));\n    }\n    return messages.join('\\n');\n  }\n  get size() {\n    return this.elements.size;\n  }\n  has(strResource) {\n    return this.elements.has(strResource);\n  }\n  set(strResource, value) {\n    this.elements.set(strResource, value);\n  }\n  delete(strResource) {\n    return this.elements.delete(strResource);\n  }\n}\nclass WorkspaceStackElement {\n  constructor(actual, resourceLabels, strResources, groupId, groupOrder, sourceId, sourceOrder) {\n    this.id = ++stackElementCounter;\n    this.type = 1 /* UndoRedoElementType.Workspace */;\n    this.actual = actual;\n    this.label = actual.label;\n    this.confirmBeforeUndo = actual.confirmBeforeUndo || false;\n    this.resourceLabels = resourceLabels;\n    this.strResources = strResources;\n    this.groupId = groupId;\n    this.groupOrder = groupOrder;\n    this.sourceId = sourceId;\n    this.sourceOrder = sourceOrder;\n    this.removedResources = null;\n    this.invalidatedResources = null;\n  }\n  canSplit() {\n    return typeof this.actual.split === 'function';\n  }\n  removeResource(resourceLabel, strResource, reason) {\n    if (!this.removedResources) {\n      this.removedResources = new RemovedResources();\n    }\n    if (!this.removedResources.has(strResource)) {\n      this.removedResources.set(strResource, new ResourceReasonPair(resourceLabel, reason));\n    }\n  }\n  setValid(resourceLabel, strResource, isValid) {\n    if (isValid) {\n      if (this.invalidatedResources) {\n        this.invalidatedResources.delete(strResource);\n        if (this.invalidatedResources.size === 0) {\n          this.invalidatedResources = null;\n        }\n      }\n    } else {\n      if (!this.invalidatedResources) {\n        this.invalidatedResources = new RemovedResources();\n      }\n      if (!this.invalidatedResources.has(strResource)) {\n        this.invalidatedResources.set(strResource, new ResourceReasonPair(resourceLabel, 0 /* RemovedResourceReason.ExternalRemoval */));\n      }\n    }\n  }\n  toString() {\n    return `[id:${this.id}] [group:${this.groupId}] [${this.invalidatedResources ? 'INVALID' : '  VALID'}] ${this.actual.constructor.name} - ${this.actual}`;\n  }\n}\nclass ResourceEditStack {\n  constructor(resourceLabel, strResource) {\n    this.resourceLabel = resourceLabel;\n    this.strResource = strResource;\n    this._past = [];\n    this._future = [];\n    this.locked = false;\n    this.versionId = 1;\n  }\n  dispose() {\n    for (const element of this._past) {\n      if (element.type === 1 /* UndoRedoElementType.Workspace */) {\n        element.removeResource(this.resourceLabel, this.strResource, 0 /* RemovedResourceReason.ExternalRemoval */);\n      }\n    }\n    for (const element of this._future) {\n      if (element.type === 1 /* UndoRedoElementType.Workspace */) {\n        element.removeResource(this.resourceLabel, this.strResource, 0 /* RemovedResourceReason.ExternalRemoval */);\n      }\n    }\n    this.versionId++;\n  }\n  toString() {\n    const result = [];\n    result.push(`* ${this.strResource}:`);\n    for (let i = 0; i < this._past.length; i++) {\n      result.push(`   * [UNDO] ${this._past[i]}`);\n    }\n    for (let i = this._future.length - 1; i >= 0; i--) {\n      result.push(`   * [REDO] ${this._future[i]}`);\n    }\n    return result.join('\\n');\n  }\n  flushAllElements() {\n    this._past = [];\n    this._future = [];\n    this.versionId++;\n  }\n  _setElementValidFlag(element, isValid) {\n    if (element.type === 1 /* UndoRedoElementType.Workspace */) {\n      element.setValid(this.resourceLabel, this.strResource, isValid);\n    } else {\n      element.setValid(isValid);\n    }\n  }\n  setElementsValidFlag(isValid, filter) {\n    for (const element of this._past) {\n      if (filter(element.actual)) {\n        this._setElementValidFlag(element, isValid);\n      }\n    }\n    for (const element of this._future) {\n      if (filter(element.actual)) {\n        this._setElementValidFlag(element, isValid);\n      }\n    }\n  }\n  pushElement(element) {\n    // remove the future\n    for (const futureElement of this._future) {\n      if (futureElement.type === 1 /* UndoRedoElementType.Workspace */) {\n        futureElement.removeResource(this.resourceLabel, this.strResource, 1 /* RemovedResourceReason.NoParallelUniverses */);\n      }\n    }\n    this._future = [];\n    this._past.push(element);\n    this.versionId++;\n  }\n  createSnapshot(resource) {\n    const elements = [];\n    for (let i = 0, len = this._past.length; i < len; i++) {\n      elements.push(this._past[i].id);\n    }\n    for (let i = this._future.length - 1; i >= 0; i--) {\n      elements.push(this._future[i].id);\n    }\n    return new ResourceEditStackSnapshot(resource, elements);\n  }\n  restoreSnapshot(snapshot) {\n    const snapshotLength = snapshot.elements.length;\n    let isOK = true;\n    let snapshotIndex = 0;\n    let removePastAfter = -1;\n    for (let i = 0, len = this._past.length; i < len; i++, snapshotIndex++) {\n      const element = this._past[i];\n      if (isOK && (snapshotIndex >= snapshotLength || element.id !== snapshot.elements[snapshotIndex])) {\n        isOK = false;\n        removePastAfter = 0;\n      }\n      if (!isOK && element.type === 1 /* UndoRedoElementType.Workspace */) {\n        element.removeResource(this.resourceLabel, this.strResource, 0 /* RemovedResourceReason.ExternalRemoval */);\n      }\n    }\n    let removeFutureBefore = -1;\n    for (let i = this._future.length - 1; i >= 0; i--, snapshotIndex++) {\n      const element = this._future[i];\n      if (isOK && (snapshotIndex >= snapshotLength || element.id !== snapshot.elements[snapshotIndex])) {\n        isOK = false;\n        removeFutureBefore = i;\n      }\n      if (!isOK && element.type === 1 /* UndoRedoElementType.Workspace */) {\n        element.removeResource(this.resourceLabel, this.strResource, 0 /* RemovedResourceReason.ExternalRemoval */);\n      }\n    }\n    if (removePastAfter !== -1) {\n      this._past = this._past.slice(0, removePastAfter);\n    }\n    if (removeFutureBefore !== -1) {\n      this._future = this._future.slice(removeFutureBefore + 1);\n    }\n    this.versionId++;\n  }\n  getElements() {\n    const past = [];\n    const future = [];\n    for (const element of this._past) {\n      past.push(element.actual);\n    }\n    for (const element of this._future) {\n      future.push(element.actual);\n    }\n    return {\n      past,\n      future\n    };\n  }\n  getClosestPastElement() {\n    if (this._past.length === 0) {\n      return null;\n    }\n    return this._past[this._past.length - 1];\n  }\n  getSecondClosestPastElement() {\n    if (this._past.length < 2) {\n      return null;\n    }\n    return this._past[this._past.length - 2];\n  }\n  getClosestFutureElement() {\n    if (this._future.length === 0) {\n      return null;\n    }\n    return this._future[this._future.length - 1];\n  }\n  hasPastElements() {\n    return this._past.length > 0;\n  }\n  hasFutureElements() {\n    return this._future.length > 0;\n  }\n  splitPastWorkspaceElement(toRemove, individualMap) {\n    for (let j = this._past.length - 1; j >= 0; j--) {\n      if (this._past[j] === toRemove) {\n        if (individualMap.has(this.strResource)) {\n          // gets replaced\n          this._past[j] = individualMap.get(this.strResource);\n        } else {\n          // gets deleted\n          this._past.splice(j, 1);\n        }\n        break;\n      }\n    }\n    this.versionId++;\n  }\n  splitFutureWorkspaceElement(toRemove, individualMap) {\n    for (let j = this._future.length - 1; j >= 0; j--) {\n      if (this._future[j] === toRemove) {\n        if (individualMap.has(this.strResource)) {\n          // gets replaced\n          this._future[j] = individualMap.get(this.strResource);\n        } else {\n          // gets deleted\n          this._future.splice(j, 1);\n        }\n        break;\n      }\n    }\n    this.versionId++;\n  }\n  moveBackward(element) {\n    this._past.pop();\n    this._future.push(element);\n    this.versionId++;\n  }\n  moveForward(element) {\n    this._future.pop();\n    this._past.push(element);\n    this.versionId++;\n  }\n}\nclass EditStackSnapshot {\n  constructor(editStacks) {\n    this.editStacks = editStacks;\n    this._versionIds = [];\n    for (let i = 0, len = this.editStacks.length; i < len; i++) {\n      this._versionIds[i] = this.editStacks[i].versionId;\n    }\n  }\n  isValid() {\n    for (let i = 0, len = this.editStacks.length; i < len; i++) {\n      if (this._versionIds[i] !== this.editStacks[i].versionId) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\nconst missingEditStack = new ResourceEditStack('', '');\nmissingEditStack.locked = true;\nlet UndoRedoService = class UndoRedoService {\n  constructor(_dialogService, _notificationService) {\n    this._dialogService = _dialogService;\n    this._notificationService = _notificationService;\n    this._editStacks = new Map();\n    this._uriComparisonKeyComputers = [];\n  }\n  getUriComparisonKey(resource) {\n    for (const uriComparisonKeyComputer of this._uriComparisonKeyComputers) {\n      if (uriComparisonKeyComputer[0] === resource.scheme) {\n        return uriComparisonKeyComputer[1].getComparisonKey(resource);\n      }\n    }\n    return resource.toString();\n  }\n  _print(label) {\n    console.log(`------------------------------------`);\n    console.log(`AFTER ${label}: `);\n    const str = [];\n    for (const element of this._editStacks) {\n      str.push(element[1].toString());\n    }\n    console.log(str.join('\\n'));\n  }\n  pushElement(element) {\n    let group = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : UndoRedoGroup.None;\n    let source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : UndoRedoSource.None;\n    if (element.type === 0 /* UndoRedoElementType.Resource */) {\n      const resourceLabel = getResourceLabel(element.resource);\n      const strResource = this.getUriComparisonKey(element.resource);\n      this._pushElement(new ResourceStackElement(element, resourceLabel, strResource, group.id, group.nextOrder(), source.id, source.nextOrder()));\n    } else {\n      const seen = new Set();\n      const resourceLabels = [];\n      const strResources = [];\n      for (const resource of element.resources) {\n        const resourceLabel = getResourceLabel(resource);\n        const strResource = this.getUriComparisonKey(resource);\n        if (seen.has(strResource)) {\n          continue;\n        }\n        seen.add(strResource);\n        resourceLabels.push(resourceLabel);\n        strResources.push(strResource);\n      }\n      if (resourceLabels.length === 1) {\n        this._pushElement(new ResourceStackElement(element, resourceLabels[0], strResources[0], group.id, group.nextOrder(), source.id, source.nextOrder()));\n      } else {\n        this._pushElement(new WorkspaceStackElement(element, resourceLabels, strResources, group.id, group.nextOrder(), source.id, source.nextOrder()));\n      }\n    }\n    if (DEBUG) {\n      this._print('pushElement');\n    }\n  }\n  _pushElement(element) {\n    for (let i = 0, len = element.strResources.length; i < len; i++) {\n      const resourceLabel = element.resourceLabels[i];\n      const strResource = element.strResources[i];\n      let editStack;\n      if (this._editStacks.has(strResource)) {\n        editStack = this._editStacks.get(strResource);\n      } else {\n        editStack = new ResourceEditStack(resourceLabel, strResource);\n        this._editStacks.set(strResource, editStack);\n      }\n      editStack.pushElement(element);\n    }\n  }\n  getLastElement(resource) {\n    const strResource = this.getUriComparisonKey(resource);\n    if (this._editStacks.has(strResource)) {\n      const editStack = this._editStacks.get(strResource);\n      if (editStack.hasFutureElements()) {\n        return null;\n      }\n      const closestPastElement = editStack.getClosestPastElement();\n      return closestPastElement ? closestPastElement.actual : null;\n    }\n    return null;\n  }\n  _splitPastWorkspaceElement(toRemove, ignoreResources) {\n    const individualArr = toRemove.actual.split();\n    const individualMap = new Map();\n    for (const _element of individualArr) {\n      const resourceLabel = getResourceLabel(_element.resource);\n      const strResource = this.getUriComparisonKey(_element.resource);\n      const element = new ResourceStackElement(_element, resourceLabel, strResource, 0, 0, 0, 0);\n      individualMap.set(element.strResource, element);\n    }\n    for (const strResource of toRemove.strResources) {\n      if (ignoreResources && ignoreResources.has(strResource)) {\n        continue;\n      }\n      const editStack = this._editStacks.get(strResource);\n      editStack.splitPastWorkspaceElement(toRemove, individualMap);\n    }\n  }\n  _splitFutureWorkspaceElement(toRemove, ignoreResources) {\n    const individualArr = toRemove.actual.split();\n    const individualMap = new Map();\n    for (const _element of individualArr) {\n      const resourceLabel = getResourceLabel(_element.resource);\n      const strResource = this.getUriComparisonKey(_element.resource);\n      const element = new ResourceStackElement(_element, resourceLabel, strResource, 0, 0, 0, 0);\n      individualMap.set(element.strResource, element);\n    }\n    for (const strResource of toRemove.strResources) {\n      if (ignoreResources && ignoreResources.has(strResource)) {\n        continue;\n      }\n      const editStack = this._editStacks.get(strResource);\n      editStack.splitFutureWorkspaceElement(toRemove, individualMap);\n    }\n  }\n  removeElements(resource) {\n    const strResource = typeof resource === 'string' ? resource : this.getUriComparisonKey(resource);\n    if (this._editStacks.has(strResource)) {\n      const editStack = this._editStacks.get(strResource);\n      editStack.dispose();\n      this._editStacks.delete(strResource);\n    }\n    if (DEBUG) {\n      this._print('removeElements');\n    }\n  }\n  setElementsValidFlag(resource, isValid, filter) {\n    const strResource = this.getUriComparisonKey(resource);\n    if (this._editStacks.has(strResource)) {\n      const editStack = this._editStacks.get(strResource);\n      editStack.setElementsValidFlag(isValid, filter);\n    }\n    if (DEBUG) {\n      this._print('setElementsValidFlag');\n    }\n  }\n  createSnapshot(resource) {\n    const strResource = this.getUriComparisonKey(resource);\n    if (this._editStacks.has(strResource)) {\n      const editStack = this._editStacks.get(strResource);\n      return editStack.createSnapshot(resource);\n    }\n    return new ResourceEditStackSnapshot(resource, []);\n  }\n  restoreSnapshot(snapshot) {\n    const strResource = this.getUriComparisonKey(snapshot.resource);\n    if (this._editStacks.has(strResource)) {\n      const editStack = this._editStacks.get(strResource);\n      editStack.restoreSnapshot(snapshot);\n      if (!editStack.hasPastElements() && !editStack.hasFutureElements()) {\n        // the edit stack is now empty, just remove it entirely\n        editStack.dispose();\n        this._editStacks.delete(strResource);\n      }\n    }\n    if (DEBUG) {\n      this._print('restoreSnapshot');\n    }\n  }\n  getElements(resource) {\n    const strResource = this.getUriComparisonKey(resource);\n    if (this._editStacks.has(strResource)) {\n      const editStack = this._editStacks.get(strResource);\n      return editStack.getElements();\n    }\n    return {\n      past: [],\n      future: []\n    };\n  }\n  _findClosestUndoElementWithSource(sourceId) {\n    if (!sourceId) {\n      return [null, null];\n    }\n    // find an element with the sourceId and with the highest sourceOrder ready to be undone\n    let matchedElement = null;\n    let matchedStrResource = null;\n    for (const [strResource, editStack] of this._editStacks) {\n      const candidate = editStack.getClosestPastElement();\n      if (!candidate) {\n        continue;\n      }\n      if (candidate.sourceId === sourceId) {\n        if (!matchedElement || candidate.sourceOrder > matchedElement.sourceOrder) {\n          matchedElement = candidate;\n          matchedStrResource = strResource;\n        }\n      }\n    }\n    return [matchedElement, matchedStrResource];\n  }\n  canUndo(resourceOrSource) {\n    if (resourceOrSource instanceof UndoRedoSource) {\n      const [, matchedStrResource] = this._findClosestUndoElementWithSource(resourceOrSource.id);\n      return matchedStrResource ? true : false;\n    }\n    const strResource = this.getUriComparisonKey(resourceOrSource);\n    if (this._editStacks.has(strResource)) {\n      const editStack = this._editStacks.get(strResource);\n      return editStack.hasPastElements();\n    }\n    return false;\n  }\n  _onError(err, element) {\n    onUnexpectedError(err);\n    // An error occurred while undoing or redoing => drop the undo/redo stack for all affected resources\n    for (const strResource of element.strResources) {\n      this.removeElements(strResource);\n    }\n    this._notificationService.error(err);\n  }\n  _acquireLocks(editStackSnapshot) {\n    // first, check if all locks can be acquired\n    for (const editStack of editStackSnapshot.editStacks) {\n      if (editStack.locked) {\n        throw new Error('Cannot acquire edit stack lock');\n      }\n    }\n    // can acquire all locks\n    for (const editStack of editStackSnapshot.editStacks) {\n      editStack.locked = true;\n    }\n    return () => {\n      // release all locks\n      for (const editStack of editStackSnapshot.editStacks) {\n        editStack.locked = false;\n      }\n    };\n  }\n  _safeInvokeWithLocks(element, invoke, editStackSnapshot, cleanup, continuation) {\n    const releaseLocks = this._acquireLocks(editStackSnapshot);\n    let result;\n    try {\n      result = invoke();\n    } catch (err) {\n      releaseLocks();\n      cleanup.dispose();\n      return this._onError(err, element);\n    }\n    if (result) {\n      // result is Promise<void>\n      return result.then(() => {\n        releaseLocks();\n        cleanup.dispose();\n        return continuation();\n      }, err => {\n        releaseLocks();\n        cleanup.dispose();\n        return this._onError(err, element);\n      });\n    } else {\n      // result is void\n      releaseLocks();\n      cleanup.dispose();\n      return continuation();\n    }\n  }\n  async _invokeWorkspacePrepare(element) {\n    if (typeof element.actual.prepareUndoRedo === 'undefined') {\n      return Disposable.None;\n    }\n    const result = element.actual.prepareUndoRedo();\n    if (typeof result === 'undefined') {\n      return Disposable.None;\n    }\n    return result;\n  }\n  _invokeResourcePrepare(element, callback) {\n    if (element.actual.type !== 1 /* UndoRedoElementType.Workspace */ || typeof element.actual.prepareUndoRedo === 'undefined') {\n      // no preparation needed\n      return callback(Disposable.None);\n    }\n    const r = element.actual.prepareUndoRedo();\n    if (!r) {\n      // nothing to clean up\n      return callback(Disposable.None);\n    }\n    if (isDisposable(r)) {\n      return callback(r);\n    }\n    return r.then(disposable => {\n      return callback(disposable);\n    });\n  }\n  _getAffectedEditStacks(element) {\n    const affectedEditStacks = [];\n    for (const strResource of element.strResources) {\n      affectedEditStacks.push(this._editStacks.get(strResource) || missingEditStack);\n    }\n    return new EditStackSnapshot(affectedEditStacks);\n  }\n  _tryToSplitAndUndo(strResource, element, ignoreResources, message) {\n    if (element.canSplit()) {\n      this._splitPastWorkspaceElement(element, ignoreResources);\n      this._notificationService.warn(message);\n      return new WorkspaceVerificationError(this._undo(strResource, 0, true));\n    } else {\n      // Cannot safely split this workspace element => flush all undo/redo stacks\n      for (const strResource of element.strResources) {\n        this.removeElements(strResource);\n      }\n      this._notificationService.warn(message);\n      return new WorkspaceVerificationError();\n    }\n  }\n  _checkWorkspaceUndo(strResource, element, editStackSnapshot, checkInvalidatedResources) {\n    if (element.removedResources) {\n      return this._tryToSplitAndUndo(strResource, element, element.removedResources, nls.localize({\n        key: 'cannotWorkspaceUndo',\n        comment: ['{0} is a label for an operation. {1} is another message.']\n      }, \"Could not undo '{0}' across all files. {1}\", element.label, element.removedResources.createMessage()));\n    }\n    if (checkInvalidatedResources && element.invalidatedResources) {\n      return this._tryToSplitAndUndo(strResource, element, element.invalidatedResources, nls.localize({\n        key: 'cannotWorkspaceUndo',\n        comment: ['{0} is a label for an operation. {1} is another message.']\n      }, \"Could not undo '{0}' across all files. {1}\", element.label, element.invalidatedResources.createMessage()));\n    }\n    // this must be the last past element in all the impacted resources!\n    const cannotUndoDueToResources = [];\n    for (const editStack of editStackSnapshot.editStacks) {\n      if (editStack.getClosestPastElement() !== element) {\n        cannotUndoDueToResources.push(editStack.resourceLabel);\n      }\n    }\n    if (cannotUndoDueToResources.length > 0) {\n      return this._tryToSplitAndUndo(strResource, element, null, nls.localize({\n        key: 'cannotWorkspaceUndoDueToChanges',\n        comment: ['{0} is a label for an operation. {1} is a list of filenames.']\n      }, \"Could not undo '{0}' across all files because changes were made to {1}\", element.label, cannotUndoDueToResources.join(', ')));\n    }\n    const cannotLockDueToResources = [];\n    for (const editStack of editStackSnapshot.editStacks) {\n      if (editStack.locked) {\n        cannotLockDueToResources.push(editStack.resourceLabel);\n      }\n    }\n    if (cannotLockDueToResources.length > 0) {\n      return this._tryToSplitAndUndo(strResource, element, null, nls.localize({\n        key: 'cannotWorkspaceUndoDueToInProgressUndoRedo',\n        comment: ['{0} is a label for an operation. {1} is a list of filenames.']\n      }, \"Could not undo '{0}' across all files because there is already an undo or redo operation running on {1}\", element.label, cannotLockDueToResources.join(', ')));\n    }\n    // check if new stack elements were added in the meantime...\n    if (!editStackSnapshot.isValid()) {\n      return this._tryToSplitAndUndo(strResource, element, null, nls.localize({\n        key: 'cannotWorkspaceUndoDueToInMeantimeUndoRedo',\n        comment: ['{0} is a label for an operation. {1} is a list of filenames.']\n      }, \"Could not undo '{0}' across all files because an undo or redo operation occurred in the meantime\", element.label));\n    }\n    return null;\n  }\n  _workspaceUndo(strResource, element, undoConfirmed) {\n    const affectedEditStacks = this._getAffectedEditStacks(element);\n    const verificationError = this._checkWorkspaceUndo(strResource, element, affectedEditStacks, /*invalidated resources will be checked after the prepare call*/false);\n    if (verificationError) {\n      return verificationError.returnValue;\n    }\n    return this._confirmAndExecuteWorkspaceUndo(strResource, element, affectedEditStacks, undoConfirmed);\n  }\n  _isPartOfUndoGroup(element) {\n    if (!element.groupId) {\n      return false;\n    }\n    // check that there is at least another element with the same groupId ready to be undone\n    for (const [, editStack] of this._editStacks) {\n      const pastElement = editStack.getClosestPastElement();\n      if (!pastElement) {\n        continue;\n      }\n      if (pastElement === element) {\n        const secondPastElement = editStack.getSecondClosestPastElement();\n        if (secondPastElement && secondPastElement.groupId === element.groupId) {\n          // there is another element with the same group id in the same stack!\n          return true;\n        }\n      }\n      if (pastElement.groupId === element.groupId) {\n        // there is another element with the same group id in another stack!\n        return true;\n      }\n    }\n    return false;\n  }\n  async _confirmAndExecuteWorkspaceUndo(strResource, element, editStackSnapshot, undoConfirmed) {\n    if (element.canSplit() && !this._isPartOfUndoGroup(element)) {\n      // this element can be split\n      let UndoChoice;\n      (function (UndoChoice) {\n        UndoChoice[UndoChoice[\"All\"] = 0] = \"All\";\n        UndoChoice[UndoChoice[\"This\"] = 1] = \"This\";\n        UndoChoice[UndoChoice[\"Cancel\"] = 2] = \"Cancel\";\n      })(UndoChoice || (UndoChoice = {}));\n      const {\n        result\n      } = await this._dialogService.prompt({\n        type: Severity.Info,\n        message: nls.localize('confirmWorkspace', \"Would you like to undo '{0}' across all files?\", element.label),\n        buttons: [{\n          label: nls.localize({\n            key: 'ok',\n            comment: ['{0} denotes a number that is > 1, && denotes a mnemonic']\n          }, \"&&Undo in {0} Files\", editStackSnapshot.editStacks.length),\n          run: () => UndoChoice.All\n        }, {\n          label: nls.localize({\n            key: 'nok',\n            comment: ['&& denotes a mnemonic']\n          }, \"Undo this &&File\"),\n          run: () => UndoChoice.This\n        }],\n        cancelButton: {\n          run: () => UndoChoice.Cancel\n        }\n      });\n      if (result === UndoChoice.Cancel) {\n        // choice: cancel\n        return;\n      }\n      if (result === UndoChoice.This) {\n        // choice: undo this file\n        this._splitPastWorkspaceElement(element, null);\n        return this._undo(strResource, 0, true);\n      }\n      // choice: undo in all files\n      // At this point, it is possible that the element has been made invalid in the meantime (due to the confirmation await)\n      const verificationError1 = this._checkWorkspaceUndo(strResource, element, editStackSnapshot, /*invalidated resources will be checked after the prepare call*/false);\n      if (verificationError1) {\n        return verificationError1.returnValue;\n      }\n      undoConfirmed = true;\n    }\n    // prepare\n    let cleanup;\n    try {\n      cleanup = await this._invokeWorkspacePrepare(element);\n    } catch (err) {\n      return this._onError(err, element);\n    }\n    // At this point, it is possible that the element has been made invalid in the meantime (due to the prepare await)\n    const verificationError2 = this._checkWorkspaceUndo(strResource, element, editStackSnapshot, /*now also check that there are no more invalidated resources*/true);\n    if (verificationError2) {\n      cleanup.dispose();\n      return verificationError2.returnValue;\n    }\n    for (const editStack of editStackSnapshot.editStacks) {\n      editStack.moveBackward(element);\n    }\n    return this._safeInvokeWithLocks(element, () => element.actual.undo(), editStackSnapshot, cleanup, () => this._continueUndoInGroup(element.groupId, undoConfirmed));\n  }\n  _resourceUndo(editStack, element, undoConfirmed) {\n    if (!element.isValid) {\n      // invalid element => immediately flush edit stack!\n      editStack.flushAllElements();\n      return;\n    }\n    if (editStack.locked) {\n      const message = nls.localize({\n        key: 'cannotResourceUndoDueToInProgressUndoRedo',\n        comment: ['{0} is a label for an operation.']\n      }, \"Could not undo '{0}' because there is already an undo or redo operation running.\", element.label);\n      this._notificationService.warn(message);\n      return;\n    }\n    return this._invokeResourcePrepare(element, cleanup => {\n      editStack.moveBackward(element);\n      return this._safeInvokeWithLocks(element, () => element.actual.undo(), new EditStackSnapshot([editStack]), cleanup, () => this._continueUndoInGroup(element.groupId, undoConfirmed));\n    });\n  }\n  _findClosestUndoElementInGroup(groupId) {\n    if (!groupId) {\n      return [null, null];\n    }\n    // find another element with the same groupId and with the highest groupOrder ready to be undone\n    let matchedElement = null;\n    let matchedStrResource = null;\n    for (const [strResource, editStack] of this._editStacks) {\n      const candidate = editStack.getClosestPastElement();\n      if (!candidate) {\n        continue;\n      }\n      if (candidate.groupId === groupId) {\n        if (!matchedElement || candidate.groupOrder > matchedElement.groupOrder) {\n          matchedElement = candidate;\n          matchedStrResource = strResource;\n        }\n      }\n    }\n    return [matchedElement, matchedStrResource];\n  }\n  _continueUndoInGroup(groupId, undoConfirmed) {\n    if (!groupId) {\n      return;\n    }\n    const [, matchedStrResource] = this._findClosestUndoElementInGroup(groupId);\n    if (matchedStrResource) {\n      return this._undo(matchedStrResource, 0, undoConfirmed);\n    }\n  }\n  undo(resourceOrSource) {\n    if (resourceOrSource instanceof UndoRedoSource) {\n      const [, matchedStrResource] = this._findClosestUndoElementWithSource(resourceOrSource.id);\n      return matchedStrResource ? this._undo(matchedStrResource, resourceOrSource.id, false) : undefined;\n    }\n    if (typeof resourceOrSource === 'string') {\n      return this._undo(resourceOrSource, 0, false);\n    }\n    return this._undo(this.getUriComparisonKey(resourceOrSource), 0, false);\n  }\n  _undo(strResource) {\n    let sourceId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let undoConfirmed = arguments.length > 2 ? arguments[2] : undefined;\n    if (!this._editStacks.has(strResource)) {\n      return;\n    }\n    const editStack = this._editStacks.get(strResource);\n    const element = editStack.getClosestPastElement();\n    if (!element) {\n      return;\n    }\n    if (element.groupId) {\n      // this element is a part of a group, we need to make sure undoing in a group is in order\n      const [matchedElement, matchedStrResource] = this._findClosestUndoElementInGroup(element.groupId);\n      if (element !== matchedElement && matchedStrResource) {\n        // there is an element in the same group that should be undone before this one\n        return this._undo(matchedStrResource, sourceId, undoConfirmed);\n      }\n    }\n    const shouldPromptForConfirmation = element.sourceId !== sourceId || element.confirmBeforeUndo;\n    if (shouldPromptForConfirmation && !undoConfirmed) {\n      // Hit a different source or the element asks for prompt before undo, prompt for confirmation\n      return this._confirmAndContinueUndo(strResource, sourceId, element);\n    }\n    try {\n      if (element.type === 1 /* UndoRedoElementType.Workspace */) {\n        return this._workspaceUndo(strResource, element, undoConfirmed);\n      } else {\n        return this._resourceUndo(editStack, element, undoConfirmed);\n      }\n    } finally {\n      if (DEBUG) {\n        this._print('undo');\n      }\n    }\n  }\n  async _confirmAndContinueUndo(strResource, sourceId, element) {\n    const result = await this._dialogService.confirm({\n      message: nls.localize('confirmDifferentSource', \"Would you like to undo '{0}'?\", element.label),\n      primaryButton: nls.localize({\n        key: 'confirmDifferentSource.yes',\n        comment: ['&& denotes a mnemonic']\n      }, \"&&Yes\"),\n      cancelButton: nls.localize('confirmDifferentSource.no', \"No\")\n    });\n    if (!result.confirmed) {\n      return;\n    }\n    return this._undo(strResource, sourceId, true);\n  }\n  _findClosestRedoElementWithSource(sourceId) {\n    if (!sourceId) {\n      return [null, null];\n    }\n    // find an element with sourceId and with the lowest sourceOrder ready to be redone\n    let matchedElement = null;\n    let matchedStrResource = null;\n    for (const [strResource, editStack] of this._editStacks) {\n      const candidate = editStack.getClosestFutureElement();\n      if (!candidate) {\n        continue;\n      }\n      if (candidate.sourceId === sourceId) {\n        if (!matchedElement || candidate.sourceOrder < matchedElement.sourceOrder) {\n          matchedElement = candidate;\n          matchedStrResource = strResource;\n        }\n      }\n    }\n    return [matchedElement, matchedStrResource];\n  }\n  canRedo(resourceOrSource) {\n    if (resourceOrSource instanceof UndoRedoSource) {\n      const [, matchedStrResource] = this._findClosestRedoElementWithSource(resourceOrSource.id);\n      return matchedStrResource ? true : false;\n    }\n    const strResource = this.getUriComparisonKey(resourceOrSource);\n    if (this._editStacks.has(strResource)) {\n      const editStack = this._editStacks.get(strResource);\n      return editStack.hasFutureElements();\n    }\n    return false;\n  }\n  _tryToSplitAndRedo(strResource, element, ignoreResources, message) {\n    if (element.canSplit()) {\n      this._splitFutureWorkspaceElement(element, ignoreResources);\n      this._notificationService.warn(message);\n      return new WorkspaceVerificationError(this._redo(strResource));\n    } else {\n      // Cannot safely split this workspace element => flush all undo/redo stacks\n      for (const strResource of element.strResources) {\n        this.removeElements(strResource);\n      }\n      this._notificationService.warn(message);\n      return new WorkspaceVerificationError();\n    }\n  }\n  _checkWorkspaceRedo(strResource, element, editStackSnapshot, checkInvalidatedResources) {\n    if (element.removedResources) {\n      return this._tryToSplitAndRedo(strResource, element, element.removedResources, nls.localize({\n        key: 'cannotWorkspaceRedo',\n        comment: ['{0} is a label for an operation. {1} is another message.']\n      }, \"Could not redo '{0}' across all files. {1}\", element.label, element.removedResources.createMessage()));\n    }\n    if (checkInvalidatedResources && element.invalidatedResources) {\n      return this._tryToSplitAndRedo(strResource, element, element.invalidatedResources, nls.localize({\n        key: 'cannotWorkspaceRedo',\n        comment: ['{0} is a label for an operation. {1} is another message.']\n      }, \"Could not redo '{0}' across all files. {1}\", element.label, element.invalidatedResources.createMessage()));\n    }\n    // this must be the last future element in all the impacted resources!\n    const cannotRedoDueToResources = [];\n    for (const editStack of editStackSnapshot.editStacks) {\n      if (editStack.getClosestFutureElement() !== element) {\n        cannotRedoDueToResources.push(editStack.resourceLabel);\n      }\n    }\n    if (cannotRedoDueToResources.length > 0) {\n      return this._tryToSplitAndRedo(strResource, element, null, nls.localize({\n        key: 'cannotWorkspaceRedoDueToChanges',\n        comment: ['{0} is a label for an operation. {1} is a list of filenames.']\n      }, \"Could not redo '{0}' across all files because changes were made to {1}\", element.label, cannotRedoDueToResources.join(', ')));\n    }\n    const cannotLockDueToResources = [];\n    for (const editStack of editStackSnapshot.editStacks) {\n      if (editStack.locked) {\n        cannotLockDueToResources.push(editStack.resourceLabel);\n      }\n    }\n    if (cannotLockDueToResources.length > 0) {\n      return this._tryToSplitAndRedo(strResource, element, null, nls.localize({\n        key: 'cannotWorkspaceRedoDueToInProgressUndoRedo',\n        comment: ['{0} is a label for an operation. {1} is a list of filenames.']\n      }, \"Could not redo '{0}' across all files because there is already an undo or redo operation running on {1}\", element.label, cannotLockDueToResources.join(', ')));\n    }\n    // check if new stack elements were added in the meantime...\n    if (!editStackSnapshot.isValid()) {\n      return this._tryToSplitAndRedo(strResource, element, null, nls.localize({\n        key: 'cannotWorkspaceRedoDueToInMeantimeUndoRedo',\n        comment: ['{0} is a label for an operation. {1} is a list of filenames.']\n      }, \"Could not redo '{0}' across all files because an undo or redo operation occurred in the meantime\", element.label));\n    }\n    return null;\n  }\n  _workspaceRedo(strResource, element) {\n    const affectedEditStacks = this._getAffectedEditStacks(element);\n    const verificationError = this._checkWorkspaceRedo(strResource, element, affectedEditStacks, /*invalidated resources will be checked after the prepare call*/false);\n    if (verificationError) {\n      return verificationError.returnValue;\n    }\n    return this._executeWorkspaceRedo(strResource, element, affectedEditStacks);\n  }\n  async _executeWorkspaceRedo(strResource, element, editStackSnapshot) {\n    // prepare\n    let cleanup;\n    try {\n      cleanup = await this._invokeWorkspacePrepare(element);\n    } catch (err) {\n      return this._onError(err, element);\n    }\n    // At this point, it is possible that the element has been made invalid in the meantime (due to the prepare await)\n    const verificationError = this._checkWorkspaceRedo(strResource, element, editStackSnapshot, /*now also check that there are no more invalidated resources*/true);\n    if (verificationError) {\n      cleanup.dispose();\n      return verificationError.returnValue;\n    }\n    for (const editStack of editStackSnapshot.editStacks) {\n      editStack.moveForward(element);\n    }\n    return this._safeInvokeWithLocks(element, () => element.actual.redo(), editStackSnapshot, cleanup, () => this._continueRedoInGroup(element.groupId));\n  }\n  _resourceRedo(editStack, element) {\n    if (!element.isValid) {\n      // invalid element => immediately flush edit stack!\n      editStack.flushAllElements();\n      return;\n    }\n    if (editStack.locked) {\n      const message = nls.localize({\n        key: 'cannotResourceRedoDueToInProgressUndoRedo',\n        comment: ['{0} is a label for an operation.']\n      }, \"Could not redo '{0}' because there is already an undo or redo operation running.\", element.label);\n      this._notificationService.warn(message);\n      return;\n    }\n    return this._invokeResourcePrepare(element, cleanup => {\n      editStack.moveForward(element);\n      return this._safeInvokeWithLocks(element, () => element.actual.redo(), new EditStackSnapshot([editStack]), cleanup, () => this._continueRedoInGroup(element.groupId));\n    });\n  }\n  _findClosestRedoElementInGroup(groupId) {\n    if (!groupId) {\n      return [null, null];\n    }\n    // find another element with the same groupId and with the lowest groupOrder ready to be redone\n    let matchedElement = null;\n    let matchedStrResource = null;\n    for (const [strResource, editStack] of this._editStacks) {\n      const candidate = editStack.getClosestFutureElement();\n      if (!candidate) {\n        continue;\n      }\n      if (candidate.groupId === groupId) {\n        if (!matchedElement || candidate.groupOrder < matchedElement.groupOrder) {\n          matchedElement = candidate;\n          matchedStrResource = strResource;\n        }\n      }\n    }\n    return [matchedElement, matchedStrResource];\n  }\n  _continueRedoInGroup(groupId) {\n    if (!groupId) {\n      return;\n    }\n    const [, matchedStrResource] = this._findClosestRedoElementInGroup(groupId);\n    if (matchedStrResource) {\n      return this._redo(matchedStrResource);\n    }\n  }\n  redo(resourceOrSource) {\n    if (resourceOrSource instanceof UndoRedoSource) {\n      const [, matchedStrResource] = this._findClosestRedoElementWithSource(resourceOrSource.id);\n      return matchedStrResource ? this._redo(matchedStrResource) : undefined;\n    }\n    if (typeof resourceOrSource === 'string') {\n      return this._redo(resourceOrSource);\n    }\n    return this._redo(this.getUriComparisonKey(resourceOrSource));\n  }\n  _redo(strResource) {\n    if (!this._editStacks.has(strResource)) {\n      return;\n    }\n    const editStack = this._editStacks.get(strResource);\n    const element = editStack.getClosestFutureElement();\n    if (!element) {\n      return;\n    }\n    if (element.groupId) {\n      // this element is a part of a group, we need to make sure redoing in a group is in order\n      const [matchedElement, matchedStrResource] = this._findClosestRedoElementInGroup(element.groupId);\n      if (element !== matchedElement && matchedStrResource) {\n        // there is an element in the same group that should be redone before this one\n        return this._redo(matchedStrResource);\n      }\n    }\n    try {\n      if (element.type === 1 /* UndoRedoElementType.Workspace */) {\n        return this._workspaceRedo(strResource, element);\n      } else {\n        return this._resourceRedo(editStack, element);\n      }\n    } finally {\n      if (DEBUG) {\n        this._print('redo');\n      }\n    }\n  }\n};\nUndoRedoService = __decorate([__param(0, IDialogService), __param(1, INotificationService)], UndoRedoService);\nexport { UndoRedoService };\nclass WorkspaceVerificationError {\n  constructor(returnValue) {\n    this.returnValue = returnValue;\n  }\n}\nregisterSingleton(IUndoRedoService, UndoRedoService, 1 /* InstantiationType.Delayed */);","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","onUnexpectedError","Disposable","isDisposable","Schemas","Severity","nls","IDialogService","registerSingleton","INotificationService","IUndoRedoService","ResourceEditStackSnapshot","UndoRedoGroup","UndoRedoSource","DEBUG","getResourceLabel","resource","scheme","file","fsPath","path","stackElementCounter","ResourceStackElement","constructor","actual","resourceLabel","strResource","groupId","groupOrder","sourceId","sourceOrder","id","type","label","confirmBeforeUndo","resourceLabels","strResources","isValid","setValid","toString","name","ResourceReasonPair","reason","RemovedResources","elements","Map","createMessage","externalRemoval","noParallelUniverses","element","dest","push","messages","localize","comment","join","size","has","set","value","delete","WorkspaceStackElement","removedResources","invalidatedResources","canSplit","split","removeResource","ResourceEditStack","_past","_future","locked","versionId","dispose","result","flushAllElements","_setElementValidFlag","setElementsValidFlag","filter","pushElement","futureElement","createSnapshot","len","restoreSnapshot","snapshot","snapshotLength","isOK","snapshotIndex","removePastAfter","removeFutureBefore","slice","getElements","past","future","getClosestPastElement","getSecondClosestPastElement","getClosestFutureElement","hasPastElements","hasFutureElements","splitPastWorkspaceElement","toRemove","individualMap","j","get","splice","splitFutureWorkspaceElement","moveBackward","pop","moveForward","EditStackSnapshot","editStacks","_versionIds","missingEditStack","UndoRedoService","_dialogService","_notificationService","_editStacks","_uriComparisonKeyComputers","getUriComparisonKey","uriComparisonKeyComputer","getComparisonKey","_print","console","log","str","group","undefined","None","source","_pushElement","nextOrder","seen","Set","resources","add","editStack","getLastElement","closestPastElement","_splitPastWorkspaceElement","ignoreResources","individualArr","_element","_splitFutureWorkspaceElement","removeElements","_findClosestUndoElementWithSource","matchedElement","matchedStrResource","candidate","canUndo","resourceOrSource","_onError","err","error","_acquireLocks","editStackSnapshot","Error","_safeInvokeWithLocks","invoke","cleanup","continuation","releaseLocks","then","_invokeWorkspacePrepare","prepareUndoRedo","_invokeResourcePrepare","callback","disposable","_getAffectedEditStacks","affectedEditStacks","_tryToSplitAndUndo","message","warn","WorkspaceVerificationError","_undo","_checkWorkspaceUndo","checkInvalidatedResources","cannotUndoDueToResources","cannotLockDueToResources","_workspaceUndo","undoConfirmed","verificationError","returnValue","_confirmAndExecuteWorkspaceUndo","_isPartOfUndoGroup","pastElement","secondPastElement","UndoChoice","prompt","Info","buttons","run","All","This","cancelButton","Cancel","verificationError1","verificationError2","undo","_continueUndoInGroup","_resourceUndo","_findClosestUndoElementInGroup","shouldPromptForConfirmation","_confirmAndContinueUndo","confirm","primaryButton","confirmed","_findClosestRedoElementWithSource","canRedo","_tryToSplitAndRedo","_redo","_checkWorkspaceRedo","cannotRedoDueToResources","_workspaceRedo","_executeWorkspaceRedo","redo","_continueRedoInGroup","_resourceRedo","_findClosestRedoElementInGroup"],"sources":["/home/arslan/modojo/node_modules/monaco-editor/esm/vs/platform/undoRedo/common/undoRedoService.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Disposable, isDisposable } from '../../../base/common/lifecycle.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport Severity from '../../../base/common/severity.js';\nimport * as nls from '../../../nls.js';\nimport { IDialogService } from '../../dialogs/common/dialogs.js';\nimport { registerSingleton } from '../../instantiation/common/extensions.js';\nimport { INotificationService } from '../../notification/common/notification.js';\nimport { IUndoRedoService, ResourceEditStackSnapshot, UndoRedoGroup, UndoRedoSource } from './undoRedo.js';\nconst DEBUG = false;\nfunction getResourceLabel(resource) {\n    return resource.scheme === Schemas.file ? resource.fsPath : resource.path;\n}\nlet stackElementCounter = 0;\nclass ResourceStackElement {\n    constructor(actual, resourceLabel, strResource, groupId, groupOrder, sourceId, sourceOrder) {\n        this.id = (++stackElementCounter);\n        this.type = 0 /* UndoRedoElementType.Resource */;\n        this.actual = actual;\n        this.label = actual.label;\n        this.confirmBeforeUndo = actual.confirmBeforeUndo || false;\n        this.resourceLabel = resourceLabel;\n        this.strResource = strResource;\n        this.resourceLabels = [this.resourceLabel];\n        this.strResources = [this.strResource];\n        this.groupId = groupId;\n        this.groupOrder = groupOrder;\n        this.sourceId = sourceId;\n        this.sourceOrder = sourceOrder;\n        this.isValid = true;\n    }\n    setValid(isValid) {\n        this.isValid = isValid;\n    }\n    toString() {\n        return `[id:${this.id}] [group:${this.groupId}] [${this.isValid ? '  VALID' : 'INVALID'}] ${this.actual.constructor.name} - ${this.actual}`;\n    }\n}\nclass ResourceReasonPair {\n    constructor(resourceLabel, reason) {\n        this.resourceLabel = resourceLabel;\n        this.reason = reason;\n    }\n}\nclass RemovedResources {\n    constructor() {\n        this.elements = new Map();\n    }\n    createMessage() {\n        const externalRemoval = [];\n        const noParallelUniverses = [];\n        for (const [, element] of this.elements) {\n            const dest = (element.reason === 0 /* RemovedResourceReason.ExternalRemoval */\n                ? externalRemoval\n                : noParallelUniverses);\n            dest.push(element.resourceLabel);\n        }\n        const messages = [];\n        if (externalRemoval.length > 0) {\n            messages.push(nls.localize({ key: 'externalRemoval', comment: ['{0} is a list of filenames'] }, \"The following files have been closed and modified on disk: {0}.\", externalRemoval.join(', ')));\n        }\n        if (noParallelUniverses.length > 0) {\n            messages.push(nls.localize({ key: 'noParallelUniverses', comment: ['{0} is a list of filenames'] }, \"The following files have been modified in an incompatible way: {0}.\", noParallelUniverses.join(', ')));\n        }\n        return messages.join('\\n');\n    }\n    get size() {\n        return this.elements.size;\n    }\n    has(strResource) {\n        return this.elements.has(strResource);\n    }\n    set(strResource, value) {\n        this.elements.set(strResource, value);\n    }\n    delete(strResource) {\n        return this.elements.delete(strResource);\n    }\n}\nclass WorkspaceStackElement {\n    constructor(actual, resourceLabels, strResources, groupId, groupOrder, sourceId, sourceOrder) {\n        this.id = (++stackElementCounter);\n        this.type = 1 /* UndoRedoElementType.Workspace */;\n        this.actual = actual;\n        this.label = actual.label;\n        this.confirmBeforeUndo = actual.confirmBeforeUndo || false;\n        this.resourceLabels = resourceLabels;\n        this.strResources = strResources;\n        this.groupId = groupId;\n        this.groupOrder = groupOrder;\n        this.sourceId = sourceId;\n        this.sourceOrder = sourceOrder;\n        this.removedResources = null;\n        this.invalidatedResources = null;\n    }\n    canSplit() {\n        return (typeof this.actual.split === 'function');\n    }\n    removeResource(resourceLabel, strResource, reason) {\n        if (!this.removedResources) {\n            this.removedResources = new RemovedResources();\n        }\n        if (!this.removedResources.has(strResource)) {\n            this.removedResources.set(strResource, new ResourceReasonPair(resourceLabel, reason));\n        }\n    }\n    setValid(resourceLabel, strResource, isValid) {\n        if (isValid) {\n            if (this.invalidatedResources) {\n                this.invalidatedResources.delete(strResource);\n                if (this.invalidatedResources.size === 0) {\n                    this.invalidatedResources = null;\n                }\n            }\n        }\n        else {\n            if (!this.invalidatedResources) {\n                this.invalidatedResources = new RemovedResources();\n            }\n            if (!this.invalidatedResources.has(strResource)) {\n                this.invalidatedResources.set(strResource, new ResourceReasonPair(resourceLabel, 0 /* RemovedResourceReason.ExternalRemoval */));\n            }\n        }\n    }\n    toString() {\n        return `[id:${this.id}] [group:${this.groupId}] [${this.invalidatedResources ? 'INVALID' : '  VALID'}] ${this.actual.constructor.name} - ${this.actual}`;\n    }\n}\nclass ResourceEditStack {\n    constructor(resourceLabel, strResource) {\n        this.resourceLabel = resourceLabel;\n        this.strResource = strResource;\n        this._past = [];\n        this._future = [];\n        this.locked = false;\n        this.versionId = 1;\n    }\n    dispose() {\n        for (const element of this._past) {\n            if (element.type === 1 /* UndoRedoElementType.Workspace */) {\n                element.removeResource(this.resourceLabel, this.strResource, 0 /* RemovedResourceReason.ExternalRemoval */);\n            }\n        }\n        for (const element of this._future) {\n            if (element.type === 1 /* UndoRedoElementType.Workspace */) {\n                element.removeResource(this.resourceLabel, this.strResource, 0 /* RemovedResourceReason.ExternalRemoval */);\n            }\n        }\n        this.versionId++;\n    }\n    toString() {\n        const result = [];\n        result.push(`* ${this.strResource}:`);\n        for (let i = 0; i < this._past.length; i++) {\n            result.push(`   * [UNDO] ${this._past[i]}`);\n        }\n        for (let i = this._future.length - 1; i >= 0; i--) {\n            result.push(`   * [REDO] ${this._future[i]}`);\n        }\n        return result.join('\\n');\n    }\n    flushAllElements() {\n        this._past = [];\n        this._future = [];\n        this.versionId++;\n    }\n    _setElementValidFlag(element, isValid) {\n        if (element.type === 1 /* UndoRedoElementType.Workspace */) {\n            element.setValid(this.resourceLabel, this.strResource, isValid);\n        }\n        else {\n            element.setValid(isValid);\n        }\n    }\n    setElementsValidFlag(isValid, filter) {\n        for (const element of this._past) {\n            if (filter(element.actual)) {\n                this._setElementValidFlag(element, isValid);\n            }\n        }\n        for (const element of this._future) {\n            if (filter(element.actual)) {\n                this._setElementValidFlag(element, isValid);\n            }\n        }\n    }\n    pushElement(element) {\n        // remove the future\n        for (const futureElement of this._future) {\n            if (futureElement.type === 1 /* UndoRedoElementType.Workspace */) {\n                futureElement.removeResource(this.resourceLabel, this.strResource, 1 /* RemovedResourceReason.NoParallelUniverses */);\n            }\n        }\n        this._future = [];\n        this._past.push(element);\n        this.versionId++;\n    }\n    createSnapshot(resource) {\n        const elements = [];\n        for (let i = 0, len = this._past.length; i < len; i++) {\n            elements.push(this._past[i].id);\n        }\n        for (let i = this._future.length - 1; i >= 0; i--) {\n            elements.push(this._future[i].id);\n        }\n        return new ResourceEditStackSnapshot(resource, elements);\n    }\n    restoreSnapshot(snapshot) {\n        const snapshotLength = snapshot.elements.length;\n        let isOK = true;\n        let snapshotIndex = 0;\n        let removePastAfter = -1;\n        for (let i = 0, len = this._past.length; i < len; i++, snapshotIndex++) {\n            const element = this._past[i];\n            if (isOK && (snapshotIndex >= snapshotLength || element.id !== snapshot.elements[snapshotIndex])) {\n                isOK = false;\n                removePastAfter = 0;\n            }\n            if (!isOK && element.type === 1 /* UndoRedoElementType.Workspace */) {\n                element.removeResource(this.resourceLabel, this.strResource, 0 /* RemovedResourceReason.ExternalRemoval */);\n            }\n        }\n        let removeFutureBefore = -1;\n        for (let i = this._future.length - 1; i >= 0; i--, snapshotIndex++) {\n            const element = this._future[i];\n            if (isOK && (snapshotIndex >= snapshotLength || element.id !== snapshot.elements[snapshotIndex])) {\n                isOK = false;\n                removeFutureBefore = i;\n            }\n            if (!isOK && element.type === 1 /* UndoRedoElementType.Workspace */) {\n                element.removeResource(this.resourceLabel, this.strResource, 0 /* RemovedResourceReason.ExternalRemoval */);\n            }\n        }\n        if (removePastAfter !== -1) {\n            this._past = this._past.slice(0, removePastAfter);\n        }\n        if (removeFutureBefore !== -1) {\n            this._future = this._future.slice(removeFutureBefore + 1);\n        }\n        this.versionId++;\n    }\n    getElements() {\n        const past = [];\n        const future = [];\n        for (const element of this._past) {\n            past.push(element.actual);\n        }\n        for (const element of this._future) {\n            future.push(element.actual);\n        }\n        return { past, future };\n    }\n    getClosestPastElement() {\n        if (this._past.length === 0) {\n            return null;\n        }\n        return this._past[this._past.length - 1];\n    }\n    getSecondClosestPastElement() {\n        if (this._past.length < 2) {\n            return null;\n        }\n        return this._past[this._past.length - 2];\n    }\n    getClosestFutureElement() {\n        if (this._future.length === 0) {\n            return null;\n        }\n        return this._future[this._future.length - 1];\n    }\n    hasPastElements() {\n        return (this._past.length > 0);\n    }\n    hasFutureElements() {\n        return (this._future.length > 0);\n    }\n    splitPastWorkspaceElement(toRemove, individualMap) {\n        for (let j = this._past.length - 1; j >= 0; j--) {\n            if (this._past[j] === toRemove) {\n                if (individualMap.has(this.strResource)) {\n                    // gets replaced\n                    this._past[j] = individualMap.get(this.strResource);\n                }\n                else {\n                    // gets deleted\n                    this._past.splice(j, 1);\n                }\n                break;\n            }\n        }\n        this.versionId++;\n    }\n    splitFutureWorkspaceElement(toRemove, individualMap) {\n        for (let j = this._future.length - 1; j >= 0; j--) {\n            if (this._future[j] === toRemove) {\n                if (individualMap.has(this.strResource)) {\n                    // gets replaced\n                    this._future[j] = individualMap.get(this.strResource);\n                }\n                else {\n                    // gets deleted\n                    this._future.splice(j, 1);\n                }\n                break;\n            }\n        }\n        this.versionId++;\n    }\n    moveBackward(element) {\n        this._past.pop();\n        this._future.push(element);\n        this.versionId++;\n    }\n    moveForward(element) {\n        this._future.pop();\n        this._past.push(element);\n        this.versionId++;\n    }\n}\nclass EditStackSnapshot {\n    constructor(editStacks) {\n        this.editStacks = editStacks;\n        this._versionIds = [];\n        for (let i = 0, len = this.editStacks.length; i < len; i++) {\n            this._versionIds[i] = this.editStacks[i].versionId;\n        }\n    }\n    isValid() {\n        for (let i = 0, len = this.editStacks.length; i < len; i++) {\n            if (this._versionIds[i] !== this.editStacks[i].versionId) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nconst missingEditStack = new ResourceEditStack('', '');\nmissingEditStack.locked = true;\nlet UndoRedoService = class UndoRedoService {\n    constructor(_dialogService, _notificationService) {\n        this._dialogService = _dialogService;\n        this._notificationService = _notificationService;\n        this._editStacks = new Map();\n        this._uriComparisonKeyComputers = [];\n    }\n    getUriComparisonKey(resource) {\n        for (const uriComparisonKeyComputer of this._uriComparisonKeyComputers) {\n            if (uriComparisonKeyComputer[0] === resource.scheme) {\n                return uriComparisonKeyComputer[1].getComparisonKey(resource);\n            }\n        }\n        return resource.toString();\n    }\n    _print(label) {\n        console.log(`------------------------------------`);\n        console.log(`AFTER ${label}: `);\n        const str = [];\n        for (const element of this._editStacks) {\n            str.push(element[1].toString());\n        }\n        console.log(str.join('\\n'));\n    }\n    pushElement(element, group = UndoRedoGroup.None, source = UndoRedoSource.None) {\n        if (element.type === 0 /* UndoRedoElementType.Resource */) {\n            const resourceLabel = getResourceLabel(element.resource);\n            const strResource = this.getUriComparisonKey(element.resource);\n            this._pushElement(new ResourceStackElement(element, resourceLabel, strResource, group.id, group.nextOrder(), source.id, source.nextOrder()));\n        }\n        else {\n            const seen = new Set();\n            const resourceLabels = [];\n            const strResources = [];\n            for (const resource of element.resources) {\n                const resourceLabel = getResourceLabel(resource);\n                const strResource = this.getUriComparisonKey(resource);\n                if (seen.has(strResource)) {\n                    continue;\n                }\n                seen.add(strResource);\n                resourceLabels.push(resourceLabel);\n                strResources.push(strResource);\n            }\n            if (resourceLabels.length === 1) {\n                this._pushElement(new ResourceStackElement(element, resourceLabels[0], strResources[0], group.id, group.nextOrder(), source.id, source.nextOrder()));\n            }\n            else {\n                this._pushElement(new WorkspaceStackElement(element, resourceLabels, strResources, group.id, group.nextOrder(), source.id, source.nextOrder()));\n            }\n        }\n        if (DEBUG) {\n            this._print('pushElement');\n        }\n    }\n    _pushElement(element) {\n        for (let i = 0, len = element.strResources.length; i < len; i++) {\n            const resourceLabel = element.resourceLabels[i];\n            const strResource = element.strResources[i];\n            let editStack;\n            if (this._editStacks.has(strResource)) {\n                editStack = this._editStacks.get(strResource);\n            }\n            else {\n                editStack = new ResourceEditStack(resourceLabel, strResource);\n                this._editStacks.set(strResource, editStack);\n            }\n            editStack.pushElement(element);\n        }\n    }\n    getLastElement(resource) {\n        const strResource = this.getUriComparisonKey(resource);\n        if (this._editStacks.has(strResource)) {\n            const editStack = this._editStacks.get(strResource);\n            if (editStack.hasFutureElements()) {\n                return null;\n            }\n            const closestPastElement = editStack.getClosestPastElement();\n            return closestPastElement ? closestPastElement.actual : null;\n        }\n        return null;\n    }\n    _splitPastWorkspaceElement(toRemove, ignoreResources) {\n        const individualArr = toRemove.actual.split();\n        const individualMap = new Map();\n        for (const _element of individualArr) {\n            const resourceLabel = getResourceLabel(_element.resource);\n            const strResource = this.getUriComparisonKey(_element.resource);\n            const element = new ResourceStackElement(_element, resourceLabel, strResource, 0, 0, 0, 0);\n            individualMap.set(element.strResource, element);\n        }\n        for (const strResource of toRemove.strResources) {\n            if (ignoreResources && ignoreResources.has(strResource)) {\n                continue;\n            }\n            const editStack = this._editStacks.get(strResource);\n            editStack.splitPastWorkspaceElement(toRemove, individualMap);\n        }\n    }\n    _splitFutureWorkspaceElement(toRemove, ignoreResources) {\n        const individualArr = toRemove.actual.split();\n        const individualMap = new Map();\n        for (const _element of individualArr) {\n            const resourceLabel = getResourceLabel(_element.resource);\n            const strResource = this.getUriComparisonKey(_element.resource);\n            const element = new ResourceStackElement(_element, resourceLabel, strResource, 0, 0, 0, 0);\n            individualMap.set(element.strResource, element);\n        }\n        for (const strResource of toRemove.strResources) {\n            if (ignoreResources && ignoreResources.has(strResource)) {\n                continue;\n            }\n            const editStack = this._editStacks.get(strResource);\n            editStack.splitFutureWorkspaceElement(toRemove, individualMap);\n        }\n    }\n    removeElements(resource) {\n        const strResource = typeof resource === 'string' ? resource : this.getUriComparisonKey(resource);\n        if (this._editStacks.has(strResource)) {\n            const editStack = this._editStacks.get(strResource);\n            editStack.dispose();\n            this._editStacks.delete(strResource);\n        }\n        if (DEBUG) {\n            this._print('removeElements');\n        }\n    }\n    setElementsValidFlag(resource, isValid, filter) {\n        const strResource = this.getUriComparisonKey(resource);\n        if (this._editStacks.has(strResource)) {\n            const editStack = this._editStacks.get(strResource);\n            editStack.setElementsValidFlag(isValid, filter);\n        }\n        if (DEBUG) {\n            this._print('setElementsValidFlag');\n        }\n    }\n    createSnapshot(resource) {\n        const strResource = this.getUriComparisonKey(resource);\n        if (this._editStacks.has(strResource)) {\n            const editStack = this._editStacks.get(strResource);\n            return editStack.createSnapshot(resource);\n        }\n        return new ResourceEditStackSnapshot(resource, []);\n    }\n    restoreSnapshot(snapshot) {\n        const strResource = this.getUriComparisonKey(snapshot.resource);\n        if (this._editStacks.has(strResource)) {\n            const editStack = this._editStacks.get(strResource);\n            editStack.restoreSnapshot(snapshot);\n            if (!editStack.hasPastElements() && !editStack.hasFutureElements()) {\n                // the edit stack is now empty, just remove it entirely\n                editStack.dispose();\n                this._editStacks.delete(strResource);\n            }\n        }\n        if (DEBUG) {\n            this._print('restoreSnapshot');\n        }\n    }\n    getElements(resource) {\n        const strResource = this.getUriComparisonKey(resource);\n        if (this._editStacks.has(strResource)) {\n            const editStack = this._editStacks.get(strResource);\n            return editStack.getElements();\n        }\n        return { past: [], future: [] };\n    }\n    _findClosestUndoElementWithSource(sourceId) {\n        if (!sourceId) {\n            return [null, null];\n        }\n        // find an element with the sourceId and with the highest sourceOrder ready to be undone\n        let matchedElement = null;\n        let matchedStrResource = null;\n        for (const [strResource, editStack] of this._editStacks) {\n            const candidate = editStack.getClosestPastElement();\n            if (!candidate) {\n                continue;\n            }\n            if (candidate.sourceId === sourceId) {\n                if (!matchedElement || candidate.sourceOrder > matchedElement.sourceOrder) {\n                    matchedElement = candidate;\n                    matchedStrResource = strResource;\n                }\n            }\n        }\n        return [matchedElement, matchedStrResource];\n    }\n    canUndo(resourceOrSource) {\n        if (resourceOrSource instanceof UndoRedoSource) {\n            const [, matchedStrResource] = this._findClosestUndoElementWithSource(resourceOrSource.id);\n            return matchedStrResource ? true : false;\n        }\n        const strResource = this.getUriComparisonKey(resourceOrSource);\n        if (this._editStacks.has(strResource)) {\n            const editStack = this._editStacks.get(strResource);\n            return editStack.hasPastElements();\n        }\n        return false;\n    }\n    _onError(err, element) {\n        onUnexpectedError(err);\n        // An error occurred while undoing or redoing => drop the undo/redo stack for all affected resources\n        for (const strResource of element.strResources) {\n            this.removeElements(strResource);\n        }\n        this._notificationService.error(err);\n    }\n    _acquireLocks(editStackSnapshot) {\n        // first, check if all locks can be acquired\n        for (const editStack of editStackSnapshot.editStacks) {\n            if (editStack.locked) {\n                throw new Error('Cannot acquire edit stack lock');\n            }\n        }\n        // can acquire all locks\n        for (const editStack of editStackSnapshot.editStacks) {\n            editStack.locked = true;\n        }\n        return () => {\n            // release all locks\n            for (const editStack of editStackSnapshot.editStacks) {\n                editStack.locked = false;\n            }\n        };\n    }\n    _safeInvokeWithLocks(element, invoke, editStackSnapshot, cleanup, continuation) {\n        const releaseLocks = this._acquireLocks(editStackSnapshot);\n        let result;\n        try {\n            result = invoke();\n        }\n        catch (err) {\n            releaseLocks();\n            cleanup.dispose();\n            return this._onError(err, element);\n        }\n        if (result) {\n            // result is Promise<void>\n            return result.then(() => {\n                releaseLocks();\n                cleanup.dispose();\n                return continuation();\n            }, (err) => {\n                releaseLocks();\n                cleanup.dispose();\n                return this._onError(err, element);\n            });\n        }\n        else {\n            // result is void\n            releaseLocks();\n            cleanup.dispose();\n            return continuation();\n        }\n    }\n    async _invokeWorkspacePrepare(element) {\n        if (typeof element.actual.prepareUndoRedo === 'undefined') {\n            return Disposable.None;\n        }\n        const result = element.actual.prepareUndoRedo();\n        if (typeof result === 'undefined') {\n            return Disposable.None;\n        }\n        return result;\n    }\n    _invokeResourcePrepare(element, callback) {\n        if (element.actual.type !== 1 /* UndoRedoElementType.Workspace */ || typeof element.actual.prepareUndoRedo === 'undefined') {\n            // no preparation needed\n            return callback(Disposable.None);\n        }\n        const r = element.actual.prepareUndoRedo();\n        if (!r) {\n            // nothing to clean up\n            return callback(Disposable.None);\n        }\n        if (isDisposable(r)) {\n            return callback(r);\n        }\n        return r.then((disposable) => {\n            return callback(disposable);\n        });\n    }\n    _getAffectedEditStacks(element) {\n        const affectedEditStacks = [];\n        for (const strResource of element.strResources) {\n            affectedEditStacks.push(this._editStacks.get(strResource) || missingEditStack);\n        }\n        return new EditStackSnapshot(affectedEditStacks);\n    }\n    _tryToSplitAndUndo(strResource, element, ignoreResources, message) {\n        if (element.canSplit()) {\n            this._splitPastWorkspaceElement(element, ignoreResources);\n            this._notificationService.warn(message);\n            return new WorkspaceVerificationError(this._undo(strResource, 0, true));\n        }\n        else {\n            // Cannot safely split this workspace element => flush all undo/redo stacks\n            for (const strResource of element.strResources) {\n                this.removeElements(strResource);\n            }\n            this._notificationService.warn(message);\n            return new WorkspaceVerificationError();\n        }\n    }\n    _checkWorkspaceUndo(strResource, element, editStackSnapshot, checkInvalidatedResources) {\n        if (element.removedResources) {\n            return this._tryToSplitAndUndo(strResource, element, element.removedResources, nls.localize({ key: 'cannotWorkspaceUndo', comment: ['{0} is a label for an operation. {1} is another message.'] }, \"Could not undo '{0}' across all files. {1}\", element.label, element.removedResources.createMessage()));\n        }\n        if (checkInvalidatedResources && element.invalidatedResources) {\n            return this._tryToSplitAndUndo(strResource, element, element.invalidatedResources, nls.localize({ key: 'cannotWorkspaceUndo', comment: ['{0} is a label for an operation. {1} is another message.'] }, \"Could not undo '{0}' across all files. {1}\", element.label, element.invalidatedResources.createMessage()));\n        }\n        // this must be the last past element in all the impacted resources!\n        const cannotUndoDueToResources = [];\n        for (const editStack of editStackSnapshot.editStacks) {\n            if (editStack.getClosestPastElement() !== element) {\n                cannotUndoDueToResources.push(editStack.resourceLabel);\n            }\n        }\n        if (cannotUndoDueToResources.length > 0) {\n            return this._tryToSplitAndUndo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceUndoDueToChanges', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, \"Could not undo '{0}' across all files because changes were made to {1}\", element.label, cannotUndoDueToResources.join(', ')));\n        }\n        const cannotLockDueToResources = [];\n        for (const editStack of editStackSnapshot.editStacks) {\n            if (editStack.locked) {\n                cannotLockDueToResources.push(editStack.resourceLabel);\n            }\n        }\n        if (cannotLockDueToResources.length > 0) {\n            return this._tryToSplitAndUndo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceUndoDueToInProgressUndoRedo', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, \"Could not undo '{0}' across all files because there is already an undo or redo operation running on {1}\", element.label, cannotLockDueToResources.join(', ')));\n        }\n        // check if new stack elements were added in the meantime...\n        if (!editStackSnapshot.isValid()) {\n            return this._tryToSplitAndUndo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceUndoDueToInMeantimeUndoRedo', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, \"Could not undo '{0}' across all files because an undo or redo operation occurred in the meantime\", element.label));\n        }\n        return null;\n    }\n    _workspaceUndo(strResource, element, undoConfirmed) {\n        const affectedEditStacks = this._getAffectedEditStacks(element);\n        const verificationError = this._checkWorkspaceUndo(strResource, element, affectedEditStacks, /*invalidated resources will be checked after the prepare call*/ false);\n        if (verificationError) {\n            return verificationError.returnValue;\n        }\n        return this._confirmAndExecuteWorkspaceUndo(strResource, element, affectedEditStacks, undoConfirmed);\n    }\n    _isPartOfUndoGroup(element) {\n        if (!element.groupId) {\n            return false;\n        }\n        // check that there is at least another element with the same groupId ready to be undone\n        for (const [, editStack] of this._editStacks) {\n            const pastElement = editStack.getClosestPastElement();\n            if (!pastElement) {\n                continue;\n            }\n            if (pastElement === element) {\n                const secondPastElement = editStack.getSecondClosestPastElement();\n                if (secondPastElement && secondPastElement.groupId === element.groupId) {\n                    // there is another element with the same group id in the same stack!\n                    return true;\n                }\n            }\n            if (pastElement.groupId === element.groupId) {\n                // there is another element with the same group id in another stack!\n                return true;\n            }\n        }\n        return false;\n    }\n    async _confirmAndExecuteWorkspaceUndo(strResource, element, editStackSnapshot, undoConfirmed) {\n        if (element.canSplit() && !this._isPartOfUndoGroup(element)) {\n            // this element can be split\n            let UndoChoice;\n            (function (UndoChoice) {\n                UndoChoice[UndoChoice[\"All\"] = 0] = \"All\";\n                UndoChoice[UndoChoice[\"This\"] = 1] = \"This\";\n                UndoChoice[UndoChoice[\"Cancel\"] = 2] = \"Cancel\";\n            })(UndoChoice || (UndoChoice = {}));\n            const { result } = await this._dialogService.prompt({\n                type: Severity.Info,\n                message: nls.localize('confirmWorkspace', \"Would you like to undo '{0}' across all files?\", element.label),\n                buttons: [\n                    {\n                        label: nls.localize({ key: 'ok', comment: ['{0} denotes a number that is > 1, && denotes a mnemonic'] }, \"&&Undo in {0} Files\", editStackSnapshot.editStacks.length),\n                        run: () => UndoChoice.All\n                    },\n                    {\n                        label: nls.localize({ key: 'nok', comment: ['&& denotes a mnemonic'] }, \"Undo this &&File\"),\n                        run: () => UndoChoice.This\n                    }\n                ],\n                cancelButton: {\n                    run: () => UndoChoice.Cancel\n                }\n            });\n            if (result === UndoChoice.Cancel) {\n                // choice: cancel\n                return;\n            }\n            if (result === UndoChoice.This) {\n                // choice: undo this file\n                this._splitPastWorkspaceElement(element, null);\n                return this._undo(strResource, 0, true);\n            }\n            // choice: undo in all files\n            // At this point, it is possible that the element has been made invalid in the meantime (due to the confirmation await)\n            const verificationError1 = this._checkWorkspaceUndo(strResource, element, editStackSnapshot, /*invalidated resources will be checked after the prepare call*/ false);\n            if (verificationError1) {\n                return verificationError1.returnValue;\n            }\n            undoConfirmed = true;\n        }\n        // prepare\n        let cleanup;\n        try {\n            cleanup = await this._invokeWorkspacePrepare(element);\n        }\n        catch (err) {\n            return this._onError(err, element);\n        }\n        // At this point, it is possible that the element has been made invalid in the meantime (due to the prepare await)\n        const verificationError2 = this._checkWorkspaceUndo(strResource, element, editStackSnapshot, /*now also check that there are no more invalidated resources*/ true);\n        if (verificationError2) {\n            cleanup.dispose();\n            return verificationError2.returnValue;\n        }\n        for (const editStack of editStackSnapshot.editStacks) {\n            editStack.moveBackward(element);\n        }\n        return this._safeInvokeWithLocks(element, () => element.actual.undo(), editStackSnapshot, cleanup, () => this._continueUndoInGroup(element.groupId, undoConfirmed));\n    }\n    _resourceUndo(editStack, element, undoConfirmed) {\n        if (!element.isValid) {\n            // invalid element => immediately flush edit stack!\n            editStack.flushAllElements();\n            return;\n        }\n        if (editStack.locked) {\n            const message = nls.localize({ key: 'cannotResourceUndoDueToInProgressUndoRedo', comment: ['{0} is a label for an operation.'] }, \"Could not undo '{0}' because there is already an undo or redo operation running.\", element.label);\n            this._notificationService.warn(message);\n            return;\n        }\n        return this._invokeResourcePrepare(element, (cleanup) => {\n            editStack.moveBackward(element);\n            return this._safeInvokeWithLocks(element, () => element.actual.undo(), new EditStackSnapshot([editStack]), cleanup, () => this._continueUndoInGroup(element.groupId, undoConfirmed));\n        });\n    }\n    _findClosestUndoElementInGroup(groupId) {\n        if (!groupId) {\n            return [null, null];\n        }\n        // find another element with the same groupId and with the highest groupOrder ready to be undone\n        let matchedElement = null;\n        let matchedStrResource = null;\n        for (const [strResource, editStack] of this._editStacks) {\n            const candidate = editStack.getClosestPastElement();\n            if (!candidate) {\n                continue;\n            }\n            if (candidate.groupId === groupId) {\n                if (!matchedElement || candidate.groupOrder > matchedElement.groupOrder) {\n                    matchedElement = candidate;\n                    matchedStrResource = strResource;\n                }\n            }\n        }\n        return [matchedElement, matchedStrResource];\n    }\n    _continueUndoInGroup(groupId, undoConfirmed) {\n        if (!groupId) {\n            return;\n        }\n        const [, matchedStrResource] = this._findClosestUndoElementInGroup(groupId);\n        if (matchedStrResource) {\n            return this._undo(matchedStrResource, 0, undoConfirmed);\n        }\n    }\n    undo(resourceOrSource) {\n        if (resourceOrSource instanceof UndoRedoSource) {\n            const [, matchedStrResource] = this._findClosestUndoElementWithSource(resourceOrSource.id);\n            return matchedStrResource ? this._undo(matchedStrResource, resourceOrSource.id, false) : undefined;\n        }\n        if (typeof resourceOrSource === 'string') {\n            return this._undo(resourceOrSource, 0, false);\n        }\n        return this._undo(this.getUriComparisonKey(resourceOrSource), 0, false);\n    }\n    _undo(strResource, sourceId = 0, undoConfirmed) {\n        if (!this._editStacks.has(strResource)) {\n            return;\n        }\n        const editStack = this._editStacks.get(strResource);\n        const element = editStack.getClosestPastElement();\n        if (!element) {\n            return;\n        }\n        if (element.groupId) {\n            // this element is a part of a group, we need to make sure undoing in a group is in order\n            const [matchedElement, matchedStrResource] = this._findClosestUndoElementInGroup(element.groupId);\n            if (element !== matchedElement && matchedStrResource) {\n                // there is an element in the same group that should be undone before this one\n                return this._undo(matchedStrResource, sourceId, undoConfirmed);\n            }\n        }\n        const shouldPromptForConfirmation = (element.sourceId !== sourceId || element.confirmBeforeUndo);\n        if (shouldPromptForConfirmation && !undoConfirmed) {\n            // Hit a different source or the element asks for prompt before undo, prompt for confirmation\n            return this._confirmAndContinueUndo(strResource, sourceId, element);\n        }\n        try {\n            if (element.type === 1 /* UndoRedoElementType.Workspace */) {\n                return this._workspaceUndo(strResource, element, undoConfirmed);\n            }\n            else {\n                return this._resourceUndo(editStack, element, undoConfirmed);\n            }\n        }\n        finally {\n            if (DEBUG) {\n                this._print('undo');\n            }\n        }\n    }\n    async _confirmAndContinueUndo(strResource, sourceId, element) {\n        const result = await this._dialogService.confirm({\n            message: nls.localize('confirmDifferentSource', \"Would you like to undo '{0}'?\", element.label),\n            primaryButton: nls.localize({ key: 'confirmDifferentSource.yes', comment: ['&& denotes a mnemonic'] }, \"&&Yes\"),\n            cancelButton: nls.localize('confirmDifferentSource.no', \"No\")\n        });\n        if (!result.confirmed) {\n            return;\n        }\n        return this._undo(strResource, sourceId, true);\n    }\n    _findClosestRedoElementWithSource(sourceId) {\n        if (!sourceId) {\n            return [null, null];\n        }\n        // find an element with sourceId and with the lowest sourceOrder ready to be redone\n        let matchedElement = null;\n        let matchedStrResource = null;\n        for (const [strResource, editStack] of this._editStacks) {\n            const candidate = editStack.getClosestFutureElement();\n            if (!candidate) {\n                continue;\n            }\n            if (candidate.sourceId === sourceId) {\n                if (!matchedElement || candidate.sourceOrder < matchedElement.sourceOrder) {\n                    matchedElement = candidate;\n                    matchedStrResource = strResource;\n                }\n            }\n        }\n        return [matchedElement, matchedStrResource];\n    }\n    canRedo(resourceOrSource) {\n        if (resourceOrSource instanceof UndoRedoSource) {\n            const [, matchedStrResource] = this._findClosestRedoElementWithSource(resourceOrSource.id);\n            return matchedStrResource ? true : false;\n        }\n        const strResource = this.getUriComparisonKey(resourceOrSource);\n        if (this._editStacks.has(strResource)) {\n            const editStack = this._editStacks.get(strResource);\n            return editStack.hasFutureElements();\n        }\n        return false;\n    }\n    _tryToSplitAndRedo(strResource, element, ignoreResources, message) {\n        if (element.canSplit()) {\n            this._splitFutureWorkspaceElement(element, ignoreResources);\n            this._notificationService.warn(message);\n            return new WorkspaceVerificationError(this._redo(strResource));\n        }\n        else {\n            // Cannot safely split this workspace element => flush all undo/redo stacks\n            for (const strResource of element.strResources) {\n                this.removeElements(strResource);\n            }\n            this._notificationService.warn(message);\n            return new WorkspaceVerificationError();\n        }\n    }\n    _checkWorkspaceRedo(strResource, element, editStackSnapshot, checkInvalidatedResources) {\n        if (element.removedResources) {\n            return this._tryToSplitAndRedo(strResource, element, element.removedResources, nls.localize({ key: 'cannotWorkspaceRedo', comment: ['{0} is a label for an operation. {1} is another message.'] }, \"Could not redo '{0}' across all files. {1}\", element.label, element.removedResources.createMessage()));\n        }\n        if (checkInvalidatedResources && element.invalidatedResources) {\n            return this._tryToSplitAndRedo(strResource, element, element.invalidatedResources, nls.localize({ key: 'cannotWorkspaceRedo', comment: ['{0} is a label for an operation. {1} is another message.'] }, \"Could not redo '{0}' across all files. {1}\", element.label, element.invalidatedResources.createMessage()));\n        }\n        // this must be the last future element in all the impacted resources!\n        const cannotRedoDueToResources = [];\n        for (const editStack of editStackSnapshot.editStacks) {\n            if (editStack.getClosestFutureElement() !== element) {\n                cannotRedoDueToResources.push(editStack.resourceLabel);\n            }\n        }\n        if (cannotRedoDueToResources.length > 0) {\n            return this._tryToSplitAndRedo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceRedoDueToChanges', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, \"Could not redo '{0}' across all files because changes were made to {1}\", element.label, cannotRedoDueToResources.join(', ')));\n        }\n        const cannotLockDueToResources = [];\n        for (const editStack of editStackSnapshot.editStacks) {\n            if (editStack.locked) {\n                cannotLockDueToResources.push(editStack.resourceLabel);\n            }\n        }\n        if (cannotLockDueToResources.length > 0) {\n            return this._tryToSplitAndRedo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceRedoDueToInProgressUndoRedo', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, \"Could not redo '{0}' across all files because there is already an undo or redo operation running on {1}\", element.label, cannotLockDueToResources.join(', ')));\n        }\n        // check if new stack elements were added in the meantime...\n        if (!editStackSnapshot.isValid()) {\n            return this._tryToSplitAndRedo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceRedoDueToInMeantimeUndoRedo', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, \"Could not redo '{0}' across all files because an undo or redo operation occurred in the meantime\", element.label));\n        }\n        return null;\n    }\n    _workspaceRedo(strResource, element) {\n        const affectedEditStacks = this._getAffectedEditStacks(element);\n        const verificationError = this._checkWorkspaceRedo(strResource, element, affectedEditStacks, /*invalidated resources will be checked after the prepare call*/ false);\n        if (verificationError) {\n            return verificationError.returnValue;\n        }\n        return this._executeWorkspaceRedo(strResource, element, affectedEditStacks);\n    }\n    async _executeWorkspaceRedo(strResource, element, editStackSnapshot) {\n        // prepare\n        let cleanup;\n        try {\n            cleanup = await this._invokeWorkspacePrepare(element);\n        }\n        catch (err) {\n            return this._onError(err, element);\n        }\n        // At this point, it is possible that the element has been made invalid in the meantime (due to the prepare await)\n        const verificationError = this._checkWorkspaceRedo(strResource, element, editStackSnapshot, /*now also check that there are no more invalidated resources*/ true);\n        if (verificationError) {\n            cleanup.dispose();\n            return verificationError.returnValue;\n        }\n        for (const editStack of editStackSnapshot.editStacks) {\n            editStack.moveForward(element);\n        }\n        return this._safeInvokeWithLocks(element, () => element.actual.redo(), editStackSnapshot, cleanup, () => this._continueRedoInGroup(element.groupId));\n    }\n    _resourceRedo(editStack, element) {\n        if (!element.isValid) {\n            // invalid element => immediately flush edit stack!\n            editStack.flushAllElements();\n            return;\n        }\n        if (editStack.locked) {\n            const message = nls.localize({ key: 'cannotResourceRedoDueToInProgressUndoRedo', comment: ['{0} is a label for an operation.'] }, \"Could not redo '{0}' because there is already an undo or redo operation running.\", element.label);\n            this._notificationService.warn(message);\n            return;\n        }\n        return this._invokeResourcePrepare(element, (cleanup) => {\n            editStack.moveForward(element);\n            return this._safeInvokeWithLocks(element, () => element.actual.redo(), new EditStackSnapshot([editStack]), cleanup, () => this._continueRedoInGroup(element.groupId));\n        });\n    }\n    _findClosestRedoElementInGroup(groupId) {\n        if (!groupId) {\n            return [null, null];\n        }\n        // find another element with the same groupId and with the lowest groupOrder ready to be redone\n        let matchedElement = null;\n        let matchedStrResource = null;\n        for (const [strResource, editStack] of this._editStacks) {\n            const candidate = editStack.getClosestFutureElement();\n            if (!candidate) {\n                continue;\n            }\n            if (candidate.groupId === groupId) {\n                if (!matchedElement || candidate.groupOrder < matchedElement.groupOrder) {\n                    matchedElement = candidate;\n                    matchedStrResource = strResource;\n                }\n            }\n        }\n        return [matchedElement, matchedStrResource];\n    }\n    _continueRedoInGroup(groupId) {\n        if (!groupId) {\n            return;\n        }\n        const [, matchedStrResource] = this._findClosestRedoElementInGroup(groupId);\n        if (matchedStrResource) {\n            return this._redo(matchedStrResource);\n        }\n    }\n    redo(resourceOrSource) {\n        if (resourceOrSource instanceof UndoRedoSource) {\n            const [, matchedStrResource] = this._findClosestRedoElementWithSource(resourceOrSource.id);\n            return matchedStrResource ? this._redo(matchedStrResource) : undefined;\n        }\n        if (typeof resourceOrSource === 'string') {\n            return this._redo(resourceOrSource);\n        }\n        return this._redo(this.getUriComparisonKey(resourceOrSource));\n    }\n    _redo(strResource) {\n        if (!this._editStacks.has(strResource)) {\n            return;\n        }\n        const editStack = this._editStacks.get(strResource);\n        const element = editStack.getClosestFutureElement();\n        if (!element) {\n            return;\n        }\n        if (element.groupId) {\n            // this element is a part of a group, we need to make sure redoing in a group is in order\n            const [matchedElement, matchedStrResource] = this._findClosestRedoElementInGroup(element.groupId);\n            if (element !== matchedElement && matchedStrResource) {\n                // there is an element in the same group that should be redone before this one\n                return this._redo(matchedStrResource);\n            }\n        }\n        try {\n            if (element.type === 1 /* UndoRedoElementType.Workspace */) {\n                return this._workspaceRedo(strResource, element);\n            }\n            else {\n                return this._resourceRedo(editStack, element);\n            }\n        }\n        finally {\n            if (DEBUG) {\n                this._print('redo');\n            }\n        }\n    }\n};\nUndoRedoService = __decorate([\n    __param(0, IDialogService),\n    __param(1, INotificationService)\n], UndoRedoService);\nexport { UndoRedoService };\nclass WorkspaceVerificationError {\n    constructor(returnValue) {\n        this.returnValue = returnValue;\n    }\n}\nregisterSingleton(IUndoRedoService, UndoRedoService, 1 /* InstantiationType.Delayed */);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}