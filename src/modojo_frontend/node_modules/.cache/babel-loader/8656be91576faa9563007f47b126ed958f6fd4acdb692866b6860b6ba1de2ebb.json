{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { strictEquals } from '../equals.js';\nimport { DebugNameData, getFunctionName } from './debugName.js';\nimport { getLogger } from './logging.js';\nlet _recomputeInitiallyAndOnChange;\nexport function _setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange) {\n  _recomputeInitiallyAndOnChange = recomputeInitiallyAndOnChange;\n}\nlet _keepObserved;\nexport function _setKeepObserved(keepObserved) {\n  _keepObserved = keepObserved;\n}\nlet _derived;\n/**\n * @internal\n * This is to allow splitting files.\n*/\nexport function _setDerivedOpts(derived) {\n  _derived = derived;\n}\nexport class ConvenientObservable {\n  get TChange() {\n    return null;\n  }\n  reportChanges() {\n    this.get();\n  }\n  /** @sealed */\n  read(reader) {\n    if (reader) {\n      return reader.readObservable(this);\n    } else {\n      return this.get();\n    }\n  }\n  map(fnOrOwner, fnOrUndefined) {\n    const owner = fnOrUndefined === undefined ? undefined : fnOrOwner;\n    const fn = fnOrUndefined === undefined ? fnOrOwner : fnOrUndefined;\n    return _derived({\n      owner,\n      debugName: () => {\n        const name = getFunctionName(fn);\n        if (name !== undefined) {\n          return name;\n        }\n        // regexp to match `x => x.y` or `x => x?.y` where x and y can be arbitrary identifiers (uses backref):\n        const regexp = /^\\s*\\(?\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*\\)?\\s*=>\\s*\\1(?:\\??)\\.([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*$/;\n        const match = regexp.exec(fn.toString());\n        if (match) {\n          return `${this.debugName}.${match[2]}`;\n        }\n        if (!owner) {\n          return `${this.debugName} (mapped)`;\n        }\n        return undefined;\n      },\n      debugReferenceFn: fn\n    }, reader => fn(this.read(reader), reader));\n  }\n  recomputeInitiallyAndOnChange(store, handleValue) {\n    store.add(_recomputeInitiallyAndOnChange(this, handleValue));\n    return this;\n  }\n}\nexport class BaseObservable extends ConvenientObservable {\n  constructor() {\n    super(...arguments);\n    this.observers = new Set();\n  }\n  addObserver(observer) {\n    const len = this.observers.size;\n    this.observers.add(observer);\n    if (len === 0) {\n      this.onFirstObserverAdded();\n    }\n  }\n  removeObserver(observer) {\n    const deleted = this.observers.delete(observer);\n    if (deleted && this.observers.size === 0) {\n      this.onLastObserverRemoved();\n    }\n  }\n  onFirstObserverAdded() {}\n  onLastObserverRemoved() {}\n}\n/**\n * Starts a transaction in which many observables can be changed at once.\n * {@link fn} should start with a JS Doc using `@description` to give the transaction a debug name.\n * Reaction run on demand or when the transaction ends.\n */\nexport function transaction(fn, getDebugName) {\n  const tx = new TransactionImpl(fn, getDebugName);\n  try {\n    fn(tx);\n  } finally {\n    tx.finish();\n  }\n}\nlet _globalTransaction = undefined;\nexport function globalTransaction(fn) {\n  if (_globalTransaction) {\n    fn(_globalTransaction);\n  } else {\n    const tx = new TransactionImpl(fn, undefined);\n    _globalTransaction = tx;\n    try {\n      fn(tx);\n    } finally {\n      tx.finish(); // During finish, more actions might be added to the transaction.\n      // Which is why we only clear the global transaction after finish.\n      _globalTransaction = undefined;\n    }\n  }\n}\nexport async function asyncTransaction(fn, getDebugName) {\n  const tx = new TransactionImpl(fn, getDebugName);\n  try {\n    await fn(tx);\n  } finally {\n    tx.finish();\n  }\n}\n/**\n * Allows to chain transactions.\n */\nexport function subtransaction(tx, fn, getDebugName) {\n  if (!tx) {\n    transaction(fn, getDebugName);\n  } else {\n    fn(tx);\n  }\n}\nexport class TransactionImpl {\n  constructor(_fn, _getDebugName) {\n    var _a;\n    this._fn = _fn;\n    this._getDebugName = _getDebugName;\n    this.updatingObservers = [];\n    (_a = getLogger()) === null || _a === void 0 ? void 0 : _a.handleBeginTransaction(this);\n  }\n  getDebugName() {\n    if (this._getDebugName) {\n      return this._getDebugName();\n    }\n    return getFunctionName(this._fn);\n  }\n  updateObserver(observer, observable) {\n    // When this gets called while finish is active, they will still get considered\n    this.updatingObservers.push({\n      observer,\n      observable\n    });\n    observer.beginUpdate(observable);\n  }\n  finish() {\n    var _a;\n    const updatingObservers = this.updatingObservers;\n    for (let i = 0; i < updatingObservers.length; i++) {\n      const {\n        observer,\n        observable\n      } = updatingObservers[i];\n      observer.endUpdate(observable);\n    }\n    // Prevent anyone from updating observers from now on.\n    this.updatingObservers = null;\n    (_a = getLogger()) === null || _a === void 0 ? void 0 : _a.handleEndTransaction();\n  }\n}\nexport function observableValue(nameOrOwner, initialValue) {\n  let debugNameData;\n  if (typeof nameOrOwner === 'string') {\n    debugNameData = new DebugNameData(undefined, nameOrOwner, undefined);\n  } else {\n    debugNameData = new DebugNameData(nameOrOwner, undefined, undefined);\n  }\n  return new ObservableValue(debugNameData, initialValue, strictEquals);\n}\nexport function observableValueOpts(options, initialValue) {\n  var _a;\n  return new ObservableValue(new DebugNameData(options.owner, options.debugName, undefined), initialValue, (_a = options.equalsFn) !== null && _a !== void 0 ? _a : strictEquals);\n}\nexport class ObservableValue extends BaseObservable {\n  get debugName() {\n    var _a;\n    return (_a = this._debugNameData.getDebugName(this)) !== null && _a !== void 0 ? _a : 'ObservableValue';\n  }\n  constructor(_debugNameData, initialValue, _equalityComparator) {\n    super();\n    this._debugNameData = _debugNameData;\n    this._equalityComparator = _equalityComparator;\n    this._value = initialValue;\n  }\n  get() {\n    return this._value;\n  }\n  set(value, tx, change) {\n    var _a;\n    if (change === undefined && this._equalityComparator(this._value, value)) {\n      return;\n    }\n    let _tx;\n    if (!tx) {\n      tx = _tx = new TransactionImpl(() => {}, () => `Setting ${this.debugName}`);\n    }\n    try {\n      const oldValue = this._value;\n      this._setValue(value);\n      (_a = getLogger()) === null || _a === void 0 ? void 0 : _a.handleObservableChanged(this, {\n        oldValue,\n        newValue: value,\n        change,\n        didChange: true,\n        hadValue: true\n      });\n      for (const observer of this.observers) {\n        tx.updateObserver(observer, this);\n        observer.handleChange(this, change);\n      }\n    } finally {\n      if (_tx) {\n        _tx.finish();\n      }\n    }\n  }\n  toString() {\n    return `${this.debugName}: ${this._value}`;\n  }\n  _setValue(newValue) {\n    this._value = newValue;\n  }\n}\n/**\n * A disposable observable. When disposed, its value is also disposed.\n * When a new value is set, the previous value is disposed.\n */\nexport function disposableObservableValue(nameOrOwner, initialValue) {\n  let debugNameData;\n  if (typeof nameOrOwner === 'string') {\n    debugNameData = new DebugNameData(undefined, nameOrOwner, undefined);\n  } else {\n    debugNameData = new DebugNameData(nameOrOwner, undefined, undefined);\n  }\n  return new DisposableObservableValue(debugNameData, initialValue, strictEquals);\n}\nexport class DisposableObservableValue extends ObservableValue {\n  _setValue(newValue) {\n    if (this._value === newValue) {\n      return;\n    }\n    if (this._value) {\n      this._value.dispose();\n    }\n    this._value = newValue;\n  }\n  dispose() {\n    var _a;\n    (_a = this._value) === null || _a === void 0 ? void 0 : _a.dispose();\n  }\n}","map":{"version":3,"names":["strictEquals","DebugNameData","getFunctionName","getLogger","_recomputeInitiallyAndOnChange","_setRecomputeInitiallyAndOnChange","recomputeInitiallyAndOnChange","_keepObserved","_setKeepObserved","keepObserved","_derived","_setDerivedOpts","derived","ConvenientObservable","TChange","reportChanges","get","read","reader","readObservable","map","fnOrOwner","fnOrUndefined","owner","undefined","fn","debugName","name","regexp","match","exec","toString","debugReferenceFn","store","handleValue","add","BaseObservable","constructor","arguments","observers","Set","addObserver","observer","len","size","onFirstObserverAdded","removeObserver","deleted","delete","onLastObserverRemoved","transaction","getDebugName","tx","TransactionImpl","finish","_globalTransaction","globalTransaction","asyncTransaction","subtransaction","_fn","_getDebugName","_a","updatingObservers","handleBeginTransaction","updateObserver","observable","push","beginUpdate","i","length","endUpdate","handleEndTransaction","observableValue","nameOrOwner","initialValue","debugNameData","ObservableValue","observableValueOpts","options","equalsFn","_debugNameData","_equalityComparator","_value","set","value","change","_tx","oldValue","_setValue","handleObservableChanged","newValue","didChange","hadValue","handleChange","disposableObservableValue","DisposableObservableValue","dispose"],"sources":["/home/arslan/modojo/node_modules/monaco-editor/esm/vs/base/common/observableInternal/base.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { strictEquals } from '../equals.js';\nimport { DebugNameData, getFunctionName } from './debugName.js';\nimport { getLogger } from './logging.js';\nlet _recomputeInitiallyAndOnChange;\nexport function _setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange) {\n    _recomputeInitiallyAndOnChange = recomputeInitiallyAndOnChange;\n}\nlet _keepObserved;\nexport function _setKeepObserved(keepObserved) {\n    _keepObserved = keepObserved;\n}\nlet _derived;\n/**\n * @internal\n * This is to allow splitting files.\n*/\nexport function _setDerivedOpts(derived) {\n    _derived = derived;\n}\nexport class ConvenientObservable {\n    get TChange() { return null; }\n    reportChanges() {\n        this.get();\n    }\n    /** @sealed */\n    read(reader) {\n        if (reader) {\n            return reader.readObservable(this);\n        }\n        else {\n            return this.get();\n        }\n    }\n    map(fnOrOwner, fnOrUndefined) {\n        const owner = fnOrUndefined === undefined ? undefined : fnOrOwner;\n        const fn = fnOrUndefined === undefined ? fnOrOwner : fnOrUndefined;\n        return _derived({\n            owner,\n            debugName: () => {\n                const name = getFunctionName(fn);\n                if (name !== undefined) {\n                    return name;\n                }\n                // regexp to match `x => x.y` or `x => x?.y` where x and y can be arbitrary identifiers (uses backref):\n                const regexp = /^\\s*\\(?\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*\\)?\\s*=>\\s*\\1(?:\\??)\\.([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*$/;\n                const match = regexp.exec(fn.toString());\n                if (match) {\n                    return `${this.debugName}.${match[2]}`;\n                }\n                if (!owner) {\n                    return `${this.debugName} (mapped)`;\n                }\n                return undefined;\n            },\n            debugReferenceFn: fn,\n        }, (reader) => fn(this.read(reader), reader));\n    }\n    recomputeInitiallyAndOnChange(store, handleValue) {\n        store.add(_recomputeInitiallyAndOnChange(this, handleValue));\n        return this;\n    }\n}\nexport class BaseObservable extends ConvenientObservable {\n    constructor() {\n        super(...arguments);\n        this.observers = new Set();\n    }\n    addObserver(observer) {\n        const len = this.observers.size;\n        this.observers.add(observer);\n        if (len === 0) {\n            this.onFirstObserverAdded();\n        }\n    }\n    removeObserver(observer) {\n        const deleted = this.observers.delete(observer);\n        if (deleted && this.observers.size === 0) {\n            this.onLastObserverRemoved();\n        }\n    }\n    onFirstObserverAdded() { }\n    onLastObserverRemoved() { }\n}\n/**\n * Starts a transaction in which many observables can be changed at once.\n * {@link fn} should start with a JS Doc using `@description` to give the transaction a debug name.\n * Reaction run on demand or when the transaction ends.\n */\nexport function transaction(fn, getDebugName) {\n    const tx = new TransactionImpl(fn, getDebugName);\n    try {\n        fn(tx);\n    }\n    finally {\n        tx.finish();\n    }\n}\nlet _globalTransaction = undefined;\nexport function globalTransaction(fn) {\n    if (_globalTransaction) {\n        fn(_globalTransaction);\n    }\n    else {\n        const tx = new TransactionImpl(fn, undefined);\n        _globalTransaction = tx;\n        try {\n            fn(tx);\n        }\n        finally {\n            tx.finish(); // During finish, more actions might be added to the transaction.\n            // Which is why we only clear the global transaction after finish.\n            _globalTransaction = undefined;\n        }\n    }\n}\nexport async function asyncTransaction(fn, getDebugName) {\n    const tx = new TransactionImpl(fn, getDebugName);\n    try {\n        await fn(tx);\n    }\n    finally {\n        tx.finish();\n    }\n}\n/**\n * Allows to chain transactions.\n */\nexport function subtransaction(tx, fn, getDebugName) {\n    if (!tx) {\n        transaction(fn, getDebugName);\n    }\n    else {\n        fn(tx);\n    }\n}\nexport class TransactionImpl {\n    constructor(_fn, _getDebugName) {\n        var _a;\n        this._fn = _fn;\n        this._getDebugName = _getDebugName;\n        this.updatingObservers = [];\n        (_a = getLogger()) === null || _a === void 0 ? void 0 : _a.handleBeginTransaction(this);\n    }\n    getDebugName() {\n        if (this._getDebugName) {\n            return this._getDebugName();\n        }\n        return getFunctionName(this._fn);\n    }\n    updateObserver(observer, observable) {\n        // When this gets called while finish is active, they will still get considered\n        this.updatingObservers.push({ observer, observable });\n        observer.beginUpdate(observable);\n    }\n    finish() {\n        var _a;\n        const updatingObservers = this.updatingObservers;\n        for (let i = 0; i < updatingObservers.length; i++) {\n            const { observer, observable } = updatingObservers[i];\n            observer.endUpdate(observable);\n        }\n        // Prevent anyone from updating observers from now on.\n        this.updatingObservers = null;\n        (_a = getLogger()) === null || _a === void 0 ? void 0 : _a.handleEndTransaction();\n    }\n}\nexport function observableValue(nameOrOwner, initialValue) {\n    let debugNameData;\n    if (typeof nameOrOwner === 'string') {\n        debugNameData = new DebugNameData(undefined, nameOrOwner, undefined);\n    }\n    else {\n        debugNameData = new DebugNameData(nameOrOwner, undefined, undefined);\n    }\n    return new ObservableValue(debugNameData, initialValue, strictEquals);\n}\nexport function observableValueOpts(options, initialValue) {\n    var _a;\n    return new ObservableValue(new DebugNameData(options.owner, options.debugName, undefined), initialValue, (_a = options.equalsFn) !== null && _a !== void 0 ? _a : strictEquals);\n}\nexport class ObservableValue extends BaseObservable {\n    get debugName() {\n        var _a;\n        return (_a = this._debugNameData.getDebugName(this)) !== null && _a !== void 0 ? _a : 'ObservableValue';\n    }\n    constructor(_debugNameData, initialValue, _equalityComparator) {\n        super();\n        this._debugNameData = _debugNameData;\n        this._equalityComparator = _equalityComparator;\n        this._value = initialValue;\n    }\n    get() {\n        return this._value;\n    }\n    set(value, tx, change) {\n        var _a;\n        if (change === undefined && this._equalityComparator(this._value, value)) {\n            return;\n        }\n        let _tx;\n        if (!tx) {\n            tx = _tx = new TransactionImpl(() => { }, () => `Setting ${this.debugName}`);\n        }\n        try {\n            const oldValue = this._value;\n            this._setValue(value);\n            (_a = getLogger()) === null || _a === void 0 ? void 0 : _a.handleObservableChanged(this, { oldValue, newValue: value, change, didChange: true, hadValue: true });\n            for (const observer of this.observers) {\n                tx.updateObserver(observer, this);\n                observer.handleChange(this, change);\n            }\n        }\n        finally {\n            if (_tx) {\n                _tx.finish();\n            }\n        }\n    }\n    toString() {\n        return `${this.debugName}: ${this._value}`;\n    }\n    _setValue(newValue) {\n        this._value = newValue;\n    }\n}\n/**\n * A disposable observable. When disposed, its value is also disposed.\n * When a new value is set, the previous value is disposed.\n */\nexport function disposableObservableValue(nameOrOwner, initialValue) {\n    let debugNameData;\n    if (typeof nameOrOwner === 'string') {\n        debugNameData = new DebugNameData(undefined, nameOrOwner, undefined);\n    }\n    else {\n        debugNameData = new DebugNameData(nameOrOwner, undefined, undefined);\n    }\n    return new DisposableObservableValue(debugNameData, initialValue, strictEquals);\n}\nexport class DisposableObservableValue extends ObservableValue {\n    _setValue(newValue) {\n        if (this._value === newValue) {\n            return;\n        }\n        if (this._value) {\n            this._value.dispose();\n        }\n        this._value = newValue;\n    }\n    dispose() {\n        var _a;\n        (_a = this._value) === null || _a === void 0 ? void 0 : _a.dispose();\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}