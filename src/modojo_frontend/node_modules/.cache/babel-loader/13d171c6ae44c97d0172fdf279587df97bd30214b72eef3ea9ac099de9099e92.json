{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\nvar TextModel_1;\nimport { ArrayQueue, pushMany } from '../../../base/common/arrays.js';\nimport { Color } from '../../../base/common/color.js';\nimport { BugIndicatingError, illegalArgument, onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, MutableDisposable, combinedDisposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { normalizeIndentation } from '../core/indentation.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../core/textModelDefaults.js';\nimport { ILanguageService } from '../languages/language.js';\nimport { ILanguageConfigurationService } from '../languages/languageConfigurationRegistry.js';\nimport * as model from '../model.js';\nimport { BracketPairsTextModelPart } from './bracketPairsTextModelPart/bracketPairsImpl.js';\nimport { ColorizedBracketPairsDecorationProvider } from './bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js';\nimport { EditStack } from './editStack.js';\nimport { GuidesTextModelPart } from './guidesTextModelPart.js';\nimport { guessIndentation } from './indentationGuesser.js';\nimport { IntervalNode, IntervalTree, recomputeMaxEnd } from './intervalTree.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer/pieceTreeTextBuffer.js';\nimport { PieceTreeTextBufferBuilder } from './pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js';\nimport { SearchParams, TextModelSearch } from './textModelSearch.js';\nimport { TokenizationTextModelPart } from './tokenizationTextModelPart.js';\nimport { InternalModelContentChangeEvent, LineInjectedText, ModelInjectedTextChangedEvent, ModelRawContentChangedEvent, ModelRawEOLChanged, ModelRawFlush, ModelRawLineChanged, ModelRawLinesDeleted, ModelRawLinesInserted } from '../textModelEvents.js';\nimport { IUndoRedoService } from '../../../platform/undoRedo/common/undoRedo.js';\nexport function createTextBufferFactory(text) {\n  const builder = new PieceTreeTextBufferBuilder();\n  builder.acceptChunk(text);\n  return builder.finish();\n}\nexport function createTextBufferFactoryFromSnapshot(snapshot) {\n  const builder = new PieceTreeTextBufferBuilder();\n  let chunk;\n  while (typeof (chunk = snapshot.read()) === 'string') {\n    builder.acceptChunk(chunk);\n  }\n  return builder.finish();\n}\nexport function createTextBuffer(value, defaultEOL) {\n  let factory;\n  if (typeof value === 'string') {\n    factory = createTextBufferFactory(value);\n  } else if (model.isITextSnapshot(value)) {\n    factory = createTextBufferFactoryFromSnapshot(value);\n  } else {\n    factory = value;\n  }\n  return factory.create(defaultEOL);\n}\nlet MODEL_ID = 0;\nconst LIMIT_FIND_COUNT = 999;\nconst LONG_LINE_BOUNDARY = 10000;\nclass TextModelSnapshot {\n  constructor(source) {\n    this._source = source;\n    this._eos = false;\n  }\n  read() {\n    if (this._eos) {\n      return null;\n    }\n    const result = [];\n    let resultCnt = 0;\n    let resultLength = 0;\n    do {\n      const tmp = this._source.read();\n      if (tmp === null) {\n        // end-of-stream\n        this._eos = true;\n        if (resultCnt === 0) {\n          return null;\n        } else {\n          return result.join('');\n        }\n      }\n      if (tmp.length > 0) {\n        result[resultCnt++] = tmp;\n        resultLength += tmp.length;\n      }\n      if (resultLength >= 64 * 1024) {\n        return result.join('');\n      }\n    } while (true);\n  }\n}\nconst invalidFunc = () => {\n  throw new Error(`Invalid change accessor`);\n};\nlet TextModel = TextModel_1 = class TextModel extends Disposable {\n  static resolveOptions(textBuffer, options) {\n    if (options.detectIndentation) {\n      const guessedIndentation = guessIndentation(textBuffer, options.tabSize, options.insertSpaces);\n      return new model.TextModelResolvedOptions({\n        tabSize: guessedIndentation.tabSize,\n        indentSize: 'tabSize',\n        // TODO@Alex: guess indentSize independent of tabSize\n        insertSpaces: guessedIndentation.insertSpaces,\n        trimAutoWhitespace: options.trimAutoWhitespace,\n        defaultEOL: options.defaultEOL,\n        bracketPairColorizationOptions: options.bracketPairColorizationOptions\n      });\n    }\n    return new model.TextModelResolvedOptions(options);\n  }\n  get onDidChangeLanguage() {\n    return this._tokenizationTextModelPart.onDidChangeLanguage;\n  }\n  get onDidChangeLanguageConfiguration() {\n    return this._tokenizationTextModelPart.onDidChangeLanguageConfiguration;\n  }\n  get onDidChangeTokens() {\n    return this._tokenizationTextModelPart.onDidChangeTokens;\n  }\n  onDidChangeContent(listener) {\n    return this._eventEmitter.slowEvent(e => listener(e.contentChangedEvent));\n  }\n  onDidChangeContentOrInjectedText(listener) {\n    return combinedDisposable(this._eventEmitter.fastEvent(e => listener(e)), this._onDidChangeInjectedText.event(e => listener(e)));\n  }\n  _isDisposing() {\n    return this.__isDisposing;\n  }\n  get tokenization() {\n    return this._tokenizationTextModelPart;\n  }\n  get bracketPairs() {\n    return this._bracketPairs;\n  }\n  get guides() {\n    return this._guidesTextModelPart;\n  }\n  constructor(source, languageIdOrSelection, creationOptions) {\n    let associatedResource = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    let _undoRedoService = arguments.length > 4 ? arguments[4] : undefined;\n    let _languageService = arguments.length > 5 ? arguments[5] : undefined;\n    let _languageConfigurationService = arguments.length > 6 ? arguments[6] : undefined;\n    super();\n    this._undoRedoService = _undoRedoService;\n    this._languageService = _languageService;\n    this._languageConfigurationService = _languageConfigurationService;\n    //#region Events\n    this._onWillDispose = this._register(new Emitter());\n    this.onWillDispose = this._onWillDispose.event;\n    this._onDidChangeDecorations = this._register(new DidChangeDecorationsEmitter(affectedInjectedTextLines => this.handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines)));\n    this.onDidChangeDecorations = this._onDidChangeDecorations.event;\n    this._onDidChangeOptions = this._register(new Emitter());\n    this.onDidChangeOptions = this._onDidChangeOptions.event;\n    this._onDidChangeAttached = this._register(new Emitter());\n    this.onDidChangeAttached = this._onDidChangeAttached.event;\n    this._onDidChangeInjectedText = this._register(new Emitter());\n    this._eventEmitter = this._register(new DidChangeContentEmitter());\n    this._languageSelectionListener = this._register(new MutableDisposable());\n    this._deltaDecorationCallCnt = 0;\n    this._attachedViews = new AttachedViews();\n    // Generate a new unique model id\n    MODEL_ID++;\n    this.id = '$model' + MODEL_ID;\n    this.isForSimpleWidget = creationOptions.isForSimpleWidget;\n    if (typeof associatedResource === 'undefined' || associatedResource === null) {\n      this._associatedResource = URI.parse('inmemory://model/' + MODEL_ID);\n    } else {\n      this._associatedResource = associatedResource;\n    }\n    this._attachedEditorCount = 0;\n    const {\n      textBuffer,\n      disposable\n    } = createTextBuffer(source, creationOptions.defaultEOL);\n    this._buffer = textBuffer;\n    this._bufferDisposable = disposable;\n    this._options = TextModel_1.resolveOptions(this._buffer, creationOptions);\n    const languageId = typeof languageIdOrSelection === 'string' ? languageIdOrSelection : languageIdOrSelection.languageId;\n    if (typeof languageIdOrSelection !== 'string') {\n      this._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId));\n    }\n    this._bracketPairs = this._register(new BracketPairsTextModelPart(this, this._languageConfigurationService));\n    this._guidesTextModelPart = this._register(new GuidesTextModelPart(this, this._languageConfigurationService));\n    this._decorationProvider = this._register(new ColorizedBracketPairsDecorationProvider(this));\n    this._tokenizationTextModelPart = new TokenizationTextModelPart(this._languageService, this._languageConfigurationService, this, this._bracketPairs, languageId, this._attachedViews);\n    const bufferLineCount = this._buffer.getLineCount();\n    const bufferTextLength = this._buffer.getValueLengthInRange(new Range(1, 1, bufferLineCount, this._buffer.getLineLength(bufferLineCount) + 1), 0 /* model.EndOfLinePreference.TextDefined */);\n    // !!! Make a decision in the ctor and permanently respect this decision !!!\n    // If a model is too large at construction time, it will never get tokenized,\n    // under no circumstances.\n    if (creationOptions.largeFileOptimizations) {\n      this._isTooLargeForTokenization = bufferTextLength > TextModel_1.LARGE_FILE_SIZE_THRESHOLD || bufferLineCount > TextModel_1.LARGE_FILE_LINE_COUNT_THRESHOLD;\n      this._isTooLargeForHeapOperation = bufferTextLength > TextModel_1.LARGE_FILE_HEAP_OPERATION_THRESHOLD;\n    } else {\n      this._isTooLargeForTokenization = false;\n      this._isTooLargeForHeapOperation = false;\n    }\n    this._isTooLargeForSyncing = bufferTextLength > TextModel_1._MODEL_SYNC_LIMIT;\n    this._versionId = 1;\n    this._alternativeVersionId = 1;\n    this._initialUndoRedoSnapshot = null;\n    this._isDisposed = false;\n    this.__isDisposing = false;\n    this._instanceId = strings.singleLetterHash(MODEL_ID);\n    this._lastDecorationId = 0;\n    this._decorations = Object.create(null);\n    this._decorationsTree = new DecorationsTrees();\n    this._commandManager = new EditStack(this, this._undoRedoService);\n    this._isUndoing = false;\n    this._isRedoing = false;\n    this._trimAutoWhitespaceLines = null;\n    this._register(this._decorationProvider.onDidChange(() => {\n      this._onDidChangeDecorations.beginDeferredEmit();\n      this._onDidChangeDecorations.fire();\n      this._onDidChangeDecorations.endDeferredEmit();\n    }));\n    this._languageService.requestRichLanguageFeatures(languageId);\n  }\n  dispose() {\n    this.__isDisposing = true;\n    this._onWillDispose.fire();\n    this._tokenizationTextModelPart.dispose();\n    this._isDisposed = true;\n    super.dispose();\n    this._bufferDisposable.dispose();\n    this.__isDisposing = false;\n    // Manually release reference to previous text buffer to avoid large leaks\n    // in case someone leaks a TextModel reference\n    const emptyDisposedTextBuffer = new PieceTreeTextBuffer([], '', '\\n', false, false, true, true);\n    emptyDisposedTextBuffer.dispose();\n    this._buffer = emptyDisposedTextBuffer;\n    this._bufferDisposable = Disposable.None;\n  }\n  _assertNotDisposed() {\n    if (this._isDisposed) {\n      throw new Error('Model is disposed!');\n    }\n  }\n  _emitContentChangedEvent(rawChange, change) {\n    if (this.__isDisposing) {\n      // Do not confuse listeners by emitting any event after disposing\n      return;\n    }\n    this._tokenizationTextModelPart.handleDidChangeContent(change);\n    this._bracketPairs.handleDidChangeContent(change);\n    this._eventEmitter.fire(new InternalModelContentChangeEvent(rawChange, change));\n  }\n  setValue(value) {\n    this._assertNotDisposed();\n    if (value === null || value === undefined) {\n      throw illegalArgument();\n    }\n    const {\n      textBuffer,\n      disposable\n    } = createTextBuffer(value, this._options.defaultEOL);\n    this._setValueFromTextBuffer(textBuffer, disposable);\n  }\n  _createContentChanged2(range, rangeOffset, rangeLength, text, isUndoing, isRedoing, isFlush, isEolChange) {\n    return {\n      changes: [{\n        range: range,\n        rangeOffset: rangeOffset,\n        rangeLength: rangeLength,\n        text: text\n      }],\n      eol: this._buffer.getEOL(),\n      isEolChange: isEolChange,\n      versionId: this.getVersionId(),\n      isUndoing: isUndoing,\n      isRedoing: isRedoing,\n      isFlush: isFlush\n    };\n  }\n  _setValueFromTextBuffer(textBuffer, textBufferDisposable) {\n    this._assertNotDisposed();\n    const oldFullModelRange = this.getFullModelRange();\n    const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n    const endLineNumber = this.getLineCount();\n    const endColumn = this.getLineMaxColumn(endLineNumber);\n    this._buffer = textBuffer;\n    this._bufferDisposable.dispose();\n    this._bufferDisposable = textBufferDisposable;\n    this._increaseVersionId();\n    // Destroy all my decorations\n    this._decorations = Object.create(null);\n    this._decorationsTree = new DecorationsTrees();\n    // Destroy my edit history and settings\n    this._commandManager.clear();\n    this._trimAutoWhitespaceLines = null;\n    this._emitContentChangedEvent(new ModelRawContentChangedEvent([new ModelRawFlush()], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, true, false));\n  }\n  setEOL(eol) {\n    this._assertNotDisposed();\n    const newEOL = eol === 1 /* model.EndOfLineSequence.CRLF */ ? '\\r\\n' : '\\n';\n    if (this._buffer.getEOL() === newEOL) {\n      // Nothing to do\n      return;\n    }\n    const oldFullModelRange = this.getFullModelRange();\n    const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n    const endLineNumber = this.getLineCount();\n    const endColumn = this.getLineMaxColumn(endLineNumber);\n    this._onBeforeEOLChange();\n    this._buffer.setEOL(newEOL);\n    this._increaseVersionId();\n    this._onAfterEOLChange();\n    this._emitContentChangedEvent(new ModelRawContentChangedEvent([new ModelRawEOLChanged()], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, false, true));\n  }\n  _onBeforeEOLChange() {\n    // Ensure all decorations get their `range` set.\n    this._decorationsTree.ensureAllNodesHaveRanges(this);\n  }\n  _onAfterEOLChange() {\n    // Transform back `range` to offsets\n    const versionId = this.getVersionId();\n    const allDecorations = this._decorationsTree.collectNodesPostOrder();\n    for (let i = 0, len = allDecorations.length; i < len; i++) {\n      const node = allDecorations[i];\n      const range = node.range; // the range is defined due to `_onBeforeEOLChange`\n      const delta = node.cachedAbsoluteStart - node.start;\n      const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n      const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n      node.cachedAbsoluteStart = startOffset;\n      node.cachedAbsoluteEnd = endOffset;\n      node.cachedVersionId = versionId;\n      node.start = startOffset - delta;\n      node.end = endOffset - delta;\n      recomputeMaxEnd(node);\n    }\n  }\n  onBeforeAttached() {\n    this._attachedEditorCount++;\n    if (this._attachedEditorCount === 1) {\n      this._tokenizationTextModelPart.handleDidChangeAttached();\n      this._onDidChangeAttached.fire(undefined);\n    }\n    return this._attachedViews.attachView();\n  }\n  onBeforeDetached(view) {\n    this._attachedEditorCount--;\n    if (this._attachedEditorCount === 0) {\n      this._tokenizationTextModelPart.handleDidChangeAttached();\n      this._onDidChangeAttached.fire(undefined);\n    }\n    this._attachedViews.detachView(view);\n  }\n  isAttachedToEditor() {\n    return this._attachedEditorCount > 0;\n  }\n  getAttachedEditorCount() {\n    return this._attachedEditorCount;\n  }\n  isTooLargeForSyncing() {\n    return this._isTooLargeForSyncing;\n  }\n  isTooLargeForTokenization() {\n    return this._isTooLargeForTokenization;\n  }\n  isTooLargeForHeapOperation() {\n    return this._isTooLargeForHeapOperation;\n  }\n  isDisposed() {\n    return this._isDisposed;\n  }\n  isDominatedByLongLines() {\n    this._assertNotDisposed();\n    if (this.isTooLargeForTokenization()) {\n      // Cannot word wrap huge files anyways, so it doesn't really matter\n      return false;\n    }\n    let smallLineCharCount = 0;\n    let longLineCharCount = 0;\n    const lineCount = this._buffer.getLineCount();\n    for (let lineNumber = 1; lineNumber <= lineCount; lineNumber++) {\n      const lineLength = this._buffer.getLineLength(lineNumber);\n      if (lineLength >= LONG_LINE_BOUNDARY) {\n        longLineCharCount += lineLength;\n      } else {\n        smallLineCharCount += lineLength;\n      }\n    }\n    return longLineCharCount > smallLineCharCount;\n  }\n  get uri() {\n    return this._associatedResource;\n  }\n  //#region Options\n  getOptions() {\n    this._assertNotDisposed();\n    return this._options;\n  }\n  getFormattingOptions() {\n    return {\n      tabSize: this._options.indentSize,\n      insertSpaces: this._options.insertSpaces\n    };\n  }\n  updateOptions(_newOpts) {\n    this._assertNotDisposed();\n    const tabSize = typeof _newOpts.tabSize !== 'undefined' ? _newOpts.tabSize : this._options.tabSize;\n    const indentSize = typeof _newOpts.indentSize !== 'undefined' ? _newOpts.indentSize : this._options.originalIndentSize;\n    const insertSpaces = typeof _newOpts.insertSpaces !== 'undefined' ? _newOpts.insertSpaces : this._options.insertSpaces;\n    const trimAutoWhitespace = typeof _newOpts.trimAutoWhitespace !== 'undefined' ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;\n    const bracketPairColorizationOptions = typeof _newOpts.bracketColorizationOptions !== 'undefined' ? _newOpts.bracketColorizationOptions : this._options.bracketPairColorizationOptions;\n    const newOpts = new model.TextModelResolvedOptions({\n      tabSize: tabSize,\n      indentSize: indentSize,\n      insertSpaces: insertSpaces,\n      defaultEOL: this._options.defaultEOL,\n      trimAutoWhitespace: trimAutoWhitespace,\n      bracketPairColorizationOptions\n    });\n    if (this._options.equals(newOpts)) {\n      return;\n    }\n    const e = this._options.createChangeEvent(newOpts);\n    this._options = newOpts;\n    this._bracketPairs.handleDidChangeOptions(e);\n    this._decorationProvider.handleDidChangeOptions(e);\n    this._onDidChangeOptions.fire(e);\n  }\n  detectIndentation(defaultInsertSpaces, defaultTabSize) {\n    this._assertNotDisposed();\n    const guessedIndentation = guessIndentation(this._buffer, defaultTabSize, defaultInsertSpaces);\n    this.updateOptions({\n      insertSpaces: guessedIndentation.insertSpaces,\n      tabSize: guessedIndentation.tabSize,\n      indentSize: guessedIndentation.tabSize // TODO@Alex: guess indentSize independent of tabSize\n    });\n  }\n  normalizeIndentation(str) {\n    this._assertNotDisposed();\n    return normalizeIndentation(str, this._options.indentSize, this._options.insertSpaces);\n  }\n  //#endregion\n  //#region Reading\n  getVersionId() {\n    this._assertNotDisposed();\n    return this._versionId;\n  }\n  mightContainRTL() {\n    return this._buffer.mightContainRTL();\n  }\n  mightContainUnusualLineTerminators() {\n    return this._buffer.mightContainUnusualLineTerminators();\n  }\n  removeUnusualLineTerminators() {\n    let selections = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    const matches = this.findMatches(strings.UNUSUAL_LINE_TERMINATORS.source, false, true, false, null, false, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */);\n    this._buffer.resetMightContainUnusualLineTerminators();\n    this.pushEditOperations(selections, matches.map(m => ({\n      range: m.range,\n      text: null\n    })), () => null);\n  }\n  mightContainNonBasicASCII() {\n    return this._buffer.mightContainNonBasicASCII();\n  }\n  getAlternativeVersionId() {\n    this._assertNotDisposed();\n    return this._alternativeVersionId;\n  }\n  getInitialUndoRedoSnapshot() {\n    this._assertNotDisposed();\n    return this._initialUndoRedoSnapshot;\n  }\n  getOffsetAt(rawPosition) {\n    this._assertNotDisposed();\n    const position = this._validatePosition(rawPosition.lineNumber, rawPosition.column, 0 /* StringOffsetValidationType.Relaxed */);\n    return this._buffer.getOffsetAt(position.lineNumber, position.column);\n  }\n  getPositionAt(rawOffset) {\n    this._assertNotDisposed();\n    const offset = Math.min(this._buffer.getLength(), Math.max(0, rawOffset));\n    return this._buffer.getPositionAt(offset);\n  }\n  _increaseVersionId() {\n    this._versionId = this._versionId + 1;\n    this._alternativeVersionId = this._versionId;\n  }\n  _overwriteVersionId(versionId) {\n    this._versionId = versionId;\n  }\n  _overwriteAlternativeVersionId(newAlternativeVersionId) {\n    this._alternativeVersionId = newAlternativeVersionId;\n  }\n  _overwriteInitialUndoRedoSnapshot(newInitialUndoRedoSnapshot) {\n    this._initialUndoRedoSnapshot = newInitialUndoRedoSnapshot;\n  }\n  getValue(eol) {\n    let preserveBOM = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    this._assertNotDisposed();\n    if (this.isTooLargeForHeapOperation()) {\n      throw new BugIndicatingError('Operation would exceed heap memory limits');\n    }\n    const fullModelRange = this.getFullModelRange();\n    const fullModelValue = this.getValueInRange(fullModelRange, eol);\n    if (preserveBOM) {\n      return this._buffer.getBOM() + fullModelValue;\n    }\n    return fullModelValue;\n  }\n  createSnapshot() {\n    let preserveBOM = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return new TextModelSnapshot(this._buffer.createSnapshot(preserveBOM));\n  }\n  getValueLength(eol) {\n    let preserveBOM = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    this._assertNotDisposed();\n    const fullModelRange = this.getFullModelRange();\n    const fullModelValue = this.getValueLengthInRange(fullModelRange, eol);\n    if (preserveBOM) {\n      return this._buffer.getBOM().length + fullModelValue;\n    }\n    return fullModelValue;\n  }\n  getValueInRange(rawRange) {\n    let eol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    this._assertNotDisposed();\n    return this._buffer.getValueInRange(this.validateRange(rawRange), eol);\n  }\n  getValueLengthInRange(rawRange) {\n    let eol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    this._assertNotDisposed();\n    return this._buffer.getValueLengthInRange(this.validateRange(rawRange), eol);\n  }\n  getCharacterCountInRange(rawRange) {\n    let eol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    this._assertNotDisposed();\n    return this._buffer.getCharacterCountInRange(this.validateRange(rawRange), eol);\n  }\n  getLineCount() {\n    this._assertNotDisposed();\n    return this._buffer.getLineCount();\n  }\n  getLineContent(lineNumber) {\n    this._assertNotDisposed();\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new BugIndicatingError('Illegal value for lineNumber');\n    }\n    return this._buffer.getLineContent(lineNumber);\n  }\n  getLineLength(lineNumber) {\n    this._assertNotDisposed();\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new BugIndicatingError('Illegal value for lineNumber');\n    }\n    return this._buffer.getLineLength(lineNumber);\n  }\n  getLinesContent() {\n    this._assertNotDisposed();\n    if (this.isTooLargeForHeapOperation()) {\n      throw new BugIndicatingError('Operation would exceed heap memory limits');\n    }\n    return this._buffer.getLinesContent();\n  }\n  getEOL() {\n    this._assertNotDisposed();\n    return this._buffer.getEOL();\n  }\n  getEndOfLineSequence() {\n    this._assertNotDisposed();\n    return this._buffer.getEOL() === '\\n' ? 0 /* model.EndOfLineSequence.LF */ : 1 /* model.EndOfLineSequence.CRLF */;\n  }\n  getLineMinColumn(lineNumber) {\n    this._assertNotDisposed();\n    return 1;\n  }\n  getLineMaxColumn(lineNumber) {\n    this._assertNotDisposed();\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new BugIndicatingError('Illegal value for lineNumber');\n    }\n    return this._buffer.getLineLength(lineNumber) + 1;\n  }\n  getLineFirstNonWhitespaceColumn(lineNumber) {\n    this._assertNotDisposed();\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new BugIndicatingError('Illegal value for lineNumber');\n    }\n    return this._buffer.getLineFirstNonWhitespaceColumn(lineNumber);\n  }\n  getLineLastNonWhitespaceColumn(lineNumber) {\n    this._assertNotDisposed();\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new BugIndicatingError('Illegal value for lineNumber');\n    }\n    return this._buffer.getLineLastNonWhitespaceColumn(lineNumber);\n  }\n  /**\n   * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.\n   * Will try to not allocate if possible.\n   */\n  _validateRangeRelaxedNoAllocations(range) {\n    const linesCount = this._buffer.getLineCount();\n    const initialStartLineNumber = range.startLineNumber;\n    const initialStartColumn = range.startColumn;\n    let startLineNumber = Math.floor(typeof initialStartLineNumber === 'number' && !isNaN(initialStartLineNumber) ? initialStartLineNumber : 1);\n    let startColumn = Math.floor(typeof initialStartColumn === 'number' && !isNaN(initialStartColumn) ? initialStartColumn : 1);\n    if (startLineNumber < 1) {\n      startLineNumber = 1;\n      startColumn = 1;\n    } else if (startLineNumber > linesCount) {\n      startLineNumber = linesCount;\n      startColumn = this.getLineMaxColumn(startLineNumber);\n    } else {\n      if (startColumn <= 1) {\n        startColumn = 1;\n      } else {\n        const maxColumn = this.getLineMaxColumn(startLineNumber);\n        if (startColumn >= maxColumn) {\n          startColumn = maxColumn;\n        }\n      }\n    }\n    const initialEndLineNumber = range.endLineNumber;\n    const initialEndColumn = range.endColumn;\n    let endLineNumber = Math.floor(typeof initialEndLineNumber === 'number' && !isNaN(initialEndLineNumber) ? initialEndLineNumber : 1);\n    let endColumn = Math.floor(typeof initialEndColumn === 'number' && !isNaN(initialEndColumn) ? initialEndColumn : 1);\n    if (endLineNumber < 1) {\n      endLineNumber = 1;\n      endColumn = 1;\n    } else if (endLineNumber > linesCount) {\n      endLineNumber = linesCount;\n      endColumn = this.getLineMaxColumn(endLineNumber);\n    } else {\n      if (endColumn <= 1) {\n        endColumn = 1;\n      } else {\n        const maxColumn = this.getLineMaxColumn(endLineNumber);\n        if (endColumn >= maxColumn) {\n          endColumn = maxColumn;\n        }\n      }\n    }\n    if (initialStartLineNumber === startLineNumber && initialStartColumn === startColumn && initialEndLineNumber === endLineNumber && initialEndColumn === endColumn && range instanceof Range && !(range instanceof Selection)) {\n      return range;\n    }\n    return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n  }\n  _isValidPosition(lineNumber, column, validationType) {\n    if (typeof lineNumber !== 'number' || typeof column !== 'number') {\n      return false;\n    }\n    if (isNaN(lineNumber) || isNaN(column)) {\n      return false;\n    }\n    if (lineNumber < 1 || column < 1) {\n      return false;\n    }\n    if ((lineNumber | 0) !== lineNumber || (column | 0) !== column) {\n      return false;\n    }\n    const lineCount = this._buffer.getLineCount();\n    if (lineNumber > lineCount) {\n      return false;\n    }\n    if (column === 1) {\n      return true;\n    }\n    const maxColumn = this.getLineMaxColumn(lineNumber);\n    if (column > maxColumn) {\n      return false;\n    }\n    if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n      // !!At this point, column > 1\n      const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n      if (strings.isHighSurrogate(charCodeBefore)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  _validatePosition(_lineNumber, _column, validationType) {\n    const lineNumber = Math.floor(typeof _lineNumber === 'number' && !isNaN(_lineNumber) ? _lineNumber : 1);\n    const column = Math.floor(typeof _column === 'number' && !isNaN(_column) ? _column : 1);\n    const lineCount = this._buffer.getLineCount();\n    if (lineNumber < 1) {\n      return new Position(1, 1);\n    }\n    if (lineNumber > lineCount) {\n      return new Position(lineCount, this.getLineMaxColumn(lineCount));\n    }\n    if (column <= 1) {\n      return new Position(lineNumber, 1);\n    }\n    const maxColumn = this.getLineMaxColumn(lineNumber);\n    if (column >= maxColumn) {\n      return new Position(lineNumber, maxColumn);\n    }\n    if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n      // If the position would end up in the middle of a high-low surrogate pair,\n      // we move it to before the pair\n      // !!At this point, column > 1\n      const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n      if (strings.isHighSurrogate(charCodeBefore)) {\n        return new Position(lineNumber, column - 1);\n      }\n    }\n    return new Position(lineNumber, column);\n  }\n  validatePosition(position) {\n    const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;\n    this._assertNotDisposed();\n    // Avoid object allocation and cover most likely case\n    if (position instanceof Position) {\n      if (this._isValidPosition(position.lineNumber, position.column, validationType)) {\n        return position;\n      }\n    }\n    return this._validatePosition(position.lineNumber, position.column, validationType);\n  }\n  _isValidRange(range, validationType) {\n    const startLineNumber = range.startLineNumber;\n    const startColumn = range.startColumn;\n    const endLineNumber = range.endLineNumber;\n    const endColumn = range.endColumn;\n    if (!this._isValidPosition(startLineNumber, startColumn, 0 /* StringOffsetValidationType.Relaxed */)) {\n      return false;\n    }\n    if (!this._isValidPosition(endLineNumber, endColumn, 0 /* StringOffsetValidationType.Relaxed */)) {\n      return false;\n    }\n    if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n      const charCodeBeforeStart = startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0;\n      const charCodeBeforeEnd = endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0;\n      const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n      const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n      if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n        return true;\n      }\n      return false;\n    }\n    return true;\n  }\n  validateRange(_range) {\n    const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;\n    this._assertNotDisposed();\n    // Avoid object allocation and cover most likely case\n    if (_range instanceof Range && !(_range instanceof Selection)) {\n      if (this._isValidRange(_range, validationType)) {\n        return _range;\n      }\n    }\n    const start = this._validatePosition(_range.startLineNumber, _range.startColumn, 0 /* StringOffsetValidationType.Relaxed */);\n    const end = this._validatePosition(_range.endLineNumber, _range.endColumn, 0 /* StringOffsetValidationType.Relaxed */);\n    const startLineNumber = start.lineNumber;\n    const startColumn = start.column;\n    const endLineNumber = end.lineNumber;\n    const endColumn = end.column;\n    if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n      const charCodeBeforeStart = startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0;\n      const charCodeBeforeEnd = endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0;\n      const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n      const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n      if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n      }\n      if (startLineNumber === endLineNumber && startColumn === endColumn) {\n        // do not expand a collapsed range, simply move it to a valid location\n        return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);\n      }\n      if (startInsideSurrogatePair && endInsideSurrogatePair) {\n        // expand range at both ends\n        return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);\n      }\n      if (startInsideSurrogatePair) {\n        // only expand range at the start\n        return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);\n      }\n      // only expand range at the end\n      return new Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);\n    }\n    return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n  }\n  modifyPosition(rawPosition, offset) {\n    this._assertNotDisposed();\n    const candidate = this.getOffsetAt(rawPosition) + offset;\n    return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, candidate)));\n  }\n  getFullModelRange() {\n    this._assertNotDisposed();\n    const lineCount = this.getLineCount();\n    return new Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));\n  }\n  findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n    return this._buffer.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n  }\n  findMatches(searchString, rawSearchScope, isRegex, matchCase, wordSeparators, captureMatches) {\n    let limitResultCount = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : LIMIT_FIND_COUNT;\n    this._assertNotDisposed();\n    let searchRanges = null;\n    if (rawSearchScope !== null) {\n      if (!Array.isArray(rawSearchScope)) {\n        rawSearchScope = [rawSearchScope];\n      }\n      if (rawSearchScope.every(searchScope => Range.isIRange(searchScope))) {\n        searchRanges = rawSearchScope.map(searchScope => this.validateRange(searchScope));\n      }\n    }\n    if (searchRanges === null) {\n      searchRanges = [this.getFullModelRange()];\n    }\n    searchRanges = searchRanges.sort((d1, d2) => d1.startLineNumber - d2.startLineNumber || d1.startColumn - d2.startColumn);\n    const uniqueSearchRanges = [];\n    uniqueSearchRanges.push(searchRanges.reduce((prev, curr) => {\n      if (Range.areIntersecting(prev, curr)) {\n        return prev.plusRange(curr);\n      }\n      uniqueSearchRanges.push(prev);\n      return curr;\n    }));\n    let matchMapper;\n    if (!isRegex && searchString.indexOf('\\n') < 0) {\n      // not regex, not multi line\n      const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n      const searchData = searchParams.parseSearchRequest();\n      if (!searchData) {\n        return [];\n      }\n      matchMapper = searchRange => this.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    } else {\n      matchMapper = searchRange => TextModelSearch.findMatches(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchRange, captureMatches, limitResultCount);\n    }\n    return uniqueSearchRanges.map(matchMapper).reduce((arr, matches) => arr.concat(matches), []);\n  }\n  findNextMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n    this._assertNotDisposed();\n    const searchStart = this.validatePosition(rawSearchStart);\n    if (!isRegex && searchString.indexOf('\\n') < 0) {\n      const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n      const searchData = searchParams.parseSearchRequest();\n      if (!searchData) {\n        return null;\n      }\n      const lineCount = this.getLineCount();\n      let searchRange = new Range(searchStart.lineNumber, searchStart.column, lineCount, this.getLineMaxColumn(lineCount));\n      let ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n      TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n      if (ret.length > 0) {\n        return ret[0];\n      }\n      searchRange = new Range(1, 1, searchStart.lineNumber, this.getLineMaxColumn(searchStart.lineNumber));\n      ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n      if (ret.length > 0) {\n        return ret[0];\n      }\n      return null;\n    }\n    return TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n  }\n  findPreviousMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n    this._assertNotDisposed();\n    const searchStart = this.validatePosition(rawSearchStart);\n    return TextModelSearch.findPreviousMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n  }\n  //#endregion\n  //#region Editing\n  pushStackElement() {\n    this._commandManager.pushStackElement();\n  }\n  popStackElement() {\n    this._commandManager.popStackElement();\n  }\n  pushEOL(eol) {\n    const currentEOL = this.getEOL() === '\\n' ? 0 /* model.EndOfLineSequence.LF */ : 1 /* model.EndOfLineSequence.CRLF */;\n    if (currentEOL === eol) {\n      return;\n    }\n    try {\n      this._onDidChangeDecorations.beginDeferredEmit();\n      this._eventEmitter.beginDeferredEmit();\n      if (this._initialUndoRedoSnapshot === null) {\n        this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n      }\n      this._commandManager.pushEOL(eol);\n    } finally {\n      this._eventEmitter.endDeferredEmit();\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  }\n  _validateEditOperation(rawOperation) {\n    if (rawOperation instanceof model.ValidAnnotatedEditOperation) {\n      return rawOperation;\n    }\n    return new model.ValidAnnotatedEditOperation(rawOperation.identifier || null, this.validateRange(rawOperation.range), rawOperation.text, rawOperation.forceMoveMarkers || false, rawOperation.isAutoWhitespaceEdit || false, rawOperation._isTracked || false);\n  }\n  _validateEditOperations(rawOperations) {\n    const result = [];\n    for (let i = 0, len = rawOperations.length; i < len; i++) {\n      result[i] = this._validateEditOperation(rawOperations[i]);\n    }\n    return result;\n  }\n  pushEditOperations(beforeCursorState, editOperations, cursorStateComputer, group) {\n    try {\n      this._onDidChangeDecorations.beginDeferredEmit();\n      this._eventEmitter.beginDeferredEmit();\n      return this._pushEditOperations(beforeCursorState, this._validateEditOperations(editOperations), cursorStateComputer, group);\n    } finally {\n      this._eventEmitter.endDeferredEmit();\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  }\n  _pushEditOperations(beforeCursorState, editOperations, cursorStateComputer, group) {\n    if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {\n      // Go through each saved line number and insert a trim whitespace edit\n      // if it is safe to do so (no conflicts with other edits).\n      const incomingEdits = editOperations.map(op => {\n        return {\n          range: this.validateRange(op.range),\n          text: op.text\n        };\n      });\n      // Sometimes, auto-formatters change ranges automatically which can cause undesired auto whitespace trimming near the cursor\n      // We'll use the following heuristic: if the edits occur near the cursor, then it's ok to trim auto whitespace\n      let editsAreNearCursors = true;\n      if (beforeCursorState) {\n        for (let i = 0, len = beforeCursorState.length; i < len; i++) {\n          const sel = beforeCursorState[i];\n          let foundEditNearSel = false;\n          for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n            const editRange = incomingEdits[j].range;\n            const selIsAbove = editRange.startLineNumber > sel.endLineNumber;\n            const selIsBelow = sel.startLineNumber > editRange.endLineNumber;\n            if (!selIsAbove && !selIsBelow) {\n              foundEditNearSel = true;\n              break;\n            }\n          }\n          if (!foundEditNearSel) {\n            editsAreNearCursors = false;\n            break;\n          }\n        }\n      }\n      if (editsAreNearCursors) {\n        for (let i = 0, len = this._trimAutoWhitespaceLines.length; i < len; i++) {\n          const trimLineNumber = this._trimAutoWhitespaceLines[i];\n          const maxLineColumn = this.getLineMaxColumn(trimLineNumber);\n          let allowTrimLine = true;\n          for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n            const editRange = incomingEdits[j].range;\n            const editText = incomingEdits[j].text;\n            if (trimLineNumber < editRange.startLineNumber || trimLineNumber > editRange.endLineNumber) {\n              // `trimLine` is completely outside this edit\n              continue;\n            }\n            // At this point:\n            //   editRange.startLineNumber <= trimLine <= editRange.endLineNumber\n            if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === maxLineColumn && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === '\\n') {\n              // This edit inserts a new line (and maybe other text) after `trimLine`\n              continue;\n            }\n            if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === 1 && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(editText.length - 1) === '\\n') {\n              // This edit inserts a new line (and maybe other text) before `trimLine`\n              continue;\n            }\n            // Looks like we can't trim this line as it would interfere with an incoming edit\n            allowTrimLine = false;\n            break;\n          }\n          if (allowTrimLine) {\n            const trimRange = new Range(trimLineNumber, 1, trimLineNumber, maxLineColumn);\n            editOperations.push(new model.ValidAnnotatedEditOperation(null, trimRange, null, false, false, false));\n          }\n        }\n      }\n      this._trimAutoWhitespaceLines = null;\n    }\n    if (this._initialUndoRedoSnapshot === null) {\n      this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n    }\n    return this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer, group);\n  }\n  _applyUndo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n    const edits = changes.map(change => {\n      const rangeStart = this.getPositionAt(change.newPosition);\n      const rangeEnd = this.getPositionAt(change.newEnd);\n      return {\n        range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n        text: change.oldText\n      };\n    });\n    this._applyUndoRedoEdits(edits, eol, true, false, resultingAlternativeVersionId, resultingSelection);\n  }\n  _applyRedo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n    const edits = changes.map(change => {\n      const rangeStart = this.getPositionAt(change.oldPosition);\n      const rangeEnd = this.getPositionAt(change.oldEnd);\n      return {\n        range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n        text: change.newText\n      };\n    });\n    this._applyUndoRedoEdits(edits, eol, false, true, resultingAlternativeVersionId, resultingSelection);\n  }\n  _applyUndoRedoEdits(edits, eol, isUndoing, isRedoing, resultingAlternativeVersionId, resultingSelection) {\n    try {\n      this._onDidChangeDecorations.beginDeferredEmit();\n      this._eventEmitter.beginDeferredEmit();\n      this._isUndoing = isUndoing;\n      this._isRedoing = isRedoing;\n      this.applyEdits(edits, false);\n      this.setEOL(eol);\n      this._overwriteAlternativeVersionId(resultingAlternativeVersionId);\n    } finally {\n      this._isUndoing = false;\n      this._isRedoing = false;\n      this._eventEmitter.endDeferredEmit(resultingSelection);\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  }\n  applyEdits(rawOperations) {\n    let computeUndoEdits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    try {\n      this._onDidChangeDecorations.beginDeferredEmit();\n      this._eventEmitter.beginDeferredEmit();\n      const operations = this._validateEditOperations(rawOperations);\n      return this._doApplyEdits(operations, computeUndoEdits);\n    } finally {\n      this._eventEmitter.endDeferredEmit();\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  }\n  _doApplyEdits(rawOperations, computeUndoEdits) {\n    const oldLineCount = this._buffer.getLineCount();\n    const result = this._buffer.applyEdits(rawOperations, this._options.trimAutoWhitespace, computeUndoEdits);\n    const newLineCount = this._buffer.getLineCount();\n    const contentChanges = result.changes;\n    this._trimAutoWhitespaceLines = result.trimAutoWhitespaceLineNumbers;\n    if (contentChanges.length !== 0) {\n      // We do a first pass to update decorations\n      // because we want to read decorations in the second pass\n      // where we will emit content change events\n      // and we want to read the final decorations\n      for (let i = 0, len = contentChanges.length; i < len; i++) {\n        const change = contentChanges[i];\n        this._decorationsTree.acceptReplace(change.rangeOffset, change.rangeLength, change.text.length, change.forceMoveMarkers);\n      }\n      const rawContentChanges = [];\n      this._increaseVersionId();\n      let lineCount = oldLineCount;\n      for (let i = 0, len = contentChanges.length; i < len; i++) {\n        const change = contentChanges[i];\n        const [eolCount] = countEOL(change.text);\n        this._onDidChangeDecorations.fire();\n        const startLineNumber = change.range.startLineNumber;\n        const endLineNumber = change.range.endLineNumber;\n        const deletingLinesCnt = endLineNumber - startLineNumber;\n        const insertingLinesCnt = eolCount;\n        const editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n        const changeLineCountDelta = insertingLinesCnt - deletingLinesCnt;\n        const currentEditStartLineNumber = newLineCount - lineCount - changeLineCountDelta + startLineNumber;\n        const firstEditLineNumber = currentEditStartLineNumber;\n        const lastInsertedLineNumber = currentEditStartLineNumber + insertingLinesCnt;\n        const decorationsWithInjectedTextInEditedRange = this._decorationsTree.getInjectedTextInInterval(this, this.getOffsetAt(new Position(firstEditLineNumber, 1)), this.getOffsetAt(new Position(lastInsertedLineNumber, this.getLineMaxColumn(lastInsertedLineNumber))), 0);\n        const injectedTextInEditedRange = LineInjectedText.fromDecorations(decorationsWithInjectedTextInEditedRange);\n        const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n        for (let j = editingLinesCnt; j >= 0; j--) {\n          const editLineNumber = startLineNumber + j;\n          const currentEditLineNumber = currentEditStartLineNumber + j;\n          injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber > currentEditLineNumber);\n          const decorationsInCurrentLine = injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber === currentEditLineNumber);\n          rawContentChanges.push(new ModelRawLineChanged(editLineNumber, this.getLineContent(currentEditLineNumber), decorationsInCurrentLine));\n        }\n        if (editingLinesCnt < deletingLinesCnt) {\n          // Must delete some lines\n          const spliceStartLineNumber = startLineNumber + editingLinesCnt;\n          rawContentChanges.push(new ModelRawLinesDeleted(spliceStartLineNumber + 1, endLineNumber));\n        }\n        if (editingLinesCnt < insertingLinesCnt) {\n          const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n          // Must insert some lines\n          const spliceLineNumber = startLineNumber + editingLinesCnt;\n          const cnt = insertingLinesCnt - editingLinesCnt;\n          const fromLineNumber = newLineCount - lineCount - cnt + spliceLineNumber + 1;\n          const injectedTexts = [];\n          const newLines = [];\n          for (let i = 0; i < cnt; i++) {\n            const lineNumber = fromLineNumber + i;\n            newLines[i] = this.getLineContent(lineNumber);\n            injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber < lineNumber);\n            injectedTexts[i] = injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber === lineNumber);\n          }\n          rawContentChanges.push(new ModelRawLinesInserted(spliceLineNumber + 1, startLineNumber + insertingLinesCnt, newLines, injectedTexts));\n        }\n        lineCount += changeLineCountDelta;\n      }\n      this._emitContentChangedEvent(new ModelRawContentChangedEvent(rawContentChanges, this.getVersionId(), this._isUndoing, this._isRedoing), {\n        changes: contentChanges,\n        eol: this._buffer.getEOL(),\n        isEolChange: false,\n        versionId: this.getVersionId(),\n        isUndoing: this._isUndoing,\n        isRedoing: this._isRedoing,\n        isFlush: false\n      });\n    }\n    return result.reverseEdits === null ? undefined : result.reverseEdits;\n  }\n  undo() {\n    return this._undoRedoService.undo(this.uri);\n  }\n  canUndo() {\n    return this._undoRedoService.canUndo(this.uri);\n  }\n  redo() {\n    return this._undoRedoService.redo(this.uri);\n  }\n  canRedo() {\n    return this._undoRedoService.canRedo(this.uri);\n  }\n  //#endregion\n  //#region Decorations\n  handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines) {\n    // This is called before the decoration changed event is fired.\n    if (affectedInjectedTextLines === null || affectedInjectedTextLines.size === 0) {\n      return;\n    }\n    const affectedLines = Array.from(affectedInjectedTextLines);\n    const lineChangeEvents = affectedLines.map(lineNumber => new ModelRawLineChanged(lineNumber, this.getLineContent(lineNumber), this._getInjectedTextInLine(lineNumber)));\n    this._onDidChangeInjectedText.fire(new ModelInjectedTextChangedEvent(lineChangeEvents));\n  }\n  changeDecorations(callback) {\n    let ownerId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    this._assertNotDisposed();\n    try {\n      this._onDidChangeDecorations.beginDeferredEmit();\n      return this._changeDecorations(ownerId, callback);\n    } finally {\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  }\n  _changeDecorations(ownerId, callback) {\n    const changeAccessor = {\n      addDecoration: (range, options) => {\n        return this._deltaDecorationsImpl(ownerId, [], [{\n          range: range,\n          options: options\n        }])[0];\n      },\n      changeDecoration: (id, newRange) => {\n        this._changeDecorationImpl(id, newRange);\n      },\n      changeDecorationOptions: (id, options) => {\n        this._changeDecorationOptionsImpl(id, _normalizeOptions(options));\n      },\n      removeDecoration: id => {\n        this._deltaDecorationsImpl(ownerId, [id], []);\n      },\n      deltaDecorations: (oldDecorations, newDecorations) => {\n        if (oldDecorations.length === 0 && newDecorations.length === 0) {\n          // nothing to do\n          return [];\n        }\n        return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n      }\n    };\n    let result = null;\n    try {\n      result = callback(changeAccessor);\n    } catch (e) {\n      onUnexpectedError(e);\n    }\n    // Invalidate change accessor\n    changeAccessor.addDecoration = invalidFunc;\n    changeAccessor.changeDecoration = invalidFunc;\n    changeAccessor.changeDecorationOptions = invalidFunc;\n    changeAccessor.removeDecoration = invalidFunc;\n    changeAccessor.deltaDecorations = invalidFunc;\n    return result;\n  }\n  deltaDecorations(oldDecorations, newDecorations) {\n    let ownerId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    this._assertNotDisposed();\n    if (!oldDecorations) {\n      oldDecorations = [];\n    }\n    if (oldDecorations.length === 0 && newDecorations.length === 0) {\n      // nothing to do\n      return [];\n    }\n    try {\n      this._deltaDecorationCallCnt++;\n      if (this._deltaDecorationCallCnt > 1) {\n        console.warn(`Invoking deltaDecorations recursively could lead to leaking decorations.`);\n        onUnexpectedError(new Error(`Invoking deltaDecorations recursively could lead to leaking decorations.`));\n      }\n      this._onDidChangeDecorations.beginDeferredEmit();\n      return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n    } finally {\n      this._onDidChangeDecorations.endDeferredEmit();\n      this._deltaDecorationCallCnt--;\n    }\n  }\n  _getTrackedRange(id) {\n    return this.getDecorationRange(id);\n  }\n  _setTrackedRange(id, newRange, newStickiness) {\n    const node = id ? this._decorations[id] : null;\n    if (!node) {\n      if (!newRange) {\n        // node doesn't exist, the request is to delete => nothing to do\n        return null;\n      }\n      // node doesn't exist, the request is to set => add the tracked range\n      return this._deltaDecorationsImpl(0, [], [{\n        range: newRange,\n        options: TRACKED_RANGE_OPTIONS[newStickiness]\n      }], true)[0];\n    }\n    if (!newRange) {\n      // node exists, the request is to delete => delete node\n      this._decorationsTree.delete(node);\n      delete this._decorations[node.id];\n      return null;\n    }\n    // node exists, the request is to set => change the tracked range and its options\n    const range = this._validateRangeRelaxedNoAllocations(newRange);\n    const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n    const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n    this._decorationsTree.delete(node);\n    node.reset(this.getVersionId(), startOffset, endOffset, range);\n    node.setOptions(TRACKED_RANGE_OPTIONS[newStickiness]);\n    this._decorationsTree.insert(node);\n    return node.id;\n  }\n  removeAllDecorationsWithOwnerId(ownerId) {\n    if (this._isDisposed) {\n      return;\n    }\n    const nodes = this._decorationsTree.collectNodesFromOwner(ownerId);\n    for (let i = 0, len = nodes.length; i < len; i++) {\n      const node = nodes[i];\n      this._decorationsTree.delete(node);\n      delete this._decorations[node.id];\n    }\n  }\n  getDecorationOptions(decorationId) {\n    const node = this._decorations[decorationId];\n    if (!node) {\n      return null;\n    }\n    return node.options;\n  }\n  getDecorationRange(decorationId) {\n    const node = this._decorations[decorationId];\n    if (!node) {\n      return null;\n    }\n    return this._decorationsTree.getNodeRange(this, node);\n  }\n  getLineDecorations(lineNumber) {\n    let ownerId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let filterOutValidation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      return [];\n    }\n    return this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation);\n  }\n  getLinesDecorations(_startLineNumber, _endLineNumber) {\n    let ownerId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let filterOutValidation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let onlyMarginDecorations = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    const lineCount = this.getLineCount();\n    const startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));\n    const endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));\n    const endColumn = this.getLineMaxColumn(endLineNumber);\n    const range = new Range(startLineNumber, 1, endLineNumber, endColumn);\n    const decorations = this._getDecorationsInRange(range, ownerId, filterOutValidation, onlyMarginDecorations);\n    pushMany(decorations, this._decorationProvider.getDecorationsInRange(range, ownerId, filterOutValidation));\n    return decorations;\n  }\n  getDecorationsInRange(range) {\n    let ownerId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let filterOutValidation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let onlyMinimapDecorations = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let onlyMarginDecorations = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    const validatedRange = this.validateRange(range);\n    const decorations = this._getDecorationsInRange(validatedRange, ownerId, filterOutValidation, onlyMarginDecorations);\n    pushMany(decorations, this._decorationProvider.getDecorationsInRange(validatedRange, ownerId, filterOutValidation, onlyMinimapDecorations));\n    return decorations;\n  }\n  getOverviewRulerDecorations() {\n    let ownerId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let filterOutValidation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return this._decorationsTree.getAll(this, ownerId, filterOutValidation, true, false);\n  }\n  getInjectedTextDecorations() {\n    let ownerId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return this._decorationsTree.getAllInjectedText(this, ownerId);\n  }\n  _getInjectedTextInLine(lineNumber) {\n    const startOffset = this._buffer.getOffsetAt(lineNumber, 1);\n    const endOffset = startOffset + this._buffer.getLineLength(lineNumber);\n    const result = this._decorationsTree.getInjectedTextInInterval(this, startOffset, endOffset, 0);\n    return LineInjectedText.fromDecorations(result).filter(t => t.lineNumber === lineNumber);\n  }\n  getAllDecorations() {\n    let ownerId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let filterOutValidation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let result = this._decorationsTree.getAll(this, ownerId, filterOutValidation, false, false);\n    result = result.concat(this._decorationProvider.getAllDecorations(ownerId, filterOutValidation));\n    return result;\n  }\n  getAllMarginDecorations() {\n    let ownerId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return this._decorationsTree.getAll(this, ownerId, false, false, true);\n  }\n  _getDecorationsInRange(filterRange, filterOwnerId, filterOutValidation, onlyMarginDecorations) {\n    const startOffset = this._buffer.getOffsetAt(filterRange.startLineNumber, filterRange.startColumn);\n    const endOffset = this._buffer.getOffsetAt(filterRange.endLineNumber, filterRange.endColumn);\n    return this._decorationsTree.getAllInInterval(this, startOffset, endOffset, filterOwnerId, filterOutValidation, onlyMarginDecorations);\n  }\n  getRangeAt(start, end) {\n    return this._buffer.getRangeAt(start, end - start);\n  }\n  _changeDecorationImpl(decorationId, _range) {\n    const node = this._decorations[decorationId];\n    if (!node) {\n      return;\n    }\n    if (node.options.after) {\n      const oldRange = this.getDecorationRange(decorationId);\n      this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.endLineNumber);\n    }\n    if (node.options.before) {\n      const oldRange = this.getDecorationRange(decorationId);\n      this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.startLineNumber);\n    }\n    const range = this._validateRangeRelaxedNoAllocations(_range);\n    const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n    const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n    this._decorationsTree.delete(node);\n    node.reset(this.getVersionId(), startOffset, endOffset, range);\n    this._decorationsTree.insert(node);\n    this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n    if (node.options.after) {\n      this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n    }\n    if (node.options.before) {\n      this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n    }\n  }\n  _changeDecorationOptionsImpl(decorationId, options) {\n    const node = this._decorations[decorationId];\n    if (!node) {\n      return;\n    }\n    const nodeWasInOverviewRuler = node.options.overviewRuler && node.options.overviewRuler.color ? true : false;\n    const nodeIsInOverviewRuler = options.overviewRuler && options.overviewRuler.color ? true : false;\n    this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n    this._onDidChangeDecorations.checkAffectedAndFire(options);\n    if (node.options.after || options.after) {\n      const nodeRange = this._decorationsTree.getNodeRange(this, node);\n      this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n    }\n    if (node.options.before || options.before) {\n      const nodeRange = this._decorationsTree.getNodeRange(this, node);\n      this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n    }\n    const movedInOverviewRuler = nodeWasInOverviewRuler !== nodeIsInOverviewRuler;\n    const changedWhetherInjectedText = isOptionsInjectedText(options) !== isNodeInjectedText(node);\n    if (movedInOverviewRuler || changedWhetherInjectedText) {\n      this._decorationsTree.delete(node);\n      node.setOptions(options);\n      this._decorationsTree.insert(node);\n    } else {\n      node.setOptions(options);\n    }\n  }\n  _deltaDecorationsImpl(ownerId, oldDecorationsIds, newDecorations) {\n    let suppressEvents = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const versionId = this.getVersionId();\n    const oldDecorationsLen = oldDecorationsIds.length;\n    let oldDecorationIndex = 0;\n    const newDecorationsLen = newDecorations.length;\n    let newDecorationIndex = 0;\n    this._onDidChangeDecorations.beginDeferredEmit();\n    try {\n      const result = new Array(newDecorationsLen);\n      while (oldDecorationIndex < oldDecorationsLen || newDecorationIndex < newDecorationsLen) {\n        let node = null;\n        if (oldDecorationIndex < oldDecorationsLen) {\n          // (1) get ourselves an old node\n          do {\n            node = this._decorations[oldDecorationsIds[oldDecorationIndex++]];\n          } while (!node && oldDecorationIndex < oldDecorationsLen);\n          // (2) remove the node from the tree (if it exists)\n          if (node) {\n            if (node.options.after) {\n              const nodeRange = this._decorationsTree.getNodeRange(this, node);\n              this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n            }\n            if (node.options.before) {\n              const nodeRange = this._decorationsTree.getNodeRange(this, node);\n              this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n            }\n            this._decorationsTree.delete(node);\n            if (!suppressEvents) {\n              this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n            }\n          }\n        }\n        if (newDecorationIndex < newDecorationsLen) {\n          // (3) create a new node if necessary\n          if (!node) {\n            const internalDecorationId = ++this._lastDecorationId;\n            const decorationId = `${this._instanceId};${internalDecorationId}`;\n            node = new IntervalNode(decorationId, 0, 0);\n            this._decorations[decorationId] = node;\n          }\n          // (4) initialize node\n          const newDecoration = newDecorations[newDecorationIndex];\n          const range = this._validateRangeRelaxedNoAllocations(newDecoration.range);\n          const options = _normalizeOptions(newDecoration.options);\n          const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n          const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n          node.ownerId = ownerId;\n          node.reset(versionId, startOffset, endOffset, range);\n          node.setOptions(options);\n          if (node.options.after) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n          }\n          if (node.options.before) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n          }\n          if (!suppressEvents) {\n            this._onDidChangeDecorations.checkAffectedAndFire(options);\n          }\n          this._decorationsTree.insert(node);\n          result[newDecorationIndex] = node.id;\n          newDecorationIndex++;\n        } else {\n          if (node) {\n            delete this._decorations[node.id];\n          }\n        }\n      }\n      return result;\n    } finally {\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  }\n  //#endregion\n  //#region Tokenization\n  // TODO move them to the tokenization part.\n  getLanguageId() {\n    return this.tokenization.getLanguageId();\n  }\n  setLanguage(languageIdOrSelection, source) {\n    if (typeof languageIdOrSelection === 'string') {\n      this._languageSelectionListener.clear();\n      this._setLanguage(languageIdOrSelection, source);\n    } else {\n      this._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId, source));\n      this._setLanguage(languageIdOrSelection.languageId, source);\n    }\n  }\n  _setLanguage(languageId, source) {\n    this.tokenization.setLanguageId(languageId, source);\n    this._languageService.requestRichLanguageFeatures(languageId);\n  }\n  getLanguageIdAtPosition(lineNumber, column) {\n    return this.tokenization.getLanguageIdAtPosition(lineNumber, column);\n  }\n  getWordAtPosition(position) {\n    return this._tokenizationTextModelPart.getWordAtPosition(position);\n  }\n  getWordUntilPosition(position) {\n    return this._tokenizationTextModelPart.getWordUntilPosition(position);\n  }\n  //#endregion\n  normalizePosition(position, affinity) {\n    return position;\n  }\n  /**\n   * Gets the column at which indentation stops at a given line.\n   * @internal\n  */\n  getLineIndentColumn(lineNumber) {\n    // Columns start with 1.\n    return indentOfLine(this.getLineContent(lineNumber)) + 1;\n  }\n};\nTextModel._MODEL_SYNC_LIMIT = 50 * 1024 * 1024; // 50 MB,  // used in tests\nTextModel.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024; // 20 MB;\nTextModel.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1000; // 300K lines\nTextModel.LARGE_FILE_HEAP_OPERATION_THRESHOLD = 256 * 1024 * 1024; // 256M characters, usually ~> 512MB memory usage\nTextModel.DEFAULT_CREATION_OPTIONS = {\n  isForSimpleWidget: false,\n  tabSize: EDITOR_MODEL_DEFAULTS.tabSize,\n  indentSize: EDITOR_MODEL_DEFAULTS.indentSize,\n  insertSpaces: EDITOR_MODEL_DEFAULTS.insertSpaces,\n  detectIndentation: false,\n  defaultEOL: 1 /* model.DefaultEndOfLine.LF */,\n  trimAutoWhitespace: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,\n  largeFileOptimizations: EDITOR_MODEL_DEFAULTS.largeFileOptimizations,\n  bracketPairColorizationOptions: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions\n};\nTextModel = TextModel_1 = __decorate([__param(4, IUndoRedoService), __param(5, ILanguageService), __param(6, ILanguageConfigurationService)], TextModel);\nexport { TextModel };\nfunction indentOfLine(line) {\n  let indent = 0;\n  for (const c of line) {\n    if (c === ' ' || c === '\\t') {\n      indent++;\n    } else {\n      break;\n    }\n  }\n  return indent;\n}\n//#region Decorations\nfunction isNodeInOverviewRuler(node) {\n  return node.options.overviewRuler && node.options.overviewRuler.color ? true : false;\n}\nfunction isOptionsInjectedText(options) {\n  return !!options.after || !!options.before;\n}\nfunction isNodeInjectedText(node) {\n  return !!node.options.after || !!node.options.before;\n}\nclass DecorationsTrees {\n  constructor() {\n    this._decorationsTree0 = new IntervalTree();\n    this._decorationsTree1 = new IntervalTree();\n    this._injectedTextDecorationsTree = new IntervalTree();\n  }\n  ensureAllNodesHaveRanges(host) {\n    this.getAll(host, 0, false, false, false);\n  }\n  _ensureNodesHaveRanges(host, nodes) {\n    for (const node of nodes) {\n      if (node.range === null) {\n        node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n      }\n    }\n    return nodes;\n  }\n  getAllInInterval(host, start, end, filterOwnerId, filterOutValidation, onlyMarginDecorations) {\n    const versionId = host.getVersionId();\n    const result = this._intervalSearch(start, end, filterOwnerId, filterOutValidation, versionId, onlyMarginDecorations);\n    return this._ensureNodesHaveRanges(host, result);\n  }\n  _intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n    const r0 = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n    const r1 = this._decorationsTree1.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n    const r2 = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n    return r0.concat(r1).concat(r2);\n  }\n  getInjectedTextInInterval(host, start, end, filterOwnerId) {\n    const versionId = host.getVersionId();\n    const result = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, false, versionId, false);\n    return this._ensureNodesHaveRanges(host, result).filter(i => i.options.showIfCollapsed || !i.range.isEmpty());\n  }\n  getAllInjectedText(host, filterOwnerId) {\n    const versionId = host.getVersionId();\n    const result = this._injectedTextDecorationsTree.search(filterOwnerId, false, versionId, false);\n    return this._ensureNodesHaveRanges(host, result).filter(i => i.options.showIfCollapsed || !i.range.isEmpty());\n  }\n  getAll(host, filterOwnerId, filterOutValidation, overviewRulerOnly, onlyMarginDecorations) {\n    const versionId = host.getVersionId();\n    const result = this._search(filterOwnerId, filterOutValidation, overviewRulerOnly, versionId, onlyMarginDecorations);\n    return this._ensureNodesHaveRanges(host, result);\n  }\n  _search(filterOwnerId, filterOutValidation, overviewRulerOnly, cachedVersionId, onlyMarginDecorations) {\n    if (overviewRulerOnly) {\n      return this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n    } else {\n      const r0 = this._decorationsTree0.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n      const r1 = this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n      const r2 = this._injectedTextDecorationsTree.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n      return r0.concat(r1).concat(r2);\n    }\n  }\n  collectNodesFromOwner(ownerId) {\n    const r0 = this._decorationsTree0.collectNodesFromOwner(ownerId);\n    const r1 = this._decorationsTree1.collectNodesFromOwner(ownerId);\n    const r2 = this._injectedTextDecorationsTree.collectNodesFromOwner(ownerId);\n    return r0.concat(r1).concat(r2);\n  }\n  collectNodesPostOrder() {\n    const r0 = this._decorationsTree0.collectNodesPostOrder();\n    const r1 = this._decorationsTree1.collectNodesPostOrder();\n    const r2 = this._injectedTextDecorationsTree.collectNodesPostOrder();\n    return r0.concat(r1).concat(r2);\n  }\n  insert(node) {\n    if (isNodeInjectedText(node)) {\n      this._injectedTextDecorationsTree.insert(node);\n    } else if (isNodeInOverviewRuler(node)) {\n      this._decorationsTree1.insert(node);\n    } else {\n      this._decorationsTree0.insert(node);\n    }\n  }\n  delete(node) {\n    if (isNodeInjectedText(node)) {\n      this._injectedTextDecorationsTree.delete(node);\n    } else if (isNodeInOverviewRuler(node)) {\n      this._decorationsTree1.delete(node);\n    } else {\n      this._decorationsTree0.delete(node);\n    }\n  }\n  getNodeRange(host, node) {\n    const versionId = host.getVersionId();\n    if (node.cachedVersionId !== versionId) {\n      this._resolveNode(node, versionId);\n    }\n    if (node.range === null) {\n      node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n    }\n    return node.range;\n  }\n  _resolveNode(node, cachedVersionId) {\n    if (isNodeInjectedText(node)) {\n      this._injectedTextDecorationsTree.resolveNode(node, cachedVersionId);\n    } else if (isNodeInOverviewRuler(node)) {\n      this._decorationsTree1.resolveNode(node, cachedVersionId);\n    } else {\n      this._decorationsTree0.resolveNode(node, cachedVersionId);\n    }\n  }\n  acceptReplace(offset, length, textLength, forceMoveMarkers) {\n    this._decorationsTree0.acceptReplace(offset, length, textLength, forceMoveMarkers);\n    this._decorationsTree1.acceptReplace(offset, length, textLength, forceMoveMarkers);\n    this._injectedTextDecorationsTree.acceptReplace(offset, length, textLength, forceMoveMarkers);\n  }\n}\nfunction cleanClassName(className) {\n  return className.replace(/[^a-z0-9\\-_]/gi, ' ');\n}\nclass DecorationOptions {\n  constructor(options) {\n    this.color = options.color || '';\n    this.darkColor = options.darkColor || '';\n  }\n}\nexport class ModelDecorationOverviewRulerOptions extends DecorationOptions {\n  constructor(options) {\n    super(options);\n    this._resolvedColor = null;\n    this.position = typeof options.position === 'number' ? options.position : model.OverviewRulerLane.Center;\n  }\n  getColor(theme) {\n    if (!this._resolvedColor) {\n      if (theme.type !== 'light' && this.darkColor) {\n        this._resolvedColor = this._resolveColor(this.darkColor, theme);\n      } else {\n        this._resolvedColor = this._resolveColor(this.color, theme);\n      }\n    }\n    return this._resolvedColor;\n  }\n  invalidateCachedColor() {\n    this._resolvedColor = null;\n  }\n  _resolveColor(color, theme) {\n    if (typeof color === 'string') {\n      return color;\n    }\n    const c = color ? theme.getColor(color.id) : null;\n    if (!c) {\n      return '';\n    }\n    return c.toString();\n  }\n}\nexport class ModelDecorationGlyphMarginOptions {\n  constructor(options) {\n    var _a;\n    this.position = (_a = options === null || options === void 0 ? void 0 : options.position) !== null && _a !== void 0 ? _a : model.GlyphMarginLane.Center;\n    this.persistLane = options === null || options === void 0 ? void 0 : options.persistLane;\n  }\n}\nexport class ModelDecorationMinimapOptions extends DecorationOptions {\n  constructor(options) {\n    var _a, _b;\n    super(options);\n    this.position = options.position;\n    this.sectionHeaderStyle = (_a = options.sectionHeaderStyle) !== null && _a !== void 0 ? _a : null;\n    this.sectionHeaderText = (_b = options.sectionHeaderText) !== null && _b !== void 0 ? _b : null;\n  }\n  getColor(theme) {\n    if (!this._resolvedColor) {\n      if (theme.type !== 'light' && this.darkColor) {\n        this._resolvedColor = this._resolveColor(this.darkColor, theme);\n      } else {\n        this._resolvedColor = this._resolveColor(this.color, theme);\n      }\n    }\n    return this._resolvedColor;\n  }\n  invalidateCachedColor() {\n    this._resolvedColor = undefined;\n  }\n  _resolveColor(color, theme) {\n    if (typeof color === 'string') {\n      return Color.fromHex(color);\n    }\n    return theme.getColor(color.id);\n  }\n}\nexport class ModelDecorationInjectedTextOptions {\n  static from(options) {\n    if (options instanceof ModelDecorationInjectedTextOptions) {\n      return options;\n    }\n    return new ModelDecorationInjectedTextOptions(options);\n  }\n  constructor(options) {\n    this.content = options.content || '';\n    this.inlineClassName = options.inlineClassName || null;\n    this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n    this.attachedData = options.attachedData || null;\n    this.cursorStops = options.cursorStops || null;\n  }\n}\nexport class ModelDecorationOptions {\n  static register(options) {\n    return new ModelDecorationOptions(options);\n  }\n  static createDynamic(options) {\n    return new ModelDecorationOptions(options);\n  }\n  constructor(options) {\n    var _a, _b, _c, _d, _e, _f;\n    this.description = options.description;\n    this.blockClassName = options.blockClassName ? cleanClassName(options.blockClassName) : null;\n    this.blockDoesNotCollapse = (_a = options.blockDoesNotCollapse) !== null && _a !== void 0 ? _a : null;\n    this.blockIsAfterEnd = (_b = options.blockIsAfterEnd) !== null && _b !== void 0 ? _b : null;\n    this.blockPadding = (_c = options.blockPadding) !== null && _c !== void 0 ? _c : null;\n    this.stickiness = options.stickiness || 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */;\n    this.zIndex = options.zIndex || 0;\n    this.className = options.className ? cleanClassName(options.className) : null;\n    this.shouldFillLineOnLineBreak = (_d = options.shouldFillLineOnLineBreak) !== null && _d !== void 0 ? _d : null;\n    this.hoverMessage = options.hoverMessage || null;\n    this.glyphMarginHoverMessage = options.glyphMarginHoverMessage || null;\n    this.lineNumberHoverMessage = options.lineNumberHoverMessage || null;\n    this.isWholeLine = options.isWholeLine || false;\n    this.showIfCollapsed = options.showIfCollapsed || false;\n    this.collapseOnReplaceEdit = options.collapseOnReplaceEdit || false;\n    this.overviewRuler = options.overviewRuler ? new ModelDecorationOverviewRulerOptions(options.overviewRuler) : null;\n    this.minimap = options.minimap ? new ModelDecorationMinimapOptions(options.minimap) : null;\n    this.glyphMargin = options.glyphMarginClassName ? new ModelDecorationGlyphMarginOptions(options.glyphMargin) : null;\n    this.glyphMarginClassName = options.glyphMarginClassName ? cleanClassName(options.glyphMarginClassName) : null;\n    this.linesDecorationsClassName = options.linesDecorationsClassName ? cleanClassName(options.linesDecorationsClassName) : null;\n    this.lineNumberClassName = options.lineNumberClassName ? cleanClassName(options.lineNumberClassName) : null;\n    this.linesDecorationsTooltip = options.linesDecorationsTooltip ? strings.htmlAttributeEncodeValue(options.linesDecorationsTooltip) : null;\n    this.firstLineDecorationClassName = options.firstLineDecorationClassName ? cleanClassName(options.firstLineDecorationClassName) : null;\n    this.marginClassName = options.marginClassName ? cleanClassName(options.marginClassName) : null;\n    this.inlineClassName = options.inlineClassName ? cleanClassName(options.inlineClassName) : null;\n    this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n    this.beforeContentClassName = options.beforeContentClassName ? cleanClassName(options.beforeContentClassName) : null;\n    this.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : null;\n    this.after = options.after ? ModelDecorationInjectedTextOptions.from(options.after) : null;\n    this.before = options.before ? ModelDecorationInjectedTextOptions.from(options.before) : null;\n    this.hideInCommentTokens = (_e = options.hideInCommentTokens) !== null && _e !== void 0 ? _e : false;\n    this.hideInStringTokens = (_f = options.hideInStringTokens) !== null && _f !== void 0 ? _f : false;\n  }\n}\nModelDecorationOptions.EMPTY = ModelDecorationOptions.register({\n  description: 'empty'\n});\n/**\n * The order carefully matches the values of the enum.\n */\nconst TRACKED_RANGE_OPTIONS = [ModelDecorationOptions.register({\n  description: 'tracked-range-always-grows-when-typing-at-edges',\n  stickiness: 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */\n}), ModelDecorationOptions.register({\n  description: 'tracked-range-never-grows-when-typing-at-edges',\n  stickiness: 1 /* model.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n}), ModelDecorationOptions.register({\n  description: 'tracked-range-grows-only-when-typing-before',\n  stickiness: 2 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */\n}), ModelDecorationOptions.register({\n  description: 'tracked-range-grows-only-when-typing-after',\n  stickiness: 3 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */\n})];\nfunction _normalizeOptions(options) {\n  if (options instanceof ModelDecorationOptions) {\n    return options;\n  }\n  return ModelDecorationOptions.createDynamic(options);\n}\nclass DidChangeDecorationsEmitter extends Disposable {\n  constructor(handleBeforeFire) {\n    super();\n    this.handleBeforeFire = handleBeforeFire;\n    this._actual = this._register(new Emitter());\n    this.event = this._actual.event;\n    this._affectedInjectedTextLines = null;\n    this._deferredCnt = 0;\n    this._shouldFireDeferred = false;\n    this._affectsMinimap = false;\n    this._affectsOverviewRuler = false;\n    this._affectsGlyphMargin = false;\n    this._affectsLineNumber = false;\n  }\n  beginDeferredEmit() {\n    this._deferredCnt++;\n  }\n  endDeferredEmit() {\n    var _a;\n    this._deferredCnt--;\n    if (this._deferredCnt === 0) {\n      if (this._shouldFireDeferred) {\n        this.doFire();\n      }\n      (_a = this._affectedInjectedTextLines) === null || _a === void 0 ? void 0 : _a.clear();\n      this._affectedInjectedTextLines = null;\n    }\n  }\n  recordLineAffectedByInjectedText(lineNumber) {\n    if (!this._affectedInjectedTextLines) {\n      this._affectedInjectedTextLines = new Set();\n    }\n    this._affectedInjectedTextLines.add(lineNumber);\n  }\n  checkAffectedAndFire(options) {\n    var _a, _b;\n    this._affectsMinimap || (this._affectsMinimap = !!((_a = options.minimap) === null || _a === void 0 ? void 0 : _a.position));\n    this._affectsOverviewRuler || (this._affectsOverviewRuler = !!((_b = options.overviewRuler) === null || _b === void 0 ? void 0 : _b.color));\n    this._affectsGlyphMargin || (this._affectsGlyphMargin = !!options.glyphMarginClassName);\n    this._affectsLineNumber || (this._affectsLineNumber = !!options.lineNumberClassName);\n    this.tryFire();\n  }\n  fire() {\n    this._affectsMinimap = true;\n    this._affectsOverviewRuler = true;\n    this._affectsGlyphMargin = true;\n    this.tryFire();\n  }\n  tryFire() {\n    if (this._deferredCnt === 0) {\n      this.doFire();\n    } else {\n      this._shouldFireDeferred = true;\n    }\n  }\n  doFire() {\n    this.handleBeforeFire(this._affectedInjectedTextLines);\n    const event = {\n      affectsMinimap: this._affectsMinimap,\n      affectsOverviewRuler: this._affectsOverviewRuler,\n      affectsGlyphMargin: this._affectsGlyphMargin,\n      affectsLineNumber: this._affectsLineNumber\n    };\n    this._shouldFireDeferred = false;\n    this._affectsMinimap = false;\n    this._affectsOverviewRuler = false;\n    this._affectsGlyphMargin = false;\n    this._actual.fire(event);\n  }\n}\n//#endregion\nclass DidChangeContentEmitter extends Disposable {\n  constructor() {\n    super();\n    /**\n     * Both `fastEvent` and `slowEvent` work the same way and contain the same events, but first we invoke `fastEvent` and then `slowEvent`.\n     */\n    this._fastEmitter = this._register(new Emitter());\n    this.fastEvent = this._fastEmitter.event;\n    this._slowEmitter = this._register(new Emitter());\n    this.slowEvent = this._slowEmitter.event;\n    this._deferredCnt = 0;\n    this._deferredEvent = null;\n  }\n  beginDeferredEmit() {\n    this._deferredCnt++;\n  }\n  endDeferredEmit() {\n    let resultingSelection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    this._deferredCnt--;\n    if (this._deferredCnt === 0) {\n      if (this._deferredEvent !== null) {\n        this._deferredEvent.rawContentChangedEvent.resultingSelection = resultingSelection;\n        const e = this._deferredEvent;\n        this._deferredEvent = null;\n        this._fastEmitter.fire(e);\n        this._slowEmitter.fire(e);\n      }\n    }\n  }\n  fire(e) {\n    if (this._deferredCnt > 0) {\n      if (this._deferredEvent) {\n        this._deferredEvent = this._deferredEvent.merge(e);\n      } else {\n        this._deferredEvent = e;\n      }\n      return;\n    }\n    this._fastEmitter.fire(e);\n    this._slowEmitter.fire(e);\n  }\n}\n/**\n * @internal\n */\nexport class AttachedViews {\n  constructor() {\n    this._onDidChangeVisibleRanges = new Emitter();\n    this.onDidChangeVisibleRanges = this._onDidChangeVisibleRanges.event;\n    this._views = new Set();\n  }\n  attachView() {\n    const view = new AttachedViewImpl(state => {\n      this._onDidChangeVisibleRanges.fire({\n        view,\n        state\n      });\n    });\n    this._views.add(view);\n    return view;\n  }\n  detachView(view) {\n    this._views.delete(view);\n    this._onDidChangeVisibleRanges.fire({\n      view,\n      state: undefined\n    });\n  }\n}\nclass AttachedViewImpl {\n  constructor(handleStateChange) {\n    this.handleStateChange = handleStateChange;\n  }\n  setVisibleLines(visibleLines, stabilized) {\n    const visibleLineRanges = visibleLines.map(line => new LineRange(line.startLineNumber, line.endLineNumber + 1));\n    this.handleStateChange({\n      visibleLineRanges,\n      stabilized\n    });\n  }\n}","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","TextModel_1","ArrayQueue","pushMany","Color","BugIndicatingError","illegalArgument","onUnexpectedError","Emitter","Disposable","MutableDisposable","combinedDisposable","strings","URI","countEOL","normalizeIndentation","LineRange","Position","Range","Selection","EDITOR_MODEL_DEFAULTS","ILanguageService","ILanguageConfigurationService","model","BracketPairsTextModelPart","ColorizedBracketPairsDecorationProvider","EditStack","GuidesTextModelPart","guessIndentation","IntervalNode","IntervalTree","recomputeMaxEnd","PieceTreeTextBuffer","PieceTreeTextBufferBuilder","SearchParams","TextModelSearch","TokenizationTextModelPart","InternalModelContentChangeEvent","LineInjectedText","ModelInjectedTextChangedEvent","ModelRawContentChangedEvent","ModelRawEOLChanged","ModelRawFlush","ModelRawLineChanged","ModelRawLinesDeleted","ModelRawLinesInserted","IUndoRedoService","createTextBufferFactory","text","builder","acceptChunk","finish","createTextBufferFactoryFromSnapshot","snapshot","chunk","read","createTextBuffer","value","defaultEOL","factory","isITextSnapshot","create","MODEL_ID","LIMIT_FIND_COUNT","LONG_LINE_BOUNDARY","TextModelSnapshot","constructor","source","_source","_eos","result","resultCnt","resultLength","tmp","join","invalidFunc","Error","TextModel","resolveOptions","textBuffer","options","detectIndentation","guessedIndentation","tabSize","insertSpaces","TextModelResolvedOptions","indentSize","trimAutoWhitespace","bracketPairColorizationOptions","onDidChangeLanguage","_tokenizationTextModelPart","onDidChangeLanguageConfiguration","onDidChangeTokens","onDidChangeContent","listener","_eventEmitter","slowEvent","e","contentChangedEvent","onDidChangeContentOrInjectedText","fastEvent","_onDidChangeInjectedText","event","_isDisposing","__isDisposing","tokenization","bracketPairs","_bracketPairs","guides","_guidesTextModelPart","languageIdOrSelection","creationOptions","associatedResource","undefined","_undoRedoService","_languageService","_languageConfigurationService","_onWillDispose","_register","onWillDispose","_onDidChangeDecorations","DidChangeDecorationsEmitter","affectedInjectedTextLines","handleBeforeFireDecorationsChangedEvent","onDidChangeDecorations","_onDidChangeOptions","onDidChangeOptions","_onDidChangeAttached","onDidChangeAttached","DidChangeContentEmitter","_languageSelectionListener","_deltaDecorationCallCnt","_attachedViews","AttachedViews","id","isForSimpleWidget","_associatedResource","parse","_attachedEditorCount","disposable","_buffer","_bufferDisposable","_options","languageId","onDidChange","_setLanguage","_decorationProvider","bufferLineCount","getLineCount","bufferTextLength","getValueLengthInRange","getLineLength","largeFileOptimizations","_isTooLargeForTokenization","LARGE_FILE_SIZE_THRESHOLD","LARGE_FILE_LINE_COUNT_THRESHOLD","_isTooLargeForHeapOperation","LARGE_FILE_HEAP_OPERATION_THRESHOLD","_isTooLargeForSyncing","_MODEL_SYNC_LIMIT","_versionId","_alternativeVersionId","_initialUndoRedoSnapshot","_isDisposed","_instanceId","singleLetterHash","_lastDecorationId","_decorations","_decorationsTree","DecorationsTrees","_commandManager","_isUndoing","_isRedoing","_trimAutoWhitespaceLines","beginDeferredEmit","fire","endDeferredEmit","requestRichLanguageFeatures","dispose","emptyDisposedTextBuffer","None","_assertNotDisposed","_emitContentChangedEvent","rawChange","change","handleDidChangeContent","setValue","_setValueFromTextBuffer","_createContentChanged2","range","rangeOffset","rangeLength","isUndoing","isRedoing","isFlush","isEolChange","changes","eol","getEOL","versionId","getVersionId","textBufferDisposable","oldFullModelRange","getFullModelRange","oldModelValueLength","endLineNumber","endColumn","getLineMaxColumn","_increaseVersionId","clear","getValue","setEOL","newEOL","_onBeforeEOLChange","_onAfterEOLChange","ensureAllNodesHaveRanges","allDecorations","collectNodesPostOrder","len","node","delta","cachedAbsoluteStart","start","startOffset","getOffsetAt","startLineNumber","startColumn","endOffset","cachedAbsoluteEnd","cachedVersionId","end","onBeforeAttached","handleDidChangeAttached","attachView","onBeforeDetached","view","detachView","isAttachedToEditor","getAttachedEditorCount","isTooLargeForSyncing","isTooLargeForTokenization","isTooLargeForHeapOperation","isDisposed","isDominatedByLongLines","smallLineCharCount","longLineCharCount","lineCount","lineNumber","lineLength","uri","getOptions","getFormattingOptions","updateOptions","_newOpts","originalIndentSize","bracketColorizationOptions","newOpts","equals","createChangeEvent","handleDidChangeOptions","defaultInsertSpaces","defaultTabSize","str","mightContainRTL","mightContainUnusualLineTerminators","removeUnusualLineTerminators","selections","matches","findMatches","UNUSUAL_LINE_TERMINATORS","resetMightContainUnusualLineTerminators","pushEditOperations","map","m","mightContainNonBasicASCII","getAlternativeVersionId","getInitialUndoRedoSnapshot","rawPosition","position","_validatePosition","column","getPositionAt","rawOffset","offset","Math","min","getLength","max","_overwriteVersionId","_overwriteAlternativeVersionId","newAlternativeVersionId","_overwriteInitialUndoRedoSnapshot","newInitialUndoRedoSnapshot","preserveBOM","fullModelRange","fullModelValue","getValueInRange","getBOM","createSnapshot","getValueLength","rawRange","validateRange","getCharacterCountInRange","getLineContent","getLinesContent","getEndOfLineSequence","getLineMinColumn","getLineFirstNonWhitespaceColumn","getLineLastNonWhitespaceColumn","_validateRangeRelaxedNoAllocations","linesCount","initialStartLineNumber","initialStartColumn","floor","isNaN","maxColumn","initialEndLineNumber","initialEndColumn","_isValidPosition","validationType","charCodeBefore","getLineCharCode","isHighSurrogate","_lineNumber","_column","validatePosition","_isValidRange","charCodeBeforeStart","charCodeBeforeEnd","startInsideSurrogatePair","endInsideSurrogatePair","_range","modifyPosition","candidate","findMatchesLineByLine","searchRange","searchData","captureMatches","limitResultCount","searchString","rawSearchScope","isRegex","matchCase","wordSeparators","searchRanges","Array","isArray","every","searchScope","isIRange","sort","d1","d2","uniqueSearchRanges","push","reduce","prev","curr","areIntersecting","plusRange","matchMapper","indexOf","searchParams","parseSearchRequest","arr","concat","findNextMatch","rawSearchStart","searchStart","ret","findPreviousMatch","pushStackElement","popStackElement","pushEOL","currentEOL","_validateEditOperation","rawOperation","ValidAnnotatedEditOperation","identifier","forceMoveMarkers","isAutoWhitespaceEdit","_isTracked","_validateEditOperations","rawOperations","beforeCursorState","editOperations","cursorStateComputer","group","_pushEditOperations","incomingEdits","op","editsAreNearCursors","sel","foundEditNearSel","j","lenJ","editRange","selIsAbove","selIsBelow","trimLineNumber","maxLineColumn","allowTrimLine","editText","isEmpty","charAt","trimRange","pushEditOperation","_applyUndo","resultingAlternativeVersionId","resultingSelection","edits","rangeStart","newPosition","rangeEnd","newEnd","oldText","_applyUndoRedoEdits","_applyRedo","oldPosition","oldEnd","newText","applyEdits","computeUndoEdits","operations","_doApplyEdits","oldLineCount","newLineCount","contentChanges","trimAutoWhitespaceLineNumbers","acceptReplace","rawContentChanges","eolCount","deletingLinesCnt","insertingLinesCnt","editingLinesCnt","changeLineCountDelta","currentEditStartLineNumber","firstEditLineNumber","lastInsertedLineNumber","decorationsWithInjectedTextInEditedRange","getInjectedTextInInterval","injectedTextInEditedRange","fromDecorations","injectedTextInEditedRangeQueue","editLineNumber","currentEditLineNumber","takeFromEndWhile","decorationsInCurrentLine","spliceStartLineNumber","spliceLineNumber","cnt","fromLineNumber","injectedTexts","newLines","takeWhile","reverseEdits","undo","canUndo","redo","canRedo","size","affectedLines","from","lineChangeEvents","_getInjectedTextInLine","changeDecorations","callback","ownerId","_changeDecorations","changeAccessor","addDecoration","_deltaDecorationsImpl","changeDecoration","newRange","_changeDecorationImpl","changeDecorationOptions","_changeDecorationOptionsImpl","_normalizeOptions","removeDecoration","deltaDecorations","oldDecorations","newDecorations","console","warn","_getTrackedRange","getDecorationRange","_setTrackedRange","newStickiness","TRACKED_RANGE_OPTIONS","delete","reset","setOptions","insert","removeAllDecorationsWithOwnerId","nodes","collectNodesFromOwner","getDecorationOptions","decorationId","getNodeRange","getLineDecorations","filterOutValidation","getLinesDecorations","_startLineNumber","_endLineNumber","onlyMarginDecorations","decorations","_getDecorationsInRange","getDecorationsInRange","onlyMinimapDecorations","validatedRange","getOverviewRulerDecorations","getAll","getInjectedTextDecorations","getAllInjectedText","filter","t","getAllDecorations","getAllMarginDecorations","filterRange","filterOwnerId","getAllInInterval","getRangeAt","after","oldRange","recordLineAffectedByInjectedText","before","checkAffectedAndFire","nodeWasInOverviewRuler","overviewRuler","color","nodeIsInOverviewRuler","nodeRange","movedInOverviewRuler","changedWhetherInjectedText","isOptionsInjectedText","isNodeInjectedText","oldDecorationsIds","suppressEvents","oldDecorationsLen","oldDecorationIndex","newDecorationsLen","newDecorationIndex","internalDecorationId","newDecoration","getLanguageId","setLanguage","setLanguageId","getLanguageIdAtPosition","getWordAtPosition","getWordUntilPosition","normalizePosition","affinity","getLineIndentColumn","indentOfLine","DEFAULT_CREATION_OPTIONS","line","indent","isNodeInOverviewRuler","_decorationsTree0","_decorationsTree1","_injectedTextDecorationsTree","host","_ensureNodesHaveRanges","_intervalSearch","r0","intervalSearch","r1","r2","showIfCollapsed","search","overviewRulerOnly","_search","_resolveNode","resolveNode","textLength","cleanClassName","className","replace","DecorationOptions","darkColor","ModelDecorationOverviewRulerOptions","_resolvedColor","OverviewRulerLane","Center","getColor","theme","type","_resolveColor","invalidateCachedColor","toString","ModelDecorationGlyphMarginOptions","_a","GlyphMarginLane","persistLane","ModelDecorationMinimapOptions","_b","sectionHeaderStyle","sectionHeaderText","fromHex","ModelDecorationInjectedTextOptions","content","inlineClassName","inlineClassNameAffectsLetterSpacing","attachedData","cursorStops","ModelDecorationOptions","register","createDynamic","_c","_d","_e","_f","description","blockClassName","blockDoesNotCollapse","blockIsAfterEnd","blockPadding","stickiness","zIndex","shouldFillLineOnLineBreak","hoverMessage","glyphMarginHoverMessage","lineNumberHoverMessage","isWholeLine","collapseOnReplaceEdit","minimap","glyphMargin","glyphMarginClassName","linesDecorationsClassName","lineNumberClassName","linesDecorationsTooltip","htmlAttributeEncodeValue","firstLineDecorationClassName","marginClassName","beforeContentClassName","afterContentClassName","hideInCommentTokens","hideInStringTokens","EMPTY","handleBeforeFire","_actual","_affectedInjectedTextLines","_deferredCnt","_shouldFireDeferred","_affectsMinimap","_affectsOverviewRuler","_affectsGlyphMargin","_affectsLineNumber","doFire","Set","add","tryFire","affectsMinimap","affectsOverviewRuler","affectsGlyphMargin","affectsLineNumber","_fastEmitter","_slowEmitter","_deferredEvent","rawContentChangedEvent","merge","_onDidChangeVisibleRanges","onDidChangeVisibleRanges","_views","AttachedViewImpl","state","handleStateChange","setVisibleLines","visibleLines","stabilized","visibleLineRanges"],"sources":["/home/arslan/modojo/node_modules/monaco-editor/esm/vs/editor/common/model/textModel.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar TextModel_1;\nimport { ArrayQueue, pushMany } from '../../../base/common/arrays.js';\nimport { Color } from '../../../base/common/color.js';\nimport { BugIndicatingError, illegalArgument, onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, MutableDisposable, combinedDisposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { normalizeIndentation } from '../core/indentation.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../core/textModelDefaults.js';\nimport { ILanguageService } from '../languages/language.js';\nimport { ILanguageConfigurationService } from '../languages/languageConfigurationRegistry.js';\nimport * as model from '../model.js';\nimport { BracketPairsTextModelPart } from './bracketPairsTextModelPart/bracketPairsImpl.js';\nimport { ColorizedBracketPairsDecorationProvider } from './bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js';\nimport { EditStack } from './editStack.js';\nimport { GuidesTextModelPart } from './guidesTextModelPart.js';\nimport { guessIndentation } from './indentationGuesser.js';\nimport { IntervalNode, IntervalTree, recomputeMaxEnd } from './intervalTree.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer/pieceTreeTextBuffer.js';\nimport { PieceTreeTextBufferBuilder } from './pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js';\nimport { SearchParams, TextModelSearch } from './textModelSearch.js';\nimport { TokenizationTextModelPart } from './tokenizationTextModelPart.js';\nimport { InternalModelContentChangeEvent, LineInjectedText, ModelInjectedTextChangedEvent, ModelRawContentChangedEvent, ModelRawEOLChanged, ModelRawFlush, ModelRawLineChanged, ModelRawLinesDeleted, ModelRawLinesInserted } from '../textModelEvents.js';\nimport { IUndoRedoService } from '../../../platform/undoRedo/common/undoRedo.js';\nexport function createTextBufferFactory(text) {\n    const builder = new PieceTreeTextBufferBuilder();\n    builder.acceptChunk(text);\n    return builder.finish();\n}\nexport function createTextBufferFactoryFromSnapshot(snapshot) {\n    const builder = new PieceTreeTextBufferBuilder();\n    let chunk;\n    while (typeof (chunk = snapshot.read()) === 'string') {\n        builder.acceptChunk(chunk);\n    }\n    return builder.finish();\n}\nexport function createTextBuffer(value, defaultEOL) {\n    let factory;\n    if (typeof value === 'string') {\n        factory = createTextBufferFactory(value);\n    }\n    else if (model.isITextSnapshot(value)) {\n        factory = createTextBufferFactoryFromSnapshot(value);\n    }\n    else {\n        factory = value;\n    }\n    return factory.create(defaultEOL);\n}\nlet MODEL_ID = 0;\nconst LIMIT_FIND_COUNT = 999;\nconst LONG_LINE_BOUNDARY = 10000;\nclass TextModelSnapshot {\n    constructor(source) {\n        this._source = source;\n        this._eos = false;\n    }\n    read() {\n        if (this._eos) {\n            return null;\n        }\n        const result = [];\n        let resultCnt = 0;\n        let resultLength = 0;\n        do {\n            const tmp = this._source.read();\n            if (tmp === null) {\n                // end-of-stream\n                this._eos = true;\n                if (resultCnt === 0) {\n                    return null;\n                }\n                else {\n                    return result.join('');\n                }\n            }\n            if (tmp.length > 0) {\n                result[resultCnt++] = tmp;\n                resultLength += tmp.length;\n            }\n            if (resultLength >= 64 * 1024) {\n                return result.join('');\n            }\n        } while (true);\n    }\n}\nconst invalidFunc = () => { throw new Error(`Invalid change accessor`); };\nlet TextModel = TextModel_1 = class TextModel extends Disposable {\n    static resolveOptions(textBuffer, options) {\n        if (options.detectIndentation) {\n            const guessedIndentation = guessIndentation(textBuffer, options.tabSize, options.insertSpaces);\n            return new model.TextModelResolvedOptions({\n                tabSize: guessedIndentation.tabSize,\n                indentSize: 'tabSize', // TODO@Alex: guess indentSize independent of tabSize\n                insertSpaces: guessedIndentation.insertSpaces,\n                trimAutoWhitespace: options.trimAutoWhitespace,\n                defaultEOL: options.defaultEOL,\n                bracketPairColorizationOptions: options.bracketPairColorizationOptions,\n            });\n        }\n        return new model.TextModelResolvedOptions(options);\n    }\n    get onDidChangeLanguage() { return this._tokenizationTextModelPart.onDidChangeLanguage; }\n    get onDidChangeLanguageConfiguration() { return this._tokenizationTextModelPart.onDidChangeLanguageConfiguration; }\n    get onDidChangeTokens() { return this._tokenizationTextModelPart.onDidChangeTokens; }\n    onDidChangeContent(listener) {\n        return this._eventEmitter.slowEvent((e) => listener(e.contentChangedEvent));\n    }\n    onDidChangeContentOrInjectedText(listener) {\n        return combinedDisposable(this._eventEmitter.fastEvent(e => listener(e)), this._onDidChangeInjectedText.event(e => listener(e)));\n    }\n    _isDisposing() { return this.__isDisposing; }\n    get tokenization() { return this._tokenizationTextModelPart; }\n    get bracketPairs() { return this._bracketPairs; }\n    get guides() { return this._guidesTextModelPart; }\n    constructor(source, languageIdOrSelection, creationOptions, associatedResource = null, _undoRedoService, _languageService, _languageConfigurationService) {\n        super();\n        this._undoRedoService = _undoRedoService;\n        this._languageService = _languageService;\n        this._languageConfigurationService = _languageConfigurationService;\n        //#region Events\n        this._onWillDispose = this._register(new Emitter());\n        this.onWillDispose = this._onWillDispose.event;\n        this._onDidChangeDecorations = this._register(new DidChangeDecorationsEmitter(affectedInjectedTextLines => this.handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines)));\n        this.onDidChangeDecorations = this._onDidChangeDecorations.event;\n        this._onDidChangeOptions = this._register(new Emitter());\n        this.onDidChangeOptions = this._onDidChangeOptions.event;\n        this._onDidChangeAttached = this._register(new Emitter());\n        this.onDidChangeAttached = this._onDidChangeAttached.event;\n        this._onDidChangeInjectedText = this._register(new Emitter());\n        this._eventEmitter = this._register(new DidChangeContentEmitter());\n        this._languageSelectionListener = this._register(new MutableDisposable());\n        this._deltaDecorationCallCnt = 0;\n        this._attachedViews = new AttachedViews();\n        // Generate a new unique model id\n        MODEL_ID++;\n        this.id = '$model' + MODEL_ID;\n        this.isForSimpleWidget = creationOptions.isForSimpleWidget;\n        if (typeof associatedResource === 'undefined' || associatedResource === null) {\n            this._associatedResource = URI.parse('inmemory://model/' + MODEL_ID);\n        }\n        else {\n            this._associatedResource = associatedResource;\n        }\n        this._attachedEditorCount = 0;\n        const { textBuffer, disposable } = createTextBuffer(source, creationOptions.defaultEOL);\n        this._buffer = textBuffer;\n        this._bufferDisposable = disposable;\n        this._options = TextModel_1.resolveOptions(this._buffer, creationOptions);\n        const languageId = (typeof languageIdOrSelection === 'string' ? languageIdOrSelection : languageIdOrSelection.languageId);\n        if (typeof languageIdOrSelection !== 'string') {\n            this._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId));\n        }\n        this._bracketPairs = this._register(new BracketPairsTextModelPart(this, this._languageConfigurationService));\n        this._guidesTextModelPart = this._register(new GuidesTextModelPart(this, this._languageConfigurationService));\n        this._decorationProvider = this._register(new ColorizedBracketPairsDecorationProvider(this));\n        this._tokenizationTextModelPart = new TokenizationTextModelPart(this._languageService, this._languageConfigurationService, this, this._bracketPairs, languageId, this._attachedViews);\n        const bufferLineCount = this._buffer.getLineCount();\n        const bufferTextLength = this._buffer.getValueLengthInRange(new Range(1, 1, bufferLineCount, this._buffer.getLineLength(bufferLineCount) + 1), 0 /* model.EndOfLinePreference.TextDefined */);\n        // !!! Make a decision in the ctor and permanently respect this decision !!!\n        // If a model is too large at construction time, it will never get tokenized,\n        // under no circumstances.\n        if (creationOptions.largeFileOptimizations) {\n            this._isTooLargeForTokenization = ((bufferTextLength > TextModel_1.LARGE_FILE_SIZE_THRESHOLD)\n                || (bufferLineCount > TextModel_1.LARGE_FILE_LINE_COUNT_THRESHOLD));\n            this._isTooLargeForHeapOperation = bufferTextLength > TextModel_1.LARGE_FILE_HEAP_OPERATION_THRESHOLD;\n        }\n        else {\n            this._isTooLargeForTokenization = false;\n            this._isTooLargeForHeapOperation = false;\n        }\n        this._isTooLargeForSyncing = (bufferTextLength > TextModel_1._MODEL_SYNC_LIMIT);\n        this._versionId = 1;\n        this._alternativeVersionId = 1;\n        this._initialUndoRedoSnapshot = null;\n        this._isDisposed = false;\n        this.__isDisposing = false;\n        this._instanceId = strings.singleLetterHash(MODEL_ID);\n        this._lastDecorationId = 0;\n        this._decorations = Object.create(null);\n        this._decorationsTree = new DecorationsTrees();\n        this._commandManager = new EditStack(this, this._undoRedoService);\n        this._isUndoing = false;\n        this._isRedoing = false;\n        this._trimAutoWhitespaceLines = null;\n        this._register(this._decorationProvider.onDidChange(() => {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._onDidChangeDecorations.fire();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }));\n        this._languageService.requestRichLanguageFeatures(languageId);\n    }\n    dispose() {\n        this.__isDisposing = true;\n        this._onWillDispose.fire();\n        this._tokenizationTextModelPart.dispose();\n        this._isDisposed = true;\n        super.dispose();\n        this._bufferDisposable.dispose();\n        this.__isDisposing = false;\n        // Manually release reference to previous text buffer to avoid large leaks\n        // in case someone leaks a TextModel reference\n        const emptyDisposedTextBuffer = new PieceTreeTextBuffer([], '', '\\n', false, false, true, true);\n        emptyDisposedTextBuffer.dispose();\n        this._buffer = emptyDisposedTextBuffer;\n        this._bufferDisposable = Disposable.None;\n    }\n    _assertNotDisposed() {\n        if (this._isDisposed) {\n            throw new Error('Model is disposed!');\n        }\n    }\n    _emitContentChangedEvent(rawChange, change) {\n        if (this.__isDisposing) {\n            // Do not confuse listeners by emitting any event after disposing\n            return;\n        }\n        this._tokenizationTextModelPart.handleDidChangeContent(change);\n        this._bracketPairs.handleDidChangeContent(change);\n        this._eventEmitter.fire(new InternalModelContentChangeEvent(rawChange, change));\n    }\n    setValue(value) {\n        this._assertNotDisposed();\n        if (value === null || value === undefined) {\n            throw illegalArgument();\n        }\n        const { textBuffer, disposable } = createTextBuffer(value, this._options.defaultEOL);\n        this._setValueFromTextBuffer(textBuffer, disposable);\n    }\n    _createContentChanged2(range, rangeOffset, rangeLength, text, isUndoing, isRedoing, isFlush, isEolChange) {\n        return {\n            changes: [{\n                    range: range,\n                    rangeOffset: rangeOffset,\n                    rangeLength: rangeLength,\n                    text: text,\n                }],\n            eol: this._buffer.getEOL(),\n            isEolChange: isEolChange,\n            versionId: this.getVersionId(),\n            isUndoing: isUndoing,\n            isRedoing: isRedoing,\n            isFlush: isFlush\n        };\n    }\n    _setValueFromTextBuffer(textBuffer, textBufferDisposable) {\n        this._assertNotDisposed();\n        const oldFullModelRange = this.getFullModelRange();\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        const endLineNumber = this.getLineCount();\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        this._buffer = textBuffer;\n        this._bufferDisposable.dispose();\n        this._bufferDisposable = textBufferDisposable;\n        this._increaseVersionId();\n        // Destroy all my decorations\n        this._decorations = Object.create(null);\n        this._decorationsTree = new DecorationsTrees();\n        // Destroy my edit history and settings\n        this._commandManager.clear();\n        this._trimAutoWhitespaceLines = null;\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\n            new ModelRawFlush()\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, true, false));\n    }\n    setEOL(eol) {\n        this._assertNotDisposed();\n        const newEOL = (eol === 1 /* model.EndOfLineSequence.CRLF */ ? '\\r\\n' : '\\n');\n        if (this._buffer.getEOL() === newEOL) {\n            // Nothing to do\n            return;\n        }\n        const oldFullModelRange = this.getFullModelRange();\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        const endLineNumber = this.getLineCount();\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        this._onBeforeEOLChange();\n        this._buffer.setEOL(newEOL);\n        this._increaseVersionId();\n        this._onAfterEOLChange();\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\n            new ModelRawEOLChanged()\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, false, true));\n    }\n    _onBeforeEOLChange() {\n        // Ensure all decorations get their `range` set.\n        this._decorationsTree.ensureAllNodesHaveRanges(this);\n    }\n    _onAfterEOLChange() {\n        // Transform back `range` to offsets\n        const versionId = this.getVersionId();\n        const allDecorations = this._decorationsTree.collectNodesPostOrder();\n        for (let i = 0, len = allDecorations.length; i < len; i++) {\n            const node = allDecorations[i];\n            const range = node.range; // the range is defined due to `_onBeforeEOLChange`\n            const delta = node.cachedAbsoluteStart - node.start;\n            const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n            const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n            node.cachedAbsoluteStart = startOffset;\n            node.cachedAbsoluteEnd = endOffset;\n            node.cachedVersionId = versionId;\n            node.start = startOffset - delta;\n            node.end = endOffset - delta;\n            recomputeMaxEnd(node);\n        }\n    }\n    onBeforeAttached() {\n        this._attachedEditorCount++;\n        if (this._attachedEditorCount === 1) {\n            this._tokenizationTextModelPart.handleDidChangeAttached();\n            this._onDidChangeAttached.fire(undefined);\n        }\n        return this._attachedViews.attachView();\n    }\n    onBeforeDetached(view) {\n        this._attachedEditorCount--;\n        if (this._attachedEditorCount === 0) {\n            this._tokenizationTextModelPart.handleDidChangeAttached();\n            this._onDidChangeAttached.fire(undefined);\n        }\n        this._attachedViews.detachView(view);\n    }\n    isAttachedToEditor() {\n        return this._attachedEditorCount > 0;\n    }\n    getAttachedEditorCount() {\n        return this._attachedEditorCount;\n    }\n    isTooLargeForSyncing() {\n        return this._isTooLargeForSyncing;\n    }\n    isTooLargeForTokenization() {\n        return this._isTooLargeForTokenization;\n    }\n    isTooLargeForHeapOperation() {\n        return this._isTooLargeForHeapOperation;\n    }\n    isDisposed() {\n        return this._isDisposed;\n    }\n    isDominatedByLongLines() {\n        this._assertNotDisposed();\n        if (this.isTooLargeForTokenization()) {\n            // Cannot word wrap huge files anyways, so it doesn't really matter\n            return false;\n        }\n        let smallLineCharCount = 0;\n        let longLineCharCount = 0;\n        const lineCount = this._buffer.getLineCount();\n        for (let lineNumber = 1; lineNumber <= lineCount; lineNumber++) {\n            const lineLength = this._buffer.getLineLength(lineNumber);\n            if (lineLength >= LONG_LINE_BOUNDARY) {\n                longLineCharCount += lineLength;\n            }\n            else {\n                smallLineCharCount += lineLength;\n            }\n        }\n        return (longLineCharCount > smallLineCharCount);\n    }\n    get uri() {\n        return this._associatedResource;\n    }\n    //#region Options\n    getOptions() {\n        this._assertNotDisposed();\n        return this._options;\n    }\n    getFormattingOptions() {\n        return {\n            tabSize: this._options.indentSize,\n            insertSpaces: this._options.insertSpaces\n        };\n    }\n    updateOptions(_newOpts) {\n        this._assertNotDisposed();\n        const tabSize = (typeof _newOpts.tabSize !== 'undefined') ? _newOpts.tabSize : this._options.tabSize;\n        const indentSize = (typeof _newOpts.indentSize !== 'undefined') ? _newOpts.indentSize : this._options.originalIndentSize;\n        const insertSpaces = (typeof _newOpts.insertSpaces !== 'undefined') ? _newOpts.insertSpaces : this._options.insertSpaces;\n        const trimAutoWhitespace = (typeof _newOpts.trimAutoWhitespace !== 'undefined') ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;\n        const bracketPairColorizationOptions = (typeof _newOpts.bracketColorizationOptions !== 'undefined') ? _newOpts.bracketColorizationOptions : this._options.bracketPairColorizationOptions;\n        const newOpts = new model.TextModelResolvedOptions({\n            tabSize: tabSize,\n            indentSize: indentSize,\n            insertSpaces: insertSpaces,\n            defaultEOL: this._options.defaultEOL,\n            trimAutoWhitespace: trimAutoWhitespace,\n            bracketPairColorizationOptions,\n        });\n        if (this._options.equals(newOpts)) {\n            return;\n        }\n        const e = this._options.createChangeEvent(newOpts);\n        this._options = newOpts;\n        this._bracketPairs.handleDidChangeOptions(e);\n        this._decorationProvider.handleDidChangeOptions(e);\n        this._onDidChangeOptions.fire(e);\n    }\n    detectIndentation(defaultInsertSpaces, defaultTabSize) {\n        this._assertNotDisposed();\n        const guessedIndentation = guessIndentation(this._buffer, defaultTabSize, defaultInsertSpaces);\n        this.updateOptions({\n            insertSpaces: guessedIndentation.insertSpaces,\n            tabSize: guessedIndentation.tabSize,\n            indentSize: guessedIndentation.tabSize, // TODO@Alex: guess indentSize independent of tabSize\n        });\n    }\n    normalizeIndentation(str) {\n        this._assertNotDisposed();\n        return normalizeIndentation(str, this._options.indentSize, this._options.insertSpaces);\n    }\n    //#endregion\n    //#region Reading\n    getVersionId() {\n        this._assertNotDisposed();\n        return this._versionId;\n    }\n    mightContainRTL() {\n        return this._buffer.mightContainRTL();\n    }\n    mightContainUnusualLineTerminators() {\n        return this._buffer.mightContainUnusualLineTerminators();\n    }\n    removeUnusualLineTerminators(selections = null) {\n        const matches = this.findMatches(strings.UNUSUAL_LINE_TERMINATORS.source, false, true, false, null, false, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */);\n        this._buffer.resetMightContainUnusualLineTerminators();\n        this.pushEditOperations(selections, matches.map(m => ({ range: m.range, text: null })), () => null);\n    }\n    mightContainNonBasicASCII() {\n        return this._buffer.mightContainNonBasicASCII();\n    }\n    getAlternativeVersionId() {\n        this._assertNotDisposed();\n        return this._alternativeVersionId;\n    }\n    getInitialUndoRedoSnapshot() {\n        this._assertNotDisposed();\n        return this._initialUndoRedoSnapshot;\n    }\n    getOffsetAt(rawPosition) {\n        this._assertNotDisposed();\n        const position = this._validatePosition(rawPosition.lineNumber, rawPosition.column, 0 /* StringOffsetValidationType.Relaxed */);\n        return this._buffer.getOffsetAt(position.lineNumber, position.column);\n    }\n    getPositionAt(rawOffset) {\n        this._assertNotDisposed();\n        const offset = (Math.min(this._buffer.getLength(), Math.max(0, rawOffset)));\n        return this._buffer.getPositionAt(offset);\n    }\n    _increaseVersionId() {\n        this._versionId = this._versionId + 1;\n        this._alternativeVersionId = this._versionId;\n    }\n    _overwriteVersionId(versionId) {\n        this._versionId = versionId;\n    }\n    _overwriteAlternativeVersionId(newAlternativeVersionId) {\n        this._alternativeVersionId = newAlternativeVersionId;\n    }\n    _overwriteInitialUndoRedoSnapshot(newInitialUndoRedoSnapshot) {\n        this._initialUndoRedoSnapshot = newInitialUndoRedoSnapshot;\n    }\n    getValue(eol, preserveBOM = false) {\n        this._assertNotDisposed();\n        if (this.isTooLargeForHeapOperation()) {\n            throw new BugIndicatingError('Operation would exceed heap memory limits');\n        }\n        const fullModelRange = this.getFullModelRange();\n        const fullModelValue = this.getValueInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM() + fullModelValue;\n        }\n        return fullModelValue;\n    }\n    createSnapshot(preserveBOM = false) {\n        return new TextModelSnapshot(this._buffer.createSnapshot(preserveBOM));\n    }\n    getValueLength(eol, preserveBOM = false) {\n        this._assertNotDisposed();\n        const fullModelRange = this.getFullModelRange();\n        const fullModelValue = this.getValueLengthInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM().length + fullModelValue;\n        }\n        return fullModelValue;\n    }\n    getValueInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getValueInRange(this.validateRange(rawRange), eol);\n    }\n    getValueLengthInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getValueLengthInRange(this.validateRange(rawRange), eol);\n    }\n    getCharacterCountInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getCharacterCountInRange(this.validateRange(rawRange), eol);\n    }\n    getLineCount() {\n        this._assertNotDisposed();\n        return this._buffer.getLineCount();\n    }\n    getLineContent(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineContent(lineNumber);\n    }\n    getLineLength(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber);\n    }\n    getLinesContent() {\n        this._assertNotDisposed();\n        if (this.isTooLargeForHeapOperation()) {\n            throw new BugIndicatingError('Operation would exceed heap memory limits');\n        }\n        return this._buffer.getLinesContent();\n    }\n    getEOL() {\n        this._assertNotDisposed();\n        return this._buffer.getEOL();\n    }\n    getEndOfLineSequence() {\n        this._assertNotDisposed();\n        return (this._buffer.getEOL() === '\\n'\n            ? 0 /* model.EndOfLineSequence.LF */\n            : 1 /* model.EndOfLineSequence.CRLF */);\n    }\n    getLineMinColumn(lineNumber) {\n        this._assertNotDisposed();\n        return 1;\n    }\n    getLineMaxColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber) + 1;\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineFirstNonWhitespaceColumn(lineNumber);\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLastNonWhitespaceColumn(lineNumber);\n    }\n    /**\n     * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.\n     * Will try to not allocate if possible.\n     */\n    _validateRangeRelaxedNoAllocations(range) {\n        const linesCount = this._buffer.getLineCount();\n        const initialStartLineNumber = range.startLineNumber;\n        const initialStartColumn = range.startColumn;\n        let startLineNumber = Math.floor((typeof initialStartLineNumber === 'number' && !isNaN(initialStartLineNumber)) ? initialStartLineNumber : 1);\n        let startColumn = Math.floor((typeof initialStartColumn === 'number' && !isNaN(initialStartColumn)) ? initialStartColumn : 1);\n        if (startLineNumber < 1) {\n            startLineNumber = 1;\n            startColumn = 1;\n        }\n        else if (startLineNumber > linesCount) {\n            startLineNumber = linesCount;\n            startColumn = this.getLineMaxColumn(startLineNumber);\n        }\n        else {\n            if (startColumn <= 1) {\n                startColumn = 1;\n            }\n            else {\n                const maxColumn = this.getLineMaxColumn(startLineNumber);\n                if (startColumn >= maxColumn) {\n                    startColumn = maxColumn;\n                }\n            }\n        }\n        const initialEndLineNumber = range.endLineNumber;\n        const initialEndColumn = range.endColumn;\n        let endLineNumber = Math.floor((typeof initialEndLineNumber === 'number' && !isNaN(initialEndLineNumber)) ? initialEndLineNumber : 1);\n        let endColumn = Math.floor((typeof initialEndColumn === 'number' && !isNaN(initialEndColumn)) ? initialEndColumn : 1);\n        if (endLineNumber < 1) {\n            endLineNumber = 1;\n            endColumn = 1;\n        }\n        else if (endLineNumber > linesCount) {\n            endLineNumber = linesCount;\n            endColumn = this.getLineMaxColumn(endLineNumber);\n        }\n        else {\n            if (endColumn <= 1) {\n                endColumn = 1;\n            }\n            else {\n                const maxColumn = this.getLineMaxColumn(endLineNumber);\n                if (endColumn >= maxColumn) {\n                    endColumn = maxColumn;\n                }\n            }\n        }\n        if (initialStartLineNumber === startLineNumber\n            && initialStartColumn === startColumn\n            && initialEndLineNumber === endLineNumber\n            && initialEndColumn === endColumn\n            && range instanceof Range\n            && !(range instanceof Selection)) {\n            return range;\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    _isValidPosition(lineNumber, column, validationType) {\n        if (typeof lineNumber !== 'number' || typeof column !== 'number') {\n            return false;\n        }\n        if (isNaN(lineNumber) || isNaN(column)) {\n            return false;\n        }\n        if (lineNumber < 1 || column < 1) {\n            return false;\n        }\n        if ((lineNumber | 0) !== lineNumber || (column | 0) !== column) {\n            return false;\n        }\n        const lineCount = this._buffer.getLineCount();\n        if (lineNumber > lineCount) {\n            return false;\n        }\n        if (column === 1) {\n            return true;\n        }\n        const maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column > maxColumn) {\n            return false;\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            // !!At this point, column > 1\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n            if (strings.isHighSurrogate(charCodeBefore)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    _validatePosition(_lineNumber, _column, validationType) {\n        const lineNumber = Math.floor((typeof _lineNumber === 'number' && !isNaN(_lineNumber)) ? _lineNumber : 1);\n        const column = Math.floor((typeof _column === 'number' && !isNaN(_column)) ? _column : 1);\n        const lineCount = this._buffer.getLineCount();\n        if (lineNumber < 1) {\n            return new Position(1, 1);\n        }\n        if (lineNumber > lineCount) {\n            return new Position(lineCount, this.getLineMaxColumn(lineCount));\n        }\n        if (column <= 1) {\n            return new Position(lineNumber, 1);\n        }\n        const maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column >= maxColumn) {\n            return new Position(lineNumber, maxColumn);\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            // If the position would end up in the middle of a high-low surrogate pair,\n            // we move it to before the pair\n            // !!At this point, column > 1\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n            if (strings.isHighSurrogate(charCodeBefore)) {\n                return new Position(lineNumber, column - 1);\n            }\n        }\n        return new Position(lineNumber, column);\n    }\n    validatePosition(position) {\n        const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if (position instanceof Position) {\n            if (this._isValidPosition(position.lineNumber, position.column, validationType)) {\n                return position;\n            }\n        }\n        return this._validatePosition(position.lineNumber, position.column, validationType);\n    }\n    _isValidRange(range, validationType) {\n        const startLineNumber = range.startLineNumber;\n        const startColumn = range.startColumn;\n        const endLineNumber = range.endLineNumber;\n        const endColumn = range.endColumn;\n        if (!this._isValidPosition(startLineNumber, startColumn, 0 /* StringOffsetValidationType.Relaxed */)) {\n            return false;\n        }\n        if (!this._isValidPosition(endLineNumber, endColumn, 0 /* StringOffsetValidationType.Relaxed */)) {\n            return false;\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    }\n    validateRange(_range) {\n        const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if ((_range instanceof Range) && !(_range instanceof Selection)) {\n            if (this._isValidRange(_range, validationType)) {\n                return _range;\n            }\n        }\n        const start = this._validatePosition(_range.startLineNumber, _range.startColumn, 0 /* StringOffsetValidationType.Relaxed */);\n        const end = this._validatePosition(_range.endLineNumber, _range.endColumn, 0 /* StringOffsetValidationType.Relaxed */);\n        const startLineNumber = start.lineNumber;\n        const startColumn = start.column;\n        const endLineNumber = end.lineNumber;\n        const endColumn = end.column;\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            }\n            if (startLineNumber === endLineNumber && startColumn === endColumn) {\n                // do not expand a collapsed range, simply move it to a valid location\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);\n            }\n            if (startInsideSurrogatePair && endInsideSurrogatePair) {\n                // expand range at both ends\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);\n            }\n            if (startInsideSurrogatePair) {\n                // only expand range at the start\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);\n            }\n            // only expand range at the end\n            return new Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    modifyPosition(rawPosition, offset) {\n        this._assertNotDisposed();\n        const candidate = this.getOffsetAt(rawPosition) + offset;\n        return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, candidate)));\n    }\n    getFullModelRange() {\n        this._assertNotDisposed();\n        const lineCount = this.getLineCount();\n        return new Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        return this._buffer.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n    findMatches(searchString, rawSearchScope, isRegex, matchCase, wordSeparators, captureMatches, limitResultCount = LIMIT_FIND_COUNT) {\n        this._assertNotDisposed();\n        let searchRanges = null;\n        if (rawSearchScope !== null) {\n            if (!Array.isArray(rawSearchScope)) {\n                rawSearchScope = [rawSearchScope];\n            }\n            if (rawSearchScope.every((searchScope) => Range.isIRange(searchScope))) {\n                searchRanges = rawSearchScope.map((searchScope) => this.validateRange(searchScope));\n            }\n        }\n        if (searchRanges === null) {\n            searchRanges = [this.getFullModelRange()];\n        }\n        searchRanges = searchRanges.sort((d1, d2) => d1.startLineNumber - d2.startLineNumber || d1.startColumn - d2.startColumn);\n        const uniqueSearchRanges = [];\n        uniqueSearchRanges.push(searchRanges.reduce((prev, curr) => {\n            if (Range.areIntersecting(prev, curr)) {\n                return prev.plusRange(curr);\n            }\n            uniqueSearchRanges.push(prev);\n            return curr;\n        }));\n        let matchMapper;\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            // not regex, not multi line\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            const searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return [];\n            }\n            matchMapper = (searchRange) => this.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n        }\n        else {\n            matchMapper = (searchRange) => TextModelSearch.findMatches(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchRange, captureMatches, limitResultCount);\n        }\n        return uniqueSearchRanges.map(matchMapper).reduce((arr, matches) => arr.concat(matches), []);\n    }\n    findNextMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        const searchStart = this.validatePosition(rawSearchStart);\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            const searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return null;\n            }\n            const lineCount = this.getLineCount();\n            let searchRange = new Range(searchStart.lineNumber, searchStart.column, lineCount, this.getLineMaxColumn(lineCount));\n            let ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            searchRange = new Range(1, 1, searchStart.lineNumber, this.getLineMaxColumn(searchStart.lineNumber));\n            ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            return null;\n        }\n        return TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    }\n    findPreviousMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        const searchStart = this.validatePosition(rawSearchStart);\n        return TextModelSearch.findPreviousMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    }\n    //#endregion\n    //#region Editing\n    pushStackElement() {\n        this._commandManager.pushStackElement();\n    }\n    popStackElement() {\n        this._commandManager.popStackElement();\n    }\n    pushEOL(eol) {\n        const currentEOL = (this.getEOL() === '\\n' ? 0 /* model.EndOfLineSequence.LF */ : 1 /* model.EndOfLineSequence.CRLF */);\n        if (currentEOL === eol) {\n            return;\n        }\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            if (this._initialUndoRedoSnapshot === null) {\n                this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n            }\n            this._commandManager.pushEOL(eol);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _validateEditOperation(rawOperation) {\n        if (rawOperation instanceof model.ValidAnnotatedEditOperation) {\n            return rawOperation;\n        }\n        return new model.ValidAnnotatedEditOperation(rawOperation.identifier || null, this.validateRange(rawOperation.range), rawOperation.text, rawOperation.forceMoveMarkers || false, rawOperation.isAutoWhitespaceEdit || false, rawOperation._isTracked || false);\n    }\n    _validateEditOperations(rawOperations) {\n        const result = [];\n        for (let i = 0, len = rawOperations.length; i < len; i++) {\n            result[i] = this._validateEditOperation(rawOperations[i]);\n        }\n        return result;\n    }\n    pushEditOperations(beforeCursorState, editOperations, cursorStateComputer, group) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            return this._pushEditOperations(beforeCursorState, this._validateEditOperations(editOperations), cursorStateComputer, group);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _pushEditOperations(beforeCursorState, editOperations, cursorStateComputer, group) {\n        if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {\n            // Go through each saved line number and insert a trim whitespace edit\n            // if it is safe to do so (no conflicts with other edits).\n            const incomingEdits = editOperations.map((op) => {\n                return {\n                    range: this.validateRange(op.range),\n                    text: op.text\n                };\n            });\n            // Sometimes, auto-formatters change ranges automatically which can cause undesired auto whitespace trimming near the cursor\n            // We'll use the following heuristic: if the edits occur near the cursor, then it's ok to trim auto whitespace\n            let editsAreNearCursors = true;\n            if (beforeCursorState) {\n                for (let i = 0, len = beforeCursorState.length; i < len; i++) {\n                    const sel = beforeCursorState[i];\n                    let foundEditNearSel = false;\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        const editRange = incomingEdits[j].range;\n                        const selIsAbove = editRange.startLineNumber > sel.endLineNumber;\n                        const selIsBelow = sel.startLineNumber > editRange.endLineNumber;\n                        if (!selIsAbove && !selIsBelow) {\n                            foundEditNearSel = true;\n                            break;\n                        }\n                    }\n                    if (!foundEditNearSel) {\n                        editsAreNearCursors = false;\n                        break;\n                    }\n                }\n            }\n            if (editsAreNearCursors) {\n                for (let i = 0, len = this._trimAutoWhitespaceLines.length; i < len; i++) {\n                    const trimLineNumber = this._trimAutoWhitespaceLines[i];\n                    const maxLineColumn = this.getLineMaxColumn(trimLineNumber);\n                    let allowTrimLine = true;\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        const editRange = incomingEdits[j].range;\n                        const editText = incomingEdits[j].text;\n                        if (trimLineNumber < editRange.startLineNumber || trimLineNumber > editRange.endLineNumber) {\n                            // `trimLine` is completely outside this edit\n                            continue;\n                        }\n                        // At this point:\n                        //   editRange.startLineNumber <= trimLine <= editRange.endLineNumber\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === maxLineColumn\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) after `trimLine`\n                            continue;\n                        }\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === 1\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(editText.length - 1) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) before `trimLine`\n                            continue;\n                        }\n                        // Looks like we can't trim this line as it would interfere with an incoming edit\n                        allowTrimLine = false;\n                        break;\n                    }\n                    if (allowTrimLine) {\n                        const trimRange = new Range(trimLineNumber, 1, trimLineNumber, maxLineColumn);\n                        editOperations.push(new model.ValidAnnotatedEditOperation(null, trimRange, null, false, false, false));\n                    }\n                }\n            }\n            this._trimAutoWhitespaceLines = null;\n        }\n        if (this._initialUndoRedoSnapshot === null) {\n            this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n        }\n        return this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer, group);\n    }\n    _applyUndo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n        const edits = changes.map((change) => {\n            const rangeStart = this.getPositionAt(change.newPosition);\n            const rangeEnd = this.getPositionAt(change.newEnd);\n            return {\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n                text: change.oldText\n            };\n        });\n        this._applyUndoRedoEdits(edits, eol, true, false, resultingAlternativeVersionId, resultingSelection);\n    }\n    _applyRedo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n        const edits = changes.map((change) => {\n            const rangeStart = this.getPositionAt(change.oldPosition);\n            const rangeEnd = this.getPositionAt(change.oldEnd);\n            return {\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n                text: change.newText\n            };\n        });\n        this._applyUndoRedoEdits(edits, eol, false, true, resultingAlternativeVersionId, resultingSelection);\n    }\n    _applyUndoRedoEdits(edits, eol, isUndoing, isRedoing, resultingAlternativeVersionId, resultingSelection) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            this._isUndoing = isUndoing;\n            this._isRedoing = isRedoing;\n            this.applyEdits(edits, false);\n            this.setEOL(eol);\n            this._overwriteAlternativeVersionId(resultingAlternativeVersionId);\n        }\n        finally {\n            this._isUndoing = false;\n            this._isRedoing = false;\n            this._eventEmitter.endDeferredEmit(resultingSelection);\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    applyEdits(rawOperations, computeUndoEdits = false) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            const operations = this._validateEditOperations(rawOperations);\n            return this._doApplyEdits(operations, computeUndoEdits);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _doApplyEdits(rawOperations, computeUndoEdits) {\n        const oldLineCount = this._buffer.getLineCount();\n        const result = this._buffer.applyEdits(rawOperations, this._options.trimAutoWhitespace, computeUndoEdits);\n        const newLineCount = this._buffer.getLineCount();\n        const contentChanges = result.changes;\n        this._trimAutoWhitespaceLines = result.trimAutoWhitespaceLineNumbers;\n        if (contentChanges.length !== 0) {\n            // We do a first pass to update decorations\n            // because we want to read decorations in the second pass\n            // where we will emit content change events\n            // and we want to read the final decorations\n            for (let i = 0, len = contentChanges.length; i < len; i++) {\n                const change = contentChanges[i];\n                this._decorationsTree.acceptReplace(change.rangeOffset, change.rangeLength, change.text.length, change.forceMoveMarkers);\n            }\n            const rawContentChanges = [];\n            this._increaseVersionId();\n            let lineCount = oldLineCount;\n            for (let i = 0, len = contentChanges.length; i < len; i++) {\n                const change = contentChanges[i];\n                const [eolCount] = countEOL(change.text);\n                this._onDidChangeDecorations.fire();\n                const startLineNumber = change.range.startLineNumber;\n                const endLineNumber = change.range.endLineNumber;\n                const deletingLinesCnt = endLineNumber - startLineNumber;\n                const insertingLinesCnt = eolCount;\n                const editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n                const changeLineCountDelta = (insertingLinesCnt - deletingLinesCnt);\n                const currentEditStartLineNumber = newLineCount - lineCount - changeLineCountDelta + startLineNumber;\n                const firstEditLineNumber = currentEditStartLineNumber;\n                const lastInsertedLineNumber = currentEditStartLineNumber + insertingLinesCnt;\n                const decorationsWithInjectedTextInEditedRange = this._decorationsTree.getInjectedTextInInterval(this, this.getOffsetAt(new Position(firstEditLineNumber, 1)), this.getOffsetAt(new Position(lastInsertedLineNumber, this.getLineMaxColumn(lastInsertedLineNumber))), 0);\n                const injectedTextInEditedRange = LineInjectedText.fromDecorations(decorationsWithInjectedTextInEditedRange);\n                const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n                for (let j = editingLinesCnt; j >= 0; j--) {\n                    const editLineNumber = startLineNumber + j;\n                    const currentEditLineNumber = currentEditStartLineNumber + j;\n                    injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber > currentEditLineNumber);\n                    const decorationsInCurrentLine = injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber === currentEditLineNumber);\n                    rawContentChanges.push(new ModelRawLineChanged(editLineNumber, this.getLineContent(currentEditLineNumber), decorationsInCurrentLine));\n                }\n                if (editingLinesCnt < deletingLinesCnt) {\n                    // Must delete some lines\n                    const spliceStartLineNumber = startLineNumber + editingLinesCnt;\n                    rawContentChanges.push(new ModelRawLinesDeleted(spliceStartLineNumber + 1, endLineNumber));\n                }\n                if (editingLinesCnt < insertingLinesCnt) {\n                    const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n                    // Must insert some lines\n                    const spliceLineNumber = startLineNumber + editingLinesCnt;\n                    const cnt = insertingLinesCnt - editingLinesCnt;\n                    const fromLineNumber = newLineCount - lineCount - cnt + spliceLineNumber + 1;\n                    const injectedTexts = [];\n                    const newLines = [];\n                    for (let i = 0; i < cnt; i++) {\n                        const lineNumber = fromLineNumber + i;\n                        newLines[i] = this.getLineContent(lineNumber);\n                        injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber < lineNumber);\n                        injectedTexts[i] = injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber === lineNumber);\n                    }\n                    rawContentChanges.push(new ModelRawLinesInserted(spliceLineNumber + 1, startLineNumber + insertingLinesCnt, newLines, injectedTexts));\n                }\n                lineCount += changeLineCountDelta;\n            }\n            this._emitContentChangedEvent(new ModelRawContentChangedEvent(rawContentChanges, this.getVersionId(), this._isUndoing, this._isRedoing), {\n                changes: contentChanges,\n                eol: this._buffer.getEOL(),\n                isEolChange: false,\n                versionId: this.getVersionId(),\n                isUndoing: this._isUndoing,\n                isRedoing: this._isRedoing,\n                isFlush: false\n            });\n        }\n        return (result.reverseEdits === null ? undefined : result.reverseEdits);\n    }\n    undo() {\n        return this._undoRedoService.undo(this.uri);\n    }\n    canUndo() {\n        return this._undoRedoService.canUndo(this.uri);\n    }\n    redo() {\n        return this._undoRedoService.redo(this.uri);\n    }\n    canRedo() {\n        return this._undoRedoService.canRedo(this.uri);\n    }\n    //#endregion\n    //#region Decorations\n    handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines) {\n        // This is called before the decoration changed event is fired.\n        if (affectedInjectedTextLines === null || affectedInjectedTextLines.size === 0) {\n            return;\n        }\n        const affectedLines = Array.from(affectedInjectedTextLines);\n        const lineChangeEvents = affectedLines.map(lineNumber => new ModelRawLineChanged(lineNumber, this.getLineContent(lineNumber), this._getInjectedTextInLine(lineNumber)));\n        this._onDidChangeInjectedText.fire(new ModelInjectedTextChangedEvent(lineChangeEvents));\n    }\n    changeDecorations(callback, ownerId = 0) {\n        this._assertNotDisposed();\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            return this._changeDecorations(ownerId, callback);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _changeDecorations(ownerId, callback) {\n        const changeAccessor = {\n            addDecoration: (range, options) => {\n                return this._deltaDecorationsImpl(ownerId, [], [{ range: range, options: options }])[0];\n            },\n            changeDecoration: (id, newRange) => {\n                this._changeDecorationImpl(id, newRange);\n            },\n            changeDecorationOptions: (id, options) => {\n                this._changeDecorationOptionsImpl(id, _normalizeOptions(options));\n            },\n            removeDecoration: (id) => {\n                this._deltaDecorationsImpl(ownerId, [id], []);\n            },\n            deltaDecorations: (oldDecorations, newDecorations) => {\n                if (oldDecorations.length === 0 && newDecorations.length === 0) {\n                    // nothing to do\n                    return [];\n                }\n                return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n            }\n        };\n        let result = null;\n        try {\n            result = callback(changeAccessor);\n        }\n        catch (e) {\n            onUnexpectedError(e);\n        }\n        // Invalidate change accessor\n        changeAccessor.addDecoration = invalidFunc;\n        changeAccessor.changeDecoration = invalidFunc;\n        changeAccessor.changeDecorationOptions = invalidFunc;\n        changeAccessor.removeDecoration = invalidFunc;\n        changeAccessor.deltaDecorations = invalidFunc;\n        return result;\n    }\n    deltaDecorations(oldDecorations, newDecorations, ownerId = 0) {\n        this._assertNotDisposed();\n        if (!oldDecorations) {\n            oldDecorations = [];\n        }\n        if (oldDecorations.length === 0 && newDecorations.length === 0) {\n            // nothing to do\n            return [];\n        }\n        try {\n            this._deltaDecorationCallCnt++;\n            if (this._deltaDecorationCallCnt > 1) {\n                console.warn(`Invoking deltaDecorations recursively could lead to leaking decorations.`);\n                onUnexpectedError(new Error(`Invoking deltaDecorations recursively could lead to leaking decorations.`));\n            }\n            this._onDidChangeDecorations.beginDeferredEmit();\n            return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n            this._deltaDecorationCallCnt--;\n        }\n    }\n    _getTrackedRange(id) {\n        return this.getDecorationRange(id);\n    }\n    _setTrackedRange(id, newRange, newStickiness) {\n        const node = (id ? this._decorations[id] : null);\n        if (!node) {\n            if (!newRange) {\n                // node doesn't exist, the request is to delete => nothing to do\n                return null;\n            }\n            // node doesn't exist, the request is to set => add the tracked range\n            return this._deltaDecorationsImpl(0, [], [{ range: newRange, options: TRACKED_RANGE_OPTIONS[newStickiness] }], true)[0];\n        }\n        if (!newRange) {\n            // node exists, the request is to delete => delete node\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n            return null;\n        }\n        // node exists, the request is to set => change the tracked range and its options\n        const range = this._validateRangeRelaxedNoAllocations(newRange);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        node.setOptions(TRACKED_RANGE_OPTIONS[newStickiness]);\n        this._decorationsTree.insert(node);\n        return node.id;\n    }\n    removeAllDecorationsWithOwnerId(ownerId) {\n        if (this._isDisposed) {\n            return;\n        }\n        const nodes = this._decorationsTree.collectNodesFromOwner(ownerId);\n        for (let i = 0, len = nodes.length; i < len; i++) {\n            const node = nodes[i];\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n        }\n    }\n    getDecorationOptions(decorationId) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        return node.options;\n    }\n    getDecorationRange(decorationId) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        return this._decorationsTree.getNodeRange(this, node);\n    }\n    getLineDecorations(lineNumber, ownerId = 0, filterOutValidation = false) {\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            return [];\n        }\n        return this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation);\n    }\n    getLinesDecorations(_startLineNumber, _endLineNumber, ownerId = 0, filterOutValidation = false, onlyMarginDecorations = false) {\n        const lineCount = this.getLineCount();\n        const startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));\n        const endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        const range = new Range(startLineNumber, 1, endLineNumber, endColumn);\n        const decorations = this._getDecorationsInRange(range, ownerId, filterOutValidation, onlyMarginDecorations);\n        pushMany(decorations, this._decorationProvider.getDecorationsInRange(range, ownerId, filterOutValidation));\n        return decorations;\n    }\n    getDecorationsInRange(range, ownerId = 0, filterOutValidation = false, onlyMinimapDecorations = false, onlyMarginDecorations = false) {\n        const validatedRange = this.validateRange(range);\n        const decorations = this._getDecorationsInRange(validatedRange, ownerId, filterOutValidation, onlyMarginDecorations);\n        pushMany(decorations, this._decorationProvider.getDecorationsInRange(validatedRange, ownerId, filterOutValidation, onlyMinimapDecorations));\n        return decorations;\n    }\n    getOverviewRulerDecorations(ownerId = 0, filterOutValidation = false) {\n        return this._decorationsTree.getAll(this, ownerId, filterOutValidation, true, false);\n    }\n    getInjectedTextDecorations(ownerId = 0) {\n        return this._decorationsTree.getAllInjectedText(this, ownerId);\n    }\n    _getInjectedTextInLine(lineNumber) {\n        const startOffset = this._buffer.getOffsetAt(lineNumber, 1);\n        const endOffset = startOffset + this._buffer.getLineLength(lineNumber);\n        const result = this._decorationsTree.getInjectedTextInInterval(this, startOffset, endOffset, 0);\n        return LineInjectedText.fromDecorations(result).filter(t => t.lineNumber === lineNumber);\n    }\n    getAllDecorations(ownerId = 0, filterOutValidation = false) {\n        let result = this._decorationsTree.getAll(this, ownerId, filterOutValidation, false, false);\n        result = result.concat(this._decorationProvider.getAllDecorations(ownerId, filterOutValidation));\n        return result;\n    }\n    getAllMarginDecorations(ownerId = 0) {\n        return this._decorationsTree.getAll(this, ownerId, false, false, true);\n    }\n    _getDecorationsInRange(filterRange, filterOwnerId, filterOutValidation, onlyMarginDecorations) {\n        const startOffset = this._buffer.getOffsetAt(filterRange.startLineNumber, filterRange.startColumn);\n        const endOffset = this._buffer.getOffsetAt(filterRange.endLineNumber, filterRange.endColumn);\n        return this._decorationsTree.getAllInInterval(this, startOffset, endOffset, filterOwnerId, filterOutValidation, onlyMarginDecorations);\n    }\n    getRangeAt(start, end) {\n        return this._buffer.getRangeAt(start, end - start);\n    }\n    _changeDecorationImpl(decorationId, _range) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        if (node.options.after) {\n            const oldRange = this.getDecorationRange(decorationId);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.endLineNumber);\n        }\n        if (node.options.before) {\n            const oldRange = this.getDecorationRange(decorationId);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.startLineNumber);\n        }\n        const range = this._validateRangeRelaxedNoAllocations(_range);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        this._decorationsTree.insert(node);\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        if (node.options.after) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n        }\n        if (node.options.before) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n        }\n    }\n    _changeDecorationOptionsImpl(decorationId, options) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        const nodeWasInOverviewRuler = (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n        const nodeIsInOverviewRuler = (options.overviewRuler && options.overviewRuler.color ? true : false);\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        this._onDidChangeDecorations.checkAffectedAndFire(options);\n        if (node.options.after || options.after) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n        }\n        if (node.options.before || options.before) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n        }\n        const movedInOverviewRuler = nodeWasInOverviewRuler !== nodeIsInOverviewRuler;\n        const changedWhetherInjectedText = isOptionsInjectedText(options) !== isNodeInjectedText(node);\n        if (movedInOverviewRuler || changedWhetherInjectedText) {\n            this._decorationsTree.delete(node);\n            node.setOptions(options);\n            this._decorationsTree.insert(node);\n        }\n        else {\n            node.setOptions(options);\n        }\n    }\n    _deltaDecorationsImpl(ownerId, oldDecorationsIds, newDecorations, suppressEvents = false) {\n        const versionId = this.getVersionId();\n        const oldDecorationsLen = oldDecorationsIds.length;\n        let oldDecorationIndex = 0;\n        const newDecorationsLen = newDecorations.length;\n        let newDecorationIndex = 0;\n        this._onDidChangeDecorations.beginDeferredEmit();\n        try {\n            const result = new Array(newDecorationsLen);\n            while (oldDecorationIndex < oldDecorationsLen || newDecorationIndex < newDecorationsLen) {\n                let node = null;\n                if (oldDecorationIndex < oldDecorationsLen) {\n                    // (1) get ourselves an old node\n                    do {\n                        node = this._decorations[oldDecorationsIds[oldDecorationIndex++]];\n                    } while (!node && oldDecorationIndex < oldDecorationsLen);\n                    // (2) remove the node from the tree (if it exists)\n                    if (node) {\n                        if (node.options.after) {\n                            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n                            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n                        }\n                        if (node.options.before) {\n                            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n                            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n                        }\n                        this._decorationsTree.delete(node);\n                        if (!suppressEvents) {\n                            this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n                        }\n                    }\n                }\n                if (newDecorationIndex < newDecorationsLen) {\n                    // (3) create a new node if necessary\n                    if (!node) {\n                        const internalDecorationId = (++this._lastDecorationId);\n                        const decorationId = `${this._instanceId};${internalDecorationId}`;\n                        node = new IntervalNode(decorationId, 0, 0);\n                        this._decorations[decorationId] = node;\n                    }\n                    // (4) initialize node\n                    const newDecoration = newDecorations[newDecorationIndex];\n                    const range = this._validateRangeRelaxedNoAllocations(newDecoration.range);\n                    const options = _normalizeOptions(newDecoration.options);\n                    const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n                    const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n                    node.ownerId = ownerId;\n                    node.reset(versionId, startOffset, endOffset, range);\n                    node.setOptions(options);\n                    if (node.options.after) {\n                        this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n                    }\n                    if (node.options.before) {\n                        this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n                    }\n                    if (!suppressEvents) {\n                        this._onDidChangeDecorations.checkAffectedAndFire(options);\n                    }\n                    this._decorationsTree.insert(node);\n                    result[newDecorationIndex] = node.id;\n                    newDecorationIndex++;\n                }\n                else {\n                    if (node) {\n                        delete this._decorations[node.id];\n                    }\n                }\n            }\n            return result;\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    //#endregion\n    //#region Tokenization\n    // TODO move them to the tokenization part.\n    getLanguageId() {\n        return this.tokenization.getLanguageId();\n    }\n    setLanguage(languageIdOrSelection, source) {\n        if (typeof languageIdOrSelection === 'string') {\n            this._languageSelectionListener.clear();\n            this._setLanguage(languageIdOrSelection, source);\n        }\n        else {\n            this._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId, source));\n            this._setLanguage(languageIdOrSelection.languageId, source);\n        }\n    }\n    _setLanguage(languageId, source) {\n        this.tokenization.setLanguageId(languageId, source);\n        this._languageService.requestRichLanguageFeatures(languageId);\n    }\n    getLanguageIdAtPosition(lineNumber, column) {\n        return this.tokenization.getLanguageIdAtPosition(lineNumber, column);\n    }\n    getWordAtPosition(position) {\n        return this._tokenizationTextModelPart.getWordAtPosition(position);\n    }\n    getWordUntilPosition(position) {\n        return this._tokenizationTextModelPart.getWordUntilPosition(position);\n    }\n    //#endregion\n    normalizePosition(position, affinity) {\n        return position;\n    }\n    /**\n     * Gets the column at which indentation stops at a given line.\n     * @internal\n    */\n    getLineIndentColumn(lineNumber) {\n        // Columns start with 1.\n        return indentOfLine(this.getLineContent(lineNumber)) + 1;\n    }\n};\nTextModel._MODEL_SYNC_LIMIT = 50 * 1024 * 1024; // 50 MB,  // used in tests\nTextModel.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024; // 20 MB;\nTextModel.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1000; // 300K lines\nTextModel.LARGE_FILE_HEAP_OPERATION_THRESHOLD = 256 * 1024 * 1024; // 256M characters, usually ~> 512MB memory usage\nTextModel.DEFAULT_CREATION_OPTIONS = {\n    isForSimpleWidget: false,\n    tabSize: EDITOR_MODEL_DEFAULTS.tabSize,\n    indentSize: EDITOR_MODEL_DEFAULTS.indentSize,\n    insertSpaces: EDITOR_MODEL_DEFAULTS.insertSpaces,\n    detectIndentation: false,\n    defaultEOL: 1 /* model.DefaultEndOfLine.LF */,\n    trimAutoWhitespace: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,\n    largeFileOptimizations: EDITOR_MODEL_DEFAULTS.largeFileOptimizations,\n    bracketPairColorizationOptions: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions,\n};\nTextModel = TextModel_1 = __decorate([\n    __param(4, IUndoRedoService),\n    __param(5, ILanguageService),\n    __param(6, ILanguageConfigurationService)\n], TextModel);\nexport { TextModel };\nfunction indentOfLine(line) {\n    let indent = 0;\n    for (const c of line) {\n        if (c === ' ' || c === '\\t') {\n            indent++;\n        }\n        else {\n            break;\n        }\n    }\n    return indent;\n}\n//#region Decorations\nfunction isNodeInOverviewRuler(node) {\n    return (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n}\nfunction isOptionsInjectedText(options) {\n    return !!options.after || !!options.before;\n}\nfunction isNodeInjectedText(node) {\n    return !!node.options.after || !!node.options.before;\n}\nclass DecorationsTrees {\n    constructor() {\n        this._decorationsTree0 = new IntervalTree();\n        this._decorationsTree1 = new IntervalTree();\n        this._injectedTextDecorationsTree = new IntervalTree();\n    }\n    ensureAllNodesHaveRanges(host) {\n        this.getAll(host, 0, false, false, false);\n    }\n    _ensureNodesHaveRanges(host, nodes) {\n        for (const node of nodes) {\n            if (node.range === null) {\n                node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n            }\n        }\n        return nodes;\n    }\n    getAllInInterval(host, start, end, filterOwnerId, filterOutValidation, onlyMarginDecorations) {\n        const versionId = host.getVersionId();\n        const result = this._intervalSearch(start, end, filterOwnerId, filterOutValidation, versionId, onlyMarginDecorations);\n        return this._ensureNodesHaveRanges(host, result);\n    }\n    _intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n        const r0 = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        const r1 = this._decorationsTree1.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        const r2 = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        return r0.concat(r1).concat(r2);\n    }\n    getInjectedTextInInterval(host, start, end, filterOwnerId) {\n        const versionId = host.getVersionId();\n        const result = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, false, versionId, false);\n        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n    }\n    getAllInjectedText(host, filterOwnerId) {\n        const versionId = host.getVersionId();\n        const result = this._injectedTextDecorationsTree.search(filterOwnerId, false, versionId, false);\n        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n    }\n    getAll(host, filterOwnerId, filterOutValidation, overviewRulerOnly, onlyMarginDecorations) {\n        const versionId = host.getVersionId();\n        const result = this._search(filterOwnerId, filterOutValidation, overviewRulerOnly, versionId, onlyMarginDecorations);\n        return this._ensureNodesHaveRanges(host, result);\n    }\n    _search(filterOwnerId, filterOutValidation, overviewRulerOnly, cachedVersionId, onlyMarginDecorations) {\n        if (overviewRulerOnly) {\n            return this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        }\n        else {\n            const r0 = this._decorationsTree0.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n            const r1 = this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n            const r2 = this._injectedTextDecorationsTree.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n            return r0.concat(r1).concat(r2);\n        }\n    }\n    collectNodesFromOwner(ownerId) {\n        const r0 = this._decorationsTree0.collectNodesFromOwner(ownerId);\n        const r1 = this._decorationsTree1.collectNodesFromOwner(ownerId);\n        const r2 = this._injectedTextDecorationsTree.collectNodesFromOwner(ownerId);\n        return r0.concat(r1).concat(r2);\n    }\n    collectNodesPostOrder() {\n        const r0 = this._decorationsTree0.collectNodesPostOrder();\n        const r1 = this._decorationsTree1.collectNodesPostOrder();\n        const r2 = this._injectedTextDecorationsTree.collectNodesPostOrder();\n        return r0.concat(r1).concat(r2);\n    }\n    insert(node) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.insert(node);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.insert(node);\n        }\n        else {\n            this._decorationsTree0.insert(node);\n        }\n    }\n    delete(node) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.delete(node);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.delete(node);\n        }\n        else {\n            this._decorationsTree0.delete(node);\n        }\n    }\n    getNodeRange(host, node) {\n        const versionId = host.getVersionId();\n        if (node.cachedVersionId !== versionId) {\n            this._resolveNode(node, versionId);\n        }\n        if (node.range === null) {\n            node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n        }\n        return node.range;\n    }\n    _resolveNode(node, cachedVersionId) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.resolveNode(node, cachedVersionId);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.resolveNode(node, cachedVersionId);\n        }\n        else {\n            this._decorationsTree0.resolveNode(node, cachedVersionId);\n        }\n    }\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\n        this._decorationsTree0.acceptReplace(offset, length, textLength, forceMoveMarkers);\n        this._decorationsTree1.acceptReplace(offset, length, textLength, forceMoveMarkers);\n        this._injectedTextDecorationsTree.acceptReplace(offset, length, textLength, forceMoveMarkers);\n    }\n}\nfunction cleanClassName(className) {\n    return className.replace(/[^a-z0-9\\-_]/gi, ' ');\n}\nclass DecorationOptions {\n    constructor(options) {\n        this.color = options.color || '';\n        this.darkColor = options.darkColor || '';\n    }\n}\nexport class ModelDecorationOverviewRulerOptions extends DecorationOptions {\n    constructor(options) {\n        super(options);\n        this._resolvedColor = null;\n        this.position = (typeof options.position === 'number' ? options.position : model.OverviewRulerLane.Center);\n    }\n    getColor(theme) {\n        if (!this._resolvedColor) {\n            if (theme.type !== 'light' && this.darkColor) {\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\n            }\n            else {\n                this._resolvedColor = this._resolveColor(this.color, theme);\n            }\n        }\n        return this._resolvedColor;\n    }\n    invalidateCachedColor() {\n        this._resolvedColor = null;\n    }\n    _resolveColor(color, theme) {\n        if (typeof color === 'string') {\n            return color;\n        }\n        const c = color ? theme.getColor(color.id) : null;\n        if (!c) {\n            return '';\n        }\n        return c.toString();\n    }\n}\nexport class ModelDecorationGlyphMarginOptions {\n    constructor(options) {\n        var _a;\n        this.position = (_a = options === null || options === void 0 ? void 0 : options.position) !== null && _a !== void 0 ? _a : model.GlyphMarginLane.Center;\n        this.persistLane = options === null || options === void 0 ? void 0 : options.persistLane;\n    }\n}\nexport class ModelDecorationMinimapOptions extends DecorationOptions {\n    constructor(options) {\n        var _a, _b;\n        super(options);\n        this.position = options.position;\n        this.sectionHeaderStyle = (_a = options.sectionHeaderStyle) !== null && _a !== void 0 ? _a : null;\n        this.sectionHeaderText = (_b = options.sectionHeaderText) !== null && _b !== void 0 ? _b : null;\n    }\n    getColor(theme) {\n        if (!this._resolvedColor) {\n            if (theme.type !== 'light' && this.darkColor) {\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\n            }\n            else {\n                this._resolvedColor = this._resolveColor(this.color, theme);\n            }\n        }\n        return this._resolvedColor;\n    }\n    invalidateCachedColor() {\n        this._resolvedColor = undefined;\n    }\n    _resolveColor(color, theme) {\n        if (typeof color === 'string') {\n            return Color.fromHex(color);\n        }\n        return theme.getColor(color.id);\n    }\n}\nexport class ModelDecorationInjectedTextOptions {\n    static from(options) {\n        if (options instanceof ModelDecorationInjectedTextOptions) {\n            return options;\n        }\n        return new ModelDecorationInjectedTextOptions(options);\n    }\n    constructor(options) {\n        this.content = options.content || '';\n        this.inlineClassName = options.inlineClassName || null;\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n        this.attachedData = options.attachedData || null;\n        this.cursorStops = options.cursorStops || null;\n    }\n}\nexport class ModelDecorationOptions {\n    static register(options) {\n        return new ModelDecorationOptions(options);\n    }\n    static createDynamic(options) {\n        return new ModelDecorationOptions(options);\n    }\n    constructor(options) {\n        var _a, _b, _c, _d, _e, _f;\n        this.description = options.description;\n        this.blockClassName = options.blockClassName ? cleanClassName(options.blockClassName) : null;\n        this.blockDoesNotCollapse = (_a = options.blockDoesNotCollapse) !== null && _a !== void 0 ? _a : null;\n        this.blockIsAfterEnd = (_b = options.blockIsAfterEnd) !== null && _b !== void 0 ? _b : null;\n        this.blockPadding = (_c = options.blockPadding) !== null && _c !== void 0 ? _c : null;\n        this.stickiness = options.stickiness || 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */;\n        this.zIndex = options.zIndex || 0;\n        this.className = options.className ? cleanClassName(options.className) : null;\n        this.shouldFillLineOnLineBreak = (_d = options.shouldFillLineOnLineBreak) !== null && _d !== void 0 ? _d : null;\n        this.hoverMessage = options.hoverMessage || null;\n        this.glyphMarginHoverMessage = options.glyphMarginHoverMessage || null;\n        this.lineNumberHoverMessage = options.lineNumberHoverMessage || null;\n        this.isWholeLine = options.isWholeLine || false;\n        this.showIfCollapsed = options.showIfCollapsed || false;\n        this.collapseOnReplaceEdit = options.collapseOnReplaceEdit || false;\n        this.overviewRuler = options.overviewRuler ? new ModelDecorationOverviewRulerOptions(options.overviewRuler) : null;\n        this.minimap = options.minimap ? new ModelDecorationMinimapOptions(options.minimap) : null;\n        this.glyphMargin = options.glyphMarginClassName ? new ModelDecorationGlyphMarginOptions(options.glyphMargin) : null;\n        this.glyphMarginClassName = options.glyphMarginClassName ? cleanClassName(options.glyphMarginClassName) : null;\n        this.linesDecorationsClassName = options.linesDecorationsClassName ? cleanClassName(options.linesDecorationsClassName) : null;\n        this.lineNumberClassName = options.lineNumberClassName ? cleanClassName(options.lineNumberClassName) : null;\n        this.linesDecorationsTooltip = options.linesDecorationsTooltip ? strings.htmlAttributeEncodeValue(options.linesDecorationsTooltip) : null;\n        this.firstLineDecorationClassName = options.firstLineDecorationClassName ? cleanClassName(options.firstLineDecorationClassName) : null;\n        this.marginClassName = options.marginClassName ? cleanClassName(options.marginClassName) : null;\n        this.inlineClassName = options.inlineClassName ? cleanClassName(options.inlineClassName) : null;\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n        this.beforeContentClassName = options.beforeContentClassName ? cleanClassName(options.beforeContentClassName) : null;\n        this.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : null;\n        this.after = options.after ? ModelDecorationInjectedTextOptions.from(options.after) : null;\n        this.before = options.before ? ModelDecorationInjectedTextOptions.from(options.before) : null;\n        this.hideInCommentTokens = (_e = options.hideInCommentTokens) !== null && _e !== void 0 ? _e : false;\n        this.hideInStringTokens = (_f = options.hideInStringTokens) !== null && _f !== void 0 ? _f : false;\n    }\n}\nModelDecorationOptions.EMPTY = ModelDecorationOptions.register({ description: 'empty' });\n/**\n * The order carefully matches the values of the enum.\n */\nconst TRACKED_RANGE_OPTIONS = [\n    ModelDecorationOptions.register({ description: 'tracked-range-always-grows-when-typing-at-edges', stickiness: 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-never-grows-when-typing-at-edges', stickiness: 1 /* model.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-before', stickiness: 2 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-after', stickiness: 3 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */ }),\n];\nfunction _normalizeOptions(options) {\n    if (options instanceof ModelDecorationOptions) {\n        return options;\n    }\n    return ModelDecorationOptions.createDynamic(options);\n}\nclass DidChangeDecorationsEmitter extends Disposable {\n    constructor(handleBeforeFire) {\n        super();\n        this.handleBeforeFire = handleBeforeFire;\n        this._actual = this._register(new Emitter());\n        this.event = this._actual.event;\n        this._affectedInjectedTextLines = null;\n        this._deferredCnt = 0;\n        this._shouldFireDeferred = false;\n        this._affectsMinimap = false;\n        this._affectsOverviewRuler = false;\n        this._affectsGlyphMargin = false;\n        this._affectsLineNumber = false;\n    }\n    beginDeferredEmit() {\n        this._deferredCnt++;\n    }\n    endDeferredEmit() {\n        var _a;\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._shouldFireDeferred) {\n                this.doFire();\n            }\n            (_a = this._affectedInjectedTextLines) === null || _a === void 0 ? void 0 : _a.clear();\n            this._affectedInjectedTextLines = null;\n        }\n    }\n    recordLineAffectedByInjectedText(lineNumber) {\n        if (!this._affectedInjectedTextLines) {\n            this._affectedInjectedTextLines = new Set();\n        }\n        this._affectedInjectedTextLines.add(lineNumber);\n    }\n    checkAffectedAndFire(options) {\n        var _a, _b;\n        this._affectsMinimap || (this._affectsMinimap = !!((_a = options.minimap) === null || _a === void 0 ? void 0 : _a.position));\n        this._affectsOverviewRuler || (this._affectsOverviewRuler = !!((_b = options.overviewRuler) === null || _b === void 0 ? void 0 : _b.color));\n        this._affectsGlyphMargin || (this._affectsGlyphMargin = !!options.glyphMarginClassName);\n        this._affectsLineNumber || (this._affectsLineNumber = !!options.lineNumberClassName);\n        this.tryFire();\n    }\n    fire() {\n        this._affectsMinimap = true;\n        this._affectsOverviewRuler = true;\n        this._affectsGlyphMargin = true;\n        this.tryFire();\n    }\n    tryFire() {\n        if (this._deferredCnt === 0) {\n            this.doFire();\n        }\n        else {\n            this._shouldFireDeferred = true;\n        }\n    }\n    doFire() {\n        this.handleBeforeFire(this._affectedInjectedTextLines);\n        const event = {\n            affectsMinimap: this._affectsMinimap,\n            affectsOverviewRuler: this._affectsOverviewRuler,\n            affectsGlyphMargin: this._affectsGlyphMargin,\n            affectsLineNumber: this._affectsLineNumber,\n        };\n        this._shouldFireDeferred = false;\n        this._affectsMinimap = false;\n        this._affectsOverviewRuler = false;\n        this._affectsGlyphMargin = false;\n        this._actual.fire(event);\n    }\n}\n//#endregion\nclass DidChangeContentEmitter extends Disposable {\n    constructor() {\n        super();\n        /**\n         * Both `fastEvent` and `slowEvent` work the same way and contain the same events, but first we invoke `fastEvent` and then `slowEvent`.\n         */\n        this._fastEmitter = this._register(new Emitter());\n        this.fastEvent = this._fastEmitter.event;\n        this._slowEmitter = this._register(new Emitter());\n        this.slowEvent = this._slowEmitter.event;\n        this._deferredCnt = 0;\n        this._deferredEvent = null;\n    }\n    beginDeferredEmit() {\n        this._deferredCnt++;\n    }\n    endDeferredEmit(resultingSelection = null) {\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._deferredEvent !== null) {\n                this._deferredEvent.rawContentChangedEvent.resultingSelection = resultingSelection;\n                const e = this._deferredEvent;\n                this._deferredEvent = null;\n                this._fastEmitter.fire(e);\n                this._slowEmitter.fire(e);\n            }\n        }\n    }\n    fire(e) {\n        if (this._deferredCnt > 0) {\n            if (this._deferredEvent) {\n                this._deferredEvent = this._deferredEvent.merge(e);\n            }\n            else {\n                this._deferredEvent = e;\n            }\n            return;\n        }\n        this._fastEmitter.fire(e);\n        this._slowEmitter.fire(e);\n    }\n}\n/**\n * @internal\n */\nexport class AttachedViews {\n    constructor() {\n        this._onDidChangeVisibleRanges = new Emitter();\n        this.onDidChangeVisibleRanges = this._onDidChangeVisibleRanges.event;\n        this._views = new Set();\n    }\n    attachView() {\n        const view = new AttachedViewImpl((state) => {\n            this._onDidChangeVisibleRanges.fire({ view, state });\n        });\n        this._views.add(view);\n        return view;\n    }\n    detachView(view) {\n        this._views.delete(view);\n        this._onDidChangeVisibleRanges.fire({ view, state: undefined });\n    }\n}\nclass AttachedViewImpl {\n    constructor(handleStateChange) {\n        this.handleStateChange = handleStateChange;\n    }\n    setVisibleLines(visibleLines, stabilized) {\n        const visibleLineRanges = visibleLines.map((line) => new LineRange(line.startLineNumber, line.endLineNumber + 1));\n        this.handleStateChange({ visibleLineRanges, stabilized });\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}