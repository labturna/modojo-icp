{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorCollection } from './cursorCollection.js';\nimport { CursorState, EditOperationResult } from '../cursorCommon.js';\nimport { CursorContext } from './cursorContext.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { CompositionOutcome, TypeOperations, TypeWithAutoClosingCommand } from './cursorTypeOperations.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { ModelInjectedTextChangedEvent } from '../textModelEvents.js';\nimport { ViewCursorStateChangedEvent, ViewRevealRangeRequestEvent } from '../viewEvents.js';\nimport { dispose, Disposable } from '../../../base/common/lifecycle.js';\nimport { CursorStateChangedEvent } from '../viewModelEventDispatcher.js';\nexport class CursorsController extends Disposable {\n  constructor(model, viewModel, coordinatesConverter, cursorConfig) {\n    super();\n    this._model = model;\n    this._knownModelVersionId = this._model.getVersionId();\n    this._viewModel = viewModel;\n    this._coordinatesConverter = coordinatesConverter;\n    this.context = new CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);\n    this._cursors = new CursorCollection(this.context);\n    this._hasFocus = false;\n    this._isHandling = false;\n    this._compositionState = null;\n    this._columnSelectData = null;\n    this._autoClosedActions = [];\n    this._prevEditOperationType = 0 /* EditOperationType.Other */;\n  }\n  dispose() {\n    this._cursors.dispose();\n    this._autoClosedActions = dispose(this._autoClosedActions);\n    super.dispose();\n  }\n  updateConfiguration(cursorConfig) {\n    this.context = new CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);\n    this._cursors.updateContext(this.context);\n  }\n  onLineMappingChanged(eventsCollector) {\n    if (this._knownModelVersionId !== this._model.getVersionId()) {\n      // There are model change events that I didn't yet receive.\n      //\n      // This can happen when editing the model, and the view model receives the change events first,\n      // and the view model emits line mapping changed events, all before the cursor gets a chance to\n      // recover from markers.\n      //\n      // The model change listener above will be called soon and we'll ensure a valid cursor state there.\n      return;\n    }\n    // Ensure valid state\n    this.setStates(eventsCollector, 'viewModel', 0 /* CursorChangeReason.NotSet */, this.getCursorStates());\n  }\n  setHasFocus(hasFocus) {\n    this._hasFocus = hasFocus;\n  }\n  _validateAutoClosedActions() {\n    if (this._autoClosedActions.length > 0) {\n      const selections = this._cursors.getSelections();\n      for (let i = 0; i < this._autoClosedActions.length; i++) {\n        const autoClosedAction = this._autoClosedActions[i];\n        if (!autoClosedAction.isValid(selections)) {\n          autoClosedAction.dispose();\n          this._autoClosedActions.splice(i, 1);\n          i--;\n        }\n      }\n    }\n  }\n  // ------ some getters/setters\n  getPrimaryCursorState() {\n    return this._cursors.getPrimaryCursor();\n  }\n  getLastAddedCursorIndex() {\n    return this._cursors.getLastAddedCursorIndex();\n  }\n  getCursorStates() {\n    return this._cursors.getAll();\n  }\n  setStates(eventsCollector, source, reason, states) {\n    let reachedMaxCursorCount = false;\n    const multiCursorLimit = this.context.cursorConfig.multiCursorLimit;\n    if (states !== null && states.length > multiCursorLimit) {\n      states = states.slice(0, multiCursorLimit);\n      reachedMaxCursorCount = true;\n    }\n    const oldState = CursorModelState.from(this._model, this);\n    this._cursors.setStates(states);\n    this._cursors.normalize();\n    this._columnSelectData = null;\n    this._validateAutoClosedActions();\n    return this._emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount);\n  }\n  setCursorColumnSelectData(columnSelectData) {\n    this._columnSelectData = columnSelectData;\n  }\n  revealAll(eventsCollector, source, minimalReveal, verticalType, revealHorizontal, scrollType) {\n    const viewPositions = this._cursors.getViewPositions();\n    let revealViewRange = null;\n    let revealViewSelections = null;\n    if (viewPositions.length > 1) {\n      revealViewSelections = this._cursors.getViewSelections();\n    } else {\n      revealViewRange = Range.fromPositions(viewPositions[0], viewPositions[0]);\n    }\n    eventsCollector.emitViewEvent(new ViewRevealRangeRequestEvent(source, minimalReveal, revealViewRange, revealViewSelections, verticalType, revealHorizontal, scrollType));\n  }\n  revealPrimary(eventsCollector, source, minimalReveal, verticalType, revealHorizontal, scrollType) {\n    const primaryCursor = this._cursors.getPrimaryCursor();\n    const revealViewSelections = [primaryCursor.viewState.selection];\n    eventsCollector.emitViewEvent(new ViewRevealRangeRequestEvent(source, minimalReveal, null, revealViewSelections, verticalType, revealHorizontal, scrollType));\n  }\n  saveState() {\n    const result = [];\n    const selections = this._cursors.getSelections();\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n      result.push({\n        inSelectionMode: !selection.isEmpty(),\n        selectionStart: {\n          lineNumber: selection.selectionStartLineNumber,\n          column: selection.selectionStartColumn\n        },\n        position: {\n          lineNumber: selection.positionLineNumber,\n          column: selection.positionColumn\n        }\n      });\n    }\n    return result;\n  }\n  restoreState(eventsCollector, states) {\n    const desiredSelections = [];\n    for (let i = 0, len = states.length; i < len; i++) {\n      const state = states[i];\n      let positionLineNumber = 1;\n      let positionColumn = 1;\n      // Avoid missing properties on the literal\n      if (state.position && state.position.lineNumber) {\n        positionLineNumber = state.position.lineNumber;\n      }\n      if (state.position && state.position.column) {\n        positionColumn = state.position.column;\n      }\n      let selectionStartLineNumber = positionLineNumber;\n      let selectionStartColumn = positionColumn;\n      // Avoid missing properties on the literal\n      if (state.selectionStart && state.selectionStart.lineNumber) {\n        selectionStartLineNumber = state.selectionStart.lineNumber;\n      }\n      if (state.selectionStart && state.selectionStart.column) {\n        selectionStartColumn = state.selectionStart.column;\n      }\n      desiredSelections.push({\n        selectionStartLineNumber: selectionStartLineNumber,\n        selectionStartColumn: selectionStartColumn,\n        positionLineNumber: positionLineNumber,\n        positionColumn: positionColumn\n      });\n    }\n    this.setStates(eventsCollector, 'restoreState', 0 /* CursorChangeReason.NotSet */, CursorState.fromModelSelections(desiredSelections));\n    this.revealAll(eventsCollector, 'restoreState', false, 0 /* VerticalRevealType.Simple */, true, 1 /* editorCommon.ScrollType.Immediate */);\n  }\n  onModelContentChanged(eventsCollector, event) {\n    if (event instanceof ModelInjectedTextChangedEvent) {\n      // If injected texts change, the view positions of all cursors need to be updated.\n      if (this._isHandling) {\n        // The view positions will be updated when handling finishes\n        return;\n      }\n      // setStates might remove markers, which could trigger a decoration change.\n      // If there are injected text decorations for that line, `onModelContentChanged` is emitted again\n      // and an endless recursion happens.\n      // _isHandling prevents that.\n      this._isHandling = true;\n      try {\n        this.setStates(eventsCollector, 'modelChange', 0 /* CursorChangeReason.NotSet */, this.getCursorStates());\n      } finally {\n        this._isHandling = false;\n      }\n    } else {\n      const e = event.rawContentChangedEvent;\n      this._knownModelVersionId = e.versionId;\n      if (this._isHandling) {\n        return;\n      }\n      const hadFlushEvent = e.containsEvent(1 /* RawContentChangedType.Flush */);\n      this._prevEditOperationType = 0 /* EditOperationType.Other */;\n      if (hadFlushEvent) {\n        // a model.setValue() was called\n        this._cursors.dispose();\n        this._cursors = new CursorCollection(this.context);\n        this._validateAutoClosedActions();\n        this._emitStateChangedIfNecessary(eventsCollector, 'model', 1 /* CursorChangeReason.ContentFlush */, null, false);\n      } else {\n        if (this._hasFocus && e.resultingSelection && e.resultingSelection.length > 0) {\n          const cursorState = CursorState.fromModelSelections(e.resultingSelection);\n          if (this.setStates(eventsCollector, 'modelChange', e.isUndoing ? 5 /* CursorChangeReason.Undo */ : e.isRedoing ? 6 /* CursorChangeReason.Redo */ : 2 /* CursorChangeReason.RecoverFromMarkers */, cursorState)) {\n            this.revealAll(eventsCollector, 'modelChange', false, 0 /* VerticalRevealType.Simple */, true, 0 /* editorCommon.ScrollType.Smooth */);\n          }\n        } else {\n          const selectionsFromMarkers = this._cursors.readSelectionFromMarkers();\n          this.setStates(eventsCollector, 'modelChange', 2 /* CursorChangeReason.RecoverFromMarkers */, CursorState.fromModelSelections(selectionsFromMarkers));\n        }\n      }\n    }\n  }\n  getSelection() {\n    return this._cursors.getPrimaryCursor().modelState.selection;\n  }\n  getTopMostViewPosition() {\n    return this._cursors.getTopMostViewPosition();\n  }\n  getBottomMostViewPosition() {\n    return this._cursors.getBottomMostViewPosition();\n  }\n  getCursorColumnSelectData() {\n    if (this._columnSelectData) {\n      return this._columnSelectData;\n    }\n    const primaryCursor = this._cursors.getPrimaryCursor();\n    const viewSelectionStart = primaryCursor.viewState.selectionStart.getStartPosition();\n    const viewPosition = primaryCursor.viewState.position;\n    return {\n      isReal: false,\n      fromViewLineNumber: viewSelectionStart.lineNumber,\n      fromViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, viewSelectionStart),\n      toViewLineNumber: viewPosition.lineNumber,\n      toViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, viewPosition)\n    };\n  }\n  getSelections() {\n    return this._cursors.getSelections();\n  }\n  setSelections(eventsCollector, source, selections, reason) {\n    this.setStates(eventsCollector, source, reason, CursorState.fromModelSelections(selections));\n  }\n  getPrevEditOperationType() {\n    return this._prevEditOperationType;\n  }\n  setPrevEditOperationType(type) {\n    this._prevEditOperationType = type;\n  }\n  // ------ auxiliary handling logic\n  _pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges) {\n    const autoClosedCharactersDeltaDecorations = [];\n    const autoClosedEnclosingDeltaDecorations = [];\n    for (let i = 0, len = autoClosedCharactersRanges.length; i < len; i++) {\n      autoClosedCharactersDeltaDecorations.push({\n        range: autoClosedCharactersRanges[i],\n        options: {\n          description: 'auto-closed-character',\n          inlineClassName: 'auto-closed-character',\n          stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n        }\n      });\n      autoClosedEnclosingDeltaDecorations.push({\n        range: autoClosedEnclosingRanges[i],\n        options: {\n          description: 'auto-closed-enclosing',\n          stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n        }\n      });\n    }\n    const autoClosedCharactersDecorations = this._model.deltaDecorations([], autoClosedCharactersDeltaDecorations);\n    const autoClosedEnclosingDecorations = this._model.deltaDecorations([], autoClosedEnclosingDeltaDecorations);\n    this._autoClosedActions.push(new AutoClosedAction(this._model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations));\n  }\n  _executeEditOperation(opResult) {\n    if (!opResult) {\n      // Nothing to execute\n      return;\n    }\n    if (opResult.shouldPushStackElementBefore) {\n      this._model.pushStackElement();\n    }\n    const result = CommandExecutor.executeCommands(this._model, this._cursors.getSelections(), opResult.commands);\n    if (result) {\n      // The commands were applied correctly\n      this._interpretCommandResult(result);\n      // Check for auto-closing closed characters\n      const autoClosedCharactersRanges = [];\n      const autoClosedEnclosingRanges = [];\n      for (let i = 0; i < opResult.commands.length; i++) {\n        const command = opResult.commands[i];\n        if (command instanceof TypeWithAutoClosingCommand && command.enclosingRange && command.closeCharacterRange) {\n          autoClosedCharactersRanges.push(command.closeCharacterRange);\n          autoClosedEnclosingRanges.push(command.enclosingRange);\n        }\n      }\n      if (autoClosedCharactersRanges.length > 0) {\n        this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n      }\n      this._prevEditOperationType = opResult.type;\n    }\n    if (opResult.shouldPushStackElementAfter) {\n      this._model.pushStackElement();\n    }\n  }\n  _interpretCommandResult(cursorState) {\n    if (!cursorState || cursorState.length === 0) {\n      cursorState = this._cursors.readSelectionFromMarkers();\n    }\n    this._columnSelectData = null;\n    this._cursors.setSelections(cursorState);\n    this._cursors.normalize();\n  }\n  // -----------------------------------------------------------------------------------------------------------\n  // ----- emitting events\n  _emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount) {\n    const newState = CursorModelState.from(this._model, this);\n    if (newState.equals(oldState)) {\n      return false;\n    }\n    const selections = this._cursors.getSelections();\n    const viewSelections = this._cursors.getViewSelections();\n    // Let the view get the event first.\n    eventsCollector.emitViewEvent(new ViewCursorStateChangedEvent(viewSelections, selections, reason));\n    // Only after the view has been notified, let the rest of the world know...\n    if (!oldState || oldState.cursorState.length !== newState.cursorState.length || newState.cursorState.some((newCursorState, i) => !newCursorState.modelState.equals(oldState.cursorState[i].modelState))) {\n      const oldSelections = oldState ? oldState.cursorState.map(s => s.modelState.selection) : null;\n      const oldModelVersionId = oldState ? oldState.modelVersionId : 0;\n      eventsCollector.emitOutgoingEvent(new CursorStateChangedEvent(oldSelections, selections, oldModelVersionId, newState.modelVersionId, source || 'keyboard', reason, reachedMaxCursorCount));\n    }\n    return true;\n  }\n  // -----------------------------------------------------------------------------------------------------------\n  // ----- handlers beyond this point\n  _findAutoClosingPairs(edits) {\n    if (!edits.length) {\n      return null;\n    }\n    const indices = [];\n    for (let i = 0, len = edits.length; i < len; i++) {\n      const edit = edits[i];\n      if (!edit.text || edit.text.indexOf('\\n') >= 0) {\n        return null;\n      }\n      const m = edit.text.match(/([)\\]}>'\"`])([^)\\]}>'\"`]*)$/);\n      if (!m) {\n        return null;\n      }\n      const closeChar = m[1];\n      const autoClosingPairsCandidates = this.context.cursorConfig.autoClosingPairs.autoClosingPairsCloseSingleChar.get(closeChar);\n      if (!autoClosingPairsCandidates || autoClosingPairsCandidates.length !== 1) {\n        return null;\n      }\n      const openChar = autoClosingPairsCandidates[0].open;\n      const closeCharIndex = edit.text.length - m[2].length - 1;\n      const openCharIndex = edit.text.lastIndexOf(openChar, closeCharIndex - 1);\n      if (openCharIndex === -1) {\n        return null;\n      }\n      indices.push([openCharIndex, closeCharIndex]);\n    }\n    return indices;\n  }\n  executeEdits(eventsCollector, source, edits, cursorStateComputer) {\n    let autoClosingIndices = null;\n    if (source === 'snippet') {\n      autoClosingIndices = this._findAutoClosingPairs(edits);\n    }\n    if (autoClosingIndices) {\n      edits[0]._isTracked = true;\n    }\n    const autoClosedCharactersRanges = [];\n    const autoClosedEnclosingRanges = [];\n    const selections = this._model.pushEditOperations(this.getSelections(), edits, undoEdits => {\n      if (autoClosingIndices) {\n        for (let i = 0, len = autoClosingIndices.length; i < len; i++) {\n          const [openCharInnerIndex, closeCharInnerIndex] = autoClosingIndices[i];\n          const undoEdit = undoEdits[i];\n          const lineNumber = undoEdit.range.startLineNumber;\n          const openCharIndex = undoEdit.range.startColumn - 1 + openCharInnerIndex;\n          const closeCharIndex = undoEdit.range.startColumn - 1 + closeCharInnerIndex;\n          autoClosedCharactersRanges.push(new Range(lineNumber, closeCharIndex + 1, lineNumber, closeCharIndex + 2));\n          autoClosedEnclosingRanges.push(new Range(lineNumber, openCharIndex + 1, lineNumber, closeCharIndex + 2));\n        }\n      }\n      const selections = cursorStateComputer(undoEdits);\n      if (selections) {\n        // Don't recover the selection from markers because\n        // we know what it should be.\n        this._isHandling = true;\n      }\n      return selections;\n    });\n    if (selections) {\n      this._isHandling = false;\n      this.setSelections(eventsCollector, source, selections, 0 /* CursorChangeReason.NotSet */);\n    }\n    if (autoClosedCharactersRanges.length > 0) {\n      this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n    }\n  }\n  _executeEdit(callback, eventsCollector, source) {\n    let cursorChangeReason = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    if (this.context.cursorConfig.readOnly) {\n      // we cannot edit when read only...\n      return;\n    }\n    const oldState = CursorModelState.from(this._model, this);\n    this._cursors.stopTrackingSelections();\n    this._isHandling = true;\n    try {\n      this._cursors.ensureValidState();\n      callback();\n    } catch (err) {\n      onUnexpectedError(err);\n    }\n    this._isHandling = false;\n    this._cursors.startTrackingSelections();\n    this._validateAutoClosedActions();\n    if (this._emitStateChangedIfNecessary(eventsCollector, source, cursorChangeReason, oldState, false)) {\n      this.revealAll(eventsCollector, source, false, 0 /* VerticalRevealType.Simple */, true, 0 /* editorCommon.ScrollType.Smooth */);\n    }\n  }\n  getAutoClosedCharacters() {\n    return AutoClosedAction.getAllAutoClosedCharacters(this._autoClosedActions);\n  }\n  startComposition(eventsCollector) {\n    this._compositionState = new CompositionState(this._model, this.getSelections());\n  }\n  endComposition(eventsCollector, source) {\n    const compositionOutcome = this._compositionState ? this._compositionState.deduceOutcome(this._model, this.getSelections()) : null;\n    this._compositionState = null;\n    this._executeEdit(() => {\n      if (source === 'keyboard') {\n        // composition finishes, let's check if we need to auto complete if necessary.\n        this._executeEditOperation(TypeOperations.compositionEndWithInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, compositionOutcome, this.getSelections(), this.getAutoClosedCharacters()));\n      }\n    }, eventsCollector, source);\n  }\n  type(eventsCollector, text, source) {\n    this._executeEdit(() => {\n      if (source === 'keyboard') {\n        // If this event is coming straight from the keyboard, look for electric characters and enter\n        const len = text.length;\n        let offset = 0;\n        while (offset < len) {\n          const charLength = strings.nextCharLength(text, offset);\n          const chr = text.substr(offset, charLength);\n          // Here we must interpret each typed character individually\n          this._executeEditOperation(TypeOperations.typeWithInterceptors(!!this._compositionState, this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), this.getAutoClosedCharacters(), chr));\n          offset += charLength;\n        }\n      } else {\n        this._executeEditOperation(TypeOperations.typeWithoutInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text));\n      }\n    }, eventsCollector, source);\n  }\n  compositionType(eventsCollector, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source) {\n    if (text.length === 0 && replacePrevCharCnt === 0 && replaceNextCharCnt === 0) {\n      // this edit is a no-op\n      if (positionDelta !== 0) {\n        // but it still wants to move the cursor\n        const newSelections = this.getSelections().map(selection => {\n          const position = selection.getPosition();\n          return new Selection(position.lineNumber, position.column + positionDelta, position.lineNumber, position.column + positionDelta);\n        });\n        this.setSelections(eventsCollector, source, newSelections, 0 /* CursorChangeReason.NotSet */);\n      }\n      return;\n    }\n    this._executeEdit(() => {\n      this._executeEditOperation(TypeOperations.compositionType(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n    }, eventsCollector, source);\n  }\n  paste(eventsCollector, text, pasteOnNewLine, multicursorText, source) {\n    this._executeEdit(() => {\n      this._executeEditOperation(TypeOperations.paste(this.context.cursorConfig, this._model, this.getSelections(), text, pasteOnNewLine, multicursorText || []));\n    }, eventsCollector, source, 4 /* CursorChangeReason.Paste */);\n  }\n  cut(eventsCollector, source) {\n    this._executeEdit(() => {\n      this._executeEditOperation(DeleteOperations.cut(this.context.cursorConfig, this._model, this.getSelections()));\n    }, eventsCollector, source);\n  }\n  executeCommand(eventsCollector, command, source) {\n    this._executeEdit(() => {\n      this._cursors.killSecondaryCursors();\n      this._executeEditOperation(new EditOperationResult(0 /* EditOperationType.Other */, [command], {\n        shouldPushStackElementBefore: false,\n        shouldPushStackElementAfter: false\n      }));\n    }, eventsCollector, source);\n  }\n  executeCommands(eventsCollector, commands, source) {\n    this._executeEdit(() => {\n      this._executeEditOperation(new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n        shouldPushStackElementBefore: false,\n        shouldPushStackElementAfter: false\n      }));\n    }, eventsCollector, source);\n  }\n}\n/**\n * A snapshot of the cursor and the model state\n */\nclass CursorModelState {\n  static from(model, cursor) {\n    return new CursorModelState(model.getVersionId(), cursor.getCursorStates());\n  }\n  constructor(modelVersionId, cursorState) {\n    this.modelVersionId = modelVersionId;\n    this.cursorState = cursorState;\n  }\n  equals(other) {\n    if (!other) {\n      return false;\n    }\n    if (this.modelVersionId !== other.modelVersionId) {\n      return false;\n    }\n    if (this.cursorState.length !== other.cursorState.length) {\n      return false;\n    }\n    for (let i = 0, len = this.cursorState.length; i < len; i++) {\n      if (!this.cursorState[i].equals(other.cursorState[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\nclass AutoClosedAction {\n  static getAllAutoClosedCharacters(autoClosedActions) {\n    let autoClosedCharacters = [];\n    for (const autoClosedAction of autoClosedActions) {\n      autoClosedCharacters = autoClosedCharacters.concat(autoClosedAction.getAutoClosedCharactersRanges());\n    }\n    return autoClosedCharacters;\n  }\n  constructor(model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations) {\n    this._model = model;\n    this._autoClosedCharactersDecorations = autoClosedCharactersDecorations;\n    this._autoClosedEnclosingDecorations = autoClosedEnclosingDecorations;\n  }\n  dispose() {\n    this._autoClosedCharactersDecorations = this._model.deltaDecorations(this._autoClosedCharactersDecorations, []);\n    this._autoClosedEnclosingDecorations = this._model.deltaDecorations(this._autoClosedEnclosingDecorations, []);\n  }\n  getAutoClosedCharactersRanges() {\n    const result = [];\n    for (let i = 0; i < this._autoClosedCharactersDecorations.length; i++) {\n      const decorationRange = this._model.getDecorationRange(this._autoClosedCharactersDecorations[i]);\n      if (decorationRange) {\n        result.push(decorationRange);\n      }\n    }\n    return result;\n  }\n  isValid(selections) {\n    const enclosingRanges = [];\n    for (let i = 0; i < this._autoClosedEnclosingDecorations.length; i++) {\n      const decorationRange = this._model.getDecorationRange(this._autoClosedEnclosingDecorations[i]);\n      if (decorationRange) {\n        enclosingRanges.push(decorationRange);\n        if (decorationRange.startLineNumber !== decorationRange.endLineNumber) {\n          // Stop tracking if the range becomes multiline...\n          return false;\n        }\n      }\n    }\n    enclosingRanges.sort(Range.compareRangesUsingStarts);\n    selections.sort(Range.compareRangesUsingStarts);\n    for (let i = 0; i < selections.length; i++) {\n      if (i >= enclosingRanges.length) {\n        return false;\n      }\n      if (!enclosingRanges[i].strictContainsRange(selections[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\nclass CommandExecutor {\n  static executeCommands(model, selectionsBefore, commands) {\n    const ctx = {\n      model: model,\n      selectionsBefore: selectionsBefore,\n      trackedRanges: [],\n      trackedRangesDirection: []\n    };\n    const result = this._innerExecuteCommands(ctx, commands);\n    for (let i = 0, len = ctx.trackedRanges.length; i < len; i++) {\n      ctx.model._setTrackedRange(ctx.trackedRanges[i], null, 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */);\n    }\n    return result;\n  }\n  static _innerExecuteCommands(ctx, commands) {\n    if (this._arrayIsEmpty(commands)) {\n      return null;\n    }\n    const commandsData = this._getEditOperations(ctx, commands);\n    if (commandsData.operations.length === 0) {\n      return null;\n    }\n    const rawOperations = commandsData.operations;\n    const loserCursorsMap = this._getLoserCursorMap(rawOperations);\n    if (loserCursorsMap.hasOwnProperty('0')) {\n      // These commands are very messed up\n      console.warn('Ignoring commands');\n      return null;\n    }\n    // Remove operations belonging to losing cursors\n    const filteredOperations = [];\n    for (let i = 0, len = rawOperations.length; i < len; i++) {\n      if (!loserCursorsMap.hasOwnProperty(rawOperations[i].identifier.major.toString())) {\n        filteredOperations.push(rawOperations[i]);\n      }\n    }\n    // TODO@Alex: find a better way to do this.\n    // give the hint that edit operations are tracked to the model\n    if (commandsData.hadTrackedEditOperation && filteredOperations.length > 0) {\n      filteredOperations[0]._isTracked = true;\n    }\n    let selectionsAfter = ctx.model.pushEditOperations(ctx.selectionsBefore, filteredOperations, inverseEditOperations => {\n      const groupedInverseEditOperations = [];\n      for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n        groupedInverseEditOperations[i] = [];\n      }\n      for (const op of inverseEditOperations) {\n        if (!op.identifier) {\n          // perhaps auto whitespace trim edits\n          continue;\n        }\n        groupedInverseEditOperations[op.identifier.major].push(op);\n      }\n      const minorBasedSorter = (a, b) => {\n        return a.identifier.minor - b.identifier.minor;\n      };\n      const cursorSelections = [];\n      for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n        if (groupedInverseEditOperations[i].length > 0) {\n          groupedInverseEditOperations[i].sort(minorBasedSorter);\n          cursorSelections[i] = commands[i].computeCursorState(ctx.model, {\n            getInverseEditOperations: () => {\n              return groupedInverseEditOperations[i];\n            },\n            getTrackedSelection: id => {\n              const idx = parseInt(id, 10);\n              const range = ctx.model._getTrackedRange(ctx.trackedRanges[idx]);\n              if (ctx.trackedRangesDirection[idx] === 0 /* SelectionDirection.LTR */) {\n                return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n              }\n              return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n            }\n          });\n        } else {\n          cursorSelections[i] = ctx.selectionsBefore[i];\n        }\n      }\n      return cursorSelections;\n    });\n    if (!selectionsAfter) {\n      selectionsAfter = ctx.selectionsBefore;\n    }\n    // Extract losing cursors\n    const losingCursors = [];\n    for (const losingCursorIndex in loserCursorsMap) {\n      if (loserCursorsMap.hasOwnProperty(losingCursorIndex)) {\n        losingCursors.push(parseInt(losingCursorIndex, 10));\n      }\n    }\n    // Sort losing cursors descending\n    losingCursors.sort((a, b) => {\n      return b - a;\n    });\n    // Remove losing cursors\n    for (const losingCursor of losingCursors) {\n      selectionsAfter.splice(losingCursor, 1);\n    }\n    return selectionsAfter;\n  }\n  static _arrayIsEmpty(commands) {\n    for (let i = 0, len = commands.length; i < len; i++) {\n      if (commands[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  static _getEditOperations(ctx, commands) {\n    let operations = [];\n    let hadTrackedEditOperation = false;\n    for (let i = 0, len = commands.length; i < len; i++) {\n      const command = commands[i];\n      if (command) {\n        const r = this._getEditOperationsFromCommand(ctx, i, command);\n        operations = operations.concat(r.operations);\n        hadTrackedEditOperation = hadTrackedEditOperation || r.hadTrackedEditOperation;\n      }\n    }\n    return {\n      operations: operations,\n      hadTrackedEditOperation: hadTrackedEditOperation\n    };\n  }\n  static _getEditOperationsFromCommand(ctx, majorIdentifier, command) {\n    // This method acts as a transaction, if the command fails\n    // everything it has done is ignored\n    const operations = [];\n    let operationMinor = 0;\n    const addEditOperation = function (range, text) {\n      let forceMoveMarkers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      if (Range.isEmpty(range) && text === '') {\n        // This command wants to add a no-op => no thank you\n        return;\n      }\n      operations.push({\n        identifier: {\n          major: majorIdentifier,\n          minor: operationMinor++\n        },\n        range: range,\n        text: text,\n        forceMoveMarkers: forceMoveMarkers,\n        isAutoWhitespaceEdit: command.insertsAutoWhitespace\n      });\n    };\n    let hadTrackedEditOperation = false;\n    const addTrackedEditOperation = (selection, text, forceMoveMarkers) => {\n      hadTrackedEditOperation = true;\n      addEditOperation(selection, text, forceMoveMarkers);\n    };\n    const trackSelection = (_selection, trackPreviousOnEmpty) => {\n      const selection = Selection.liftSelection(_selection);\n      let stickiness;\n      if (selection.isEmpty()) {\n        if (typeof trackPreviousOnEmpty === 'boolean') {\n          if (trackPreviousOnEmpty) {\n            stickiness = 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */;\n          } else {\n            stickiness = 3 /* TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */;\n          }\n        } else {\n          // Try to lock it with surrounding text\n          const maxLineColumn = ctx.model.getLineMaxColumn(selection.startLineNumber);\n          if (selection.startColumn === maxLineColumn) {\n            stickiness = 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */;\n          } else {\n            stickiness = 3 /* TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */;\n          }\n        }\n      } else {\n        stickiness = 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */;\n      }\n      const l = ctx.trackedRanges.length;\n      const id = ctx.model._setTrackedRange(null, selection, stickiness);\n      ctx.trackedRanges[l] = id;\n      ctx.trackedRangesDirection[l] = selection.getDirection();\n      return l.toString();\n    };\n    const editOperationBuilder = {\n      addEditOperation: addEditOperation,\n      addTrackedEditOperation: addTrackedEditOperation,\n      trackSelection: trackSelection\n    };\n    try {\n      command.getEditOperations(ctx.model, editOperationBuilder);\n    } catch (e) {\n      // TODO@Alex use notification service if this should be user facing\n      // e.friendlyMessage = nls.localize('corrupt.commands', \"Unexpected exception while executing command.\");\n      onUnexpectedError(e);\n      return {\n        operations: [],\n        hadTrackedEditOperation: false\n      };\n    }\n    return {\n      operations: operations,\n      hadTrackedEditOperation: hadTrackedEditOperation\n    };\n  }\n  static _getLoserCursorMap(operations) {\n    // This is destructive on the array\n    operations = operations.slice(0);\n    // Sort operations with last one first\n    operations.sort((a, b) => {\n      // Note the minus!\n      return -Range.compareRangesUsingEnds(a.range, b.range);\n    });\n    // Operations can not overlap!\n    const loserCursorsMap = {};\n    for (let i = 1; i < operations.length; i++) {\n      const previousOp = operations[i - 1];\n      const currentOp = operations[i];\n      if (Range.getStartPosition(previousOp.range).isBefore(Range.getEndPosition(currentOp.range))) {\n        let loserMajor;\n        if (previousOp.identifier.major > currentOp.identifier.major) {\n          // previousOp loses the battle\n          loserMajor = previousOp.identifier.major;\n        } else {\n          loserMajor = currentOp.identifier.major;\n        }\n        loserCursorsMap[loserMajor.toString()] = true;\n        for (let j = 0; j < operations.length; j++) {\n          if (operations[j].identifier.major === loserMajor) {\n            operations.splice(j, 1);\n            if (j < i) {\n              i--;\n            }\n            j--;\n          }\n        }\n        if (i > 0) {\n          i--;\n        }\n      }\n    }\n    return loserCursorsMap;\n  }\n}\nclass CompositionLineState {\n  constructor(text, startSelection, endSelection) {\n    this.text = text;\n    this.startSelection = startSelection;\n    this.endSelection = endSelection;\n  }\n}\nclass CompositionState {\n  static _capture(textModel, selections) {\n    const result = [];\n    for (const selection of selections) {\n      if (selection.startLineNumber !== selection.endLineNumber) {\n        return null;\n      }\n      result.push(new CompositionLineState(textModel.getLineContent(selection.startLineNumber), selection.startColumn - 1, selection.endColumn - 1));\n    }\n    return result;\n  }\n  constructor(textModel, selections) {\n    this._original = CompositionState._capture(textModel, selections);\n  }\n  /**\n   * Returns the inserted text during this composition.\n   * If the composition resulted in existing text being changed (i.e. not a pure insertion) it returns null.\n   */\n  deduceOutcome(textModel, selections) {\n    if (!this._original) {\n      return null;\n    }\n    const current = CompositionState._capture(textModel, selections);\n    if (!current) {\n      return null;\n    }\n    if (this._original.length !== current.length) {\n      return null;\n    }\n    const result = [];\n    for (let i = 0, len = this._original.length; i < len; i++) {\n      result.push(CompositionState._deduceOutcome(this._original[i], current[i]));\n    }\n    return result;\n  }\n  static _deduceOutcome(original, current) {\n    const commonPrefix = Math.min(original.startSelection, current.startSelection, strings.commonPrefixLength(original.text, current.text));\n    const commonSuffix = Math.min(original.text.length - original.endSelection, current.text.length - current.endSelection, strings.commonSuffixLength(original.text, current.text));\n    const deletedText = original.text.substring(commonPrefix, original.text.length - commonSuffix);\n    const insertedText = current.text.substring(commonPrefix, current.text.length - commonSuffix);\n    return new CompositionOutcome(deletedText, original.startSelection - commonPrefix, original.endSelection - commonPrefix, insertedText, current.startSelection - commonPrefix, current.endSelection - commonPrefix);\n  }\n}","map":{"version":3,"names":["onUnexpectedError","strings","CursorCollection","CursorState","EditOperationResult","CursorContext","DeleteOperations","CompositionOutcome","TypeOperations","TypeWithAutoClosingCommand","Range","Selection","ModelInjectedTextChangedEvent","ViewCursorStateChangedEvent","ViewRevealRangeRequestEvent","dispose","Disposable","CursorStateChangedEvent","CursorsController","constructor","model","viewModel","coordinatesConverter","cursorConfig","_model","_knownModelVersionId","getVersionId","_viewModel","_coordinatesConverter","context","_cursors","_hasFocus","_isHandling","_compositionState","_columnSelectData","_autoClosedActions","_prevEditOperationType","updateConfiguration","updateContext","onLineMappingChanged","eventsCollector","setStates","getCursorStates","setHasFocus","hasFocus","_validateAutoClosedActions","length","selections","getSelections","i","autoClosedAction","isValid","splice","getPrimaryCursorState","getPrimaryCursor","getLastAddedCursorIndex","getAll","source","reason","states","reachedMaxCursorCount","multiCursorLimit","slice","oldState","CursorModelState","from","normalize","_emitStateChangedIfNecessary","setCursorColumnSelectData","columnSelectData","revealAll","minimalReveal","verticalType","revealHorizontal","scrollType","viewPositions","getViewPositions","revealViewRange","revealViewSelections","getViewSelections","fromPositions","emitViewEvent","revealPrimary","primaryCursor","viewState","selection","saveState","result","len","push","inSelectionMode","isEmpty","selectionStart","lineNumber","selectionStartLineNumber","column","selectionStartColumn","position","positionLineNumber","positionColumn","restoreState","desiredSelections","state","fromModelSelections","onModelContentChanged","event","e","rawContentChangedEvent","versionId","hadFlushEvent","containsEvent","resultingSelection","cursorState","isUndoing","isRedoing","selectionsFromMarkers","readSelectionFromMarkers","getSelection","modelState","getTopMostViewPosition","getBottomMostViewPosition","getCursorColumnSelectData","viewSelectionStart","getStartPosition","viewPosition","isReal","fromViewLineNumber","fromViewVisualColumn","visibleColumnFromColumn","toViewLineNumber","toViewVisualColumn","setSelections","getPrevEditOperationType","setPrevEditOperationType","type","_pushAutoClosedAction","autoClosedCharactersRanges","autoClosedEnclosingRanges","autoClosedCharactersDeltaDecorations","autoClosedEnclosingDeltaDecorations","range","options","description","inlineClassName","stickiness","autoClosedCharactersDecorations","deltaDecorations","autoClosedEnclosingDecorations","AutoClosedAction","_executeEditOperation","opResult","shouldPushStackElementBefore","pushStackElement","CommandExecutor","executeCommands","commands","_interpretCommandResult","command","enclosingRange","closeCharacterRange","shouldPushStackElementAfter","newState","equals","viewSelections","some","newCursorState","oldSelections","map","s","oldModelVersionId","modelVersionId","emitOutgoingEvent","_findAutoClosingPairs","edits","indices","edit","text","indexOf","m","match","closeChar","autoClosingPairsCandidates","autoClosingPairs","autoClosingPairsCloseSingleChar","get","openChar","open","closeCharIndex","openCharIndex","lastIndexOf","executeEdits","cursorStateComputer","autoClosingIndices","_isTracked","pushEditOperations","undoEdits","openCharInnerIndex","closeCharInnerIndex","undoEdit","startLineNumber","startColumn","_executeEdit","callback","cursorChangeReason","arguments","undefined","readOnly","stopTrackingSelections","ensureValidState","err","startTrackingSelections","getAutoClosedCharacters","getAllAutoClosedCharacters","startComposition","CompositionState","endComposition","compositionOutcome","deduceOutcome","compositionEndWithInterceptors","offset","charLength","nextCharLength","chr","substr","typeWithInterceptors","typeWithoutInterceptors","compositionType","replacePrevCharCnt","replaceNextCharCnt","positionDelta","newSelections","getPosition","paste","pasteOnNewLine","multicursorText","cut","executeCommand","killSecondaryCursors","cursor","other","autoClosedActions","autoClosedCharacters","concat","getAutoClosedCharactersRanges","_autoClosedCharactersDecorations","_autoClosedEnclosingDecorations","decorationRange","getDecorationRange","enclosingRanges","endLineNumber","sort","compareRangesUsingStarts","strictContainsRange","selectionsBefore","ctx","trackedRanges","trackedRangesDirection","_innerExecuteCommands","_setTrackedRange","_arrayIsEmpty","commandsData","_getEditOperations","operations","rawOperations","loserCursorsMap","_getLoserCursorMap","hasOwnProperty","console","warn","filteredOperations","identifier","major","toString","hadTrackedEditOperation","selectionsAfter","inverseEditOperations","groupedInverseEditOperations","op","minorBasedSorter","a","b","minor","cursorSelections","computeCursorState","getInverseEditOperations","getTrackedSelection","id","idx","parseInt","_getTrackedRange","endColumn","losingCursors","losingCursorIndex","losingCursor","r","_getEditOperationsFromCommand","majorIdentifier","operationMinor","addEditOperation","forceMoveMarkers","isAutoWhitespaceEdit","insertsAutoWhitespace","addTrackedEditOperation","trackSelection","_selection","trackPreviousOnEmpty","liftSelection","maxLineColumn","getLineMaxColumn","l","getDirection","editOperationBuilder","getEditOperations","compareRangesUsingEnds","previousOp","currentOp","isBefore","getEndPosition","loserMajor","j","CompositionLineState","startSelection","endSelection","_capture","textModel","getLineContent","_original","current","_deduceOutcome","original","commonPrefix","Math","min","commonPrefixLength","commonSuffix","commonSuffixLength","deletedText","substring","insertedText"],"sources":["/home/arslan/modojo/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursor.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorCollection } from './cursorCollection.js';\nimport { CursorState, EditOperationResult } from '../cursorCommon.js';\nimport { CursorContext } from './cursorContext.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { CompositionOutcome, TypeOperations, TypeWithAutoClosingCommand } from './cursorTypeOperations.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { ModelInjectedTextChangedEvent } from '../textModelEvents.js';\nimport { ViewCursorStateChangedEvent, ViewRevealRangeRequestEvent } from '../viewEvents.js';\nimport { dispose, Disposable } from '../../../base/common/lifecycle.js';\nimport { CursorStateChangedEvent } from '../viewModelEventDispatcher.js';\nexport class CursorsController extends Disposable {\n    constructor(model, viewModel, coordinatesConverter, cursorConfig) {\n        super();\n        this._model = model;\n        this._knownModelVersionId = this._model.getVersionId();\n        this._viewModel = viewModel;\n        this._coordinatesConverter = coordinatesConverter;\n        this.context = new CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);\n        this._cursors = new CursorCollection(this.context);\n        this._hasFocus = false;\n        this._isHandling = false;\n        this._compositionState = null;\n        this._columnSelectData = null;\n        this._autoClosedActions = [];\n        this._prevEditOperationType = 0 /* EditOperationType.Other */;\n    }\n    dispose() {\n        this._cursors.dispose();\n        this._autoClosedActions = dispose(this._autoClosedActions);\n        super.dispose();\n    }\n    updateConfiguration(cursorConfig) {\n        this.context = new CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);\n        this._cursors.updateContext(this.context);\n    }\n    onLineMappingChanged(eventsCollector) {\n        if (this._knownModelVersionId !== this._model.getVersionId()) {\n            // There are model change events that I didn't yet receive.\n            //\n            // This can happen when editing the model, and the view model receives the change events first,\n            // and the view model emits line mapping changed events, all before the cursor gets a chance to\n            // recover from markers.\n            //\n            // The model change listener above will be called soon and we'll ensure a valid cursor state there.\n            return;\n        }\n        // Ensure valid state\n        this.setStates(eventsCollector, 'viewModel', 0 /* CursorChangeReason.NotSet */, this.getCursorStates());\n    }\n    setHasFocus(hasFocus) {\n        this._hasFocus = hasFocus;\n    }\n    _validateAutoClosedActions() {\n        if (this._autoClosedActions.length > 0) {\n            const selections = this._cursors.getSelections();\n            for (let i = 0; i < this._autoClosedActions.length; i++) {\n                const autoClosedAction = this._autoClosedActions[i];\n                if (!autoClosedAction.isValid(selections)) {\n                    autoClosedAction.dispose();\n                    this._autoClosedActions.splice(i, 1);\n                    i--;\n                }\n            }\n        }\n    }\n    // ------ some getters/setters\n    getPrimaryCursorState() {\n        return this._cursors.getPrimaryCursor();\n    }\n    getLastAddedCursorIndex() {\n        return this._cursors.getLastAddedCursorIndex();\n    }\n    getCursorStates() {\n        return this._cursors.getAll();\n    }\n    setStates(eventsCollector, source, reason, states) {\n        let reachedMaxCursorCount = false;\n        const multiCursorLimit = this.context.cursorConfig.multiCursorLimit;\n        if (states !== null && states.length > multiCursorLimit) {\n            states = states.slice(0, multiCursorLimit);\n            reachedMaxCursorCount = true;\n        }\n        const oldState = CursorModelState.from(this._model, this);\n        this._cursors.setStates(states);\n        this._cursors.normalize();\n        this._columnSelectData = null;\n        this._validateAutoClosedActions();\n        return this._emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount);\n    }\n    setCursorColumnSelectData(columnSelectData) {\n        this._columnSelectData = columnSelectData;\n    }\n    revealAll(eventsCollector, source, minimalReveal, verticalType, revealHorizontal, scrollType) {\n        const viewPositions = this._cursors.getViewPositions();\n        let revealViewRange = null;\n        let revealViewSelections = null;\n        if (viewPositions.length > 1) {\n            revealViewSelections = this._cursors.getViewSelections();\n        }\n        else {\n            revealViewRange = Range.fromPositions(viewPositions[0], viewPositions[0]);\n        }\n        eventsCollector.emitViewEvent(new ViewRevealRangeRequestEvent(source, minimalReveal, revealViewRange, revealViewSelections, verticalType, revealHorizontal, scrollType));\n    }\n    revealPrimary(eventsCollector, source, minimalReveal, verticalType, revealHorizontal, scrollType) {\n        const primaryCursor = this._cursors.getPrimaryCursor();\n        const revealViewSelections = [primaryCursor.viewState.selection];\n        eventsCollector.emitViewEvent(new ViewRevealRangeRequestEvent(source, minimalReveal, null, revealViewSelections, verticalType, revealHorizontal, scrollType));\n    }\n    saveState() {\n        const result = [];\n        const selections = this._cursors.getSelections();\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            result.push({\n                inSelectionMode: !selection.isEmpty(),\n                selectionStart: {\n                    lineNumber: selection.selectionStartLineNumber,\n                    column: selection.selectionStartColumn,\n                },\n                position: {\n                    lineNumber: selection.positionLineNumber,\n                    column: selection.positionColumn,\n                }\n            });\n        }\n        return result;\n    }\n    restoreState(eventsCollector, states) {\n        const desiredSelections = [];\n        for (let i = 0, len = states.length; i < len; i++) {\n            const state = states[i];\n            let positionLineNumber = 1;\n            let positionColumn = 1;\n            // Avoid missing properties on the literal\n            if (state.position && state.position.lineNumber) {\n                positionLineNumber = state.position.lineNumber;\n            }\n            if (state.position && state.position.column) {\n                positionColumn = state.position.column;\n            }\n            let selectionStartLineNumber = positionLineNumber;\n            let selectionStartColumn = positionColumn;\n            // Avoid missing properties on the literal\n            if (state.selectionStart && state.selectionStart.lineNumber) {\n                selectionStartLineNumber = state.selectionStart.lineNumber;\n            }\n            if (state.selectionStart && state.selectionStart.column) {\n                selectionStartColumn = state.selectionStart.column;\n            }\n            desiredSelections.push({\n                selectionStartLineNumber: selectionStartLineNumber,\n                selectionStartColumn: selectionStartColumn,\n                positionLineNumber: positionLineNumber,\n                positionColumn: positionColumn\n            });\n        }\n        this.setStates(eventsCollector, 'restoreState', 0 /* CursorChangeReason.NotSet */, CursorState.fromModelSelections(desiredSelections));\n        this.revealAll(eventsCollector, 'restoreState', false, 0 /* VerticalRevealType.Simple */, true, 1 /* editorCommon.ScrollType.Immediate */);\n    }\n    onModelContentChanged(eventsCollector, event) {\n        if (event instanceof ModelInjectedTextChangedEvent) {\n            // If injected texts change, the view positions of all cursors need to be updated.\n            if (this._isHandling) {\n                // The view positions will be updated when handling finishes\n                return;\n            }\n            // setStates might remove markers, which could trigger a decoration change.\n            // If there are injected text decorations for that line, `onModelContentChanged` is emitted again\n            // and an endless recursion happens.\n            // _isHandling prevents that.\n            this._isHandling = true;\n            try {\n                this.setStates(eventsCollector, 'modelChange', 0 /* CursorChangeReason.NotSet */, this.getCursorStates());\n            }\n            finally {\n                this._isHandling = false;\n            }\n        }\n        else {\n            const e = event.rawContentChangedEvent;\n            this._knownModelVersionId = e.versionId;\n            if (this._isHandling) {\n                return;\n            }\n            const hadFlushEvent = e.containsEvent(1 /* RawContentChangedType.Flush */);\n            this._prevEditOperationType = 0 /* EditOperationType.Other */;\n            if (hadFlushEvent) {\n                // a model.setValue() was called\n                this._cursors.dispose();\n                this._cursors = new CursorCollection(this.context);\n                this._validateAutoClosedActions();\n                this._emitStateChangedIfNecessary(eventsCollector, 'model', 1 /* CursorChangeReason.ContentFlush */, null, false);\n            }\n            else {\n                if (this._hasFocus && e.resultingSelection && e.resultingSelection.length > 0) {\n                    const cursorState = CursorState.fromModelSelections(e.resultingSelection);\n                    if (this.setStates(eventsCollector, 'modelChange', e.isUndoing ? 5 /* CursorChangeReason.Undo */ : e.isRedoing ? 6 /* CursorChangeReason.Redo */ : 2 /* CursorChangeReason.RecoverFromMarkers */, cursorState)) {\n                        this.revealAll(eventsCollector, 'modelChange', false, 0 /* VerticalRevealType.Simple */, true, 0 /* editorCommon.ScrollType.Smooth */);\n                    }\n                }\n                else {\n                    const selectionsFromMarkers = this._cursors.readSelectionFromMarkers();\n                    this.setStates(eventsCollector, 'modelChange', 2 /* CursorChangeReason.RecoverFromMarkers */, CursorState.fromModelSelections(selectionsFromMarkers));\n                }\n            }\n        }\n    }\n    getSelection() {\n        return this._cursors.getPrimaryCursor().modelState.selection;\n    }\n    getTopMostViewPosition() {\n        return this._cursors.getTopMostViewPosition();\n    }\n    getBottomMostViewPosition() {\n        return this._cursors.getBottomMostViewPosition();\n    }\n    getCursorColumnSelectData() {\n        if (this._columnSelectData) {\n            return this._columnSelectData;\n        }\n        const primaryCursor = this._cursors.getPrimaryCursor();\n        const viewSelectionStart = primaryCursor.viewState.selectionStart.getStartPosition();\n        const viewPosition = primaryCursor.viewState.position;\n        return {\n            isReal: false,\n            fromViewLineNumber: viewSelectionStart.lineNumber,\n            fromViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, viewSelectionStart),\n            toViewLineNumber: viewPosition.lineNumber,\n            toViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, viewPosition),\n        };\n    }\n    getSelections() {\n        return this._cursors.getSelections();\n    }\n    setSelections(eventsCollector, source, selections, reason) {\n        this.setStates(eventsCollector, source, reason, CursorState.fromModelSelections(selections));\n    }\n    getPrevEditOperationType() {\n        return this._prevEditOperationType;\n    }\n    setPrevEditOperationType(type) {\n        this._prevEditOperationType = type;\n    }\n    // ------ auxiliary handling logic\n    _pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges) {\n        const autoClosedCharactersDeltaDecorations = [];\n        const autoClosedEnclosingDeltaDecorations = [];\n        for (let i = 0, len = autoClosedCharactersRanges.length; i < len; i++) {\n            autoClosedCharactersDeltaDecorations.push({\n                range: autoClosedCharactersRanges[i],\n                options: {\n                    description: 'auto-closed-character',\n                    inlineClassName: 'auto-closed-character',\n                    stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n                }\n            });\n            autoClosedEnclosingDeltaDecorations.push({\n                range: autoClosedEnclosingRanges[i],\n                options: {\n                    description: 'auto-closed-enclosing',\n                    stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n                }\n            });\n        }\n        const autoClosedCharactersDecorations = this._model.deltaDecorations([], autoClosedCharactersDeltaDecorations);\n        const autoClosedEnclosingDecorations = this._model.deltaDecorations([], autoClosedEnclosingDeltaDecorations);\n        this._autoClosedActions.push(new AutoClosedAction(this._model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations));\n    }\n    _executeEditOperation(opResult) {\n        if (!opResult) {\n            // Nothing to execute\n            return;\n        }\n        if (opResult.shouldPushStackElementBefore) {\n            this._model.pushStackElement();\n        }\n        const result = CommandExecutor.executeCommands(this._model, this._cursors.getSelections(), opResult.commands);\n        if (result) {\n            // The commands were applied correctly\n            this._interpretCommandResult(result);\n            // Check for auto-closing closed characters\n            const autoClosedCharactersRanges = [];\n            const autoClosedEnclosingRanges = [];\n            for (let i = 0; i < opResult.commands.length; i++) {\n                const command = opResult.commands[i];\n                if (command instanceof TypeWithAutoClosingCommand && command.enclosingRange && command.closeCharacterRange) {\n                    autoClosedCharactersRanges.push(command.closeCharacterRange);\n                    autoClosedEnclosingRanges.push(command.enclosingRange);\n                }\n            }\n            if (autoClosedCharactersRanges.length > 0) {\n                this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n            }\n            this._prevEditOperationType = opResult.type;\n        }\n        if (opResult.shouldPushStackElementAfter) {\n            this._model.pushStackElement();\n        }\n    }\n    _interpretCommandResult(cursorState) {\n        if (!cursorState || cursorState.length === 0) {\n            cursorState = this._cursors.readSelectionFromMarkers();\n        }\n        this._columnSelectData = null;\n        this._cursors.setSelections(cursorState);\n        this._cursors.normalize();\n    }\n    // -----------------------------------------------------------------------------------------------------------\n    // ----- emitting events\n    _emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount) {\n        const newState = CursorModelState.from(this._model, this);\n        if (newState.equals(oldState)) {\n            return false;\n        }\n        const selections = this._cursors.getSelections();\n        const viewSelections = this._cursors.getViewSelections();\n        // Let the view get the event first.\n        eventsCollector.emitViewEvent(new ViewCursorStateChangedEvent(viewSelections, selections, reason));\n        // Only after the view has been notified, let the rest of the world know...\n        if (!oldState\n            || oldState.cursorState.length !== newState.cursorState.length\n            || newState.cursorState.some((newCursorState, i) => !newCursorState.modelState.equals(oldState.cursorState[i].modelState))) {\n            const oldSelections = oldState ? oldState.cursorState.map(s => s.modelState.selection) : null;\n            const oldModelVersionId = oldState ? oldState.modelVersionId : 0;\n            eventsCollector.emitOutgoingEvent(new CursorStateChangedEvent(oldSelections, selections, oldModelVersionId, newState.modelVersionId, source || 'keyboard', reason, reachedMaxCursorCount));\n        }\n        return true;\n    }\n    // -----------------------------------------------------------------------------------------------------------\n    // ----- handlers beyond this point\n    _findAutoClosingPairs(edits) {\n        if (!edits.length) {\n            return null;\n        }\n        const indices = [];\n        for (let i = 0, len = edits.length; i < len; i++) {\n            const edit = edits[i];\n            if (!edit.text || edit.text.indexOf('\\n') >= 0) {\n                return null;\n            }\n            const m = edit.text.match(/([)\\]}>'\"`])([^)\\]}>'\"`]*)$/);\n            if (!m) {\n                return null;\n            }\n            const closeChar = m[1];\n            const autoClosingPairsCandidates = this.context.cursorConfig.autoClosingPairs.autoClosingPairsCloseSingleChar.get(closeChar);\n            if (!autoClosingPairsCandidates || autoClosingPairsCandidates.length !== 1) {\n                return null;\n            }\n            const openChar = autoClosingPairsCandidates[0].open;\n            const closeCharIndex = edit.text.length - m[2].length - 1;\n            const openCharIndex = edit.text.lastIndexOf(openChar, closeCharIndex - 1);\n            if (openCharIndex === -1) {\n                return null;\n            }\n            indices.push([openCharIndex, closeCharIndex]);\n        }\n        return indices;\n    }\n    executeEdits(eventsCollector, source, edits, cursorStateComputer) {\n        let autoClosingIndices = null;\n        if (source === 'snippet') {\n            autoClosingIndices = this._findAutoClosingPairs(edits);\n        }\n        if (autoClosingIndices) {\n            edits[0]._isTracked = true;\n        }\n        const autoClosedCharactersRanges = [];\n        const autoClosedEnclosingRanges = [];\n        const selections = this._model.pushEditOperations(this.getSelections(), edits, (undoEdits) => {\n            if (autoClosingIndices) {\n                for (let i = 0, len = autoClosingIndices.length; i < len; i++) {\n                    const [openCharInnerIndex, closeCharInnerIndex] = autoClosingIndices[i];\n                    const undoEdit = undoEdits[i];\n                    const lineNumber = undoEdit.range.startLineNumber;\n                    const openCharIndex = undoEdit.range.startColumn - 1 + openCharInnerIndex;\n                    const closeCharIndex = undoEdit.range.startColumn - 1 + closeCharInnerIndex;\n                    autoClosedCharactersRanges.push(new Range(lineNumber, closeCharIndex + 1, lineNumber, closeCharIndex + 2));\n                    autoClosedEnclosingRanges.push(new Range(lineNumber, openCharIndex + 1, lineNumber, closeCharIndex + 2));\n                }\n            }\n            const selections = cursorStateComputer(undoEdits);\n            if (selections) {\n                // Don't recover the selection from markers because\n                // we know what it should be.\n                this._isHandling = true;\n            }\n            return selections;\n        });\n        if (selections) {\n            this._isHandling = false;\n            this.setSelections(eventsCollector, source, selections, 0 /* CursorChangeReason.NotSet */);\n        }\n        if (autoClosedCharactersRanges.length > 0) {\n            this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n        }\n    }\n    _executeEdit(callback, eventsCollector, source, cursorChangeReason = 0 /* CursorChangeReason.NotSet */) {\n        if (this.context.cursorConfig.readOnly) {\n            // we cannot edit when read only...\n            return;\n        }\n        const oldState = CursorModelState.from(this._model, this);\n        this._cursors.stopTrackingSelections();\n        this._isHandling = true;\n        try {\n            this._cursors.ensureValidState();\n            callback();\n        }\n        catch (err) {\n            onUnexpectedError(err);\n        }\n        this._isHandling = false;\n        this._cursors.startTrackingSelections();\n        this._validateAutoClosedActions();\n        if (this._emitStateChangedIfNecessary(eventsCollector, source, cursorChangeReason, oldState, false)) {\n            this.revealAll(eventsCollector, source, false, 0 /* VerticalRevealType.Simple */, true, 0 /* editorCommon.ScrollType.Smooth */);\n        }\n    }\n    getAutoClosedCharacters() {\n        return AutoClosedAction.getAllAutoClosedCharacters(this._autoClosedActions);\n    }\n    startComposition(eventsCollector) {\n        this._compositionState = new CompositionState(this._model, this.getSelections());\n    }\n    endComposition(eventsCollector, source) {\n        const compositionOutcome = this._compositionState ? this._compositionState.deduceOutcome(this._model, this.getSelections()) : null;\n        this._compositionState = null;\n        this._executeEdit(() => {\n            if (source === 'keyboard') {\n                // composition finishes, let's check if we need to auto complete if necessary.\n                this._executeEditOperation(TypeOperations.compositionEndWithInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, compositionOutcome, this.getSelections(), this.getAutoClosedCharacters()));\n            }\n        }, eventsCollector, source);\n    }\n    type(eventsCollector, text, source) {\n        this._executeEdit(() => {\n            if (source === 'keyboard') {\n                // If this event is coming straight from the keyboard, look for electric characters and enter\n                const len = text.length;\n                let offset = 0;\n                while (offset < len) {\n                    const charLength = strings.nextCharLength(text, offset);\n                    const chr = text.substr(offset, charLength);\n                    // Here we must interpret each typed character individually\n                    this._executeEditOperation(TypeOperations.typeWithInterceptors(!!this._compositionState, this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), this.getAutoClosedCharacters(), chr));\n                    offset += charLength;\n                }\n            }\n            else {\n                this._executeEditOperation(TypeOperations.typeWithoutInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text));\n            }\n        }, eventsCollector, source);\n    }\n    compositionType(eventsCollector, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source) {\n        if (text.length === 0 && replacePrevCharCnt === 0 && replaceNextCharCnt === 0) {\n            // this edit is a no-op\n            if (positionDelta !== 0) {\n                // but it still wants to move the cursor\n                const newSelections = this.getSelections().map(selection => {\n                    const position = selection.getPosition();\n                    return new Selection(position.lineNumber, position.column + positionDelta, position.lineNumber, position.column + positionDelta);\n                });\n                this.setSelections(eventsCollector, source, newSelections, 0 /* CursorChangeReason.NotSet */);\n            }\n            return;\n        }\n        this._executeEdit(() => {\n            this._executeEditOperation(TypeOperations.compositionType(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n        }, eventsCollector, source);\n    }\n    paste(eventsCollector, text, pasteOnNewLine, multicursorText, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(TypeOperations.paste(this.context.cursorConfig, this._model, this.getSelections(), text, pasteOnNewLine, multicursorText || []));\n        }, eventsCollector, source, 4 /* CursorChangeReason.Paste */);\n    }\n    cut(eventsCollector, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(DeleteOperations.cut(this.context.cursorConfig, this._model, this.getSelections()));\n        }, eventsCollector, source);\n    }\n    executeCommand(eventsCollector, command, source) {\n        this._executeEdit(() => {\n            this._cursors.killSecondaryCursors();\n            this._executeEditOperation(new EditOperationResult(0 /* EditOperationType.Other */, [command], {\n                shouldPushStackElementBefore: false,\n                shouldPushStackElementAfter: false\n            }));\n        }, eventsCollector, source);\n    }\n    executeCommands(eventsCollector, commands, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n                shouldPushStackElementBefore: false,\n                shouldPushStackElementAfter: false\n            }));\n        }, eventsCollector, source);\n    }\n}\n/**\n * A snapshot of the cursor and the model state\n */\nclass CursorModelState {\n    static from(model, cursor) {\n        return new CursorModelState(model.getVersionId(), cursor.getCursorStates());\n    }\n    constructor(modelVersionId, cursorState) {\n        this.modelVersionId = modelVersionId;\n        this.cursorState = cursorState;\n    }\n    equals(other) {\n        if (!other) {\n            return false;\n        }\n        if (this.modelVersionId !== other.modelVersionId) {\n            return false;\n        }\n        if (this.cursorState.length !== other.cursorState.length) {\n            return false;\n        }\n        for (let i = 0, len = this.cursorState.length; i < len; i++) {\n            if (!this.cursorState[i].equals(other.cursorState[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nclass AutoClosedAction {\n    static getAllAutoClosedCharacters(autoClosedActions) {\n        let autoClosedCharacters = [];\n        for (const autoClosedAction of autoClosedActions) {\n            autoClosedCharacters = autoClosedCharacters.concat(autoClosedAction.getAutoClosedCharactersRanges());\n        }\n        return autoClosedCharacters;\n    }\n    constructor(model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations) {\n        this._model = model;\n        this._autoClosedCharactersDecorations = autoClosedCharactersDecorations;\n        this._autoClosedEnclosingDecorations = autoClosedEnclosingDecorations;\n    }\n    dispose() {\n        this._autoClosedCharactersDecorations = this._model.deltaDecorations(this._autoClosedCharactersDecorations, []);\n        this._autoClosedEnclosingDecorations = this._model.deltaDecorations(this._autoClosedEnclosingDecorations, []);\n    }\n    getAutoClosedCharactersRanges() {\n        const result = [];\n        for (let i = 0; i < this._autoClosedCharactersDecorations.length; i++) {\n            const decorationRange = this._model.getDecorationRange(this._autoClosedCharactersDecorations[i]);\n            if (decorationRange) {\n                result.push(decorationRange);\n            }\n        }\n        return result;\n    }\n    isValid(selections) {\n        const enclosingRanges = [];\n        for (let i = 0; i < this._autoClosedEnclosingDecorations.length; i++) {\n            const decorationRange = this._model.getDecorationRange(this._autoClosedEnclosingDecorations[i]);\n            if (decorationRange) {\n                enclosingRanges.push(decorationRange);\n                if (decorationRange.startLineNumber !== decorationRange.endLineNumber) {\n                    // Stop tracking if the range becomes multiline...\n                    return false;\n                }\n            }\n        }\n        enclosingRanges.sort(Range.compareRangesUsingStarts);\n        selections.sort(Range.compareRangesUsingStarts);\n        for (let i = 0; i < selections.length; i++) {\n            if (i >= enclosingRanges.length) {\n                return false;\n            }\n            if (!enclosingRanges[i].strictContainsRange(selections[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nclass CommandExecutor {\n    static executeCommands(model, selectionsBefore, commands) {\n        const ctx = {\n            model: model,\n            selectionsBefore: selectionsBefore,\n            trackedRanges: [],\n            trackedRangesDirection: []\n        };\n        const result = this._innerExecuteCommands(ctx, commands);\n        for (let i = 0, len = ctx.trackedRanges.length; i < len; i++) {\n            ctx.model._setTrackedRange(ctx.trackedRanges[i], null, 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */);\n        }\n        return result;\n    }\n    static _innerExecuteCommands(ctx, commands) {\n        if (this._arrayIsEmpty(commands)) {\n            return null;\n        }\n        const commandsData = this._getEditOperations(ctx, commands);\n        if (commandsData.operations.length === 0) {\n            return null;\n        }\n        const rawOperations = commandsData.operations;\n        const loserCursorsMap = this._getLoserCursorMap(rawOperations);\n        if (loserCursorsMap.hasOwnProperty('0')) {\n            // These commands are very messed up\n            console.warn('Ignoring commands');\n            return null;\n        }\n        // Remove operations belonging to losing cursors\n        const filteredOperations = [];\n        for (let i = 0, len = rawOperations.length; i < len; i++) {\n            if (!loserCursorsMap.hasOwnProperty(rawOperations[i].identifier.major.toString())) {\n                filteredOperations.push(rawOperations[i]);\n            }\n        }\n        // TODO@Alex: find a better way to do this.\n        // give the hint that edit operations are tracked to the model\n        if (commandsData.hadTrackedEditOperation && filteredOperations.length > 0) {\n            filteredOperations[0]._isTracked = true;\n        }\n        let selectionsAfter = ctx.model.pushEditOperations(ctx.selectionsBefore, filteredOperations, (inverseEditOperations) => {\n            const groupedInverseEditOperations = [];\n            for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n                groupedInverseEditOperations[i] = [];\n            }\n            for (const op of inverseEditOperations) {\n                if (!op.identifier) {\n                    // perhaps auto whitespace trim edits\n                    continue;\n                }\n                groupedInverseEditOperations[op.identifier.major].push(op);\n            }\n            const minorBasedSorter = (a, b) => {\n                return a.identifier.minor - b.identifier.minor;\n            };\n            const cursorSelections = [];\n            for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n                if (groupedInverseEditOperations[i].length > 0) {\n                    groupedInverseEditOperations[i].sort(minorBasedSorter);\n                    cursorSelections[i] = commands[i].computeCursorState(ctx.model, {\n                        getInverseEditOperations: () => {\n                            return groupedInverseEditOperations[i];\n                        },\n                        getTrackedSelection: (id) => {\n                            const idx = parseInt(id, 10);\n                            const range = ctx.model._getTrackedRange(ctx.trackedRanges[idx]);\n                            if (ctx.trackedRangesDirection[idx] === 0 /* SelectionDirection.LTR */) {\n                                return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n                            }\n                            return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n                        }\n                    });\n                }\n                else {\n                    cursorSelections[i] = ctx.selectionsBefore[i];\n                }\n            }\n            return cursorSelections;\n        });\n        if (!selectionsAfter) {\n            selectionsAfter = ctx.selectionsBefore;\n        }\n        // Extract losing cursors\n        const losingCursors = [];\n        for (const losingCursorIndex in loserCursorsMap) {\n            if (loserCursorsMap.hasOwnProperty(losingCursorIndex)) {\n                losingCursors.push(parseInt(losingCursorIndex, 10));\n            }\n        }\n        // Sort losing cursors descending\n        losingCursors.sort((a, b) => {\n            return b - a;\n        });\n        // Remove losing cursors\n        for (const losingCursor of losingCursors) {\n            selectionsAfter.splice(losingCursor, 1);\n        }\n        return selectionsAfter;\n    }\n    static _arrayIsEmpty(commands) {\n        for (let i = 0, len = commands.length; i < len; i++) {\n            if (commands[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _getEditOperations(ctx, commands) {\n        let operations = [];\n        let hadTrackedEditOperation = false;\n        for (let i = 0, len = commands.length; i < len; i++) {\n            const command = commands[i];\n            if (command) {\n                const r = this._getEditOperationsFromCommand(ctx, i, command);\n                operations = operations.concat(r.operations);\n                hadTrackedEditOperation = hadTrackedEditOperation || r.hadTrackedEditOperation;\n            }\n        }\n        return {\n            operations: operations,\n            hadTrackedEditOperation: hadTrackedEditOperation\n        };\n    }\n    static _getEditOperationsFromCommand(ctx, majorIdentifier, command) {\n        // This method acts as a transaction, if the command fails\n        // everything it has done is ignored\n        const operations = [];\n        let operationMinor = 0;\n        const addEditOperation = (range, text, forceMoveMarkers = false) => {\n            if (Range.isEmpty(range) && text === '') {\n                // This command wants to add a no-op => no thank you\n                return;\n            }\n            operations.push({\n                identifier: {\n                    major: majorIdentifier,\n                    minor: operationMinor++\n                },\n                range: range,\n                text: text,\n                forceMoveMarkers: forceMoveMarkers,\n                isAutoWhitespaceEdit: command.insertsAutoWhitespace\n            });\n        };\n        let hadTrackedEditOperation = false;\n        const addTrackedEditOperation = (selection, text, forceMoveMarkers) => {\n            hadTrackedEditOperation = true;\n            addEditOperation(selection, text, forceMoveMarkers);\n        };\n        const trackSelection = (_selection, trackPreviousOnEmpty) => {\n            const selection = Selection.liftSelection(_selection);\n            let stickiness;\n            if (selection.isEmpty()) {\n                if (typeof trackPreviousOnEmpty === 'boolean') {\n                    if (trackPreviousOnEmpty) {\n                        stickiness = 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */;\n                    }\n                    else {\n                        stickiness = 3 /* TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */;\n                    }\n                }\n                else {\n                    // Try to lock it with surrounding text\n                    const maxLineColumn = ctx.model.getLineMaxColumn(selection.startLineNumber);\n                    if (selection.startColumn === maxLineColumn) {\n                        stickiness = 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */;\n                    }\n                    else {\n                        stickiness = 3 /* TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */;\n                    }\n                }\n            }\n            else {\n                stickiness = 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */;\n            }\n            const l = ctx.trackedRanges.length;\n            const id = ctx.model._setTrackedRange(null, selection, stickiness);\n            ctx.trackedRanges[l] = id;\n            ctx.trackedRangesDirection[l] = selection.getDirection();\n            return l.toString();\n        };\n        const editOperationBuilder = {\n            addEditOperation: addEditOperation,\n            addTrackedEditOperation: addTrackedEditOperation,\n            trackSelection: trackSelection\n        };\n        try {\n            command.getEditOperations(ctx.model, editOperationBuilder);\n        }\n        catch (e) {\n            // TODO@Alex use notification service if this should be user facing\n            // e.friendlyMessage = nls.localize('corrupt.commands', \"Unexpected exception while executing command.\");\n            onUnexpectedError(e);\n            return {\n                operations: [],\n                hadTrackedEditOperation: false\n            };\n        }\n        return {\n            operations: operations,\n            hadTrackedEditOperation: hadTrackedEditOperation\n        };\n    }\n    static _getLoserCursorMap(operations) {\n        // This is destructive on the array\n        operations = operations.slice(0);\n        // Sort operations with last one first\n        operations.sort((a, b) => {\n            // Note the minus!\n            return -(Range.compareRangesUsingEnds(a.range, b.range));\n        });\n        // Operations can not overlap!\n        const loserCursorsMap = {};\n        for (let i = 1; i < operations.length; i++) {\n            const previousOp = operations[i - 1];\n            const currentOp = operations[i];\n            if (Range.getStartPosition(previousOp.range).isBefore(Range.getEndPosition(currentOp.range))) {\n                let loserMajor;\n                if (previousOp.identifier.major > currentOp.identifier.major) {\n                    // previousOp loses the battle\n                    loserMajor = previousOp.identifier.major;\n                }\n                else {\n                    loserMajor = currentOp.identifier.major;\n                }\n                loserCursorsMap[loserMajor.toString()] = true;\n                for (let j = 0; j < operations.length; j++) {\n                    if (operations[j].identifier.major === loserMajor) {\n                        operations.splice(j, 1);\n                        if (j < i) {\n                            i--;\n                        }\n                        j--;\n                    }\n                }\n                if (i > 0) {\n                    i--;\n                }\n            }\n        }\n        return loserCursorsMap;\n    }\n}\nclass CompositionLineState {\n    constructor(text, startSelection, endSelection) {\n        this.text = text;\n        this.startSelection = startSelection;\n        this.endSelection = endSelection;\n    }\n}\nclass CompositionState {\n    static _capture(textModel, selections) {\n        const result = [];\n        for (const selection of selections) {\n            if (selection.startLineNumber !== selection.endLineNumber) {\n                return null;\n            }\n            result.push(new CompositionLineState(textModel.getLineContent(selection.startLineNumber), selection.startColumn - 1, selection.endColumn - 1));\n        }\n        return result;\n    }\n    constructor(textModel, selections) {\n        this._original = CompositionState._capture(textModel, selections);\n    }\n    /**\n     * Returns the inserted text during this composition.\n     * If the composition resulted in existing text being changed (i.e. not a pure insertion) it returns null.\n     */\n    deduceOutcome(textModel, selections) {\n        if (!this._original) {\n            return null;\n        }\n        const current = CompositionState._capture(textModel, selections);\n        if (!current) {\n            return null;\n        }\n        if (this._original.length !== current.length) {\n            return null;\n        }\n        const result = [];\n        for (let i = 0, len = this._original.length; i < len; i++) {\n            result.push(CompositionState._deduceOutcome(this._original[i], current[i]));\n        }\n        return result;\n    }\n    static _deduceOutcome(original, current) {\n        const commonPrefix = Math.min(original.startSelection, current.startSelection, strings.commonPrefixLength(original.text, current.text));\n        const commonSuffix = Math.min(original.text.length - original.endSelection, current.text.length - current.endSelection, strings.commonSuffixLength(original.text, current.text));\n        const deletedText = original.text.substring(commonPrefix, original.text.length - commonSuffix);\n        const insertedText = current.text.substring(commonPrefix, current.text.length - commonSuffix);\n        return new CompositionOutcome(deletedText, original.startSelection - commonPrefix, original.endSelection - commonPrefix, insertedText, current.startSelection - commonPrefix, current.endSelection - commonPrefix);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}