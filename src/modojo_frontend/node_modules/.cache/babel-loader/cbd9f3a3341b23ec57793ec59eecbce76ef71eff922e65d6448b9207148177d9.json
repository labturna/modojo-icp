{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\nvar BrowserClipboardService_1;\nimport { isSafari, isWebkitWebView } from '../../../base/browser/browser.js';\nimport { $, addDisposableListener, getActiveDocument, getActiveWindow, isHTMLElement, onDidRegisterWindow } from '../../../base/browser/dom.js';\nimport { mainWindow } from '../../../base/browser/window.js';\nimport { DeferredPromise } from '../../../base/common/async.js';\nimport { Event } from '../../../base/common/event.js';\nimport { hash } from '../../../base/common/hash.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { ILayoutService } from '../../layout/browser/layoutService.js';\nimport { ILogService } from '../../log/common/log.js';\nlet BrowserClipboardService = BrowserClipboardService_1 = class BrowserClipboardService extends Disposable {\n  constructor(layoutService, logService) {\n    super();\n    this.layoutService = layoutService;\n    this.logService = logService;\n    this.mapTextToType = new Map(); // unsupported in web (only in-memory)\n    this.findText = ''; // unsupported in web (only in-memory)\n    this.resources = []; // unsupported in web (only in-memory)\n    this.resourcesStateHash = undefined;\n    if (isSafari || isWebkitWebView) {\n      this.installWebKitWriteTextWorkaround();\n    }\n    // Keep track of copy operations to reset our set of\n    // copied resources: since we keep resources in memory\n    // and not in the clipboard, we have to invalidate\n    // that state when the user copies other data.\n    this._register(Event.runAndSubscribe(onDidRegisterWindow, _ref => {\n      let {\n        window,\n        disposables\n      } = _ref;\n      disposables.add(addDisposableListener(window.document, 'copy', () => this.clearResources()));\n    }, {\n      window: mainWindow,\n      disposables: this._store\n    }));\n  }\n  // In Safari, it has the following note:\n  //\n  // \"The request to write to the clipboard must be triggered during a user gesture.\n  // A call to clipboard.write or clipboard.writeText outside the scope of a user\n  // gesture(such as \"click\" or \"touch\" event handlers) will result in the immediate\n  // rejection of the promise returned by the API call.\"\n  // From: https://webkit.org/blog/10855/async-clipboard-api/\n  //\n  // Since extensions run in a web worker, and handle gestures in an asynchronous way,\n  // they are not classified by Safari as \"in response to a user gesture\" and will reject.\n  //\n  // This function sets up some handlers to work around that behavior.\n  installWebKitWriteTextWorkaround() {\n    const handler = () => {\n      const currentWritePromise = new DeferredPromise();\n      // Cancel the previous promise since we just created a new one in response to this new event\n      if (this.webKitPendingClipboardWritePromise && !this.webKitPendingClipboardWritePromise.isSettled) {\n        this.webKitPendingClipboardWritePromise.cancel();\n      }\n      this.webKitPendingClipboardWritePromise = currentWritePromise;\n      // The ctor of ClipboardItem allows you to pass in a promise that will resolve to a string.\n      // This allows us to pass in a Promise that will either be cancelled by another event or\n      // resolved with the contents of the first call to this.writeText.\n      // see https://developer.mozilla.org/en-US/docs/Web/API/ClipboardItem/ClipboardItem#parameters\n      getActiveWindow().navigator.clipboard.write([new ClipboardItem({\n        'text/plain': currentWritePromise.p\n      })]).catch(async err => {\n        if (!(err instanceof Error) || err.name !== 'NotAllowedError' || !currentWritePromise.isRejected) {\n          this.logService.error(err);\n        }\n      });\n    };\n    this._register(Event.runAndSubscribe(this.layoutService.onDidAddContainer, _ref2 => {\n      let {\n        container,\n        disposables\n      } = _ref2;\n      disposables.add(addDisposableListener(container, 'click', handler));\n      disposables.add(addDisposableListener(container, 'keydown', handler));\n    }, {\n      container: this.layoutService.mainContainer,\n      disposables: this._store\n    }));\n  }\n  async writeText(text, type) {\n    // Clear resources given we are writing text\n    this.writeResources([]);\n    // With type: only in-memory is supported\n    if (type) {\n      this.mapTextToType.set(type, text);\n      return;\n    }\n    if (this.webKitPendingClipboardWritePromise) {\n      // For Safari, we complete this Promise which allows the call to `navigator.clipboard.write()`\n      // above to resolve and successfully copy to the clipboard. If we let this continue, Safari\n      // would throw an error because this call stack doesn't appear to originate from a user gesture.\n      return this.webKitPendingClipboardWritePromise.complete(text);\n    }\n    // Guard access to navigator.clipboard with try/catch\n    // as we have seen DOMExceptions in certain browsers\n    // due to security policies.\n    try {\n      return await getActiveWindow().navigator.clipboard.writeText(text);\n    } catch (error) {\n      console.error(error);\n    }\n    // Fallback to textarea and execCommand solution\n    this.fallbackWriteText(text);\n  }\n  fallbackWriteText(text) {\n    const activeDocument = getActiveDocument();\n    const activeElement = activeDocument.activeElement;\n    const textArea = activeDocument.body.appendChild($('textarea', {\n      'aria-hidden': true\n    }));\n    textArea.style.height = '1px';\n    textArea.style.width = '1px';\n    textArea.style.position = 'absolute';\n    textArea.value = text;\n    textArea.focus();\n    textArea.select();\n    activeDocument.execCommand('copy');\n    if (isHTMLElement(activeElement)) {\n      activeElement.focus();\n    }\n    activeDocument.body.removeChild(textArea);\n  }\n  async readText(type) {\n    // With type: only in-memory is supported\n    if (type) {\n      return this.mapTextToType.get(type) || '';\n    }\n    // Guard access to navigator.clipboard with try/catch\n    // as we have seen DOMExceptions in certain browsers\n    // due to security policies.\n    try {\n      return await getActiveWindow().navigator.clipboard.readText();\n    } catch (error) {\n      console.error(error);\n    }\n    return '';\n  }\n  async readFindText() {\n    return this.findText;\n  }\n  async writeFindText(text) {\n    this.findText = text;\n  }\n  async writeResources(resources) {\n    if (resources.length === 0) {\n      this.clearResources();\n    } else {\n      this.resources = resources;\n      this.resourcesStateHash = await this.computeResourcesStateHash();\n    }\n  }\n  async readResources() {\n    const resourcesStateHash = await this.computeResourcesStateHash();\n    if (this.resourcesStateHash !== resourcesStateHash) {\n      this.clearResources(); // state mismatch, resources no longer valid\n    }\n    return this.resources;\n  }\n  async computeResourcesStateHash() {\n    if (this.resources.length === 0) {\n      return undefined; // no resources, no hash needed\n    }\n    // Resources clipboard is managed in-memory only and thus\n    // fails to invalidate when clipboard data is changing.\n    // As such, we compute the hash of the current clipboard\n    // and use that to later validate the resources clipboard.\n    const clipboardText = await this.readText();\n    return hash(clipboardText.substring(0, BrowserClipboardService_1.MAX_RESOURCE_STATE_SOURCE_LENGTH));\n  }\n  clearResources() {\n    this.resources = [];\n    this.resourcesStateHash = undefined;\n  }\n};\nBrowserClipboardService.MAX_RESOURCE_STATE_SOURCE_LENGTH = 1000;\nBrowserClipboardService = BrowserClipboardService_1 = __decorate([__param(0, ILayoutService), __param(1, ILogService)], BrowserClipboardService);\nexport { BrowserClipboardService };","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","BrowserClipboardService_1","isSafari","isWebkitWebView","$","addDisposableListener","getActiveDocument","getActiveWindow","isHTMLElement","onDidRegisterWindow","mainWindow","DeferredPromise","Event","hash","Disposable","ILayoutService","ILogService","BrowserClipboardService","constructor","layoutService","logService","mapTextToType","Map","findText","resources","resourcesStateHash","undefined","installWebKitWriteTextWorkaround","_register","runAndSubscribe","_ref","window","disposables","add","document","clearResources","_store","handler","currentWritePromise","webKitPendingClipboardWritePromise","isSettled","cancel","navigator","clipboard","write","ClipboardItem","p","catch","err","Error","name","isRejected","error","onDidAddContainer","_ref2","container","mainContainer","writeText","text","type","writeResources","set","complete","console","fallbackWriteText","activeDocument","activeElement","textArea","body","appendChild","style","height","width","position","value","focus","select","execCommand","removeChild","readText","get","readFindText","writeFindText","computeResourcesStateHash","readResources","clipboardText","substring","MAX_RESOURCE_STATE_SOURCE_LENGTH"],"sources":["/home/arslan/modojo/node_modules/monaco-editor/esm/vs/platform/clipboard/browser/clipboardService.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar BrowserClipboardService_1;\nimport { isSafari, isWebkitWebView } from '../../../base/browser/browser.js';\nimport { $, addDisposableListener, getActiveDocument, getActiveWindow, isHTMLElement, onDidRegisterWindow } from '../../../base/browser/dom.js';\nimport { mainWindow } from '../../../base/browser/window.js';\nimport { DeferredPromise } from '../../../base/common/async.js';\nimport { Event } from '../../../base/common/event.js';\nimport { hash } from '../../../base/common/hash.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { ILayoutService } from '../../layout/browser/layoutService.js';\nimport { ILogService } from '../../log/common/log.js';\nlet BrowserClipboardService = BrowserClipboardService_1 = class BrowserClipboardService extends Disposable {\n    constructor(layoutService, logService) {\n        super();\n        this.layoutService = layoutService;\n        this.logService = logService;\n        this.mapTextToType = new Map(); // unsupported in web (only in-memory)\n        this.findText = ''; // unsupported in web (only in-memory)\n        this.resources = []; // unsupported in web (only in-memory)\n        this.resourcesStateHash = undefined;\n        if (isSafari || isWebkitWebView) {\n            this.installWebKitWriteTextWorkaround();\n        }\n        // Keep track of copy operations to reset our set of\n        // copied resources: since we keep resources in memory\n        // and not in the clipboard, we have to invalidate\n        // that state when the user copies other data.\n        this._register(Event.runAndSubscribe(onDidRegisterWindow, ({ window, disposables }) => {\n            disposables.add(addDisposableListener(window.document, 'copy', () => this.clearResources()));\n        }, { window: mainWindow, disposables: this._store }));\n    }\n    // In Safari, it has the following note:\n    //\n    // \"The request to write to the clipboard must be triggered during a user gesture.\n    // A call to clipboard.write or clipboard.writeText outside the scope of a user\n    // gesture(such as \"click\" or \"touch\" event handlers) will result in the immediate\n    // rejection of the promise returned by the API call.\"\n    // From: https://webkit.org/blog/10855/async-clipboard-api/\n    //\n    // Since extensions run in a web worker, and handle gestures in an asynchronous way,\n    // they are not classified by Safari as \"in response to a user gesture\" and will reject.\n    //\n    // This function sets up some handlers to work around that behavior.\n    installWebKitWriteTextWorkaround() {\n        const handler = () => {\n            const currentWritePromise = new DeferredPromise();\n            // Cancel the previous promise since we just created a new one in response to this new event\n            if (this.webKitPendingClipboardWritePromise && !this.webKitPendingClipboardWritePromise.isSettled) {\n                this.webKitPendingClipboardWritePromise.cancel();\n            }\n            this.webKitPendingClipboardWritePromise = currentWritePromise;\n            // The ctor of ClipboardItem allows you to pass in a promise that will resolve to a string.\n            // This allows us to pass in a Promise that will either be cancelled by another event or\n            // resolved with the contents of the first call to this.writeText.\n            // see https://developer.mozilla.org/en-US/docs/Web/API/ClipboardItem/ClipboardItem#parameters\n            getActiveWindow().navigator.clipboard.write([new ClipboardItem({\n                    'text/plain': currentWritePromise.p,\n                })]).catch(async (err) => {\n                if (!(err instanceof Error) || err.name !== 'NotAllowedError' || !currentWritePromise.isRejected) {\n                    this.logService.error(err);\n                }\n            });\n        };\n        this._register(Event.runAndSubscribe(this.layoutService.onDidAddContainer, ({ container, disposables }) => {\n            disposables.add(addDisposableListener(container, 'click', handler));\n            disposables.add(addDisposableListener(container, 'keydown', handler));\n        }, { container: this.layoutService.mainContainer, disposables: this._store }));\n    }\n    async writeText(text, type) {\n        // Clear resources given we are writing text\n        this.writeResources([]);\n        // With type: only in-memory is supported\n        if (type) {\n            this.mapTextToType.set(type, text);\n            return;\n        }\n        if (this.webKitPendingClipboardWritePromise) {\n            // For Safari, we complete this Promise which allows the call to `navigator.clipboard.write()`\n            // above to resolve and successfully copy to the clipboard. If we let this continue, Safari\n            // would throw an error because this call stack doesn't appear to originate from a user gesture.\n            return this.webKitPendingClipboardWritePromise.complete(text);\n        }\n        // Guard access to navigator.clipboard with try/catch\n        // as we have seen DOMExceptions in certain browsers\n        // due to security policies.\n        try {\n            return await getActiveWindow().navigator.clipboard.writeText(text);\n        }\n        catch (error) {\n            console.error(error);\n        }\n        // Fallback to textarea and execCommand solution\n        this.fallbackWriteText(text);\n    }\n    fallbackWriteText(text) {\n        const activeDocument = getActiveDocument();\n        const activeElement = activeDocument.activeElement;\n        const textArea = activeDocument.body.appendChild($('textarea', { 'aria-hidden': true }));\n        textArea.style.height = '1px';\n        textArea.style.width = '1px';\n        textArea.style.position = 'absolute';\n        textArea.value = text;\n        textArea.focus();\n        textArea.select();\n        activeDocument.execCommand('copy');\n        if (isHTMLElement(activeElement)) {\n            activeElement.focus();\n        }\n        activeDocument.body.removeChild(textArea);\n    }\n    async readText(type) {\n        // With type: only in-memory is supported\n        if (type) {\n            return this.mapTextToType.get(type) || '';\n        }\n        // Guard access to navigator.clipboard with try/catch\n        // as we have seen DOMExceptions in certain browsers\n        // due to security policies.\n        try {\n            return await getActiveWindow().navigator.clipboard.readText();\n        }\n        catch (error) {\n            console.error(error);\n        }\n        return '';\n    }\n    async readFindText() {\n        return this.findText;\n    }\n    async writeFindText(text) {\n        this.findText = text;\n    }\n    async writeResources(resources) {\n        if (resources.length === 0) {\n            this.clearResources();\n        }\n        else {\n            this.resources = resources;\n            this.resourcesStateHash = await this.computeResourcesStateHash();\n        }\n    }\n    async readResources() {\n        const resourcesStateHash = await this.computeResourcesStateHash();\n        if (this.resourcesStateHash !== resourcesStateHash) {\n            this.clearResources(); // state mismatch, resources no longer valid\n        }\n        return this.resources;\n    }\n    async computeResourcesStateHash() {\n        if (this.resources.length === 0) {\n            return undefined; // no resources, no hash needed\n        }\n        // Resources clipboard is managed in-memory only and thus\n        // fails to invalidate when clipboard data is changing.\n        // As such, we compute the hash of the current clipboard\n        // and use that to later validate the resources clipboard.\n        const clipboardText = await this.readText();\n        return hash(clipboardText.substring(0, BrowserClipboardService_1.MAX_RESOURCE_STATE_SOURCE_LENGTH));\n    }\n    clearResources() {\n        this.resources = [];\n        this.resourcesStateHash = undefined;\n    }\n};\nBrowserClipboardService.MAX_RESOURCE_STATE_SOURCE_LENGTH = 1000;\nBrowserClipboardService = BrowserClipboardService_1 = __decorate([\n    __param(0, ILayoutService),\n    __param(1, ILogService)\n], BrowserClipboardService);\nexport { BrowserClipboardService };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}