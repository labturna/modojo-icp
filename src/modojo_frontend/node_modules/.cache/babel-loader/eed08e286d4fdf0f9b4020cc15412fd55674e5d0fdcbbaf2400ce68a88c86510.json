{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { TreeError } from './tree.js';\nimport { splice, tail2 } from '../../../common/arrays.js';\nimport { Delayer } from '../../../common/async.js';\nimport { MicrotaskDelay } from '../../../common/symbols.js';\nimport { LcsDiff } from '../../../common/diff/diff.js';\nimport { Emitter, EventBufferer } from '../../../common/event.js';\nimport { Iterable } from '../../../common/iterator.js';\nexport function isFilterResult(obj) {\n  return typeof obj === 'object' && 'visibility' in obj && 'data' in obj;\n}\nexport function getVisibleState(visibility) {\n  switch (visibility) {\n    case true:\n      return 1 /* TreeVisibility.Visible */;\n    case false:\n      return 0 /* TreeVisibility.Hidden */;\n    default:\n      return visibility;\n  }\n}\nfunction isCollapsibleStateUpdate(update) {\n  return typeof update.collapsible === 'boolean';\n}\nexport class IndexTreeModel {\n  constructor(user, list, rootElement) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var _a;\n    this.user = user;\n    this.list = list;\n    this.rootRef = [];\n    this.eventBufferer = new EventBufferer();\n    this._onDidChangeCollapseState = new Emitter();\n    this.onDidChangeCollapseState = this.eventBufferer.wrapEvent(this._onDidChangeCollapseState.event);\n    this._onDidChangeRenderNodeCount = new Emitter();\n    this.onDidChangeRenderNodeCount = this.eventBufferer.wrapEvent(this._onDidChangeRenderNodeCount.event);\n    this._onDidSplice = new Emitter();\n    this.onDidSplice = this._onDidSplice.event;\n    this.refilterDelayer = new Delayer(MicrotaskDelay);\n    this.collapseByDefault = typeof options.collapseByDefault === 'undefined' ? false : options.collapseByDefault;\n    this.allowNonCollapsibleParents = (_a = options.allowNonCollapsibleParents) !== null && _a !== void 0 ? _a : false;\n    this.filter = options.filter;\n    this.autoExpandSingleChildren = typeof options.autoExpandSingleChildren === 'undefined' ? false : options.autoExpandSingleChildren;\n    this.root = {\n      parent: undefined,\n      element: rootElement,\n      children: [],\n      depth: 0,\n      visibleChildrenCount: 0,\n      visibleChildIndex: -1,\n      collapsible: false,\n      collapsed: false,\n      renderNodeCount: 0,\n      visibility: 1 /* TreeVisibility.Visible */,\n      visible: true,\n      filterData: undefined\n    };\n  }\n  splice(location, deleteCount) {\n    let toInsert = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Iterable.empty();\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    if (location.length === 0) {\n      throw new TreeError(this.user, 'Invalid tree location');\n    }\n    if (options.diffIdentityProvider) {\n      this.spliceSmart(options.diffIdentityProvider, location, deleteCount, toInsert, options);\n    } else {\n      this.spliceSimple(location, deleteCount, toInsert, options);\n    }\n  }\n  spliceSmart(identity, location, deleteCount, toInsertIterable, options, recurseLevels) {\n    var _a;\n    if (toInsertIterable === void 0) {\n      toInsertIterable = Iterable.empty();\n    }\n    if (recurseLevels === void 0) {\n      recurseLevels = (_a = options.diffDepth) !== null && _a !== void 0 ? _a : 0;\n    }\n    const {\n      parentNode\n    } = this.getParentNodeWithListIndex(location);\n    if (!parentNode.lastDiffIds) {\n      return this.spliceSimple(location, deleteCount, toInsertIterable, options);\n    }\n    const toInsert = [...toInsertIterable];\n    const index = location[location.length - 1];\n    const diff = new LcsDiff({\n      getElements: () => parentNode.lastDiffIds\n    }, {\n      getElements: () => [...parentNode.children.slice(0, index), ...toInsert, ...parentNode.children.slice(index + deleteCount)].map(e => identity.getId(e.element).toString())\n    }).ComputeDiff(false);\n    // if we were given a 'best effort' diff, use default behavior\n    if (diff.quitEarly) {\n      parentNode.lastDiffIds = undefined;\n      return this.spliceSimple(location, deleteCount, toInsert, options);\n    }\n    const locationPrefix = location.slice(0, -1);\n    const recurseSplice = (fromOriginal, fromModified, count) => {\n      if (recurseLevels > 0) {\n        for (let i = 0; i < count; i++) {\n          fromOriginal--;\n          fromModified--;\n          this.spliceSmart(identity, [...locationPrefix, fromOriginal, 0], Number.MAX_SAFE_INTEGER, toInsert[fromModified].children, options, recurseLevels - 1);\n        }\n      }\n    };\n    let lastStartO = Math.min(parentNode.children.length, index + deleteCount);\n    let lastStartM = toInsert.length;\n    for (const change of diff.changes.sort((a, b) => b.originalStart - a.originalStart)) {\n      recurseSplice(lastStartO, lastStartM, lastStartO - (change.originalStart + change.originalLength));\n      lastStartO = change.originalStart;\n      lastStartM = change.modifiedStart - index;\n      this.spliceSimple([...locationPrefix, lastStartO], change.originalLength, Iterable.slice(toInsert, lastStartM, lastStartM + change.modifiedLength), options);\n    }\n    // at this point, startO === startM === count since any remaining prefix should match\n    recurseSplice(lastStartO, lastStartM, lastStartO);\n  }\n  spliceSimple(location, deleteCount) {\n    let toInsert = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Iterable.empty();\n    let {\n      onDidCreateNode,\n      onDidDeleteNode,\n      diffIdentityProvider\n    } = arguments.length > 3 ? arguments[3] : undefined;\n    const {\n      parentNode,\n      listIndex,\n      revealed,\n      visible\n    } = this.getParentNodeWithListIndex(location);\n    const treeListElementsToInsert = [];\n    const nodesToInsertIterator = Iterable.map(toInsert, el => this.createTreeNode(el, parentNode, parentNode.visible ? 1 /* TreeVisibility.Visible */ : 0 /* TreeVisibility.Hidden */, revealed, treeListElementsToInsert, onDidCreateNode));\n    const lastIndex = location[location.length - 1];\n    // figure out what's the visible child start index right before the\n    // splice point\n    let visibleChildStartIndex = 0;\n    for (let i = lastIndex; i >= 0 && i < parentNode.children.length; i--) {\n      const child = parentNode.children[i];\n      if (child.visible) {\n        visibleChildStartIndex = child.visibleChildIndex;\n        break;\n      }\n    }\n    const nodesToInsert = [];\n    let insertedVisibleChildrenCount = 0;\n    let renderNodeCount = 0;\n    for (const child of nodesToInsertIterator) {\n      nodesToInsert.push(child);\n      renderNodeCount += child.renderNodeCount;\n      if (child.visible) {\n        child.visibleChildIndex = visibleChildStartIndex + insertedVisibleChildrenCount++;\n      }\n    }\n    const deletedNodes = splice(parentNode.children, lastIndex, deleteCount, nodesToInsert);\n    if (!diffIdentityProvider) {\n      parentNode.lastDiffIds = undefined;\n    } else if (parentNode.lastDiffIds) {\n      splice(parentNode.lastDiffIds, lastIndex, deleteCount, nodesToInsert.map(n => diffIdentityProvider.getId(n.element).toString()));\n    } else {\n      parentNode.lastDiffIds = parentNode.children.map(n => diffIdentityProvider.getId(n.element).toString());\n    }\n    // figure out what is the count of deleted visible children\n    let deletedVisibleChildrenCount = 0;\n    for (const child of deletedNodes) {\n      if (child.visible) {\n        deletedVisibleChildrenCount++;\n      }\n    }\n    // and adjust for all visible children after the splice point\n    if (deletedVisibleChildrenCount !== 0) {\n      for (let i = lastIndex + nodesToInsert.length; i < parentNode.children.length; i++) {\n        const child = parentNode.children[i];\n        if (child.visible) {\n          child.visibleChildIndex -= deletedVisibleChildrenCount;\n        }\n      }\n    }\n    // update parent's visible children count\n    parentNode.visibleChildrenCount += insertedVisibleChildrenCount - deletedVisibleChildrenCount;\n    if (revealed && visible) {\n      const visibleDeleteCount = deletedNodes.reduce((r, node) => r + (node.visible ? node.renderNodeCount : 0), 0);\n      this._updateAncestorsRenderNodeCount(parentNode, renderNodeCount - visibleDeleteCount);\n      this.list.splice(listIndex, visibleDeleteCount, treeListElementsToInsert);\n    }\n    if (deletedNodes.length > 0 && onDidDeleteNode) {\n      const visit = node => {\n        onDidDeleteNode(node);\n        node.children.forEach(visit);\n      };\n      deletedNodes.forEach(visit);\n    }\n    this._onDidSplice.fire({\n      insertedNodes: nodesToInsert,\n      deletedNodes\n    });\n    let node = parentNode;\n    while (node) {\n      if (node.visibility === 2 /* TreeVisibility.Recurse */) {\n        // delayed to avoid excessive refiltering, see #135941\n        this.refilterDelayer.trigger(() => this.refilter());\n        break;\n      }\n      node = node.parent;\n    }\n  }\n  rerender(location) {\n    if (location.length === 0) {\n      throw new TreeError(this.user, 'Invalid tree location');\n    }\n    const {\n      node,\n      listIndex,\n      revealed\n    } = this.getTreeNodeWithListIndex(location);\n    if (node.visible && revealed) {\n      this.list.splice(listIndex, 1, [node]);\n    }\n  }\n  has(location) {\n    return this.hasTreeNode(location);\n  }\n  getListIndex(location) {\n    const {\n      listIndex,\n      visible,\n      revealed\n    } = this.getTreeNodeWithListIndex(location);\n    return visible && revealed ? listIndex : -1;\n  }\n  getListRenderCount(location) {\n    return this.getTreeNode(location).renderNodeCount;\n  }\n  isCollapsible(location) {\n    return this.getTreeNode(location).collapsible;\n  }\n  setCollapsible(location, collapsible) {\n    const node = this.getTreeNode(location);\n    if (typeof collapsible === 'undefined') {\n      collapsible = !node.collapsible;\n    }\n    const update = {\n      collapsible\n    };\n    return this.eventBufferer.bufferEvents(() => this._setCollapseState(location, update));\n  }\n  isCollapsed(location) {\n    return this.getTreeNode(location).collapsed;\n  }\n  setCollapsed(location, collapsed, recursive) {\n    const node = this.getTreeNode(location);\n    if (typeof collapsed === 'undefined') {\n      collapsed = !node.collapsed;\n    }\n    const update = {\n      collapsed,\n      recursive: recursive || false\n    };\n    return this.eventBufferer.bufferEvents(() => this._setCollapseState(location, update));\n  }\n  _setCollapseState(location, update) {\n    const {\n      node,\n      listIndex,\n      revealed\n    } = this.getTreeNodeWithListIndex(location);\n    const result = this._setListNodeCollapseState(node, listIndex, revealed, update);\n    if (node !== this.root && this.autoExpandSingleChildren && result && !isCollapsibleStateUpdate(update) && node.collapsible && !node.collapsed && !update.recursive) {\n      let onlyVisibleChildIndex = -1;\n      for (let i = 0; i < node.children.length; i++) {\n        const child = node.children[i];\n        if (child.visible) {\n          if (onlyVisibleChildIndex > -1) {\n            onlyVisibleChildIndex = -1;\n            break;\n          } else {\n            onlyVisibleChildIndex = i;\n          }\n        }\n      }\n      if (onlyVisibleChildIndex > -1) {\n        this._setCollapseState([...location, onlyVisibleChildIndex], update);\n      }\n    }\n    return result;\n  }\n  _setListNodeCollapseState(node, listIndex, revealed, update) {\n    const result = this._setNodeCollapseState(node, update, false);\n    if (!revealed || !node.visible || !result) {\n      return result;\n    }\n    const previousRenderNodeCount = node.renderNodeCount;\n    const toInsert = this.updateNodeAfterCollapseChange(node);\n    const deleteCount = previousRenderNodeCount - (listIndex === -1 ? 0 : 1);\n    this.list.splice(listIndex + 1, deleteCount, toInsert.slice(1));\n    return result;\n  }\n  _setNodeCollapseState(node, update, deep) {\n    let result;\n    if (node === this.root) {\n      result = false;\n    } else {\n      if (isCollapsibleStateUpdate(update)) {\n        result = node.collapsible !== update.collapsible;\n        node.collapsible = update.collapsible;\n      } else if (!node.collapsible) {\n        result = false;\n      } else {\n        result = node.collapsed !== update.collapsed;\n        node.collapsed = update.collapsed;\n      }\n      if (result) {\n        this._onDidChangeCollapseState.fire({\n          node,\n          deep\n        });\n      }\n    }\n    if (!isCollapsibleStateUpdate(update) && update.recursive) {\n      for (const child of node.children) {\n        result = this._setNodeCollapseState(child, update, true) || result;\n      }\n    }\n    return result;\n  }\n  expandTo(location) {\n    this.eventBufferer.bufferEvents(() => {\n      let node = this.getTreeNode(location);\n      while (node.parent) {\n        node = node.parent;\n        location = location.slice(0, location.length - 1);\n        if (node.collapsed) {\n          this._setCollapseState(location, {\n            collapsed: false,\n            recursive: false\n          });\n        }\n      }\n    });\n  }\n  refilter() {\n    const previousRenderNodeCount = this.root.renderNodeCount;\n    const toInsert = this.updateNodeAfterFilterChange(this.root);\n    this.list.splice(0, previousRenderNodeCount, toInsert);\n    this.refilterDelayer.cancel();\n  }\n  createTreeNode(treeElement, parent, parentVisibility, revealed, treeListElements, onDidCreateNode) {\n    const node = {\n      parent,\n      element: treeElement.element,\n      children: [],\n      depth: parent.depth + 1,\n      visibleChildrenCount: 0,\n      visibleChildIndex: -1,\n      collapsible: typeof treeElement.collapsible === 'boolean' ? treeElement.collapsible : typeof treeElement.collapsed !== 'undefined',\n      collapsed: typeof treeElement.collapsed === 'undefined' ? this.collapseByDefault : treeElement.collapsed,\n      renderNodeCount: 1,\n      visibility: 1 /* TreeVisibility.Visible */,\n      visible: true,\n      filterData: undefined\n    };\n    const visibility = this._filterNode(node, parentVisibility);\n    node.visibility = visibility;\n    if (revealed) {\n      treeListElements.push(node);\n    }\n    const childElements = treeElement.children || Iterable.empty();\n    const childRevealed = revealed && visibility !== 0 /* TreeVisibility.Hidden */ && !node.collapsed;\n    let visibleChildrenCount = 0;\n    let renderNodeCount = 1;\n    for (const el of childElements) {\n      const child = this.createTreeNode(el, node, visibility, childRevealed, treeListElements, onDidCreateNode);\n      node.children.push(child);\n      renderNodeCount += child.renderNodeCount;\n      if (child.visible) {\n        child.visibleChildIndex = visibleChildrenCount++;\n      }\n    }\n    if (!this.allowNonCollapsibleParents) {\n      node.collapsible = node.collapsible || node.children.length > 0;\n    }\n    node.visibleChildrenCount = visibleChildrenCount;\n    node.visible = visibility === 2 /* TreeVisibility.Recurse */ ? visibleChildrenCount > 0 : visibility === 1 /* TreeVisibility.Visible */;\n    if (!node.visible) {\n      node.renderNodeCount = 0;\n      if (revealed) {\n        treeListElements.pop();\n      }\n    } else if (!node.collapsed) {\n      node.renderNodeCount = renderNodeCount;\n    }\n    onDidCreateNode === null || onDidCreateNode === void 0 ? void 0 : onDidCreateNode(node);\n    return node;\n  }\n  updateNodeAfterCollapseChange(node) {\n    const previousRenderNodeCount = node.renderNodeCount;\n    const result = [];\n    this._updateNodeAfterCollapseChange(node, result);\n    this._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);\n    return result;\n  }\n  _updateNodeAfterCollapseChange(node, result) {\n    if (node.visible === false) {\n      return 0;\n    }\n    result.push(node);\n    node.renderNodeCount = 1;\n    if (!node.collapsed) {\n      for (const child of node.children) {\n        node.renderNodeCount += this._updateNodeAfterCollapseChange(child, result);\n      }\n    }\n    this._onDidChangeRenderNodeCount.fire(node);\n    return node.renderNodeCount;\n  }\n  updateNodeAfterFilterChange(node) {\n    const previousRenderNodeCount = node.renderNodeCount;\n    const result = [];\n    this._updateNodeAfterFilterChange(node, node.visible ? 1 /* TreeVisibility.Visible */ : 0 /* TreeVisibility.Hidden */, result);\n    this._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);\n    return result;\n  }\n  _updateNodeAfterFilterChange(node, parentVisibility, result) {\n    let revealed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    let visibility;\n    if (node !== this.root) {\n      visibility = this._filterNode(node, parentVisibility);\n      if (visibility === 0 /* TreeVisibility.Hidden */) {\n        node.visible = false;\n        node.renderNodeCount = 0;\n        return false;\n      }\n      if (revealed) {\n        result.push(node);\n      }\n    }\n    const resultStartLength = result.length;\n    node.renderNodeCount = node === this.root ? 0 : 1;\n    let hasVisibleDescendants = false;\n    if (!node.collapsed || visibility !== 0 /* TreeVisibility.Hidden */) {\n      let visibleChildIndex = 0;\n      for (const child of node.children) {\n        hasVisibleDescendants = this._updateNodeAfterFilterChange(child, visibility, result, revealed && !node.collapsed) || hasVisibleDescendants;\n        if (child.visible) {\n          child.visibleChildIndex = visibleChildIndex++;\n        }\n      }\n      node.visibleChildrenCount = visibleChildIndex;\n    } else {\n      node.visibleChildrenCount = 0;\n    }\n    if (node !== this.root) {\n      node.visible = visibility === 2 /* TreeVisibility.Recurse */ ? hasVisibleDescendants : visibility === 1 /* TreeVisibility.Visible */;\n      node.visibility = visibility;\n    }\n    if (!node.visible) {\n      node.renderNodeCount = 0;\n      if (revealed) {\n        result.pop();\n      }\n    } else if (!node.collapsed) {\n      node.renderNodeCount += result.length - resultStartLength;\n    }\n    this._onDidChangeRenderNodeCount.fire(node);\n    return node.visible;\n  }\n  _updateAncestorsRenderNodeCount(node, diff) {\n    if (diff === 0) {\n      return;\n    }\n    while (node) {\n      node.renderNodeCount += diff;\n      this._onDidChangeRenderNodeCount.fire(node);\n      node = node.parent;\n    }\n  }\n  _filterNode(node, parentVisibility) {\n    const result = this.filter ? this.filter.filter(node.element, parentVisibility) : 1 /* TreeVisibility.Visible */;\n    if (typeof result === 'boolean') {\n      node.filterData = undefined;\n      return result ? 1 /* TreeVisibility.Visible */ : 0 /* TreeVisibility.Hidden */;\n    } else if (isFilterResult(result)) {\n      node.filterData = result.data;\n      return getVisibleState(result.visibility);\n    } else {\n      node.filterData = undefined;\n      return getVisibleState(result);\n    }\n  }\n  // cheap\n  hasTreeNode(location) {\n    let node = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.root;\n    if (!location || location.length === 0) {\n      return true;\n    }\n    const [index, ...rest] = location;\n    if (index < 0 || index > node.children.length) {\n      return false;\n    }\n    return this.hasTreeNode(rest, node.children[index]);\n  }\n  // cheap\n  getTreeNode(location) {\n    let node = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.root;\n    if (!location || location.length === 0) {\n      return node;\n    }\n    const [index, ...rest] = location;\n    if (index < 0 || index > node.children.length) {\n      throw new TreeError(this.user, 'Invalid tree location');\n    }\n    return this.getTreeNode(rest, node.children[index]);\n  }\n  // expensive\n  getTreeNodeWithListIndex(location) {\n    if (location.length === 0) {\n      return {\n        node: this.root,\n        listIndex: -1,\n        revealed: true,\n        visible: false\n      };\n    }\n    const {\n      parentNode,\n      listIndex,\n      revealed,\n      visible\n    } = this.getParentNodeWithListIndex(location);\n    const index = location[location.length - 1];\n    if (index < 0 || index > parentNode.children.length) {\n      throw new TreeError(this.user, 'Invalid tree location');\n    }\n    const node = parentNode.children[index];\n    return {\n      node,\n      listIndex,\n      revealed,\n      visible: visible && node.visible\n    };\n  }\n  getParentNodeWithListIndex(location) {\n    let node = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.root;\n    let listIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let revealed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    let visible = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    const [index, ...rest] = location;\n    if (index < 0 || index > node.children.length) {\n      throw new TreeError(this.user, 'Invalid tree location');\n    }\n    // TODO@joao perf!\n    for (let i = 0; i < index; i++) {\n      listIndex += node.children[i].renderNodeCount;\n    }\n    revealed = revealed && !node.collapsed;\n    visible = visible && node.visible;\n    if (rest.length === 0) {\n      return {\n        parentNode: node,\n        listIndex,\n        revealed,\n        visible\n      };\n    }\n    return this.getParentNodeWithListIndex(rest, node.children[index], listIndex + 1, revealed, visible);\n  }\n  getNode() {\n    let location = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    return this.getTreeNode(location);\n  }\n  // TODO@joao perf!\n  getNodeLocation(node) {\n    const location = [];\n    let indexTreeNode = node; // typing woes\n    while (indexTreeNode.parent) {\n      location.push(indexTreeNode.parent.children.indexOf(indexTreeNode));\n      indexTreeNode = indexTreeNode.parent;\n    }\n    return location.reverse();\n  }\n  getParentNodeLocation(location) {\n    if (location.length === 0) {\n      return undefined;\n    } else if (location.length === 1) {\n      return [];\n    } else {\n      return tail2(location)[0];\n    }\n  }\n  getFirstElementChild(location) {\n    const node = this.getTreeNode(location);\n    if (node.children.length === 0) {\n      return undefined;\n    }\n    return node.children[0].element;\n  }\n}","map":{"version":3,"names":["TreeError","splice","tail2","Delayer","MicrotaskDelay","LcsDiff","Emitter","EventBufferer","Iterable","isFilterResult","obj","getVisibleState","visibility","isCollapsibleStateUpdate","update","collapsible","IndexTreeModel","constructor","user","list","rootElement","options","arguments","length","undefined","_a","rootRef","eventBufferer","_onDidChangeCollapseState","onDidChangeCollapseState","wrapEvent","event","_onDidChangeRenderNodeCount","onDidChangeRenderNodeCount","_onDidSplice","onDidSplice","refilterDelayer","collapseByDefault","allowNonCollapsibleParents","filter","autoExpandSingleChildren","root","parent","element","children","depth","visibleChildrenCount","visibleChildIndex","collapsed","renderNodeCount","visible","filterData","location","deleteCount","toInsert","empty","diffIdentityProvider","spliceSmart","spliceSimple","identity","toInsertIterable","recurseLevels","diffDepth","parentNode","getParentNodeWithListIndex","lastDiffIds","index","diff","getElements","slice","map","e","getId","toString","ComputeDiff","quitEarly","locationPrefix","recurseSplice","fromOriginal","fromModified","count","i","Number","MAX_SAFE_INTEGER","lastStartO","Math","min","lastStartM","change","changes","sort","a","b","originalStart","originalLength","modifiedStart","modifiedLength","onDidCreateNode","onDidDeleteNode","listIndex","revealed","treeListElementsToInsert","nodesToInsertIterator","el","createTreeNode","lastIndex","visibleChildStartIndex","child","nodesToInsert","insertedVisibleChildrenCount","push","deletedNodes","n","deletedVisibleChildrenCount","visibleDeleteCount","reduce","r","node","_updateAncestorsRenderNodeCount","visit","forEach","fire","insertedNodes","trigger","refilter","rerender","getTreeNodeWithListIndex","has","hasTreeNode","getListIndex","getListRenderCount","getTreeNode","isCollapsible","setCollapsible","bufferEvents","_setCollapseState","isCollapsed","setCollapsed","recursive","result","_setListNodeCollapseState","onlyVisibleChildIndex","_setNodeCollapseState","previousRenderNodeCount","updateNodeAfterCollapseChange","deep","expandTo","updateNodeAfterFilterChange","cancel","treeElement","parentVisibility","treeListElements","_filterNode","childElements","childRevealed","pop","_updateNodeAfterCollapseChange","_updateNodeAfterFilterChange","resultStartLength","hasVisibleDescendants","data","rest","getNode","getNodeLocation","indexTreeNode","indexOf","reverse","getParentNodeLocation","getFirstElementChild"],"sources":["/home/arslan/modojo/node_modules/monaco-editor/esm/vs/base/browser/ui/tree/indexTreeModel.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { TreeError } from './tree.js';\nimport { splice, tail2 } from '../../../common/arrays.js';\nimport { Delayer } from '../../../common/async.js';\nimport { MicrotaskDelay } from '../../../common/symbols.js';\nimport { LcsDiff } from '../../../common/diff/diff.js';\nimport { Emitter, EventBufferer } from '../../../common/event.js';\nimport { Iterable } from '../../../common/iterator.js';\nexport function isFilterResult(obj) {\n    return typeof obj === 'object' && 'visibility' in obj && 'data' in obj;\n}\nexport function getVisibleState(visibility) {\n    switch (visibility) {\n        case true: return 1 /* TreeVisibility.Visible */;\n        case false: return 0 /* TreeVisibility.Hidden */;\n        default: return visibility;\n    }\n}\nfunction isCollapsibleStateUpdate(update) {\n    return typeof update.collapsible === 'boolean';\n}\nexport class IndexTreeModel {\n    constructor(user, list, rootElement, options = {}) {\n        var _a;\n        this.user = user;\n        this.list = list;\n        this.rootRef = [];\n        this.eventBufferer = new EventBufferer();\n        this._onDidChangeCollapseState = new Emitter();\n        this.onDidChangeCollapseState = this.eventBufferer.wrapEvent(this._onDidChangeCollapseState.event);\n        this._onDidChangeRenderNodeCount = new Emitter();\n        this.onDidChangeRenderNodeCount = this.eventBufferer.wrapEvent(this._onDidChangeRenderNodeCount.event);\n        this._onDidSplice = new Emitter();\n        this.onDidSplice = this._onDidSplice.event;\n        this.refilterDelayer = new Delayer(MicrotaskDelay);\n        this.collapseByDefault = typeof options.collapseByDefault === 'undefined' ? false : options.collapseByDefault;\n        this.allowNonCollapsibleParents = (_a = options.allowNonCollapsibleParents) !== null && _a !== void 0 ? _a : false;\n        this.filter = options.filter;\n        this.autoExpandSingleChildren = typeof options.autoExpandSingleChildren === 'undefined' ? false : options.autoExpandSingleChildren;\n        this.root = {\n            parent: undefined,\n            element: rootElement,\n            children: [],\n            depth: 0,\n            visibleChildrenCount: 0,\n            visibleChildIndex: -1,\n            collapsible: false,\n            collapsed: false,\n            renderNodeCount: 0,\n            visibility: 1 /* TreeVisibility.Visible */,\n            visible: true,\n            filterData: undefined\n        };\n    }\n    splice(location, deleteCount, toInsert = Iterable.empty(), options = {}) {\n        if (location.length === 0) {\n            throw new TreeError(this.user, 'Invalid tree location');\n        }\n        if (options.diffIdentityProvider) {\n            this.spliceSmart(options.diffIdentityProvider, location, deleteCount, toInsert, options);\n        }\n        else {\n            this.spliceSimple(location, deleteCount, toInsert, options);\n        }\n    }\n    spliceSmart(identity, location, deleteCount, toInsertIterable, options, recurseLevels) {\n        var _a;\n        if (toInsertIterable === void 0) { toInsertIterable = Iterable.empty(); }\n        if (recurseLevels === void 0) { recurseLevels = (_a = options.diffDepth) !== null && _a !== void 0 ? _a : 0; }\n        const { parentNode } = this.getParentNodeWithListIndex(location);\n        if (!parentNode.lastDiffIds) {\n            return this.spliceSimple(location, deleteCount, toInsertIterable, options);\n        }\n        const toInsert = [...toInsertIterable];\n        const index = location[location.length - 1];\n        const diff = new LcsDiff({ getElements: () => parentNode.lastDiffIds }, {\n            getElements: () => [\n                ...parentNode.children.slice(0, index),\n                ...toInsert,\n                ...parentNode.children.slice(index + deleteCount),\n            ].map(e => identity.getId(e.element).toString())\n        }).ComputeDiff(false);\n        // if we were given a 'best effort' diff, use default behavior\n        if (diff.quitEarly) {\n            parentNode.lastDiffIds = undefined;\n            return this.spliceSimple(location, deleteCount, toInsert, options);\n        }\n        const locationPrefix = location.slice(0, -1);\n        const recurseSplice = (fromOriginal, fromModified, count) => {\n            if (recurseLevels > 0) {\n                for (let i = 0; i < count; i++) {\n                    fromOriginal--;\n                    fromModified--;\n                    this.spliceSmart(identity, [...locationPrefix, fromOriginal, 0], Number.MAX_SAFE_INTEGER, toInsert[fromModified].children, options, recurseLevels - 1);\n                }\n            }\n        };\n        let lastStartO = Math.min(parentNode.children.length, index + deleteCount);\n        let lastStartM = toInsert.length;\n        for (const change of diff.changes.sort((a, b) => b.originalStart - a.originalStart)) {\n            recurseSplice(lastStartO, lastStartM, lastStartO - (change.originalStart + change.originalLength));\n            lastStartO = change.originalStart;\n            lastStartM = change.modifiedStart - index;\n            this.spliceSimple([...locationPrefix, lastStartO], change.originalLength, Iterable.slice(toInsert, lastStartM, lastStartM + change.modifiedLength), options);\n        }\n        // at this point, startO === startM === count since any remaining prefix should match\n        recurseSplice(lastStartO, lastStartM, lastStartO);\n    }\n    spliceSimple(location, deleteCount, toInsert = Iterable.empty(), { onDidCreateNode, onDidDeleteNode, diffIdentityProvider }) {\n        const { parentNode, listIndex, revealed, visible } = this.getParentNodeWithListIndex(location);\n        const treeListElementsToInsert = [];\n        const nodesToInsertIterator = Iterable.map(toInsert, el => this.createTreeNode(el, parentNode, parentNode.visible ? 1 /* TreeVisibility.Visible */ : 0 /* TreeVisibility.Hidden */, revealed, treeListElementsToInsert, onDidCreateNode));\n        const lastIndex = location[location.length - 1];\n        // figure out what's the visible child start index right before the\n        // splice point\n        let visibleChildStartIndex = 0;\n        for (let i = lastIndex; i >= 0 && i < parentNode.children.length; i--) {\n            const child = parentNode.children[i];\n            if (child.visible) {\n                visibleChildStartIndex = child.visibleChildIndex;\n                break;\n            }\n        }\n        const nodesToInsert = [];\n        let insertedVisibleChildrenCount = 0;\n        let renderNodeCount = 0;\n        for (const child of nodesToInsertIterator) {\n            nodesToInsert.push(child);\n            renderNodeCount += child.renderNodeCount;\n            if (child.visible) {\n                child.visibleChildIndex = visibleChildStartIndex + insertedVisibleChildrenCount++;\n            }\n        }\n        const deletedNodes = splice(parentNode.children, lastIndex, deleteCount, nodesToInsert);\n        if (!diffIdentityProvider) {\n            parentNode.lastDiffIds = undefined;\n        }\n        else if (parentNode.lastDiffIds) {\n            splice(parentNode.lastDiffIds, lastIndex, deleteCount, nodesToInsert.map(n => diffIdentityProvider.getId(n.element).toString()));\n        }\n        else {\n            parentNode.lastDiffIds = parentNode.children.map(n => diffIdentityProvider.getId(n.element).toString());\n        }\n        // figure out what is the count of deleted visible children\n        let deletedVisibleChildrenCount = 0;\n        for (const child of deletedNodes) {\n            if (child.visible) {\n                deletedVisibleChildrenCount++;\n            }\n        }\n        // and adjust for all visible children after the splice point\n        if (deletedVisibleChildrenCount !== 0) {\n            for (let i = lastIndex + nodesToInsert.length; i < parentNode.children.length; i++) {\n                const child = parentNode.children[i];\n                if (child.visible) {\n                    child.visibleChildIndex -= deletedVisibleChildrenCount;\n                }\n            }\n        }\n        // update parent's visible children count\n        parentNode.visibleChildrenCount += insertedVisibleChildrenCount - deletedVisibleChildrenCount;\n        if (revealed && visible) {\n            const visibleDeleteCount = deletedNodes.reduce((r, node) => r + (node.visible ? node.renderNodeCount : 0), 0);\n            this._updateAncestorsRenderNodeCount(parentNode, renderNodeCount - visibleDeleteCount);\n            this.list.splice(listIndex, visibleDeleteCount, treeListElementsToInsert);\n        }\n        if (deletedNodes.length > 0 && onDidDeleteNode) {\n            const visit = (node) => {\n                onDidDeleteNode(node);\n                node.children.forEach(visit);\n            };\n            deletedNodes.forEach(visit);\n        }\n        this._onDidSplice.fire({ insertedNodes: nodesToInsert, deletedNodes });\n        let node = parentNode;\n        while (node) {\n            if (node.visibility === 2 /* TreeVisibility.Recurse */) {\n                // delayed to avoid excessive refiltering, see #135941\n                this.refilterDelayer.trigger(() => this.refilter());\n                break;\n            }\n            node = node.parent;\n        }\n    }\n    rerender(location) {\n        if (location.length === 0) {\n            throw new TreeError(this.user, 'Invalid tree location');\n        }\n        const { node, listIndex, revealed } = this.getTreeNodeWithListIndex(location);\n        if (node.visible && revealed) {\n            this.list.splice(listIndex, 1, [node]);\n        }\n    }\n    has(location) {\n        return this.hasTreeNode(location);\n    }\n    getListIndex(location) {\n        const { listIndex, visible, revealed } = this.getTreeNodeWithListIndex(location);\n        return visible && revealed ? listIndex : -1;\n    }\n    getListRenderCount(location) {\n        return this.getTreeNode(location).renderNodeCount;\n    }\n    isCollapsible(location) {\n        return this.getTreeNode(location).collapsible;\n    }\n    setCollapsible(location, collapsible) {\n        const node = this.getTreeNode(location);\n        if (typeof collapsible === 'undefined') {\n            collapsible = !node.collapsible;\n        }\n        const update = { collapsible };\n        return this.eventBufferer.bufferEvents(() => this._setCollapseState(location, update));\n    }\n    isCollapsed(location) {\n        return this.getTreeNode(location).collapsed;\n    }\n    setCollapsed(location, collapsed, recursive) {\n        const node = this.getTreeNode(location);\n        if (typeof collapsed === 'undefined') {\n            collapsed = !node.collapsed;\n        }\n        const update = { collapsed, recursive: recursive || false };\n        return this.eventBufferer.bufferEvents(() => this._setCollapseState(location, update));\n    }\n    _setCollapseState(location, update) {\n        const { node, listIndex, revealed } = this.getTreeNodeWithListIndex(location);\n        const result = this._setListNodeCollapseState(node, listIndex, revealed, update);\n        if (node !== this.root && this.autoExpandSingleChildren && result && !isCollapsibleStateUpdate(update) && node.collapsible && !node.collapsed && !update.recursive) {\n            let onlyVisibleChildIndex = -1;\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                if (child.visible) {\n                    if (onlyVisibleChildIndex > -1) {\n                        onlyVisibleChildIndex = -1;\n                        break;\n                    }\n                    else {\n                        onlyVisibleChildIndex = i;\n                    }\n                }\n            }\n            if (onlyVisibleChildIndex > -1) {\n                this._setCollapseState([...location, onlyVisibleChildIndex], update);\n            }\n        }\n        return result;\n    }\n    _setListNodeCollapseState(node, listIndex, revealed, update) {\n        const result = this._setNodeCollapseState(node, update, false);\n        if (!revealed || !node.visible || !result) {\n            return result;\n        }\n        const previousRenderNodeCount = node.renderNodeCount;\n        const toInsert = this.updateNodeAfterCollapseChange(node);\n        const deleteCount = previousRenderNodeCount - (listIndex === -1 ? 0 : 1);\n        this.list.splice(listIndex + 1, deleteCount, toInsert.slice(1));\n        return result;\n    }\n    _setNodeCollapseState(node, update, deep) {\n        let result;\n        if (node === this.root) {\n            result = false;\n        }\n        else {\n            if (isCollapsibleStateUpdate(update)) {\n                result = node.collapsible !== update.collapsible;\n                node.collapsible = update.collapsible;\n            }\n            else if (!node.collapsible) {\n                result = false;\n            }\n            else {\n                result = node.collapsed !== update.collapsed;\n                node.collapsed = update.collapsed;\n            }\n            if (result) {\n                this._onDidChangeCollapseState.fire({ node, deep });\n            }\n        }\n        if (!isCollapsibleStateUpdate(update) && update.recursive) {\n            for (const child of node.children) {\n                result = this._setNodeCollapseState(child, update, true) || result;\n            }\n        }\n        return result;\n    }\n    expandTo(location) {\n        this.eventBufferer.bufferEvents(() => {\n            let node = this.getTreeNode(location);\n            while (node.parent) {\n                node = node.parent;\n                location = location.slice(0, location.length - 1);\n                if (node.collapsed) {\n                    this._setCollapseState(location, { collapsed: false, recursive: false });\n                }\n            }\n        });\n    }\n    refilter() {\n        const previousRenderNodeCount = this.root.renderNodeCount;\n        const toInsert = this.updateNodeAfterFilterChange(this.root);\n        this.list.splice(0, previousRenderNodeCount, toInsert);\n        this.refilterDelayer.cancel();\n    }\n    createTreeNode(treeElement, parent, parentVisibility, revealed, treeListElements, onDidCreateNode) {\n        const node = {\n            parent,\n            element: treeElement.element,\n            children: [],\n            depth: parent.depth + 1,\n            visibleChildrenCount: 0,\n            visibleChildIndex: -1,\n            collapsible: typeof treeElement.collapsible === 'boolean' ? treeElement.collapsible : (typeof treeElement.collapsed !== 'undefined'),\n            collapsed: typeof treeElement.collapsed === 'undefined' ? this.collapseByDefault : treeElement.collapsed,\n            renderNodeCount: 1,\n            visibility: 1 /* TreeVisibility.Visible */,\n            visible: true,\n            filterData: undefined\n        };\n        const visibility = this._filterNode(node, parentVisibility);\n        node.visibility = visibility;\n        if (revealed) {\n            treeListElements.push(node);\n        }\n        const childElements = treeElement.children || Iterable.empty();\n        const childRevealed = revealed && visibility !== 0 /* TreeVisibility.Hidden */ && !node.collapsed;\n        let visibleChildrenCount = 0;\n        let renderNodeCount = 1;\n        for (const el of childElements) {\n            const child = this.createTreeNode(el, node, visibility, childRevealed, treeListElements, onDidCreateNode);\n            node.children.push(child);\n            renderNodeCount += child.renderNodeCount;\n            if (child.visible) {\n                child.visibleChildIndex = visibleChildrenCount++;\n            }\n        }\n        if (!this.allowNonCollapsibleParents) {\n            node.collapsible = node.collapsible || node.children.length > 0;\n        }\n        node.visibleChildrenCount = visibleChildrenCount;\n        node.visible = visibility === 2 /* TreeVisibility.Recurse */ ? visibleChildrenCount > 0 : (visibility === 1 /* TreeVisibility.Visible */);\n        if (!node.visible) {\n            node.renderNodeCount = 0;\n            if (revealed) {\n                treeListElements.pop();\n            }\n        }\n        else if (!node.collapsed) {\n            node.renderNodeCount = renderNodeCount;\n        }\n        onDidCreateNode === null || onDidCreateNode === void 0 ? void 0 : onDidCreateNode(node);\n        return node;\n    }\n    updateNodeAfterCollapseChange(node) {\n        const previousRenderNodeCount = node.renderNodeCount;\n        const result = [];\n        this._updateNodeAfterCollapseChange(node, result);\n        this._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);\n        return result;\n    }\n    _updateNodeAfterCollapseChange(node, result) {\n        if (node.visible === false) {\n            return 0;\n        }\n        result.push(node);\n        node.renderNodeCount = 1;\n        if (!node.collapsed) {\n            for (const child of node.children) {\n                node.renderNodeCount += this._updateNodeAfterCollapseChange(child, result);\n            }\n        }\n        this._onDidChangeRenderNodeCount.fire(node);\n        return node.renderNodeCount;\n    }\n    updateNodeAfterFilterChange(node) {\n        const previousRenderNodeCount = node.renderNodeCount;\n        const result = [];\n        this._updateNodeAfterFilterChange(node, node.visible ? 1 /* TreeVisibility.Visible */ : 0 /* TreeVisibility.Hidden */, result);\n        this._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);\n        return result;\n    }\n    _updateNodeAfterFilterChange(node, parentVisibility, result, revealed = true) {\n        let visibility;\n        if (node !== this.root) {\n            visibility = this._filterNode(node, parentVisibility);\n            if (visibility === 0 /* TreeVisibility.Hidden */) {\n                node.visible = false;\n                node.renderNodeCount = 0;\n                return false;\n            }\n            if (revealed) {\n                result.push(node);\n            }\n        }\n        const resultStartLength = result.length;\n        node.renderNodeCount = node === this.root ? 0 : 1;\n        let hasVisibleDescendants = false;\n        if (!node.collapsed || visibility !== 0 /* TreeVisibility.Hidden */) {\n            let visibleChildIndex = 0;\n            for (const child of node.children) {\n                hasVisibleDescendants = this._updateNodeAfterFilterChange(child, visibility, result, revealed && !node.collapsed) || hasVisibleDescendants;\n                if (child.visible) {\n                    child.visibleChildIndex = visibleChildIndex++;\n                }\n            }\n            node.visibleChildrenCount = visibleChildIndex;\n        }\n        else {\n            node.visibleChildrenCount = 0;\n        }\n        if (node !== this.root) {\n            node.visible = visibility === 2 /* TreeVisibility.Recurse */ ? hasVisibleDescendants : (visibility === 1 /* TreeVisibility.Visible */);\n            node.visibility = visibility;\n        }\n        if (!node.visible) {\n            node.renderNodeCount = 0;\n            if (revealed) {\n                result.pop();\n            }\n        }\n        else if (!node.collapsed) {\n            node.renderNodeCount += result.length - resultStartLength;\n        }\n        this._onDidChangeRenderNodeCount.fire(node);\n        return node.visible;\n    }\n    _updateAncestorsRenderNodeCount(node, diff) {\n        if (diff === 0) {\n            return;\n        }\n        while (node) {\n            node.renderNodeCount += diff;\n            this._onDidChangeRenderNodeCount.fire(node);\n            node = node.parent;\n        }\n    }\n    _filterNode(node, parentVisibility) {\n        const result = this.filter ? this.filter.filter(node.element, parentVisibility) : 1 /* TreeVisibility.Visible */;\n        if (typeof result === 'boolean') {\n            node.filterData = undefined;\n            return result ? 1 /* TreeVisibility.Visible */ : 0 /* TreeVisibility.Hidden */;\n        }\n        else if (isFilterResult(result)) {\n            node.filterData = result.data;\n            return getVisibleState(result.visibility);\n        }\n        else {\n            node.filterData = undefined;\n            return getVisibleState(result);\n        }\n    }\n    // cheap\n    hasTreeNode(location, node = this.root) {\n        if (!location || location.length === 0) {\n            return true;\n        }\n        const [index, ...rest] = location;\n        if (index < 0 || index > node.children.length) {\n            return false;\n        }\n        return this.hasTreeNode(rest, node.children[index]);\n    }\n    // cheap\n    getTreeNode(location, node = this.root) {\n        if (!location || location.length === 0) {\n            return node;\n        }\n        const [index, ...rest] = location;\n        if (index < 0 || index > node.children.length) {\n            throw new TreeError(this.user, 'Invalid tree location');\n        }\n        return this.getTreeNode(rest, node.children[index]);\n    }\n    // expensive\n    getTreeNodeWithListIndex(location) {\n        if (location.length === 0) {\n            return { node: this.root, listIndex: -1, revealed: true, visible: false };\n        }\n        const { parentNode, listIndex, revealed, visible } = this.getParentNodeWithListIndex(location);\n        const index = location[location.length - 1];\n        if (index < 0 || index > parentNode.children.length) {\n            throw new TreeError(this.user, 'Invalid tree location');\n        }\n        const node = parentNode.children[index];\n        return { node, listIndex, revealed, visible: visible && node.visible };\n    }\n    getParentNodeWithListIndex(location, node = this.root, listIndex = 0, revealed = true, visible = true) {\n        const [index, ...rest] = location;\n        if (index < 0 || index > node.children.length) {\n            throw new TreeError(this.user, 'Invalid tree location');\n        }\n        // TODO@joao perf!\n        for (let i = 0; i < index; i++) {\n            listIndex += node.children[i].renderNodeCount;\n        }\n        revealed = revealed && !node.collapsed;\n        visible = visible && node.visible;\n        if (rest.length === 0) {\n            return { parentNode: node, listIndex, revealed, visible };\n        }\n        return this.getParentNodeWithListIndex(rest, node.children[index], listIndex + 1, revealed, visible);\n    }\n    getNode(location = []) {\n        return this.getTreeNode(location);\n    }\n    // TODO@joao perf!\n    getNodeLocation(node) {\n        const location = [];\n        let indexTreeNode = node; // typing woes\n        while (indexTreeNode.parent) {\n            location.push(indexTreeNode.parent.children.indexOf(indexTreeNode));\n            indexTreeNode = indexTreeNode.parent;\n        }\n        return location.reverse();\n    }\n    getParentNodeLocation(location) {\n        if (location.length === 0) {\n            return undefined;\n        }\n        else if (location.length === 1) {\n            return [];\n        }\n        else {\n            return tail2(location)[0];\n        }\n    }\n    getFirstElementChild(location) {\n        const node = this.getTreeNode(location);\n        if (node.children.length === 0) {\n            return undefined;\n        }\n        return node.children[0].element;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}