{"ast":null,"code":"import { SignIdentity, wrapDER, DER_COSE_OID, fromHex, toHex } from '@dfinity/agent';\nimport borc from 'borc';\nimport { randomBytes } from '@noble/hashes/utils';\nimport { bufFromBufLike } from '@dfinity/candid';\nfunction _coseToDerEncodedBlob(cose) {\n  return wrapDER(cose, DER_COSE_OID).buffer;\n}\n/**\n * From the documentation;\n * The authData is a byte array described in the spec. Parsing it will involve slicing bytes from\n * the array and converting them into usable objects.\n *\n * See https://webauthn.guide/#registration (subsection \"Example: Parsing the authenticator data\").\n * @param authData The authData field of the attestation response.\n * @returns The COSE key of the authData.\n */\nfunction _authDataToCose(authData) {\n  const dataView = new DataView(new ArrayBuffer(2));\n  const idLenBytes = authData.slice(53, 55);\n  [...new Uint8Array(idLenBytes)].forEach((v, i) => dataView.setUint8(i, v));\n  const credentialIdLength = dataView.getUint16(0);\n  // Get the public key object.\n  return authData.slice(55 + credentialIdLength);\n}\nexport class CosePublicKey {\n  constructor(_cose) {\n    this._cose = _cose;\n    this._encodedKey = _coseToDerEncodedBlob(_cose);\n  }\n  toDer() {\n    return this._encodedKey;\n  }\n  getCose() {\n    return this._cose;\n  }\n}\n/**\n * Create a challenge from a string or array. The default challenge is always the same\n * because we don't need to verify the authenticity of the key on the server (we don't\n * register our keys with the IC). Any challenge would do, even one per key, randomly\n * generated.\n * @param challenge The challenge to transform into a byte array. By default a hard\n *        coded string.\n */\nfunction _createChallengeBuffer() {\n  let challenge = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '<ic0.app>';\n  if (typeof challenge === 'string') {\n    return Uint8Array.from(challenge, c => c.charCodeAt(0));\n  } else {\n    return challenge;\n  }\n}\n/**\n * Create a credentials to authenticate with a server. This is necessary in order in\n * WebAuthn to get credentials IDs (which give us the public key and allow us to\n * sign), but in the case of the Internet Computer, we don't actually need to register\n * it, so we don't.\n * @param credentialCreationOptions an optional CredentialCreationOptions object\n */\nasync function _createCredential(credentialCreationOptions) {\n  const creds = await navigator.credentials.create(credentialCreationOptions !== null && credentialCreationOptions !== void 0 ? credentialCreationOptions : {\n    publicKey: {\n      authenticatorSelection: {\n        userVerification: 'preferred'\n      },\n      attestation: 'direct',\n      challenge: _createChallengeBuffer(),\n      pubKeyCredParams: [{\n        type: 'public-key',\n        alg: PubKeyCoseAlgo.ECDSA_WITH_SHA256\n      }],\n      rp: {\n        name: 'Internet Identity Service'\n      },\n      user: {\n        id: randomBytes(16),\n        name: 'Internet Identity',\n        displayName: 'Internet Identity'\n      }\n    }\n  });\n  if (creds === null) {\n    return null;\n  }\n  return {\n    // do _not_ use ...creds here, as creds is not enumerable in all cases\n    id: creds.id,\n    response: creds.response,\n    type: creds.type,\n    authenticatorAttachment: creds.authenticatorAttachment,\n    getClientExtensionResults: creds.getClientExtensionResults,\n    // Some password managers will return a Uint8Array, so we ensure we return an ArrayBuffer.\n    rawId: bufFromBufLike(creds.rawId)\n  };\n}\n// See https://www.iana.org/assignments/cose/cose.xhtml#algorithms for a complete\n// list of these algorithms. We only list the ones we support here.\nvar PubKeyCoseAlgo;\n(function (PubKeyCoseAlgo) {\n  PubKeyCoseAlgo[PubKeyCoseAlgo[\"ECDSA_WITH_SHA256\"] = -7] = \"ECDSA_WITH_SHA256\";\n})(PubKeyCoseAlgo || (PubKeyCoseAlgo = {}));\n/**\n * A SignIdentity that uses `navigator.credentials`. See https://webauthn.guide/ for\n * more information about WebAuthentication.\n */\nexport class WebAuthnIdentity extends SignIdentity {\n  constructor(rawId, cose, authenticatorAttachment) {\n    super();\n    this.rawId = rawId;\n    this.authenticatorAttachment = authenticatorAttachment;\n    this._publicKey = new CosePublicKey(cose);\n  }\n  /**\n   * Create an identity from a JSON serialization.\n   * @param json - json to parse\n   */\n  static fromJSON(json) {\n    const {\n      publicKey,\n      rawId\n    } = JSON.parse(json);\n    if (typeof publicKey !== 'string' || typeof rawId !== 'string') {\n      throw new Error('Invalid JSON string.');\n    }\n    return new this(fromHex(rawId), fromHex(publicKey), undefined);\n  }\n  /**\n   * Create an identity.\n   * @param credentialCreationOptions an optional CredentialCreationOptions Challenge\n   */\n  static async create(credentialCreationOptions) {\n    var _a;\n    const creds = await _createCredential(credentialCreationOptions);\n    if (!creds || creds.type !== 'public-key') {\n      throw new Error('Could not create credentials.');\n    }\n    const response = creds.response;\n    if (response.attestationObject === undefined) {\n      throw new Error('Was expecting an attestation response.');\n    }\n    // Parse the attestationObject as CBOR.\n    const attObject = borc.decodeFirst(new Uint8Array(response.attestationObject));\n    return new this(creds.rawId, _authDataToCose(attObject.authData), (_a = creds.authenticatorAttachment) !== null && _a !== void 0 ? _a : undefined);\n  }\n  getPublicKey() {\n    return this._publicKey;\n  }\n  /**\n   * WebAuthn level 3 spec introduces a new attribute on successful WebAuthn interactions,\n   * see https://w3c.github.io/webauthn/#dom-publickeycredential-authenticatorattachment.\n   * This attribute is already implemented for Chrome, Safari and Edge.\n   *\n   * Given the attribute is only available after a successful interaction, the information is\n   * provided opportunistically and might also be `undefined`.\n   */\n  getAuthenticatorAttachment() {\n    return this.authenticatorAttachment;\n  }\n  async sign(blob) {\n    const result = await navigator.credentials.get({\n      publicKey: {\n        allowCredentials: [{\n          type: 'public-key',\n          id: this.rawId\n        }],\n        challenge: blob,\n        userVerification: 'preferred'\n      }\n    });\n    if (result.authenticatorAttachment !== null) {\n      this.authenticatorAttachment = result.authenticatorAttachment;\n    }\n    const response = result.response;\n    const cbor = borc.encode(new borc.Tagged(55799, {\n      authenticator_data: new Uint8Array(response.authenticatorData),\n      client_data_json: new TextDecoder().decode(response.clientDataJSON),\n      signature: new Uint8Array(response.signature)\n    }));\n    if (!cbor) {\n      throw new Error('failed to encode cbor');\n    }\n    return cbor.buffer;\n  }\n  /**\n   * Allow for JSON serialization of all information needed to reuse this identity.\n   */\n  toJSON() {\n    return {\n      publicKey: toHex(this._publicKey.getCose()),\n      rawId: toHex(this.rawId)\n    };\n  }\n}","map":{"version":3,"names":["SignIdentity","wrapDER","DER_COSE_OID","fromHex","toHex","borc","randomBytes","bufFromBufLike","_coseToDerEncodedBlob","cose","buffer","_authDataToCose","authData","dataView","DataView","ArrayBuffer","idLenBytes","slice","Uint8Array","forEach","v","i","setUint8","credentialIdLength","getUint16","CosePublicKey","constructor","_cose","_encodedKey","toDer","getCose","_createChallengeBuffer","challenge","arguments","length","undefined","from","c","charCodeAt","_createCredential","credentialCreationOptions","creds","navigator","credentials","create","publicKey","authenticatorSelection","userVerification","attestation","pubKeyCredParams","type","alg","PubKeyCoseAlgo","ECDSA_WITH_SHA256","rp","name","user","id","displayName","response","authenticatorAttachment","getClientExtensionResults","rawId","WebAuthnIdentity","_publicKey","fromJSON","json","JSON","parse","Error","attestationObject","attObject","decodeFirst","_a","getPublicKey","getAuthenticatorAttachment","sign","blob","result","get","allowCredentials","cbor","encode","Tagged","authenticator_data","authenticatorData","client_data_json","TextDecoder","decode","clientDataJSON","signature","toJSON"],"sources":["/home/arslan/modojo/node_modules/@dfinity/identity/src/identity/webauthn.ts"],"sourcesContent":["import {\n  DerEncodedPublicKey,\n  PublicKey,\n  Signature,\n  SignIdentity,\n  wrapDER,\n  DER_COSE_OID,\n  fromHex,\n  toHex,\n} from '@dfinity/agent';\nimport borc from 'borc';\nimport { randomBytes } from '@noble/hashes/utils';\nimport { bufFromBufLike } from '@dfinity/candid';\n\nfunction _coseToDerEncodedBlob(cose: ArrayBuffer): DerEncodedPublicKey {\n  return wrapDER(cose, DER_COSE_OID).buffer as DerEncodedPublicKey;\n}\n\ntype PublicKeyCredentialWithAttachment = PublicKeyCredential & {\n  // Extends `PublicKeyCredential` with an optional field introduced in the WebAuthn level 3 spec:\n  // https://w3c.github.io/webauthn/#dom-publickeycredential-authenticatorattachment\n  // Already supported by Chrome, Safari and Edge\n  // Note: `null` is included here as a possible value because Edge set this value to null in the\n  // past.\n  authenticatorAttachment: AuthenticatorAttachment | undefined | null;\n};\n\n/**\n * From the documentation;\n * The authData is a byte array described in the spec. Parsing it will involve slicing bytes from\n * the array and converting them into usable objects.\n *\n * See https://webauthn.guide/#registration (subsection \"Example: Parsing the authenticator data\").\n * @param authData The authData field of the attestation response.\n * @returns The COSE key of the authData.\n */\nfunction _authDataToCose(authData: ArrayBuffer): ArrayBuffer {\n  const dataView = new DataView(new ArrayBuffer(2));\n  const idLenBytes = authData.slice(53, 55);\n  [...new Uint8Array(idLenBytes)].forEach((v, i) => dataView.setUint8(i, v));\n  const credentialIdLength = dataView.getUint16(0);\n\n  // Get the public key object.\n  return authData.slice(55 + credentialIdLength);\n}\n\nexport class CosePublicKey implements PublicKey {\n  protected _encodedKey: DerEncodedPublicKey;\n\n  public constructor(protected _cose: ArrayBuffer) {\n    this._encodedKey = _coseToDerEncodedBlob(_cose);\n  }\n\n  public toDer(): DerEncodedPublicKey {\n    return this._encodedKey;\n  }\n\n  public getCose(): ArrayBuffer {\n    return this._cose;\n  }\n}\n\n/**\n * Create a challenge from a string or array. The default challenge is always the same\n * because we don't need to verify the authenticity of the key on the server (we don't\n * register our keys with the IC). Any challenge would do, even one per key, randomly\n * generated.\n * @param challenge The challenge to transform into a byte array. By default a hard\n *        coded string.\n */\nfunction _createChallengeBuffer(challenge: string | Uint8Array = '<ic0.app>'): Uint8Array {\n  if (typeof challenge === 'string') {\n    return Uint8Array.from(challenge, c => c.charCodeAt(0));\n  } else {\n    return challenge;\n  }\n}\n\n/**\n * Create a credentials to authenticate with a server. This is necessary in order in\n * WebAuthn to get credentials IDs (which give us the public key and allow us to\n * sign), but in the case of the Internet Computer, we don't actually need to register\n * it, so we don't.\n * @param credentialCreationOptions an optional CredentialCreationOptions object\n */\nasync function _createCredential(\n  credentialCreationOptions?: CredentialCreationOptions,\n): Promise<PublicKeyCredentialWithAttachment | null> {\n  const creds = (await navigator.credentials.create(\n    credentialCreationOptions ?? {\n      publicKey: {\n        authenticatorSelection: {\n          userVerification: 'preferred',\n        },\n        attestation: 'direct',\n        challenge: _createChallengeBuffer(),\n        pubKeyCredParams: [{ type: 'public-key', alg: PubKeyCoseAlgo.ECDSA_WITH_SHA256 }],\n        rp: {\n          name: 'Internet Identity Service',\n        },\n        user: {\n          id: randomBytes(16),\n          name: 'Internet Identity',\n          displayName: 'Internet Identity',\n        },\n      },\n    },\n  )) as PublicKeyCredentialWithAttachment | null;\n\n  if (creds === null) {\n    return null;\n  }\n\n  return {\n    // do _not_ use ...creds here, as creds is not enumerable in all cases\n    id: creds.id,\n    response: creds.response,\n    type: creds.type,\n    authenticatorAttachment: creds.authenticatorAttachment,\n    getClientExtensionResults: creds.getClientExtensionResults,\n    // Some password managers will return a Uint8Array, so we ensure we return an ArrayBuffer.\n    rawId: bufFromBufLike(creds.rawId),\n  };\n}\n\n// See https://www.iana.org/assignments/cose/cose.xhtml#algorithms for a complete\n// list of these algorithms. We only list the ones we support here.\nenum PubKeyCoseAlgo {\n  ECDSA_WITH_SHA256 = -7,\n}\n\n/**\n * A SignIdentity that uses `navigator.credentials`. See https://webauthn.guide/ for\n * more information about WebAuthentication.\n */\nexport class WebAuthnIdentity extends SignIdentity {\n  /**\n   * Create an identity from a JSON serialization.\n   * @param json - json to parse\n   */\n  public static fromJSON(json: string): WebAuthnIdentity {\n    const { publicKey, rawId } = JSON.parse(json);\n\n    if (typeof publicKey !== 'string' || typeof rawId !== 'string') {\n      throw new Error('Invalid JSON string.');\n    }\n\n    return new this(fromHex(rawId), fromHex(publicKey), undefined);\n  }\n\n  /**\n   * Create an identity.\n   * @param credentialCreationOptions an optional CredentialCreationOptions Challenge\n   */\n  public static async create(\n    credentialCreationOptions?: CredentialCreationOptions,\n  ): Promise<WebAuthnIdentity> {\n    const creds = await _createCredential(credentialCreationOptions);\n\n    if (!creds || creds.type !== 'public-key') {\n      throw new Error('Could not create credentials.');\n    }\n\n    const response = creds.response as AuthenticatorAttestationResponse;\n    if (response.attestationObject === undefined) {\n      throw new Error('Was expecting an attestation response.');\n    }\n\n    // Parse the attestationObject as CBOR.\n    const attObject = borc.decodeFirst(new Uint8Array(response.attestationObject));\n\n    return new this(\n      creds.rawId,\n      _authDataToCose(attObject.authData),\n      creds.authenticatorAttachment ?? undefined,\n    );\n  }\n\n  protected _publicKey: CosePublicKey;\n\n  public constructor(\n    public readonly rawId: ArrayBuffer,\n    cose: ArrayBuffer,\n    protected authenticatorAttachment: AuthenticatorAttachment | undefined,\n  ) {\n    super();\n    this._publicKey = new CosePublicKey(cose);\n  }\n\n  public getPublicKey(): PublicKey {\n    return this._publicKey;\n  }\n\n  /**\n   * WebAuthn level 3 spec introduces a new attribute on successful WebAuthn interactions,\n   * see https://w3c.github.io/webauthn/#dom-publickeycredential-authenticatorattachment.\n   * This attribute is already implemented for Chrome, Safari and Edge.\n   *\n   * Given the attribute is only available after a successful interaction, the information is\n   * provided opportunistically and might also be `undefined`.\n   */\n  public getAuthenticatorAttachment(): AuthenticatorAttachment | undefined {\n    return this.authenticatorAttachment;\n  }\n\n  public async sign(blob: ArrayBuffer): Promise<Signature> {\n    const result = (await navigator.credentials.get({\n      publicKey: {\n        allowCredentials: [\n          {\n            type: 'public-key',\n            id: this.rawId,\n          },\n        ],\n        challenge: blob,\n        userVerification: 'preferred',\n      },\n    })) as PublicKeyCredentialWithAttachment;\n\n    if (result.authenticatorAttachment !== null) {\n      this.authenticatorAttachment = result.authenticatorAttachment;\n    }\n\n    const response = result.response as AuthenticatorAssertionResponse;\n\n    const cbor = borc.encode(\n      new borc.Tagged(55799, {\n        authenticator_data: new Uint8Array(response.authenticatorData),\n        client_data_json: new TextDecoder().decode(response.clientDataJSON),\n        signature: new Uint8Array(response.signature),\n      }),\n    );\n    if (!cbor) {\n      throw new Error('failed to encode cbor');\n    }\n    return cbor.buffer as Signature;\n  }\n\n  /**\n   * Allow for JSON serialization of all information needed to reuse this identity.\n   */\n  public toJSON(): JsonnableWebAuthnIdentity {\n    return {\n      publicKey: toHex(this._publicKey.getCose()),\n      rawId: toHex(this.rawId),\n    };\n  }\n}\n\n/**\n * ReturnType<WebAuthnIdentity.toJSON>\n */\nexport interface JsonnableWebAuthnIdentity {\n  // The hexadecimal representation of the DER encoded public key.\n  publicKey: string;\n  // The string representation of the local WebAuthn Credential.id (base64url encoded).\n  rawId: string;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}