{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\nimport * as strings from '../../../../base/common/strings.js';\nimport { ShiftCommand } from '../../../common/commands/shiftCommand.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { IndentAction } from '../../../common/languages/languageConfiguration.js';\nimport { ILanguageConfigurationService } from '../../../common/languages/languageConfigurationRegistry.js';\nimport * as indentUtils from '../../indentation/common/indentUtils.js';\nimport { getGoodIndentForLine, getIndentMetadata } from '../../../common/languages/autoIndent.js';\nimport { getEnterAction } from '../../../common/languages/enterAction.js';\nlet MoveLinesCommand = class MoveLinesCommand {\n  constructor(selection, isMovingDown, autoIndent, _languageConfigurationService) {\n    this._languageConfigurationService = _languageConfigurationService;\n    this._selection = selection;\n    this._isMovingDown = isMovingDown;\n    this._autoIndent = autoIndent;\n    this._selectionId = null;\n    this._moveEndLineSelectionShrink = false;\n  }\n  getEditOperations(model, builder) {\n    const getLanguageId = () => {\n      return model.getLanguageId();\n    };\n    const getLanguageIdAtPosition = (lineNumber, column) => {\n      return model.getLanguageIdAtPosition(lineNumber, column);\n    };\n    const modelLineCount = model.getLineCount();\n    if (this._isMovingDown && this._selection.endLineNumber === modelLineCount) {\n      this._selectionId = builder.trackSelection(this._selection);\n      return;\n    }\n    if (!this._isMovingDown && this._selection.startLineNumber === 1) {\n      this._selectionId = builder.trackSelection(this._selection);\n      return;\n    }\n    this._moveEndPositionDown = false;\n    let s = this._selection;\n    if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {\n      this._moveEndPositionDown = true;\n      s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));\n    }\n    const {\n      tabSize,\n      indentSize,\n      insertSpaces\n    } = model.getOptions();\n    const indentConverter = this.buildIndentConverter(tabSize, indentSize, insertSpaces);\n    if (s.startLineNumber === s.endLineNumber && model.getLineMaxColumn(s.startLineNumber) === 1) {\n      // Current line is empty\n      const lineNumber = s.startLineNumber;\n      const otherLineNumber = this._isMovingDown ? lineNumber + 1 : lineNumber - 1;\n      if (model.getLineMaxColumn(otherLineNumber) === 1) {\n        // Other line number is empty too, so no editing is needed\n        // Add a no-op to force running by the model\n        builder.addEditOperation(new Range(1, 1, 1, 1), null);\n      } else {\n        // Type content from other line number on line number\n        builder.addEditOperation(new Range(lineNumber, 1, lineNumber, 1), model.getLineContent(otherLineNumber));\n        // Remove content from other line number\n        builder.addEditOperation(new Range(otherLineNumber, 1, otherLineNumber, model.getLineMaxColumn(otherLineNumber)), null);\n      }\n      // Track selection at the other line number\n      s = new Selection(otherLineNumber, 1, otherLineNumber, 1);\n    } else {\n      let movingLineNumber;\n      let movingLineText;\n      if (this._isMovingDown) {\n        movingLineNumber = s.endLineNumber + 1;\n        movingLineText = model.getLineContent(movingLineNumber);\n        // Delete line that needs to be moved\n        builder.addEditOperation(new Range(movingLineNumber - 1, model.getLineMaxColumn(movingLineNumber - 1), movingLineNumber, model.getLineMaxColumn(movingLineNumber)), null);\n        let insertingText = movingLineText;\n        if (this.shouldAutoIndent(model, s)) {\n          const movingLineMatchResult = this.matchEnterRule(model, indentConverter, tabSize, movingLineNumber, s.startLineNumber - 1);\n          // if s.startLineNumber - 1 matches onEnter rule, we still honor that.\n          if (movingLineMatchResult !== null) {\n            const oldIndentation = strings.getLeadingWhitespace(model.getLineContent(movingLineNumber));\n            const newSpaceCnt = movingLineMatchResult + indentUtils.getSpaceCnt(oldIndentation, tabSize);\n            const newIndentation = indentUtils.generateIndent(newSpaceCnt, tabSize, insertSpaces);\n            insertingText = newIndentation + this.trimStart(movingLineText);\n          } else {\n            // no enter rule matches, let's check indentatin rules then.\n            const virtualModel = {\n              tokenization: {\n                getLineTokens: lineNumber => {\n                  if (lineNumber === s.startLineNumber) {\n                    return model.tokenization.getLineTokens(movingLineNumber);\n                  } else {\n                    return model.tokenization.getLineTokens(lineNumber);\n                  }\n                },\n                getLanguageId,\n                getLanguageIdAtPosition\n              },\n              getLineContent: lineNumber => {\n                if (lineNumber === s.startLineNumber) {\n                  return model.getLineContent(movingLineNumber);\n                } else {\n                  return model.getLineContent(lineNumber);\n                }\n              }\n            };\n            const indentOfMovingLine = getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(movingLineNumber, 1), s.startLineNumber, indentConverter, this._languageConfigurationService);\n            if (indentOfMovingLine !== null) {\n              const oldIndentation = strings.getLeadingWhitespace(model.getLineContent(movingLineNumber));\n              const newSpaceCnt = indentUtils.getSpaceCnt(indentOfMovingLine, tabSize);\n              const oldSpaceCnt = indentUtils.getSpaceCnt(oldIndentation, tabSize);\n              if (newSpaceCnt !== oldSpaceCnt) {\n                const newIndentation = indentUtils.generateIndent(newSpaceCnt, tabSize, insertSpaces);\n                insertingText = newIndentation + this.trimStart(movingLineText);\n              }\n            }\n          }\n          // add edit operations for moving line first to make sure it's executed after we make indentation change\n          // to s.startLineNumber\n          builder.addEditOperation(new Range(s.startLineNumber, 1, s.startLineNumber, 1), insertingText + '\\n');\n          const ret = this.matchEnterRuleMovingDown(model, indentConverter, tabSize, s.startLineNumber, movingLineNumber, insertingText);\n          // check if the line being moved before matches onEnter rules, if so let's adjust the indentation by onEnter rules.\n          if (ret !== null) {\n            if (ret !== 0) {\n              this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, ret);\n            }\n          } else {\n            // it doesn't match onEnter rules, let's check indentation rules then.\n            const virtualModel = {\n              tokenization: {\n                getLineTokens: lineNumber => {\n                  if (lineNumber === s.startLineNumber) {\n                    return model.tokenization.getLineTokens(movingLineNumber);\n                  } else if (lineNumber >= s.startLineNumber + 1 && lineNumber <= s.endLineNumber + 1) {\n                    return model.tokenization.getLineTokens(lineNumber - 1);\n                  } else {\n                    return model.tokenization.getLineTokens(lineNumber);\n                  }\n                },\n                getLanguageId,\n                getLanguageIdAtPosition\n              },\n              getLineContent: lineNumber => {\n                if (lineNumber === s.startLineNumber) {\n                  return insertingText;\n                } else if (lineNumber >= s.startLineNumber + 1 && lineNumber <= s.endLineNumber + 1) {\n                  return model.getLineContent(lineNumber - 1);\n                } else {\n                  return model.getLineContent(lineNumber);\n                }\n              }\n            };\n            const newIndentatOfMovingBlock = getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(movingLineNumber, 1), s.startLineNumber + 1, indentConverter, this._languageConfigurationService);\n            if (newIndentatOfMovingBlock !== null) {\n              const oldIndentation = strings.getLeadingWhitespace(model.getLineContent(s.startLineNumber));\n              const newSpaceCnt = indentUtils.getSpaceCnt(newIndentatOfMovingBlock, tabSize);\n              const oldSpaceCnt = indentUtils.getSpaceCnt(oldIndentation, tabSize);\n              if (newSpaceCnt !== oldSpaceCnt) {\n                const spaceCntOffset = newSpaceCnt - oldSpaceCnt;\n                this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, spaceCntOffset);\n              }\n            }\n          }\n        } else {\n          // Insert line that needs to be moved before\n          builder.addEditOperation(new Range(s.startLineNumber, 1, s.startLineNumber, 1), insertingText + '\\n');\n        }\n      } else {\n        movingLineNumber = s.startLineNumber - 1;\n        movingLineText = model.getLineContent(movingLineNumber);\n        // Delete line that needs to be moved\n        builder.addEditOperation(new Range(movingLineNumber, 1, movingLineNumber + 1, 1), null);\n        // Insert line that needs to be moved after\n        builder.addEditOperation(new Range(s.endLineNumber, model.getLineMaxColumn(s.endLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), '\\n' + movingLineText);\n        if (this.shouldAutoIndent(model, s)) {\n          const virtualModel = {\n            tokenization: {\n              getLineTokens: lineNumber => {\n                if (lineNumber === movingLineNumber) {\n                  return model.tokenization.getLineTokens(s.startLineNumber);\n                } else {\n                  return model.tokenization.getLineTokens(lineNumber);\n                }\n              },\n              getLanguageId,\n              getLanguageIdAtPosition\n            },\n            getLineContent: lineNumber => {\n              if (lineNumber === movingLineNumber) {\n                return model.getLineContent(s.startLineNumber);\n              } else {\n                return model.getLineContent(lineNumber);\n              }\n            }\n          };\n          const ret = this.matchEnterRule(model, indentConverter, tabSize, s.startLineNumber, s.startLineNumber - 2);\n          // check if s.startLineNumber - 2 matches onEnter rules, if so adjust the moving block by onEnter rules.\n          if (ret !== null) {\n            if (ret !== 0) {\n              this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, ret);\n            }\n          } else {\n            // it doesn't match any onEnter rule, let's check indentation rules then.\n            const indentOfFirstLine = getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(s.startLineNumber, 1), movingLineNumber, indentConverter, this._languageConfigurationService);\n            if (indentOfFirstLine !== null) {\n              // adjust the indentation of the moving block\n              const oldIndent = strings.getLeadingWhitespace(model.getLineContent(s.startLineNumber));\n              const newSpaceCnt = indentUtils.getSpaceCnt(indentOfFirstLine, tabSize);\n              const oldSpaceCnt = indentUtils.getSpaceCnt(oldIndent, tabSize);\n              if (newSpaceCnt !== oldSpaceCnt) {\n                const spaceCntOffset = newSpaceCnt - oldSpaceCnt;\n                this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, spaceCntOffset);\n              }\n            }\n          }\n        }\n      }\n    }\n    this._selectionId = builder.trackSelection(s);\n  }\n  buildIndentConverter(tabSize, indentSize, insertSpaces) {\n    return {\n      shiftIndent: indentation => {\n        return ShiftCommand.shiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);\n      },\n      unshiftIndent: indentation => {\n        return ShiftCommand.unshiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);\n      }\n    };\n  }\n  parseEnterResult(model, indentConverter, tabSize, line, enter) {\n    if (enter) {\n      let enterPrefix = enter.indentation;\n      if (enter.indentAction === IndentAction.None) {\n        enterPrefix = enter.indentation + enter.appendText;\n      } else if (enter.indentAction === IndentAction.Indent) {\n        enterPrefix = enter.indentation + enter.appendText;\n      } else if (enter.indentAction === IndentAction.IndentOutdent) {\n        enterPrefix = enter.indentation;\n      } else if (enter.indentAction === IndentAction.Outdent) {\n        enterPrefix = indentConverter.unshiftIndent(enter.indentation) + enter.appendText;\n      }\n      const movingLineText = model.getLineContent(line);\n      if (this.trimStart(movingLineText).indexOf(this.trimStart(enterPrefix)) >= 0) {\n        const oldIndentation = strings.getLeadingWhitespace(model.getLineContent(line));\n        let newIndentation = strings.getLeadingWhitespace(enterPrefix);\n        const indentMetadataOfMovelingLine = getIndentMetadata(model, line, this._languageConfigurationService);\n        if (indentMetadataOfMovelingLine !== null && indentMetadataOfMovelingLine & 2 /* IndentConsts.DECREASE_MASK */) {\n          newIndentation = indentConverter.unshiftIndent(newIndentation);\n        }\n        const newSpaceCnt = indentUtils.getSpaceCnt(newIndentation, tabSize);\n        const oldSpaceCnt = indentUtils.getSpaceCnt(oldIndentation, tabSize);\n        return newSpaceCnt - oldSpaceCnt;\n      }\n    }\n    return null;\n  }\n  /**\n   *\n   * @param model\n   * @param indentConverter\n   * @param tabSize\n   * @param line the line moving down\n   * @param futureAboveLineNumber the line which will be at the `line` position\n   * @param futureAboveLineText\n   */\n  matchEnterRuleMovingDown(model, indentConverter, tabSize, line, futureAboveLineNumber, futureAboveLineText) {\n    if (strings.lastNonWhitespaceIndex(futureAboveLineText) >= 0) {\n      // break\n      const maxColumn = model.getLineMaxColumn(futureAboveLineNumber);\n      const enter = getEnterAction(this._autoIndent, model, new Range(futureAboveLineNumber, maxColumn, futureAboveLineNumber, maxColumn), this._languageConfigurationService);\n      return this.parseEnterResult(model, indentConverter, tabSize, line, enter);\n    } else {\n      // go upwards, starting from `line - 1`\n      let validPrecedingLine = line - 1;\n      while (validPrecedingLine >= 1) {\n        const lineContent = model.getLineContent(validPrecedingLine);\n        const nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineContent);\n        if (nonWhitespaceIdx >= 0) {\n          break;\n        }\n        validPrecedingLine--;\n      }\n      if (validPrecedingLine < 1 || line > model.getLineCount()) {\n        return null;\n      }\n      const maxColumn = model.getLineMaxColumn(validPrecedingLine);\n      const enter = getEnterAction(this._autoIndent, model, new Range(validPrecedingLine, maxColumn, validPrecedingLine, maxColumn), this._languageConfigurationService);\n      return this.parseEnterResult(model, indentConverter, tabSize, line, enter);\n    }\n  }\n  matchEnterRule(model, indentConverter, tabSize, line, oneLineAbove, previousLineText) {\n    let validPrecedingLine = oneLineAbove;\n    while (validPrecedingLine >= 1) {\n      // ship empty lines as empty lines just inherit indentation\n      let lineContent;\n      if (validPrecedingLine === oneLineAbove && previousLineText !== undefined) {\n        lineContent = previousLineText;\n      } else {\n        lineContent = model.getLineContent(validPrecedingLine);\n      }\n      const nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineContent);\n      if (nonWhitespaceIdx >= 0) {\n        break;\n      }\n      validPrecedingLine--;\n    }\n    if (validPrecedingLine < 1 || line > model.getLineCount()) {\n      return null;\n    }\n    const maxColumn = model.getLineMaxColumn(validPrecedingLine);\n    const enter = getEnterAction(this._autoIndent, model, new Range(validPrecedingLine, maxColumn, validPrecedingLine, maxColumn), this._languageConfigurationService);\n    return this.parseEnterResult(model, indentConverter, tabSize, line, enter);\n  }\n  trimStart(str) {\n    return str.replace(/^\\s+/, '');\n  }\n  shouldAutoIndent(model, selection) {\n    if (this._autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n      return false;\n    }\n    // if it's not easy to tokenize, we stop auto indent.\n    if (!model.tokenization.isCheapToTokenize(selection.startLineNumber)) {\n      return false;\n    }\n    const languageAtSelectionStart = model.getLanguageIdAtPosition(selection.startLineNumber, 1);\n    const languageAtSelectionEnd = model.getLanguageIdAtPosition(selection.endLineNumber, 1);\n    if (languageAtSelectionStart !== languageAtSelectionEnd) {\n      return false;\n    }\n    if (this._languageConfigurationService.getLanguageConfiguration(languageAtSelectionStart).indentRulesSupport === null) {\n      return false;\n    }\n    return true;\n  }\n  getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, offset) {\n    for (let i = s.startLineNumber; i <= s.endLineNumber; i++) {\n      const lineContent = model.getLineContent(i);\n      const originalIndent = strings.getLeadingWhitespace(lineContent);\n      const originalSpacesCnt = indentUtils.getSpaceCnt(originalIndent, tabSize);\n      const newSpacesCnt = originalSpacesCnt + offset;\n      const newIndent = indentUtils.generateIndent(newSpacesCnt, tabSize, insertSpaces);\n      if (newIndent !== originalIndent) {\n        builder.addEditOperation(new Range(i, 1, i, originalIndent.length + 1), newIndent);\n        if (i === s.endLineNumber && s.endColumn <= originalIndent.length + 1 && newIndent === '') {\n          // as users select part of the original indent white spaces\n          // when we adjust the indentation of endLine, we should adjust the cursor position as well.\n          this._moveEndLineSelectionShrink = true;\n        }\n      }\n    }\n  }\n  computeCursorState(model, helper) {\n    let result = helper.getTrackedSelection(this._selectionId);\n    if (this._moveEndPositionDown) {\n      result = result.setEndPosition(result.endLineNumber + 1, 1);\n    }\n    if (this._moveEndLineSelectionShrink && result.startLineNumber < result.endLineNumber) {\n      result = result.setEndPosition(result.endLineNumber, 2);\n    }\n    return result;\n  }\n};\nMoveLinesCommand = __decorate([__param(3, ILanguageConfigurationService)], MoveLinesCommand);\nexport { MoveLinesCommand };","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","strings","ShiftCommand","Range","Selection","IndentAction","ILanguageConfigurationService","indentUtils","getGoodIndentForLine","getIndentMetadata","getEnterAction","MoveLinesCommand","constructor","selection","isMovingDown","autoIndent","_languageConfigurationService","_selection","_isMovingDown","_autoIndent","_selectionId","_moveEndLineSelectionShrink","getEditOperations","model","builder","getLanguageId","getLanguageIdAtPosition","lineNumber","column","modelLineCount","getLineCount","endLineNumber","trackSelection","startLineNumber","_moveEndPositionDown","s","endColumn","setEndPosition","getLineMaxColumn","tabSize","indentSize","insertSpaces","getOptions","indentConverter","buildIndentConverter","otherLineNumber","addEditOperation","getLineContent","movingLineNumber","movingLineText","insertingText","shouldAutoIndent","movingLineMatchResult","matchEnterRule","oldIndentation","getLeadingWhitespace","newSpaceCnt","getSpaceCnt","newIndentation","generateIndent","trimStart","virtualModel","tokenization","getLineTokens","indentOfMovingLine","oldSpaceCnt","ret","matchEnterRuleMovingDown","getIndentEditsOfMovingBlock","newIndentatOfMovingBlock","spaceCntOffset","indentOfFirstLine","oldIndent","shiftIndent","indentation","unshiftIndent","parseEnterResult","line","enter","enterPrefix","indentAction","None","appendText","Indent","IndentOutdent","Outdent","indexOf","indentMetadataOfMovelingLine","futureAboveLineNumber","futureAboveLineText","lastNonWhitespaceIndex","maxColumn","validPrecedingLine","lineContent","nonWhitespaceIdx","oneLineAbove","previousLineText","undefined","str","replace","isCheapToTokenize","languageAtSelectionStart","languageAtSelectionEnd","getLanguageConfiguration","indentRulesSupport","offset","originalIndent","originalSpacesCnt","newSpacesCnt","newIndent","computeCursorState","helper","result","getTrackedSelection"],"sources":["/home/arslan/modojo/node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/browser/moveLinesCommand.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport * as strings from '../../../../base/common/strings.js';\nimport { ShiftCommand } from '../../../common/commands/shiftCommand.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { IndentAction } from '../../../common/languages/languageConfiguration.js';\nimport { ILanguageConfigurationService } from '../../../common/languages/languageConfigurationRegistry.js';\nimport * as indentUtils from '../../indentation/common/indentUtils.js';\nimport { getGoodIndentForLine, getIndentMetadata } from '../../../common/languages/autoIndent.js';\nimport { getEnterAction } from '../../../common/languages/enterAction.js';\nlet MoveLinesCommand = class MoveLinesCommand {\n    constructor(selection, isMovingDown, autoIndent, _languageConfigurationService) {\n        this._languageConfigurationService = _languageConfigurationService;\n        this._selection = selection;\n        this._isMovingDown = isMovingDown;\n        this._autoIndent = autoIndent;\n        this._selectionId = null;\n        this._moveEndLineSelectionShrink = false;\n    }\n    getEditOperations(model, builder) {\n        const getLanguageId = () => {\n            return model.getLanguageId();\n        };\n        const getLanguageIdAtPosition = (lineNumber, column) => {\n            return model.getLanguageIdAtPosition(lineNumber, column);\n        };\n        const modelLineCount = model.getLineCount();\n        if (this._isMovingDown && this._selection.endLineNumber === modelLineCount) {\n            this._selectionId = builder.trackSelection(this._selection);\n            return;\n        }\n        if (!this._isMovingDown && this._selection.startLineNumber === 1) {\n            this._selectionId = builder.trackSelection(this._selection);\n            return;\n        }\n        this._moveEndPositionDown = false;\n        let s = this._selection;\n        if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {\n            this._moveEndPositionDown = true;\n            s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));\n        }\n        const { tabSize, indentSize, insertSpaces } = model.getOptions();\n        const indentConverter = this.buildIndentConverter(tabSize, indentSize, insertSpaces);\n        if (s.startLineNumber === s.endLineNumber && model.getLineMaxColumn(s.startLineNumber) === 1) {\n            // Current line is empty\n            const lineNumber = s.startLineNumber;\n            const otherLineNumber = (this._isMovingDown ? lineNumber + 1 : lineNumber - 1);\n            if (model.getLineMaxColumn(otherLineNumber) === 1) {\n                // Other line number is empty too, so no editing is needed\n                // Add a no-op to force running by the model\n                builder.addEditOperation(new Range(1, 1, 1, 1), null);\n            }\n            else {\n                // Type content from other line number on line number\n                builder.addEditOperation(new Range(lineNumber, 1, lineNumber, 1), model.getLineContent(otherLineNumber));\n                // Remove content from other line number\n                builder.addEditOperation(new Range(otherLineNumber, 1, otherLineNumber, model.getLineMaxColumn(otherLineNumber)), null);\n            }\n            // Track selection at the other line number\n            s = new Selection(otherLineNumber, 1, otherLineNumber, 1);\n        }\n        else {\n            let movingLineNumber;\n            let movingLineText;\n            if (this._isMovingDown) {\n                movingLineNumber = s.endLineNumber + 1;\n                movingLineText = model.getLineContent(movingLineNumber);\n                // Delete line that needs to be moved\n                builder.addEditOperation(new Range(movingLineNumber - 1, model.getLineMaxColumn(movingLineNumber - 1), movingLineNumber, model.getLineMaxColumn(movingLineNumber)), null);\n                let insertingText = movingLineText;\n                if (this.shouldAutoIndent(model, s)) {\n                    const movingLineMatchResult = this.matchEnterRule(model, indentConverter, tabSize, movingLineNumber, s.startLineNumber - 1);\n                    // if s.startLineNumber - 1 matches onEnter rule, we still honor that.\n                    if (movingLineMatchResult !== null) {\n                        const oldIndentation = strings.getLeadingWhitespace(model.getLineContent(movingLineNumber));\n                        const newSpaceCnt = movingLineMatchResult + indentUtils.getSpaceCnt(oldIndentation, tabSize);\n                        const newIndentation = indentUtils.generateIndent(newSpaceCnt, tabSize, insertSpaces);\n                        insertingText = newIndentation + this.trimStart(movingLineText);\n                    }\n                    else {\n                        // no enter rule matches, let's check indentatin rules then.\n                        const virtualModel = {\n                            tokenization: {\n                                getLineTokens: (lineNumber) => {\n                                    if (lineNumber === s.startLineNumber) {\n                                        return model.tokenization.getLineTokens(movingLineNumber);\n                                    }\n                                    else {\n                                        return model.tokenization.getLineTokens(lineNumber);\n                                    }\n                                },\n                                getLanguageId,\n                                getLanguageIdAtPosition,\n                            },\n                            getLineContent: (lineNumber) => {\n                                if (lineNumber === s.startLineNumber) {\n                                    return model.getLineContent(movingLineNumber);\n                                }\n                                else {\n                                    return model.getLineContent(lineNumber);\n                                }\n                            },\n                        };\n                        const indentOfMovingLine = getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(movingLineNumber, 1), s.startLineNumber, indentConverter, this._languageConfigurationService);\n                        if (indentOfMovingLine !== null) {\n                            const oldIndentation = strings.getLeadingWhitespace(model.getLineContent(movingLineNumber));\n                            const newSpaceCnt = indentUtils.getSpaceCnt(indentOfMovingLine, tabSize);\n                            const oldSpaceCnt = indentUtils.getSpaceCnt(oldIndentation, tabSize);\n                            if (newSpaceCnt !== oldSpaceCnt) {\n                                const newIndentation = indentUtils.generateIndent(newSpaceCnt, tabSize, insertSpaces);\n                                insertingText = newIndentation + this.trimStart(movingLineText);\n                            }\n                        }\n                    }\n                    // add edit operations for moving line first to make sure it's executed after we make indentation change\n                    // to s.startLineNumber\n                    builder.addEditOperation(new Range(s.startLineNumber, 1, s.startLineNumber, 1), insertingText + '\\n');\n                    const ret = this.matchEnterRuleMovingDown(model, indentConverter, tabSize, s.startLineNumber, movingLineNumber, insertingText);\n                    // check if the line being moved before matches onEnter rules, if so let's adjust the indentation by onEnter rules.\n                    if (ret !== null) {\n                        if (ret !== 0) {\n                            this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, ret);\n                        }\n                    }\n                    else {\n                        // it doesn't match onEnter rules, let's check indentation rules then.\n                        const virtualModel = {\n                            tokenization: {\n                                getLineTokens: (lineNumber) => {\n                                    if (lineNumber === s.startLineNumber) {\n                                        return model.tokenization.getLineTokens(movingLineNumber);\n                                    }\n                                    else if (lineNumber >= s.startLineNumber + 1 && lineNumber <= s.endLineNumber + 1) {\n                                        return model.tokenization.getLineTokens(lineNumber - 1);\n                                    }\n                                    else {\n                                        return model.tokenization.getLineTokens(lineNumber);\n                                    }\n                                },\n                                getLanguageId,\n                                getLanguageIdAtPosition,\n                            },\n                            getLineContent: (lineNumber) => {\n                                if (lineNumber === s.startLineNumber) {\n                                    return insertingText;\n                                }\n                                else if (lineNumber >= s.startLineNumber + 1 && lineNumber <= s.endLineNumber + 1) {\n                                    return model.getLineContent(lineNumber - 1);\n                                }\n                                else {\n                                    return model.getLineContent(lineNumber);\n                                }\n                            },\n                        };\n                        const newIndentatOfMovingBlock = getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(movingLineNumber, 1), s.startLineNumber + 1, indentConverter, this._languageConfigurationService);\n                        if (newIndentatOfMovingBlock !== null) {\n                            const oldIndentation = strings.getLeadingWhitespace(model.getLineContent(s.startLineNumber));\n                            const newSpaceCnt = indentUtils.getSpaceCnt(newIndentatOfMovingBlock, tabSize);\n                            const oldSpaceCnt = indentUtils.getSpaceCnt(oldIndentation, tabSize);\n                            if (newSpaceCnt !== oldSpaceCnt) {\n                                const spaceCntOffset = newSpaceCnt - oldSpaceCnt;\n                                this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, spaceCntOffset);\n                            }\n                        }\n                    }\n                }\n                else {\n                    // Insert line that needs to be moved before\n                    builder.addEditOperation(new Range(s.startLineNumber, 1, s.startLineNumber, 1), insertingText + '\\n');\n                }\n            }\n            else {\n                movingLineNumber = s.startLineNumber - 1;\n                movingLineText = model.getLineContent(movingLineNumber);\n                // Delete line that needs to be moved\n                builder.addEditOperation(new Range(movingLineNumber, 1, movingLineNumber + 1, 1), null);\n                // Insert line that needs to be moved after\n                builder.addEditOperation(new Range(s.endLineNumber, model.getLineMaxColumn(s.endLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), '\\n' + movingLineText);\n                if (this.shouldAutoIndent(model, s)) {\n                    const virtualModel = {\n                        tokenization: {\n                            getLineTokens: (lineNumber) => {\n                                if (lineNumber === movingLineNumber) {\n                                    return model.tokenization.getLineTokens(s.startLineNumber);\n                                }\n                                else {\n                                    return model.tokenization.getLineTokens(lineNumber);\n                                }\n                            },\n                            getLanguageId,\n                            getLanguageIdAtPosition,\n                        },\n                        getLineContent: (lineNumber) => {\n                            if (lineNumber === movingLineNumber) {\n                                return model.getLineContent(s.startLineNumber);\n                            }\n                            else {\n                                return model.getLineContent(lineNumber);\n                            }\n                        },\n                    };\n                    const ret = this.matchEnterRule(model, indentConverter, tabSize, s.startLineNumber, s.startLineNumber - 2);\n                    // check if s.startLineNumber - 2 matches onEnter rules, if so adjust the moving block by onEnter rules.\n                    if (ret !== null) {\n                        if (ret !== 0) {\n                            this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, ret);\n                        }\n                    }\n                    else {\n                        // it doesn't match any onEnter rule, let's check indentation rules then.\n                        const indentOfFirstLine = getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(s.startLineNumber, 1), movingLineNumber, indentConverter, this._languageConfigurationService);\n                        if (indentOfFirstLine !== null) {\n                            // adjust the indentation of the moving block\n                            const oldIndent = strings.getLeadingWhitespace(model.getLineContent(s.startLineNumber));\n                            const newSpaceCnt = indentUtils.getSpaceCnt(indentOfFirstLine, tabSize);\n                            const oldSpaceCnt = indentUtils.getSpaceCnt(oldIndent, tabSize);\n                            if (newSpaceCnt !== oldSpaceCnt) {\n                                const spaceCntOffset = newSpaceCnt - oldSpaceCnt;\n                                this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, spaceCntOffset);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        this._selectionId = builder.trackSelection(s);\n    }\n    buildIndentConverter(tabSize, indentSize, insertSpaces) {\n        return {\n            shiftIndent: (indentation) => {\n                return ShiftCommand.shiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);\n            },\n            unshiftIndent: (indentation) => {\n                return ShiftCommand.unshiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);\n            }\n        };\n    }\n    parseEnterResult(model, indentConverter, tabSize, line, enter) {\n        if (enter) {\n            let enterPrefix = enter.indentation;\n            if (enter.indentAction === IndentAction.None) {\n                enterPrefix = enter.indentation + enter.appendText;\n            }\n            else if (enter.indentAction === IndentAction.Indent) {\n                enterPrefix = enter.indentation + enter.appendText;\n            }\n            else if (enter.indentAction === IndentAction.IndentOutdent) {\n                enterPrefix = enter.indentation;\n            }\n            else if (enter.indentAction === IndentAction.Outdent) {\n                enterPrefix = indentConverter.unshiftIndent(enter.indentation) + enter.appendText;\n            }\n            const movingLineText = model.getLineContent(line);\n            if (this.trimStart(movingLineText).indexOf(this.trimStart(enterPrefix)) >= 0) {\n                const oldIndentation = strings.getLeadingWhitespace(model.getLineContent(line));\n                let newIndentation = strings.getLeadingWhitespace(enterPrefix);\n                const indentMetadataOfMovelingLine = getIndentMetadata(model, line, this._languageConfigurationService);\n                if (indentMetadataOfMovelingLine !== null && indentMetadataOfMovelingLine & 2 /* IndentConsts.DECREASE_MASK */) {\n                    newIndentation = indentConverter.unshiftIndent(newIndentation);\n                }\n                const newSpaceCnt = indentUtils.getSpaceCnt(newIndentation, tabSize);\n                const oldSpaceCnt = indentUtils.getSpaceCnt(oldIndentation, tabSize);\n                return newSpaceCnt - oldSpaceCnt;\n            }\n        }\n        return null;\n    }\n    /**\n     *\n     * @param model\n     * @param indentConverter\n     * @param tabSize\n     * @param line the line moving down\n     * @param futureAboveLineNumber the line which will be at the `line` position\n     * @param futureAboveLineText\n     */\n    matchEnterRuleMovingDown(model, indentConverter, tabSize, line, futureAboveLineNumber, futureAboveLineText) {\n        if (strings.lastNonWhitespaceIndex(futureAboveLineText) >= 0) {\n            // break\n            const maxColumn = model.getLineMaxColumn(futureAboveLineNumber);\n            const enter = getEnterAction(this._autoIndent, model, new Range(futureAboveLineNumber, maxColumn, futureAboveLineNumber, maxColumn), this._languageConfigurationService);\n            return this.parseEnterResult(model, indentConverter, tabSize, line, enter);\n        }\n        else {\n            // go upwards, starting from `line - 1`\n            let validPrecedingLine = line - 1;\n            while (validPrecedingLine >= 1) {\n                const lineContent = model.getLineContent(validPrecedingLine);\n                const nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineContent);\n                if (nonWhitespaceIdx >= 0) {\n                    break;\n                }\n                validPrecedingLine--;\n            }\n            if (validPrecedingLine < 1 || line > model.getLineCount()) {\n                return null;\n            }\n            const maxColumn = model.getLineMaxColumn(validPrecedingLine);\n            const enter = getEnterAction(this._autoIndent, model, new Range(validPrecedingLine, maxColumn, validPrecedingLine, maxColumn), this._languageConfigurationService);\n            return this.parseEnterResult(model, indentConverter, tabSize, line, enter);\n        }\n    }\n    matchEnterRule(model, indentConverter, tabSize, line, oneLineAbove, previousLineText) {\n        let validPrecedingLine = oneLineAbove;\n        while (validPrecedingLine >= 1) {\n            // ship empty lines as empty lines just inherit indentation\n            let lineContent;\n            if (validPrecedingLine === oneLineAbove && previousLineText !== undefined) {\n                lineContent = previousLineText;\n            }\n            else {\n                lineContent = model.getLineContent(validPrecedingLine);\n            }\n            const nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineContent);\n            if (nonWhitespaceIdx >= 0) {\n                break;\n            }\n            validPrecedingLine--;\n        }\n        if (validPrecedingLine < 1 || line > model.getLineCount()) {\n            return null;\n        }\n        const maxColumn = model.getLineMaxColumn(validPrecedingLine);\n        const enter = getEnterAction(this._autoIndent, model, new Range(validPrecedingLine, maxColumn, validPrecedingLine, maxColumn), this._languageConfigurationService);\n        return this.parseEnterResult(model, indentConverter, tabSize, line, enter);\n    }\n    trimStart(str) {\n        return str.replace(/^\\s+/, '');\n    }\n    shouldAutoIndent(model, selection) {\n        if (this._autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n            return false;\n        }\n        // if it's not easy to tokenize, we stop auto indent.\n        if (!model.tokenization.isCheapToTokenize(selection.startLineNumber)) {\n            return false;\n        }\n        const languageAtSelectionStart = model.getLanguageIdAtPosition(selection.startLineNumber, 1);\n        const languageAtSelectionEnd = model.getLanguageIdAtPosition(selection.endLineNumber, 1);\n        if (languageAtSelectionStart !== languageAtSelectionEnd) {\n            return false;\n        }\n        if (this._languageConfigurationService.getLanguageConfiguration(languageAtSelectionStart).indentRulesSupport === null) {\n            return false;\n        }\n        return true;\n    }\n    getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, offset) {\n        for (let i = s.startLineNumber; i <= s.endLineNumber; i++) {\n            const lineContent = model.getLineContent(i);\n            const originalIndent = strings.getLeadingWhitespace(lineContent);\n            const originalSpacesCnt = indentUtils.getSpaceCnt(originalIndent, tabSize);\n            const newSpacesCnt = originalSpacesCnt + offset;\n            const newIndent = indentUtils.generateIndent(newSpacesCnt, tabSize, insertSpaces);\n            if (newIndent !== originalIndent) {\n                builder.addEditOperation(new Range(i, 1, i, originalIndent.length + 1), newIndent);\n                if (i === s.endLineNumber && s.endColumn <= originalIndent.length + 1 && newIndent === '') {\n                    // as users select part of the original indent white spaces\n                    // when we adjust the indentation of endLine, we should adjust the cursor position as well.\n                    this._moveEndLineSelectionShrink = true;\n                }\n            }\n        }\n    }\n    computeCursorState(model, helper) {\n        let result = helper.getTrackedSelection(this._selectionId);\n        if (this._moveEndPositionDown) {\n            result = result.setEndPosition(result.endLineNumber + 1, 1);\n        }\n        if (this._moveEndLineSelectionShrink && result.startLineNumber < result.endLineNumber) {\n            result = result.setEndPosition(result.endLineNumber, 2);\n        }\n        return result;\n    }\n};\nMoveLinesCommand = __decorate([\n    __param(3, ILanguageConfigurationService)\n], MoveLinesCommand);\nexport { MoveLinesCommand };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}