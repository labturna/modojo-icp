{"ast":null,"code":"import { lebEncode } from '@dfinity/candid';\nimport * as cbor from 'simple-cbor';\nimport { makeNonce } from './types';\nconst NANOSECONDS_PER_MILLISECONDS = BigInt(1000000);\nconst REPLICA_PERMITTED_DRIFT_MILLISECONDS = 60 * 1000;\nexport class Expiry {\n  constructor(deltaInMSec) {\n    // Use bigint because it can overflow the maximum number allowed in a double float.\n    const raw_value = BigInt(Math.floor(Date.now() + deltaInMSec - REPLICA_PERMITTED_DRIFT_MILLISECONDS)) * NANOSECONDS_PER_MILLISECONDS;\n    // round down to the nearest second\n    const ingress_as_seconds = raw_value / BigInt(1000000000);\n    // round down to nearest minute\n    const ingress_as_minutes = ingress_as_seconds / BigInt(60);\n    const rounded_down_nanos = ingress_as_minutes * BigInt(60) * BigInt(1000000000);\n    this._value = rounded_down_nanos;\n  }\n  toCBOR() {\n    // TODO: change this to take the minimum amount of space (it always takes 8 bytes now).\n    return cbor.value.u64(this._value.toString(16), 16);\n  }\n  toHash() {\n    return lebEncode(this._value);\n  }\n}\n/**\n * Create a Nonce transform, which takes a function that returns a Buffer, and adds it\n * as the nonce to every call requests.\n * @param nonceFn A function that returns a buffer. By default uses a semi-random method.\n */\nexport function makeNonceTransform() {\n  let nonceFn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : makeNonce;\n  return async request => {\n    // Nonce needs to be inserted into the header for all requests, to enable logs to be correlated with requests.\n    const headers = request.request.headers;\n    // TODO: uncomment this when the http proxy supports it.\n    // headers.set('X-IC-Request-ID', toHex(new Uint8Array(nonce)));\n    request.request.headers = headers;\n    // Nonce only needs to be inserted into the body for async calls, to prevent replay attacks.\n    if (request.endpoint === \"call\" /* Endpoint.Call */) {\n      request.body.nonce = nonceFn();\n    }\n  };\n}\n/**\n * Create a transform that adds a delay (by default 5 minutes) to the expiry.\n *\n * @param delayInMilliseconds The delay to add to the call time, in milliseconds.\n */\nexport function makeExpiryTransform(delayInMilliseconds) {\n  return async request => {\n    request.body.ingress_expiry = new Expiry(delayInMilliseconds);\n  };\n}\n/**\n * Maps the default fetch headers field to the serializable HttpHeaderField.\n *\n * @param headers Fetch definition of the headers type\n * @returns array of header fields\n */\nexport function httpHeadersTransform(headers) {\n  const headerFields = [];\n  headers.forEach((value, key) => {\n    headerFields.push([key, value]);\n  });\n  return headerFields;\n}","map":{"version":3,"names":["lebEncode","cbor","makeNonce","NANOSECONDS_PER_MILLISECONDS","BigInt","REPLICA_PERMITTED_DRIFT_MILLISECONDS","Expiry","constructor","deltaInMSec","raw_value","Math","floor","Date","now","ingress_as_seconds","ingress_as_minutes","rounded_down_nanos","_value","toCBOR","value","u64","toString","toHash","makeNonceTransform","nonceFn","arguments","length","undefined","request","headers","endpoint","body","nonce","makeExpiryTransform","delayInMilliseconds","ingress_expiry","httpHeadersTransform","headerFields","forEach","key","push"],"sources":["/home/arslan/modojo/node_modules/@dfinity/agent/src/agent/http/transforms.ts"],"sourcesContent":["import { lebEncode } from '@dfinity/candid';\nimport * as cbor from 'simple-cbor';\nimport {\n  Endpoint,\n  HttpAgentRequest,\n  HttpAgentRequestTransformFn,\n  HttpHeaderField,\n  makeNonce,\n  Nonce,\n} from './types';\n\nconst NANOSECONDS_PER_MILLISECONDS = BigInt(1_000_000);\n\nconst REPLICA_PERMITTED_DRIFT_MILLISECONDS = 60 * 1000;\n\nexport class Expiry {\n  private readonly _value: bigint;\n\n  constructor(deltaInMSec: number) {\n    // Use bigint because it can overflow the maximum number allowed in a double float.\n    const raw_value =\n      BigInt(Math.floor(Date.now() + deltaInMSec - REPLICA_PERMITTED_DRIFT_MILLISECONDS)) *\n      NANOSECONDS_PER_MILLISECONDS;\n\n    // round down to the nearest second\n    const ingress_as_seconds = raw_value / BigInt(1_000_000_000);\n\n    // round down to nearest minute\n    const ingress_as_minutes = ingress_as_seconds / BigInt(60);\n\n    const rounded_down_nanos = ingress_as_minutes * BigInt(60) * BigInt(1_000_000_000);\n\n    this._value = rounded_down_nanos;\n  }\n\n  public toCBOR(): cbor.CborValue {\n    // TODO: change this to take the minimum amount of space (it always takes 8 bytes now).\n    return cbor.value.u64(this._value.toString(16), 16);\n  }\n\n  public toHash(): ArrayBuffer {\n    return lebEncode(this._value);\n  }\n}\n\n/**\n * Create a Nonce transform, which takes a function that returns a Buffer, and adds it\n * as the nonce to every call requests.\n * @param nonceFn A function that returns a buffer. By default uses a semi-random method.\n */\nexport function makeNonceTransform(nonceFn: () => Nonce = makeNonce): HttpAgentRequestTransformFn {\n  return async (request: HttpAgentRequest) => {\n    // Nonce needs to be inserted into the header for all requests, to enable logs to be correlated with requests.\n    const headers = request.request.headers;\n    // TODO: uncomment this when the http proxy supports it.\n    // headers.set('X-IC-Request-ID', toHex(new Uint8Array(nonce)));\n    request.request.headers = headers;\n\n    // Nonce only needs to be inserted into the body for async calls, to prevent replay attacks.\n    if (request.endpoint === Endpoint.Call) {\n      request.body.nonce = nonceFn();\n    }\n  };\n}\n\n/**\n * Create a transform that adds a delay (by default 5 minutes) to the expiry.\n *\n * @param delayInMilliseconds The delay to add to the call time, in milliseconds.\n */\nexport function makeExpiryTransform(delayInMilliseconds: number): HttpAgentRequestTransformFn {\n  return async (request: HttpAgentRequest) => {\n    request.body.ingress_expiry = new Expiry(delayInMilliseconds);\n  };\n}\n\n/**\n * Maps the default fetch headers field to the serializable HttpHeaderField.\n *\n * @param headers Fetch definition of the headers type\n * @returns array of header fields\n */\nexport function httpHeadersTransform(headers: Headers): HttpHeaderField[] {\n  const headerFields: HttpHeaderField[] = [];\n  headers.forEach((value, key) => {\n    headerFields.push([key, value]);\n  });\n  return headerFields;\n}\n"],"mappings":"AAAA,SAASA,SAAS,QAAQ,iBAAiB;AAC3C,OAAO,KAAKC,IAAI,MAAM,aAAa;AACnC,SAKEC,SAAS,QAEJ,SAAS;AAEhB,MAAMC,4BAA4B,GAAGC,MAAM,CAAC,OAAS,CAAC;AAEtD,MAAMC,oCAAoC,GAAG,EAAE,GAAG,IAAI;AAEtD,OAAM,MAAOC,MAAM;EAGjBC,YAAYC,WAAmB;IAC7B;IACA,MAAMC,SAAS,GACbL,MAAM,CAACM,IAAI,CAACC,KAAK,CAACC,IAAI,CAACC,GAAG,EAAE,GAAGL,WAAW,GAAGH,oCAAoC,CAAC,CAAC,GACnFF,4BAA4B;IAE9B;IACA,MAAMW,kBAAkB,GAAGL,SAAS,GAAGL,MAAM,CAAC,UAAa,CAAC;IAE5D;IACA,MAAMW,kBAAkB,GAAGD,kBAAkB,GAAGV,MAAM,CAAC,EAAE,CAAC;IAE1D,MAAMY,kBAAkB,GAAGD,kBAAkB,GAAGX,MAAM,CAAC,EAAE,CAAC,GAAGA,MAAM,CAAC,UAAa,CAAC;IAElF,IAAI,CAACa,MAAM,GAAGD,kBAAkB;EAClC;EAEOE,MAAMA,CAAA;IACX;IACA,OAAOjB,IAAI,CAACkB,KAAK,CAACC,GAAG,CAAC,IAAI,CAACH,MAAM,CAACI,QAAQ,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;EACrD;EAEOC,MAAMA,CAAA;IACX,OAAOtB,SAAS,CAAC,IAAI,CAACiB,MAAM,CAAC;EAC/B;;AAGF;;;;;AAKA,OAAM,SAAUM,kBAAkBA,CAAA,EAAiC;EAAA,IAAhCC,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAuBvB,SAAS;EACjE,OAAO,MAAO0B,OAAyB,IAAI;IACzC;IACA,MAAMC,OAAO,GAAGD,OAAO,CAACA,OAAO,CAACC,OAAO;IACvC;IACA;IACAD,OAAO,CAACA,OAAO,CAACC,OAAO,GAAGA,OAAO;IAEjC;IACA,IAAID,OAAO,CAACE,QAAQ,iCAAoB;MACtCF,OAAO,CAACG,IAAI,CAACC,KAAK,GAAGR,OAAO,EAAE;;EAElC,CAAC;AACH;AAEA;;;;;AAKA,OAAM,SAAUS,mBAAmBA,CAACC,mBAA2B;EAC7D,OAAO,MAAON,OAAyB,IAAI;IACzCA,OAAO,CAACG,IAAI,CAACI,cAAc,GAAG,IAAI7B,MAAM,CAAC4B,mBAAmB,CAAC;EAC/D,CAAC;AACH;AAEA;;;;;;AAMA,OAAM,SAAUE,oBAAoBA,CAACP,OAAgB;EACnD,MAAMQ,YAAY,GAAsB,EAAE;EAC1CR,OAAO,CAACS,OAAO,CAAC,CAACnB,KAAK,EAAEoB,GAAG,KAAI;IAC7BF,YAAY,CAACG,IAAI,CAAC,CAACD,GAAG,EAAEpB,KAAK,CAAC,CAAC;EACjC,CAAC,CAAC;EACF,OAAOkB,YAAY;AACrB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}