{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { SequenceDiff } from './algorithms/diffAlgorithm.js';\nimport { LineRangeMapping } from '../rangeMapping.js';\nimport { pushMany, compareBy, numberComparator, reverseOrder } from '../../../../base/common/arrays.js';\nimport { MonotonousArray, findLastMonotonous } from '../../../../base/common/arraysFind.js';\nimport { SetMap } from '../../../../base/common/map.js';\nimport { LineRange, LineRangeSet } from '../../core/lineRange.js';\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { LinesSliceCharSequence } from './linesSliceCharSequence.js';\nimport { LineRangeFragment, isSpace } from './utils.js';\nimport { MyersDiffAlgorithm } from './algorithms/myersDiffAlgorithm.js';\nexport function computeMovedLines(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout) {\n  let {\n    moves,\n    excludedChanges\n  } = computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout);\n  if (!timeout.isValid()) {\n    return [];\n  }\n  const filteredChanges = changes.filter(c => !excludedChanges.has(c));\n  const unchangedMoves = computeUnchangedMoves(filteredChanges, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout);\n  pushMany(moves, unchangedMoves);\n  moves = joinCloseConsecutiveMoves(moves);\n  // Ignore too short moves\n  moves = moves.filter(current => {\n    const lines = current.original.toOffsetRange().slice(originalLines).map(l => l.trim());\n    const originalText = lines.join('\\n');\n    return originalText.length >= 15 && countWhere(lines, l => l.length >= 2) >= 2;\n  });\n  moves = removeMovesInSameDiff(changes, moves);\n  return moves;\n}\nfunction countWhere(arr, predicate) {\n  let count = 0;\n  for (const t of arr) {\n    if (predicate(t)) {\n      count++;\n    }\n  }\n  return count;\n}\nfunction computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout) {\n  const moves = [];\n  const deletions = changes.filter(c => c.modified.isEmpty && c.original.length >= 3).map(d => new LineRangeFragment(d.original, originalLines, d));\n  const insertions = new Set(changes.filter(c => c.original.isEmpty && c.modified.length >= 3).map(d => new LineRangeFragment(d.modified, modifiedLines, d)));\n  const excludedChanges = new Set();\n  for (const deletion of deletions) {\n    let highestSimilarity = -1;\n    let best;\n    for (const insertion of insertions) {\n      const similarity = deletion.computeSimilarity(insertion);\n      if (similarity > highestSimilarity) {\n        highestSimilarity = similarity;\n        best = insertion;\n      }\n    }\n    if (highestSimilarity > 0.90 && best) {\n      insertions.delete(best);\n      moves.push(new LineRangeMapping(deletion.range, best.range));\n      excludedChanges.add(deletion.source);\n      excludedChanges.add(best.source);\n    }\n    if (!timeout.isValid()) {\n      return {\n        moves,\n        excludedChanges\n      };\n    }\n  }\n  return {\n    moves,\n    excludedChanges\n  };\n}\nfunction computeUnchangedMoves(changes, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout) {\n  const moves = [];\n  const original3LineHashes = new SetMap();\n  for (const change of changes) {\n    for (let i = change.original.startLineNumber; i < change.original.endLineNumberExclusive - 2; i++) {\n      const key = `${hashedOriginalLines[i - 1]}:${hashedOriginalLines[i + 1 - 1]}:${hashedOriginalLines[i + 2 - 1]}`;\n      original3LineHashes.add(key, {\n        range: new LineRange(i, i + 3)\n      });\n    }\n  }\n  const possibleMappings = [];\n  changes.sort(compareBy(c => c.modified.startLineNumber, numberComparator));\n  for (const change of changes) {\n    let lastMappings = [];\n    for (let i = change.modified.startLineNumber; i < change.modified.endLineNumberExclusive - 2; i++) {\n      const key = `${hashedModifiedLines[i - 1]}:${hashedModifiedLines[i + 1 - 1]}:${hashedModifiedLines[i + 2 - 1]}`;\n      const currentModifiedRange = new LineRange(i, i + 3);\n      const nextMappings = [];\n      original3LineHashes.forEach(key, _ref => {\n        let {\n          range\n        } = _ref;\n        for (const lastMapping of lastMappings) {\n          // does this match extend some last match?\n          if (lastMapping.originalLineRange.endLineNumberExclusive + 1 === range.endLineNumberExclusive && lastMapping.modifiedLineRange.endLineNumberExclusive + 1 === currentModifiedRange.endLineNumberExclusive) {\n            lastMapping.originalLineRange = new LineRange(lastMapping.originalLineRange.startLineNumber, range.endLineNumberExclusive);\n            lastMapping.modifiedLineRange = new LineRange(lastMapping.modifiedLineRange.startLineNumber, currentModifiedRange.endLineNumberExclusive);\n            nextMappings.push(lastMapping);\n            return;\n          }\n        }\n        const mapping = {\n          modifiedLineRange: currentModifiedRange,\n          originalLineRange: range\n        };\n        possibleMappings.push(mapping);\n        nextMappings.push(mapping);\n      });\n      lastMappings = nextMappings;\n    }\n    if (!timeout.isValid()) {\n      return [];\n    }\n  }\n  possibleMappings.sort(reverseOrder(compareBy(m => m.modifiedLineRange.length, numberComparator)));\n  const modifiedSet = new LineRangeSet();\n  const originalSet = new LineRangeSet();\n  for (const mapping of possibleMappings) {\n    const diffOrigToMod = mapping.modifiedLineRange.startLineNumber - mapping.originalLineRange.startLineNumber;\n    const modifiedSections = modifiedSet.subtractFrom(mapping.modifiedLineRange);\n    const originalTranslatedSections = originalSet.subtractFrom(mapping.originalLineRange).getWithDelta(diffOrigToMod);\n    const modifiedIntersectedSections = modifiedSections.getIntersection(originalTranslatedSections);\n    for (const s of modifiedIntersectedSections.ranges) {\n      if (s.length < 3) {\n        continue;\n      }\n      const modifiedLineRange = s;\n      const originalLineRange = s.delta(-diffOrigToMod);\n      moves.push(new LineRangeMapping(originalLineRange, modifiedLineRange));\n      modifiedSet.addRange(modifiedLineRange);\n      originalSet.addRange(originalLineRange);\n    }\n  }\n  moves.sort(compareBy(m => m.original.startLineNumber, numberComparator));\n  const monotonousChanges = new MonotonousArray(changes);\n  for (let i = 0; i < moves.length; i++) {\n    const move = moves[i];\n    const firstTouchingChangeOrig = monotonousChanges.findLastMonotonous(c => c.original.startLineNumber <= move.original.startLineNumber);\n    const firstTouchingChangeMod = findLastMonotonous(changes, c => c.modified.startLineNumber <= move.modified.startLineNumber);\n    const linesAbove = Math.max(move.original.startLineNumber - firstTouchingChangeOrig.original.startLineNumber, move.modified.startLineNumber - firstTouchingChangeMod.modified.startLineNumber);\n    const lastTouchingChangeOrig = monotonousChanges.findLastMonotonous(c => c.original.startLineNumber < move.original.endLineNumberExclusive);\n    const lastTouchingChangeMod = findLastMonotonous(changes, c => c.modified.startLineNumber < move.modified.endLineNumberExclusive);\n    const linesBelow = Math.max(lastTouchingChangeOrig.original.endLineNumberExclusive - move.original.endLineNumberExclusive, lastTouchingChangeMod.modified.endLineNumberExclusive - move.modified.endLineNumberExclusive);\n    let extendToTop;\n    for (extendToTop = 0; extendToTop < linesAbove; extendToTop++) {\n      const origLine = move.original.startLineNumber - extendToTop - 1;\n      const modLine = move.modified.startLineNumber - extendToTop - 1;\n      if (origLine > originalLines.length || modLine > modifiedLines.length) {\n        break;\n      }\n      if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {\n        break;\n      }\n      if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {\n        break;\n      }\n    }\n    if (extendToTop > 0) {\n      originalSet.addRange(new LineRange(move.original.startLineNumber - extendToTop, move.original.startLineNumber));\n      modifiedSet.addRange(new LineRange(move.modified.startLineNumber - extendToTop, move.modified.startLineNumber));\n    }\n    let extendToBottom;\n    for (extendToBottom = 0; extendToBottom < linesBelow; extendToBottom++) {\n      const origLine = move.original.endLineNumberExclusive + extendToBottom;\n      const modLine = move.modified.endLineNumberExclusive + extendToBottom;\n      if (origLine > originalLines.length || modLine > modifiedLines.length) {\n        break;\n      }\n      if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {\n        break;\n      }\n      if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {\n        break;\n      }\n    }\n    if (extendToBottom > 0) {\n      originalSet.addRange(new LineRange(move.original.endLineNumberExclusive, move.original.endLineNumberExclusive + extendToBottom));\n      modifiedSet.addRange(new LineRange(move.modified.endLineNumberExclusive, move.modified.endLineNumberExclusive + extendToBottom));\n    }\n    if (extendToTop > 0 || extendToBottom > 0) {\n      moves[i] = new LineRangeMapping(new LineRange(move.original.startLineNumber - extendToTop, move.original.endLineNumberExclusive + extendToBottom), new LineRange(move.modified.startLineNumber - extendToTop, move.modified.endLineNumberExclusive + extendToBottom));\n    }\n  }\n  return moves;\n}\nfunction areLinesSimilar(line1, line2, timeout) {\n  if (line1.trim() === line2.trim()) {\n    return true;\n  }\n  if (line1.length > 300 && line2.length > 300) {\n    return false;\n  }\n  const myersDiffingAlgorithm = new MyersDiffAlgorithm();\n  const result = myersDiffingAlgorithm.compute(new LinesSliceCharSequence([line1], new OffsetRange(0, 1), false), new LinesSliceCharSequence([line2], new OffsetRange(0, 1), false), timeout);\n  let commonNonSpaceCharCount = 0;\n  const inverted = SequenceDiff.invert(result.diffs, line1.length);\n  for (const seq of inverted) {\n    seq.seq1Range.forEach(idx => {\n      if (!isSpace(line1.charCodeAt(idx))) {\n        commonNonSpaceCharCount++;\n      }\n    });\n  }\n  function countNonWsChars(str) {\n    let count = 0;\n    for (let i = 0; i < line1.length; i++) {\n      if (!isSpace(str.charCodeAt(i))) {\n        count++;\n      }\n    }\n    return count;\n  }\n  const longerLineLength = countNonWsChars(line1.length > line2.length ? line1 : line2);\n  const r = commonNonSpaceCharCount / longerLineLength > 0.6 && longerLineLength > 10;\n  return r;\n}\nfunction joinCloseConsecutiveMoves(moves) {\n  if (moves.length === 0) {\n    return moves;\n  }\n  moves.sort(compareBy(m => m.original.startLineNumber, numberComparator));\n  const result = [moves[0]];\n  for (let i = 1; i < moves.length; i++) {\n    const last = result[result.length - 1];\n    const current = moves[i];\n    const originalDist = current.original.startLineNumber - last.original.endLineNumberExclusive;\n    const modifiedDist = current.modified.startLineNumber - last.modified.endLineNumberExclusive;\n    const currentMoveAfterLast = originalDist >= 0 && modifiedDist >= 0;\n    if (currentMoveAfterLast && originalDist + modifiedDist <= 2) {\n      result[result.length - 1] = last.join(current);\n      continue;\n    }\n    result.push(current);\n  }\n  return result;\n}\nfunction removeMovesInSameDiff(changes, moves) {\n  const changesMonotonous = new MonotonousArray(changes);\n  moves = moves.filter(m => {\n    const diffBeforeEndOfMoveOriginal = changesMonotonous.findLastMonotonous(c => c.original.startLineNumber < m.original.endLineNumberExclusive) || new LineRangeMapping(new LineRange(1, 1), new LineRange(1, 1));\n    const diffBeforeEndOfMoveModified = findLastMonotonous(changes, c => c.modified.startLineNumber < m.modified.endLineNumberExclusive);\n    const differentDiffs = diffBeforeEndOfMoveOriginal !== diffBeforeEndOfMoveModified;\n    return differentDiffs;\n  });\n  return moves;\n}","map":{"version":3,"names":["SequenceDiff","LineRangeMapping","pushMany","compareBy","numberComparator","reverseOrder","MonotonousArray","findLastMonotonous","SetMap","LineRange","LineRangeSet","OffsetRange","LinesSliceCharSequence","LineRangeFragment","isSpace","MyersDiffAlgorithm","computeMovedLines","changes","originalLines","modifiedLines","hashedOriginalLines","hashedModifiedLines","timeout","moves","excludedChanges","computeMovesFromSimpleDeletionsToSimpleInsertions","isValid","filteredChanges","filter","c","has","unchangedMoves","computeUnchangedMoves","joinCloseConsecutiveMoves","current","lines","original","toOffsetRange","slice","map","l","trim","originalText","join","length","countWhere","removeMovesInSameDiff","arr","predicate","count","t","deletions","modified","isEmpty","d","insertions","Set","deletion","highestSimilarity","best","insertion","similarity","computeSimilarity","delete","push","range","add","source","original3LineHashes","change","i","startLineNumber","endLineNumberExclusive","key","possibleMappings","sort","lastMappings","currentModifiedRange","nextMappings","forEach","_ref","lastMapping","originalLineRange","modifiedLineRange","mapping","m","modifiedSet","originalSet","diffOrigToMod","modifiedSections","subtractFrom","originalTranslatedSections","getWithDelta","modifiedIntersectedSections","getIntersection","s","ranges","delta","addRange","monotonousChanges","move","firstTouchingChangeOrig","firstTouchingChangeMod","linesAbove","Math","max","lastTouchingChangeOrig","lastTouchingChangeMod","linesBelow","extendToTop","origLine","modLine","contains","areLinesSimilar","extendToBottom","line1","line2","myersDiffingAlgorithm","result","compute","commonNonSpaceCharCount","inverted","invert","diffs","seq","seq1Range","idx","charCodeAt","countNonWsChars","str","longerLineLength","r","last","originalDist","modifiedDist","currentMoveAfterLast","changesMonotonous","diffBeforeEndOfMoveOriginal","diffBeforeEndOfMoveModified","differentDiffs"],"sources":["/home/arslan/modojo/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/computeMovedLines.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { SequenceDiff } from './algorithms/diffAlgorithm.js';\nimport { LineRangeMapping } from '../rangeMapping.js';\nimport { pushMany, compareBy, numberComparator, reverseOrder } from '../../../../base/common/arrays.js';\nimport { MonotonousArray, findLastMonotonous } from '../../../../base/common/arraysFind.js';\nimport { SetMap } from '../../../../base/common/map.js';\nimport { LineRange, LineRangeSet } from '../../core/lineRange.js';\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { LinesSliceCharSequence } from './linesSliceCharSequence.js';\nimport { LineRangeFragment, isSpace } from './utils.js';\nimport { MyersDiffAlgorithm } from './algorithms/myersDiffAlgorithm.js';\nexport function computeMovedLines(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout) {\n    let { moves, excludedChanges } = computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout);\n    if (!timeout.isValid()) {\n        return [];\n    }\n    const filteredChanges = changes.filter(c => !excludedChanges.has(c));\n    const unchangedMoves = computeUnchangedMoves(filteredChanges, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout);\n    pushMany(moves, unchangedMoves);\n    moves = joinCloseConsecutiveMoves(moves);\n    // Ignore too short moves\n    moves = moves.filter(current => {\n        const lines = current.original.toOffsetRange().slice(originalLines).map(l => l.trim());\n        const originalText = lines.join('\\n');\n        return originalText.length >= 15 && countWhere(lines, l => l.length >= 2) >= 2;\n    });\n    moves = removeMovesInSameDiff(changes, moves);\n    return moves;\n}\nfunction countWhere(arr, predicate) {\n    let count = 0;\n    for (const t of arr) {\n        if (predicate(t)) {\n            count++;\n        }\n    }\n    return count;\n}\nfunction computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout) {\n    const moves = [];\n    const deletions = changes\n        .filter(c => c.modified.isEmpty && c.original.length >= 3)\n        .map(d => new LineRangeFragment(d.original, originalLines, d));\n    const insertions = new Set(changes\n        .filter(c => c.original.isEmpty && c.modified.length >= 3)\n        .map(d => new LineRangeFragment(d.modified, modifiedLines, d)));\n    const excludedChanges = new Set();\n    for (const deletion of deletions) {\n        let highestSimilarity = -1;\n        let best;\n        for (const insertion of insertions) {\n            const similarity = deletion.computeSimilarity(insertion);\n            if (similarity > highestSimilarity) {\n                highestSimilarity = similarity;\n                best = insertion;\n            }\n        }\n        if (highestSimilarity > 0.90 && best) {\n            insertions.delete(best);\n            moves.push(new LineRangeMapping(deletion.range, best.range));\n            excludedChanges.add(deletion.source);\n            excludedChanges.add(best.source);\n        }\n        if (!timeout.isValid()) {\n            return { moves, excludedChanges };\n        }\n    }\n    return { moves, excludedChanges };\n}\nfunction computeUnchangedMoves(changes, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout) {\n    const moves = [];\n    const original3LineHashes = new SetMap();\n    for (const change of changes) {\n        for (let i = change.original.startLineNumber; i < change.original.endLineNumberExclusive - 2; i++) {\n            const key = `${hashedOriginalLines[i - 1]}:${hashedOriginalLines[i + 1 - 1]}:${hashedOriginalLines[i + 2 - 1]}`;\n            original3LineHashes.add(key, { range: new LineRange(i, i + 3) });\n        }\n    }\n    const possibleMappings = [];\n    changes.sort(compareBy(c => c.modified.startLineNumber, numberComparator));\n    for (const change of changes) {\n        let lastMappings = [];\n        for (let i = change.modified.startLineNumber; i < change.modified.endLineNumberExclusive - 2; i++) {\n            const key = `${hashedModifiedLines[i - 1]}:${hashedModifiedLines[i + 1 - 1]}:${hashedModifiedLines[i + 2 - 1]}`;\n            const currentModifiedRange = new LineRange(i, i + 3);\n            const nextMappings = [];\n            original3LineHashes.forEach(key, ({ range }) => {\n                for (const lastMapping of lastMappings) {\n                    // does this match extend some last match?\n                    if (lastMapping.originalLineRange.endLineNumberExclusive + 1 === range.endLineNumberExclusive &&\n                        lastMapping.modifiedLineRange.endLineNumberExclusive + 1 === currentModifiedRange.endLineNumberExclusive) {\n                        lastMapping.originalLineRange = new LineRange(lastMapping.originalLineRange.startLineNumber, range.endLineNumberExclusive);\n                        lastMapping.modifiedLineRange = new LineRange(lastMapping.modifiedLineRange.startLineNumber, currentModifiedRange.endLineNumberExclusive);\n                        nextMappings.push(lastMapping);\n                        return;\n                    }\n                }\n                const mapping = {\n                    modifiedLineRange: currentModifiedRange,\n                    originalLineRange: range,\n                };\n                possibleMappings.push(mapping);\n                nextMappings.push(mapping);\n            });\n            lastMappings = nextMappings;\n        }\n        if (!timeout.isValid()) {\n            return [];\n        }\n    }\n    possibleMappings.sort(reverseOrder(compareBy(m => m.modifiedLineRange.length, numberComparator)));\n    const modifiedSet = new LineRangeSet();\n    const originalSet = new LineRangeSet();\n    for (const mapping of possibleMappings) {\n        const diffOrigToMod = mapping.modifiedLineRange.startLineNumber - mapping.originalLineRange.startLineNumber;\n        const modifiedSections = modifiedSet.subtractFrom(mapping.modifiedLineRange);\n        const originalTranslatedSections = originalSet.subtractFrom(mapping.originalLineRange).getWithDelta(diffOrigToMod);\n        const modifiedIntersectedSections = modifiedSections.getIntersection(originalTranslatedSections);\n        for (const s of modifiedIntersectedSections.ranges) {\n            if (s.length < 3) {\n                continue;\n            }\n            const modifiedLineRange = s;\n            const originalLineRange = s.delta(-diffOrigToMod);\n            moves.push(new LineRangeMapping(originalLineRange, modifiedLineRange));\n            modifiedSet.addRange(modifiedLineRange);\n            originalSet.addRange(originalLineRange);\n        }\n    }\n    moves.sort(compareBy(m => m.original.startLineNumber, numberComparator));\n    const monotonousChanges = new MonotonousArray(changes);\n    for (let i = 0; i < moves.length; i++) {\n        const move = moves[i];\n        const firstTouchingChangeOrig = monotonousChanges.findLastMonotonous(c => c.original.startLineNumber <= move.original.startLineNumber);\n        const firstTouchingChangeMod = findLastMonotonous(changes, c => c.modified.startLineNumber <= move.modified.startLineNumber);\n        const linesAbove = Math.max(move.original.startLineNumber - firstTouchingChangeOrig.original.startLineNumber, move.modified.startLineNumber - firstTouchingChangeMod.modified.startLineNumber);\n        const lastTouchingChangeOrig = monotonousChanges.findLastMonotonous(c => c.original.startLineNumber < move.original.endLineNumberExclusive);\n        const lastTouchingChangeMod = findLastMonotonous(changes, c => c.modified.startLineNumber < move.modified.endLineNumberExclusive);\n        const linesBelow = Math.max(lastTouchingChangeOrig.original.endLineNumberExclusive - move.original.endLineNumberExclusive, lastTouchingChangeMod.modified.endLineNumberExclusive - move.modified.endLineNumberExclusive);\n        let extendToTop;\n        for (extendToTop = 0; extendToTop < linesAbove; extendToTop++) {\n            const origLine = move.original.startLineNumber - extendToTop - 1;\n            const modLine = move.modified.startLineNumber - extendToTop - 1;\n            if (origLine > originalLines.length || modLine > modifiedLines.length) {\n                break;\n            }\n            if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {\n                break;\n            }\n            if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {\n                break;\n            }\n        }\n        if (extendToTop > 0) {\n            originalSet.addRange(new LineRange(move.original.startLineNumber - extendToTop, move.original.startLineNumber));\n            modifiedSet.addRange(new LineRange(move.modified.startLineNumber - extendToTop, move.modified.startLineNumber));\n        }\n        let extendToBottom;\n        for (extendToBottom = 0; extendToBottom < linesBelow; extendToBottom++) {\n            const origLine = move.original.endLineNumberExclusive + extendToBottom;\n            const modLine = move.modified.endLineNumberExclusive + extendToBottom;\n            if (origLine > originalLines.length || modLine > modifiedLines.length) {\n                break;\n            }\n            if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {\n                break;\n            }\n            if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {\n                break;\n            }\n        }\n        if (extendToBottom > 0) {\n            originalSet.addRange(new LineRange(move.original.endLineNumberExclusive, move.original.endLineNumberExclusive + extendToBottom));\n            modifiedSet.addRange(new LineRange(move.modified.endLineNumberExclusive, move.modified.endLineNumberExclusive + extendToBottom));\n        }\n        if (extendToTop > 0 || extendToBottom > 0) {\n            moves[i] = new LineRangeMapping(new LineRange(move.original.startLineNumber - extendToTop, move.original.endLineNumberExclusive + extendToBottom), new LineRange(move.modified.startLineNumber - extendToTop, move.modified.endLineNumberExclusive + extendToBottom));\n        }\n    }\n    return moves;\n}\nfunction areLinesSimilar(line1, line2, timeout) {\n    if (line1.trim() === line2.trim()) {\n        return true;\n    }\n    if (line1.length > 300 && line2.length > 300) {\n        return false;\n    }\n    const myersDiffingAlgorithm = new MyersDiffAlgorithm();\n    const result = myersDiffingAlgorithm.compute(new LinesSliceCharSequence([line1], new OffsetRange(0, 1), false), new LinesSliceCharSequence([line2], new OffsetRange(0, 1), false), timeout);\n    let commonNonSpaceCharCount = 0;\n    const inverted = SequenceDiff.invert(result.diffs, line1.length);\n    for (const seq of inverted) {\n        seq.seq1Range.forEach(idx => {\n            if (!isSpace(line1.charCodeAt(idx))) {\n                commonNonSpaceCharCount++;\n            }\n        });\n    }\n    function countNonWsChars(str) {\n        let count = 0;\n        for (let i = 0; i < line1.length; i++) {\n            if (!isSpace(str.charCodeAt(i))) {\n                count++;\n            }\n        }\n        return count;\n    }\n    const longerLineLength = countNonWsChars(line1.length > line2.length ? line1 : line2);\n    const r = commonNonSpaceCharCount / longerLineLength > 0.6 && longerLineLength > 10;\n    return r;\n}\nfunction joinCloseConsecutiveMoves(moves) {\n    if (moves.length === 0) {\n        return moves;\n    }\n    moves.sort(compareBy(m => m.original.startLineNumber, numberComparator));\n    const result = [moves[0]];\n    for (let i = 1; i < moves.length; i++) {\n        const last = result[result.length - 1];\n        const current = moves[i];\n        const originalDist = current.original.startLineNumber - last.original.endLineNumberExclusive;\n        const modifiedDist = current.modified.startLineNumber - last.modified.endLineNumberExclusive;\n        const currentMoveAfterLast = originalDist >= 0 && modifiedDist >= 0;\n        if (currentMoveAfterLast && originalDist + modifiedDist <= 2) {\n            result[result.length - 1] = last.join(current);\n            continue;\n        }\n        result.push(current);\n    }\n    return result;\n}\nfunction removeMovesInSameDiff(changes, moves) {\n    const changesMonotonous = new MonotonousArray(changes);\n    moves = moves.filter(m => {\n        const diffBeforeEndOfMoveOriginal = changesMonotonous.findLastMonotonous(c => c.original.startLineNumber < m.original.endLineNumberExclusive)\n            || new LineRangeMapping(new LineRange(1, 1), new LineRange(1, 1));\n        const diffBeforeEndOfMoveModified = findLastMonotonous(changes, c => c.modified.startLineNumber < m.modified.endLineNumberExclusive);\n        const differentDiffs = diffBeforeEndOfMoveOriginal !== diffBeforeEndOfMoveModified;\n        return differentDiffs;\n    });\n    return moves;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}