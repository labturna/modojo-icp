{"ast":null,"code":"import { SignIdentity } from '@dfinity/agent';\nexport class CryptoError extends Error {\n  constructor(message) {\n    super(message);\n    this.message = message;\n    Object.setPrototypeOf(this, CryptoError.prototype);\n  }\n}\n/**\n * Utility method to ensure that a subtleCrypto implementation is provided or is available in the global context\n * @param subtleCrypto SubtleCrypto implementation\n * @returns subleCrypto\n */\nfunction _getEffectiveCrypto(subtleCrypto) {\n  if (typeof global !== 'undefined' && global['crypto'] && global['crypto']['subtle']) {\n    return global['crypto']['subtle'];\n  }\n  if (subtleCrypto) {\n    return subtleCrypto;\n  } else if (typeof crypto !== 'undefined' && crypto['subtle']) {\n    return crypto.subtle;\n  } else {\n    throw new CryptoError('Global crypto was not available and none was provided. Please inlcude a SubtleCrypto implementation. See https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto');\n  }\n}\n/**\n * An identity interface that wraps an ECDSA keypair using the P-256 named curve. Supports DER-encoding and decoding for agent calls\n */\nexport class ECDSAKeyIdentity extends SignIdentity {\n  // `fromKeyPair` and `generate` should be used for instantiation, not this constructor.\n  constructor(keyPair, derKey, subtleCrypto) {\n    super();\n    this._keyPair = keyPair;\n    this._derKey = derKey;\n    this._subtleCrypto = subtleCrypto;\n  }\n  /**\n   * Generates a randomly generated identity for use in calls to the Internet Computer.\n   * @param {CryptoKeyOptions} options optional settings\n   * @param {CryptoKeyOptions['extractable']} options.extractable - whether the key should allow itself to be used. Set to false for maximum security.\n   * @param {CryptoKeyOptions['keyUsages']} options.keyUsages - a list of key usages that the key can be used for\n   * @param {CryptoKeyOptions['subtleCrypto']} options.subtleCrypto interface\n   * @constructs ECDSAKeyIdentity\n   * @returns a {@link ECDSAKeyIdentity}\n   */\n  static async generate(options) {\n    const {\n      extractable = false,\n      keyUsages = ['sign', 'verify'],\n      subtleCrypto\n    } = options !== null && options !== void 0 ? options : {};\n    const effectiveCrypto = _getEffectiveCrypto(subtleCrypto);\n    const keyPair = await effectiveCrypto.generateKey({\n      name: 'ECDSA',\n      namedCurve: 'P-256'\n    }, extractable, keyUsages);\n    const derKey = await effectiveCrypto.exportKey('spki', keyPair.publicKey);\n    return new this(keyPair, derKey, effectiveCrypto);\n  }\n  /**\n   * generates an identity from a public and private key. Please ensure that you are generating these keys securely and protect the user's private key\n   * @param keyPair a CryptoKeyPair\n   * @param subtleCrypto - a SubtleCrypto interface in case one is not available globally\n   * @returns an {@link ECDSAKeyIdentity}\n   */\n  static async fromKeyPair(keyPair, subtleCrypto) {\n    const effectiveCrypto = _getEffectiveCrypto(subtleCrypto);\n    const derKey = await effectiveCrypto.exportKey('spki', keyPair.publicKey);\n    return new ECDSAKeyIdentity(keyPair, derKey, effectiveCrypto);\n  }\n  /**\n   * Return the internally-used key pair.\n   * @returns a CryptoKeyPair\n   */\n  getKeyPair() {\n    return this._keyPair;\n  }\n  /**\n   * Return the public key.\n   * @returns an {@link PublicKey & DerCryptoKey}\n   */\n  getPublicKey() {\n    const derKey = this._derKey;\n    const key = Object.create(this._keyPair.publicKey);\n    key.toDer = function () {\n      return derKey;\n    };\n    return key;\n  }\n  /**\n   * Signs a blob of data, with this identity's private key.\n   * @param {ArrayBuffer} challenge - challenge to sign with this identity's secretKey, producing a signature\n   * @returns {Promise<Signature>} signature\n   */\n  async sign(challenge) {\n    const params = {\n      name: 'ECDSA',\n      hash: {\n        name: 'SHA-256'\n      }\n    };\n    const signature = await this._subtleCrypto.sign(params, this._keyPair.privateKey, challenge);\n    return signature;\n  }\n}\nexport default ECDSAKeyIdentity;","map":{"version":3,"names":["SignIdentity","CryptoError","Error","constructor","message","Object","setPrototypeOf","prototype","_getEffectiveCrypto","subtleCrypto","global","crypto","subtle","ECDSAKeyIdentity","keyPair","derKey","_keyPair","_derKey","_subtleCrypto","generate","options","extractable","keyUsages","effectiveCrypto","generateKey","name","namedCurve","exportKey","publicKey","fromKeyPair","getKeyPair","getPublicKey","key","create","toDer","sign","challenge","params","hash","signature","privateKey"],"sources":["/home/arslan/modojo/node_modules/@dfinity/identity/src/identity/ecdsa.ts"],"sourcesContent":["import { DerEncodedPublicKey, PublicKey, Signature, SignIdentity } from '@dfinity/agent';\n\n/**\n * Options used in a {@link ECDSAKeyIdentity}\n */\nexport type CryptoKeyOptions = {\n  extractable?: boolean;\n  keyUsages?: KeyUsage[];\n  subtleCrypto?: SubtleCrypto;\n};\n\nexport class CryptoError extends Error {\n  constructor(public readonly message: string) {\n    super(message);\n    Object.setPrototypeOf(this, CryptoError.prototype);\n  }\n}\n\nexport interface DerCryptoKey extends CryptoKey {\n  toDer: () => DerEncodedPublicKey;\n}\n\n/**\n * Utility method to ensure that a subtleCrypto implementation is provided or is available in the global context\n * @param subtleCrypto SubtleCrypto implementation\n * @returns subleCrypto\n */\nfunction _getEffectiveCrypto(subtleCrypto: CryptoKeyOptions['subtleCrypto']): SubtleCrypto {\n  if (typeof global !== 'undefined' && global['crypto'] && global['crypto']['subtle']) {\n    return global['crypto']['subtle'];\n  }\n  if (subtleCrypto) {\n    return subtleCrypto;\n  } else if (typeof crypto !== 'undefined' && crypto['subtle']) {\n    return crypto.subtle;\n  } else {\n    throw new CryptoError(\n      'Global crypto was not available and none was provided. Please inlcude a SubtleCrypto implementation. See https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto',\n    );\n  }\n}\n\n/**\n * An identity interface that wraps an ECDSA keypair using the P-256 named curve. Supports DER-encoding and decoding for agent calls\n */\nexport class ECDSAKeyIdentity extends SignIdentity {\n  /**\n   * Generates a randomly generated identity for use in calls to the Internet Computer.\n   * @param {CryptoKeyOptions} options optional settings\n   * @param {CryptoKeyOptions['extractable']} options.extractable - whether the key should allow itself to be used. Set to false for maximum security.\n   * @param {CryptoKeyOptions['keyUsages']} options.keyUsages - a list of key usages that the key can be used for\n   * @param {CryptoKeyOptions['subtleCrypto']} options.subtleCrypto interface\n   * @constructs ECDSAKeyIdentity\n   * @returns a {@link ECDSAKeyIdentity}\n   */\n  public static async generate(options?: CryptoKeyOptions): Promise<ECDSAKeyIdentity> {\n    const { extractable = false, keyUsages = ['sign', 'verify'], subtleCrypto } = options ?? {};\n    const effectiveCrypto = _getEffectiveCrypto(subtleCrypto);\n    const keyPair = await effectiveCrypto.generateKey(\n      {\n        name: 'ECDSA',\n        namedCurve: 'P-256',\n      },\n      extractable,\n      keyUsages,\n    );\n    const derKey = (await effectiveCrypto.exportKey(\n      'spki',\n      keyPair.publicKey,\n    )) as DerEncodedPublicKey;\n\n    return new this(keyPair, derKey, effectiveCrypto);\n  }\n\n  /**\n   * generates an identity from a public and private key. Please ensure that you are generating these keys securely and protect the user's private key\n   * @param keyPair a CryptoKeyPair\n   * @param subtleCrypto - a SubtleCrypto interface in case one is not available globally\n   * @returns an {@link ECDSAKeyIdentity}\n   */\n  public static async fromKeyPair(\n    keyPair: CryptoKeyPair | { privateKey: CryptoKey; publicKey: CryptoKey },\n    subtleCrypto?: SubtleCrypto,\n  ): Promise<ECDSAKeyIdentity> {\n    const effectiveCrypto = _getEffectiveCrypto(subtleCrypto);\n    const derKey = (await effectiveCrypto.exportKey(\n      'spki',\n      keyPair.publicKey,\n    )) as DerEncodedPublicKey;\n    return new ECDSAKeyIdentity(keyPair, derKey, effectiveCrypto);\n  }\n\n  protected _derKey: DerEncodedPublicKey;\n  protected _keyPair: CryptoKeyPair;\n  protected _subtleCrypto: SubtleCrypto;\n\n  // `fromKeyPair` and `generate` should be used for instantiation, not this constructor.\n  protected constructor(\n    keyPair: CryptoKeyPair,\n    derKey: DerEncodedPublicKey,\n    subtleCrypto: SubtleCrypto,\n  ) {\n    super();\n    this._keyPair = keyPair;\n    this._derKey = derKey;\n    this._subtleCrypto = subtleCrypto;\n  }\n\n  /**\n   * Return the internally-used key pair.\n   * @returns a CryptoKeyPair\n   */\n  public getKeyPair(): CryptoKeyPair {\n    return this._keyPair;\n  }\n\n  /**\n   * Return the public key.\n   * @returns an {@link PublicKey & DerCryptoKey}\n   */\n  public getPublicKey(): PublicKey & DerCryptoKey {\n    const derKey = this._derKey;\n    const key: DerCryptoKey = Object.create(this._keyPair.publicKey);\n    key.toDer = function () {\n      return derKey;\n    };\n\n    return key;\n  }\n\n  /**\n   * Signs a blob of data, with this identity's private key.\n   * @param {ArrayBuffer} challenge - challenge to sign with this identity's secretKey, producing a signature\n   * @returns {Promise<Signature>} signature\n   */\n  public async sign(challenge: ArrayBuffer): Promise<Signature> {\n    const params: EcdsaParams = {\n      name: 'ECDSA',\n      hash: { name: 'SHA-256' },\n    };\n    const signature = await this._subtleCrypto.sign(params, this._keyPair.privateKey, challenge);\n\n    return signature as Signature;\n  }\n}\n\nexport default ECDSAKeyIdentity;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}