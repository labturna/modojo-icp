{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\nvar AbstractGotoSymbolQuickAccessProvider_1;\nimport { DeferredPromise } from '../../../../base/common/async.js';\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { Codicon } from '../../../../base/common/codicons.js';\nimport { ThemeIcon } from '../../../../base/common/themables.js';\nimport { pieceToQuery, prepareQuery, scoreFuzzy2 } from '../../../../base/common/fuzzyScorer.js';\nimport { Disposable, DisposableStore, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { format, trim } from '../../../../base/common/strings.js';\nimport { Range } from '../../../common/core/range.js';\nimport { SymbolKinds, getAriaLabelForSymbol } from '../../../common/languages.js';\nimport { IOutlineModelService } from '../../documentSymbols/browser/outlineModel.js';\nimport { AbstractEditorNavigationQuickAccessProvider } from './editorNavigationQuickAccess.js';\nimport { localize } from '../../../../nls.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nimport { findLast } from '../../../../base/common/arraysFind.js';\nlet AbstractGotoSymbolQuickAccessProvider = AbstractGotoSymbolQuickAccessProvider_1 = class AbstractGotoSymbolQuickAccessProvider extends AbstractEditorNavigationQuickAccessProvider {\n  constructor(_languageFeaturesService, _outlineModelService) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Object.create(null);\n    super(options);\n    this._languageFeaturesService = _languageFeaturesService;\n    this._outlineModelService = _outlineModelService;\n    this.options = options;\n    this.options.canAcceptInBackground = true;\n  }\n  provideWithoutTextEditor(picker) {\n    this.provideLabelPick(picker, localize('cannotRunGotoSymbolWithoutEditor', \"To go to a symbol, first open a text editor with symbol information.\"));\n    return Disposable.None;\n  }\n  provideWithTextEditor(context, picker, token, runOptions) {\n    const editor = context.editor;\n    const model = this.getModel(editor);\n    if (!model) {\n      return Disposable.None;\n    }\n    // Provide symbols from model if available in registry\n    if (this._languageFeaturesService.documentSymbolProvider.has(model)) {\n      return this.doProvideWithEditorSymbols(context, model, picker, token, runOptions);\n    }\n    // Otherwise show an entry for a model without registry\n    // But give a chance to resolve the symbols at a later\n    // point if possible\n    return this.doProvideWithoutEditorSymbols(context, model, picker, token);\n  }\n  doProvideWithoutEditorSymbols(context, model, picker, token) {\n    const disposables = new DisposableStore();\n    // Generic pick for not having any symbol information\n    this.provideLabelPick(picker, localize('cannotRunGotoSymbolWithoutSymbolProvider', \"The active text editor does not provide symbol information.\"));\n    // Wait for changes to the registry and see if eventually\n    // we do get symbols. This can happen if the picker is opened\n    // very early after the model has loaded but before the\n    // language registry is ready.\n    // https://github.com/microsoft/vscode/issues/70607\n    (async () => {\n      const result = await this.waitForLanguageSymbolRegistry(model, disposables);\n      if (!result || token.isCancellationRequested) {\n        return;\n      }\n      disposables.add(this.doProvideWithEditorSymbols(context, model, picker, token));\n    })();\n    return disposables;\n  }\n  provideLabelPick(picker, label) {\n    picker.items = [{\n      label,\n      index: 0,\n      kind: 14 /* SymbolKind.String */\n    }];\n    picker.ariaLabel = label;\n  }\n  async waitForLanguageSymbolRegistry(model, disposables) {\n    if (this._languageFeaturesService.documentSymbolProvider.has(model)) {\n      return true;\n    }\n    const symbolProviderRegistryPromise = new DeferredPromise();\n    // Resolve promise when registry knows model\n    const symbolProviderListener = disposables.add(this._languageFeaturesService.documentSymbolProvider.onDidChange(() => {\n      if (this._languageFeaturesService.documentSymbolProvider.has(model)) {\n        symbolProviderListener.dispose();\n        symbolProviderRegistryPromise.complete(true);\n      }\n    }));\n    // Resolve promise when we get disposed too\n    disposables.add(toDisposable(() => symbolProviderRegistryPromise.complete(false)));\n    return symbolProviderRegistryPromise.p;\n  }\n  doProvideWithEditorSymbols(context, model, picker, token, runOptions) {\n    var _a;\n    const editor = context.editor;\n    const disposables = new DisposableStore();\n    // Goto symbol once picked\n    disposables.add(picker.onDidAccept(event => {\n      var _a;\n      const [item] = picker.selectedItems;\n      if (item && item.range) {\n        this.gotoLocation(context, {\n          range: item.range.selection,\n          keyMods: picker.keyMods,\n          preserveFocus: event.inBackground\n        });\n        (_a = runOptions === null || runOptions === void 0 ? void 0 : runOptions.handleAccept) === null || _a === void 0 ? void 0 : _a.call(runOptions, item);\n        if (!event.inBackground) {\n          picker.hide();\n        }\n      }\n    }));\n    // Goto symbol side by side if enabled\n    disposables.add(picker.onDidTriggerItemButton(_ref => {\n      let {\n        item\n      } = _ref;\n      if (item && item.range) {\n        this.gotoLocation(context, {\n          range: item.range.selection,\n          keyMods: picker.keyMods,\n          forceSideBySide: true\n        });\n        picker.hide();\n      }\n    }));\n    // Resolve symbols from document once and reuse this\n    // request for all filtering and typing then on\n    const symbolsPromise = this.getDocumentSymbols(model, token);\n    // Set initial picks and update on type\n    let picksCts = undefined;\n    const updatePickerItems = async positionToEnclose => {\n      // Cancel any previous ask for picks and busy\n      picksCts === null || picksCts === void 0 ? void 0 : picksCts.dispose(true);\n      picker.busy = false;\n      // Create new cancellation source for this run\n      picksCts = new CancellationTokenSource(token);\n      // Collect symbol picks\n      picker.busy = true;\n      try {\n        const query = prepareQuery(picker.value.substr(AbstractGotoSymbolQuickAccessProvider_1.PREFIX.length).trim());\n        const items = await this.doGetSymbolPicks(symbolsPromise, query, undefined, picksCts.token, model);\n        if (token.isCancellationRequested) {\n          return;\n        }\n        if (items.length > 0) {\n          picker.items = items;\n          if (positionToEnclose && query.original.length === 0) {\n            const candidate = findLast(items, item => Boolean(item.type !== 'separator' && item.range && Range.containsPosition(item.range.decoration, positionToEnclose)));\n            if (candidate) {\n              picker.activeItems = [candidate];\n            }\n          }\n        } else {\n          if (query.original.length > 0) {\n            this.provideLabelPick(picker, localize('noMatchingSymbolResults', \"No matching editor symbols\"));\n          } else {\n            this.provideLabelPick(picker, localize('noSymbolResults', \"No editor symbols\"));\n          }\n        }\n      } finally {\n        if (!token.isCancellationRequested) {\n          picker.busy = false;\n        }\n      }\n    };\n    disposables.add(picker.onDidChangeValue(() => updatePickerItems(undefined)));\n    updatePickerItems((_a = editor.getSelection()) === null || _a === void 0 ? void 0 : _a.getPosition());\n    // Reveal and decorate when active item changes\n    disposables.add(picker.onDidChangeActive(() => {\n      const [item] = picker.activeItems;\n      if (item && item.range) {\n        // Reveal\n        editor.revealRangeInCenter(item.range.selection, 0 /* ScrollType.Smooth */);\n        // Decorate\n        this.addDecorations(editor, item.range.decoration);\n      }\n    }));\n    return disposables;\n  }\n  async doGetSymbolPicks(symbolsPromise, query, options, token, model) {\n    var _a, _b;\n    const symbols = await symbolsPromise;\n    if (token.isCancellationRequested) {\n      return [];\n    }\n    const filterBySymbolKind = query.original.indexOf(AbstractGotoSymbolQuickAccessProvider_1.SCOPE_PREFIX) === 0;\n    const filterPos = filterBySymbolKind ? 1 : 0;\n    // Split between symbol and container query\n    let symbolQuery;\n    let containerQuery;\n    if (query.values && query.values.length > 1) {\n      symbolQuery = pieceToQuery(query.values[0]); // symbol: only match on first part\n      containerQuery = pieceToQuery(query.values.slice(1)); // container: match on all but first parts\n    } else {\n      symbolQuery = query;\n    }\n    // Convert to symbol picks and apply filtering\n    let buttons;\n    const openSideBySideDirection = (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.openSideBySideDirection) === null || _b === void 0 ? void 0 : _b.call(_a);\n    if (openSideBySideDirection) {\n      buttons = [{\n        iconClass: openSideBySideDirection === 'right' ? ThemeIcon.asClassName(Codicon.splitHorizontal) : ThemeIcon.asClassName(Codicon.splitVertical),\n        tooltip: openSideBySideDirection === 'right' ? localize('openToSide', \"Open to the Side\") : localize('openToBottom', \"Open to the Bottom\")\n      }];\n    }\n    const filteredSymbolPicks = [];\n    for (let index = 0; index < symbols.length; index++) {\n      const symbol = symbols[index];\n      const symbolLabel = trim(symbol.name);\n      const symbolLabelWithIcon = `$(${SymbolKinds.toIcon(symbol.kind).id}) ${symbolLabel}`;\n      const symbolLabelIconOffset = symbolLabelWithIcon.length - symbolLabel.length;\n      let containerLabel = symbol.containerName;\n      if (options === null || options === void 0 ? void 0 : options.extraContainerLabel) {\n        if (containerLabel) {\n          containerLabel = `${options.extraContainerLabel} • ${containerLabel}`;\n        } else {\n          containerLabel = options.extraContainerLabel;\n        }\n      }\n      let symbolScore = undefined;\n      let symbolMatches = undefined;\n      let containerScore = undefined;\n      let containerMatches = undefined;\n      if (query.original.length > filterPos) {\n        // First: try to score on the entire query, it is possible that\n        // the symbol matches perfectly (e.g. searching for \"change log\"\n        // can be a match on a markdown symbol \"change log\"). In that\n        // case we want to skip the container query altogether.\n        let skipContainerQuery = false;\n        if (symbolQuery !== query) {\n          [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, {\n            ...query,\n            values: undefined /* disable multi-query support */\n          }, filterPos, symbolLabelIconOffset);\n          if (typeof symbolScore === 'number') {\n            skipContainerQuery = true; // since we consumed the query, skip any container matching\n          }\n        }\n        // Otherwise: score on the symbol query and match on the container later\n        if (typeof symbolScore !== 'number') {\n          [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, symbolQuery, filterPos, symbolLabelIconOffset);\n          if (typeof symbolScore !== 'number') {\n            continue;\n          }\n        }\n        // Score by container if specified\n        if (!skipContainerQuery && containerQuery) {\n          if (containerLabel && containerQuery.original.length > 0) {\n            [containerScore, containerMatches] = scoreFuzzy2(containerLabel, containerQuery);\n          }\n          if (typeof containerScore !== 'number') {\n            continue;\n          }\n          if (typeof symbolScore === 'number') {\n            symbolScore += containerScore; // boost symbolScore by containerScore\n          }\n        }\n      }\n      const deprecated = symbol.tags && symbol.tags.indexOf(1 /* SymbolTag.Deprecated */) >= 0;\n      filteredSymbolPicks.push({\n        index,\n        kind: symbol.kind,\n        score: symbolScore,\n        label: symbolLabelWithIcon,\n        ariaLabel: getAriaLabelForSymbol(symbol.name, symbol.kind),\n        description: containerLabel,\n        highlights: deprecated ? undefined : {\n          label: symbolMatches,\n          description: containerMatches\n        },\n        range: {\n          selection: Range.collapseToStart(symbol.selectionRange),\n          decoration: symbol.range\n        },\n        uri: model.uri,\n        symbolName: symbolLabel,\n        strikethrough: deprecated,\n        buttons\n      });\n    }\n    // Sort by score\n    const sortedFilteredSymbolPicks = filteredSymbolPicks.sort((symbolA, symbolB) => filterBySymbolKind ? this.compareByKindAndScore(symbolA, symbolB) : this.compareByScore(symbolA, symbolB));\n    // Add separator for types\n    // - @  only total number of symbols\n    // - @: grouped by symbol kind\n    let symbolPicks = [];\n    if (filterBySymbolKind) {\n      let lastSymbolKind = undefined;\n      let lastSeparator = undefined;\n      let lastSymbolKindCounter = 0;\n      function updateLastSeparatorLabel() {\n        if (lastSeparator && typeof lastSymbolKind === 'number' && lastSymbolKindCounter > 0) {\n          lastSeparator.label = format(NLS_SYMBOL_KIND_CACHE[lastSymbolKind] || FALLBACK_NLS_SYMBOL_KIND, lastSymbolKindCounter);\n        }\n      }\n      for (const symbolPick of sortedFilteredSymbolPicks) {\n        // Found new kind\n        if (lastSymbolKind !== symbolPick.kind) {\n          // Update last separator with number of symbols we found for kind\n          updateLastSeparatorLabel();\n          lastSymbolKind = symbolPick.kind;\n          lastSymbolKindCounter = 1;\n          // Add new separator for new kind\n          lastSeparator = {\n            type: 'separator'\n          };\n          symbolPicks.push(lastSeparator);\n        }\n        // Existing kind, keep counting\n        else {\n          lastSymbolKindCounter++;\n        }\n        // Add to final result\n        symbolPicks.push(symbolPick);\n      }\n      // Update last separator with number of symbols we found for kind\n      updateLastSeparatorLabel();\n    } else if (sortedFilteredSymbolPicks.length > 0) {\n      symbolPicks = [{\n        label: localize('symbols', \"symbols ({0})\", filteredSymbolPicks.length),\n        type: 'separator'\n      }, ...sortedFilteredSymbolPicks];\n    }\n    return symbolPicks;\n  }\n  compareByScore(symbolA, symbolB) {\n    if (typeof symbolA.score !== 'number' && typeof symbolB.score === 'number') {\n      return 1;\n    } else if (typeof symbolA.score === 'number' && typeof symbolB.score !== 'number') {\n      return -1;\n    }\n    if (typeof symbolA.score === 'number' && typeof symbolB.score === 'number') {\n      if (symbolA.score > symbolB.score) {\n        return -1;\n      } else if (symbolA.score < symbolB.score) {\n        return 1;\n      }\n    }\n    if (symbolA.index < symbolB.index) {\n      return -1;\n    } else if (symbolA.index > symbolB.index) {\n      return 1;\n    }\n    return 0;\n  }\n  compareByKindAndScore(symbolA, symbolB) {\n    const kindA = NLS_SYMBOL_KIND_CACHE[symbolA.kind] || FALLBACK_NLS_SYMBOL_KIND;\n    const kindB = NLS_SYMBOL_KIND_CACHE[symbolB.kind] || FALLBACK_NLS_SYMBOL_KIND;\n    // Sort by type first if scoped search\n    const result = kindA.localeCompare(kindB);\n    if (result === 0) {\n      return this.compareByScore(symbolA, symbolB);\n    }\n    return result;\n  }\n  async getDocumentSymbols(document, token) {\n    const model = await this._outlineModelService.getOrCreate(document, token);\n    return token.isCancellationRequested ? [] : model.asListOfDocumentSymbols();\n  }\n};\nAbstractGotoSymbolQuickAccessProvider.PREFIX = '@';\nAbstractGotoSymbolQuickAccessProvider.SCOPE_PREFIX = ':';\nAbstractGotoSymbolQuickAccessProvider.PREFIX_BY_CATEGORY = `${AbstractGotoSymbolQuickAccessProvider_1.PREFIX}${AbstractGotoSymbolQuickAccessProvider_1.SCOPE_PREFIX}`;\nAbstractGotoSymbolQuickAccessProvider = AbstractGotoSymbolQuickAccessProvider_1 = __decorate([__param(0, ILanguageFeaturesService), __param(1, IOutlineModelService)], AbstractGotoSymbolQuickAccessProvider);\nexport { AbstractGotoSymbolQuickAccessProvider };\n// #region NLS Helpers\nconst FALLBACK_NLS_SYMBOL_KIND = localize('property', \"properties ({0})\");\nconst NLS_SYMBOL_KIND_CACHE = {\n  [5 /* SymbolKind.Method */]: localize('method', \"methods ({0})\"),\n  [11 /* SymbolKind.Function */]: localize('function', \"functions ({0})\"),\n  [8 /* SymbolKind.Constructor */]: localize('_constructor', \"constructors ({0})\"),\n  [12 /* SymbolKind.Variable */]: localize('variable', \"variables ({0})\"),\n  [4 /* SymbolKind.Class */]: localize('class', \"classes ({0})\"),\n  [22 /* SymbolKind.Struct */]: localize('struct', \"structs ({0})\"),\n  [23 /* SymbolKind.Event */]: localize('event', \"events ({0})\"),\n  [24 /* SymbolKind.Operator */]: localize('operator', \"operators ({0})\"),\n  [10 /* SymbolKind.Interface */]: localize('interface', \"interfaces ({0})\"),\n  [2 /* SymbolKind.Namespace */]: localize('namespace', \"namespaces ({0})\"),\n  [3 /* SymbolKind.Package */]: localize('package', \"packages ({0})\"),\n  [25 /* SymbolKind.TypeParameter */]: localize('typeParameter', \"type parameters ({0})\"),\n  [1 /* SymbolKind.Module */]: localize('modules', \"modules ({0})\"),\n  [6 /* SymbolKind.Property */]: localize('property', \"properties ({0})\"),\n  [9 /* SymbolKind.Enum */]: localize('enum', \"enumerations ({0})\"),\n  [21 /* SymbolKind.EnumMember */]: localize('enumMember', \"enumeration members ({0})\"),\n  [14 /* SymbolKind.String */]: localize('string', \"strings ({0})\"),\n  [0 /* SymbolKind.File */]: localize('file', \"files ({0})\"),\n  [17 /* SymbolKind.Array */]: localize('array', \"arrays ({0})\"),\n  [15 /* SymbolKind.Number */]: localize('number', \"numbers ({0})\"),\n  [16 /* SymbolKind.Boolean */]: localize('boolean', \"booleans ({0})\"),\n  [18 /* SymbolKind.Object */]: localize('object', \"objects ({0})\"),\n  [19 /* SymbolKind.Key */]: localize('key', \"keys ({0})\"),\n  [7 /* SymbolKind.Field */]: localize('field', \"fields ({0})\"),\n  [13 /* SymbolKind.Constant */]: localize('constant', \"constants ({0})\")\n};\n//#endregion","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","AbstractGotoSymbolQuickAccessProvider_1","DeferredPromise","CancellationTokenSource","Codicon","ThemeIcon","pieceToQuery","prepareQuery","scoreFuzzy2","Disposable","DisposableStore","toDisposable","format","trim","Range","SymbolKinds","getAriaLabelForSymbol","IOutlineModelService","AbstractEditorNavigationQuickAccessProvider","localize","ILanguageFeaturesService","findLast","AbstractGotoSymbolQuickAccessProvider","constructor","_languageFeaturesService","_outlineModelService","options","undefined","create","canAcceptInBackground","provideWithoutTextEditor","picker","provideLabelPick","None","provideWithTextEditor","context","token","runOptions","editor","model","getModel","documentSymbolProvider","has","doProvideWithEditorSymbols","doProvideWithoutEditorSymbols","disposables","result","waitForLanguageSymbolRegistry","isCancellationRequested","add","label","items","index","kind","ariaLabel","symbolProviderRegistryPromise","symbolProviderListener","onDidChange","dispose","complete","p","_a","onDidAccept","event","item","selectedItems","range","gotoLocation","selection","keyMods","preserveFocus","inBackground","handleAccept","call","hide","onDidTriggerItemButton","_ref","forceSideBySide","symbolsPromise","getDocumentSymbols","picksCts","updatePickerItems","positionToEnclose","busy","query","value","substr","PREFIX","doGetSymbolPicks","original","candidate","Boolean","type","containsPosition","decoration","activeItems","onDidChangeValue","getSelection","getPosition","onDidChangeActive","revealRangeInCenter","addDecorations","_b","symbols","filterBySymbolKind","indexOf","SCOPE_PREFIX","filterPos","symbolQuery","containerQuery","values","slice","buttons","openSideBySideDirection","iconClass","asClassName","splitHorizontal","splitVertical","tooltip","filteredSymbolPicks","symbol","symbolLabel","name","symbolLabelWithIcon","toIcon","id","symbolLabelIconOffset","containerLabel","containerName","extraContainerLabel","symbolScore","symbolMatches","containerScore","containerMatches","skipContainerQuery","deprecated","tags","push","score","description","highlights","collapseToStart","selectionRange","uri","symbolName","strikethrough","sortedFilteredSymbolPicks","sort","symbolA","symbolB","compareByKindAndScore","compareByScore","symbolPicks","lastSymbolKind","lastSeparator","lastSymbolKindCounter","updateLastSeparatorLabel","NLS_SYMBOL_KIND_CACHE","FALLBACK_NLS_SYMBOL_KIND","symbolPick","kindA","kindB","localeCompare","document","getOrCreate","asListOfDocumentSymbols","PREFIX_BY_CATEGORY"],"sources":["/home/arslan/modojo/node_modules/monaco-editor/esm/vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar AbstractGotoSymbolQuickAccessProvider_1;\nimport { DeferredPromise } from '../../../../base/common/async.js';\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { Codicon } from '../../../../base/common/codicons.js';\nimport { ThemeIcon } from '../../../../base/common/themables.js';\nimport { pieceToQuery, prepareQuery, scoreFuzzy2 } from '../../../../base/common/fuzzyScorer.js';\nimport { Disposable, DisposableStore, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { format, trim } from '../../../../base/common/strings.js';\nimport { Range } from '../../../common/core/range.js';\nimport { SymbolKinds, getAriaLabelForSymbol } from '../../../common/languages.js';\nimport { IOutlineModelService } from '../../documentSymbols/browser/outlineModel.js';\nimport { AbstractEditorNavigationQuickAccessProvider } from './editorNavigationQuickAccess.js';\nimport { localize } from '../../../../nls.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nimport { findLast } from '../../../../base/common/arraysFind.js';\nlet AbstractGotoSymbolQuickAccessProvider = AbstractGotoSymbolQuickAccessProvider_1 = class AbstractGotoSymbolQuickAccessProvider extends AbstractEditorNavigationQuickAccessProvider {\n    constructor(_languageFeaturesService, _outlineModelService, options = Object.create(null)) {\n        super(options);\n        this._languageFeaturesService = _languageFeaturesService;\n        this._outlineModelService = _outlineModelService;\n        this.options = options;\n        this.options.canAcceptInBackground = true;\n    }\n    provideWithoutTextEditor(picker) {\n        this.provideLabelPick(picker, localize('cannotRunGotoSymbolWithoutEditor', \"To go to a symbol, first open a text editor with symbol information.\"));\n        return Disposable.None;\n    }\n    provideWithTextEditor(context, picker, token, runOptions) {\n        const editor = context.editor;\n        const model = this.getModel(editor);\n        if (!model) {\n            return Disposable.None;\n        }\n        // Provide symbols from model if available in registry\n        if (this._languageFeaturesService.documentSymbolProvider.has(model)) {\n            return this.doProvideWithEditorSymbols(context, model, picker, token, runOptions);\n        }\n        // Otherwise show an entry for a model without registry\n        // But give a chance to resolve the symbols at a later\n        // point if possible\n        return this.doProvideWithoutEditorSymbols(context, model, picker, token);\n    }\n    doProvideWithoutEditorSymbols(context, model, picker, token) {\n        const disposables = new DisposableStore();\n        // Generic pick for not having any symbol information\n        this.provideLabelPick(picker, localize('cannotRunGotoSymbolWithoutSymbolProvider', \"The active text editor does not provide symbol information.\"));\n        // Wait for changes to the registry and see if eventually\n        // we do get symbols. This can happen if the picker is opened\n        // very early after the model has loaded but before the\n        // language registry is ready.\n        // https://github.com/microsoft/vscode/issues/70607\n        (async () => {\n            const result = await this.waitForLanguageSymbolRegistry(model, disposables);\n            if (!result || token.isCancellationRequested) {\n                return;\n            }\n            disposables.add(this.doProvideWithEditorSymbols(context, model, picker, token));\n        })();\n        return disposables;\n    }\n    provideLabelPick(picker, label) {\n        picker.items = [{ label, index: 0, kind: 14 /* SymbolKind.String */ }];\n        picker.ariaLabel = label;\n    }\n    async waitForLanguageSymbolRegistry(model, disposables) {\n        if (this._languageFeaturesService.documentSymbolProvider.has(model)) {\n            return true;\n        }\n        const symbolProviderRegistryPromise = new DeferredPromise();\n        // Resolve promise when registry knows model\n        const symbolProviderListener = disposables.add(this._languageFeaturesService.documentSymbolProvider.onDidChange(() => {\n            if (this._languageFeaturesService.documentSymbolProvider.has(model)) {\n                symbolProviderListener.dispose();\n                symbolProviderRegistryPromise.complete(true);\n            }\n        }));\n        // Resolve promise when we get disposed too\n        disposables.add(toDisposable(() => symbolProviderRegistryPromise.complete(false)));\n        return symbolProviderRegistryPromise.p;\n    }\n    doProvideWithEditorSymbols(context, model, picker, token, runOptions) {\n        var _a;\n        const editor = context.editor;\n        const disposables = new DisposableStore();\n        // Goto symbol once picked\n        disposables.add(picker.onDidAccept(event => {\n            var _a;\n            const [item] = picker.selectedItems;\n            if (item && item.range) {\n                this.gotoLocation(context, { range: item.range.selection, keyMods: picker.keyMods, preserveFocus: event.inBackground });\n                (_a = runOptions === null || runOptions === void 0 ? void 0 : runOptions.handleAccept) === null || _a === void 0 ? void 0 : _a.call(runOptions, item);\n                if (!event.inBackground) {\n                    picker.hide();\n                }\n            }\n        }));\n        // Goto symbol side by side if enabled\n        disposables.add(picker.onDidTriggerItemButton(({ item }) => {\n            if (item && item.range) {\n                this.gotoLocation(context, { range: item.range.selection, keyMods: picker.keyMods, forceSideBySide: true });\n                picker.hide();\n            }\n        }));\n        // Resolve symbols from document once and reuse this\n        // request for all filtering and typing then on\n        const symbolsPromise = this.getDocumentSymbols(model, token);\n        // Set initial picks and update on type\n        let picksCts = undefined;\n        const updatePickerItems = async (positionToEnclose) => {\n            // Cancel any previous ask for picks and busy\n            picksCts === null || picksCts === void 0 ? void 0 : picksCts.dispose(true);\n            picker.busy = false;\n            // Create new cancellation source for this run\n            picksCts = new CancellationTokenSource(token);\n            // Collect symbol picks\n            picker.busy = true;\n            try {\n                const query = prepareQuery(picker.value.substr(AbstractGotoSymbolQuickAccessProvider_1.PREFIX.length).trim());\n                const items = await this.doGetSymbolPicks(symbolsPromise, query, undefined, picksCts.token, model);\n                if (token.isCancellationRequested) {\n                    return;\n                }\n                if (items.length > 0) {\n                    picker.items = items;\n                    if (positionToEnclose && query.original.length === 0) {\n                        const candidate = findLast(items, item => Boolean(item.type !== 'separator' && item.range && Range.containsPosition(item.range.decoration, positionToEnclose)));\n                        if (candidate) {\n                            picker.activeItems = [candidate];\n                        }\n                    }\n                }\n                else {\n                    if (query.original.length > 0) {\n                        this.provideLabelPick(picker, localize('noMatchingSymbolResults', \"No matching editor symbols\"));\n                    }\n                    else {\n                        this.provideLabelPick(picker, localize('noSymbolResults', \"No editor symbols\"));\n                    }\n                }\n            }\n            finally {\n                if (!token.isCancellationRequested) {\n                    picker.busy = false;\n                }\n            }\n        };\n        disposables.add(picker.onDidChangeValue(() => updatePickerItems(undefined)));\n        updatePickerItems((_a = editor.getSelection()) === null || _a === void 0 ? void 0 : _a.getPosition());\n        // Reveal and decorate when active item changes\n        disposables.add(picker.onDidChangeActive(() => {\n            const [item] = picker.activeItems;\n            if (item && item.range) {\n                // Reveal\n                editor.revealRangeInCenter(item.range.selection, 0 /* ScrollType.Smooth */);\n                // Decorate\n                this.addDecorations(editor, item.range.decoration);\n            }\n        }));\n        return disposables;\n    }\n    async doGetSymbolPicks(symbolsPromise, query, options, token, model) {\n        var _a, _b;\n        const symbols = await symbolsPromise;\n        if (token.isCancellationRequested) {\n            return [];\n        }\n        const filterBySymbolKind = query.original.indexOf(AbstractGotoSymbolQuickAccessProvider_1.SCOPE_PREFIX) === 0;\n        const filterPos = filterBySymbolKind ? 1 : 0;\n        // Split between symbol and container query\n        let symbolQuery;\n        let containerQuery;\n        if (query.values && query.values.length > 1) {\n            symbolQuery = pieceToQuery(query.values[0]); // symbol: only match on first part\n            containerQuery = pieceToQuery(query.values.slice(1)); // container: match on all but first parts\n        }\n        else {\n            symbolQuery = query;\n        }\n        // Convert to symbol picks and apply filtering\n        let buttons;\n        const openSideBySideDirection = (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.openSideBySideDirection) === null || _b === void 0 ? void 0 : _b.call(_a);\n        if (openSideBySideDirection) {\n            buttons = [{\n                    iconClass: openSideBySideDirection === 'right' ? ThemeIcon.asClassName(Codicon.splitHorizontal) : ThemeIcon.asClassName(Codicon.splitVertical),\n                    tooltip: openSideBySideDirection === 'right' ? localize('openToSide', \"Open to the Side\") : localize('openToBottom', \"Open to the Bottom\")\n                }];\n        }\n        const filteredSymbolPicks = [];\n        for (let index = 0; index < symbols.length; index++) {\n            const symbol = symbols[index];\n            const symbolLabel = trim(symbol.name);\n            const symbolLabelWithIcon = `$(${SymbolKinds.toIcon(symbol.kind).id}) ${symbolLabel}`;\n            const symbolLabelIconOffset = symbolLabelWithIcon.length - symbolLabel.length;\n            let containerLabel = symbol.containerName;\n            if (options === null || options === void 0 ? void 0 : options.extraContainerLabel) {\n                if (containerLabel) {\n                    containerLabel = `${options.extraContainerLabel} • ${containerLabel}`;\n                }\n                else {\n                    containerLabel = options.extraContainerLabel;\n                }\n            }\n            let symbolScore = undefined;\n            let symbolMatches = undefined;\n            let containerScore = undefined;\n            let containerMatches = undefined;\n            if (query.original.length > filterPos) {\n                // First: try to score on the entire query, it is possible that\n                // the symbol matches perfectly (e.g. searching for \"change log\"\n                // can be a match on a markdown symbol \"change log\"). In that\n                // case we want to skip the container query altogether.\n                let skipContainerQuery = false;\n                if (symbolQuery !== query) {\n                    [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, { ...query, values: undefined /* disable multi-query support */ }, filterPos, symbolLabelIconOffset);\n                    if (typeof symbolScore === 'number') {\n                        skipContainerQuery = true; // since we consumed the query, skip any container matching\n                    }\n                }\n                // Otherwise: score on the symbol query and match on the container later\n                if (typeof symbolScore !== 'number') {\n                    [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, symbolQuery, filterPos, symbolLabelIconOffset);\n                    if (typeof symbolScore !== 'number') {\n                        continue;\n                    }\n                }\n                // Score by container if specified\n                if (!skipContainerQuery && containerQuery) {\n                    if (containerLabel && containerQuery.original.length > 0) {\n                        [containerScore, containerMatches] = scoreFuzzy2(containerLabel, containerQuery);\n                    }\n                    if (typeof containerScore !== 'number') {\n                        continue;\n                    }\n                    if (typeof symbolScore === 'number') {\n                        symbolScore += containerScore; // boost symbolScore by containerScore\n                    }\n                }\n            }\n            const deprecated = symbol.tags && symbol.tags.indexOf(1 /* SymbolTag.Deprecated */) >= 0;\n            filteredSymbolPicks.push({\n                index,\n                kind: symbol.kind,\n                score: symbolScore,\n                label: symbolLabelWithIcon,\n                ariaLabel: getAriaLabelForSymbol(symbol.name, symbol.kind),\n                description: containerLabel,\n                highlights: deprecated ? undefined : {\n                    label: symbolMatches,\n                    description: containerMatches\n                },\n                range: {\n                    selection: Range.collapseToStart(symbol.selectionRange),\n                    decoration: symbol.range\n                },\n                uri: model.uri,\n                symbolName: symbolLabel,\n                strikethrough: deprecated,\n                buttons\n            });\n        }\n        // Sort by score\n        const sortedFilteredSymbolPicks = filteredSymbolPicks.sort((symbolA, symbolB) => filterBySymbolKind ?\n            this.compareByKindAndScore(symbolA, symbolB) :\n            this.compareByScore(symbolA, symbolB));\n        // Add separator for types\n        // - @  only total number of symbols\n        // - @: grouped by symbol kind\n        let symbolPicks = [];\n        if (filterBySymbolKind) {\n            let lastSymbolKind = undefined;\n            let lastSeparator = undefined;\n            let lastSymbolKindCounter = 0;\n            function updateLastSeparatorLabel() {\n                if (lastSeparator && typeof lastSymbolKind === 'number' && lastSymbolKindCounter > 0) {\n                    lastSeparator.label = format(NLS_SYMBOL_KIND_CACHE[lastSymbolKind] || FALLBACK_NLS_SYMBOL_KIND, lastSymbolKindCounter);\n                }\n            }\n            for (const symbolPick of sortedFilteredSymbolPicks) {\n                // Found new kind\n                if (lastSymbolKind !== symbolPick.kind) {\n                    // Update last separator with number of symbols we found for kind\n                    updateLastSeparatorLabel();\n                    lastSymbolKind = symbolPick.kind;\n                    lastSymbolKindCounter = 1;\n                    // Add new separator for new kind\n                    lastSeparator = { type: 'separator' };\n                    symbolPicks.push(lastSeparator);\n                }\n                // Existing kind, keep counting\n                else {\n                    lastSymbolKindCounter++;\n                }\n                // Add to final result\n                symbolPicks.push(symbolPick);\n            }\n            // Update last separator with number of symbols we found for kind\n            updateLastSeparatorLabel();\n        }\n        else if (sortedFilteredSymbolPicks.length > 0) {\n            symbolPicks = [\n                { label: localize('symbols', \"symbols ({0})\", filteredSymbolPicks.length), type: 'separator' },\n                ...sortedFilteredSymbolPicks\n            ];\n        }\n        return symbolPicks;\n    }\n    compareByScore(symbolA, symbolB) {\n        if (typeof symbolA.score !== 'number' && typeof symbolB.score === 'number') {\n            return 1;\n        }\n        else if (typeof symbolA.score === 'number' && typeof symbolB.score !== 'number') {\n            return -1;\n        }\n        if (typeof symbolA.score === 'number' && typeof symbolB.score === 'number') {\n            if (symbolA.score > symbolB.score) {\n                return -1;\n            }\n            else if (symbolA.score < symbolB.score) {\n                return 1;\n            }\n        }\n        if (symbolA.index < symbolB.index) {\n            return -1;\n        }\n        else if (symbolA.index > symbolB.index) {\n            return 1;\n        }\n        return 0;\n    }\n    compareByKindAndScore(symbolA, symbolB) {\n        const kindA = NLS_SYMBOL_KIND_CACHE[symbolA.kind] || FALLBACK_NLS_SYMBOL_KIND;\n        const kindB = NLS_SYMBOL_KIND_CACHE[symbolB.kind] || FALLBACK_NLS_SYMBOL_KIND;\n        // Sort by type first if scoped search\n        const result = kindA.localeCompare(kindB);\n        if (result === 0) {\n            return this.compareByScore(symbolA, symbolB);\n        }\n        return result;\n    }\n    async getDocumentSymbols(document, token) {\n        const model = await this._outlineModelService.getOrCreate(document, token);\n        return token.isCancellationRequested ? [] : model.asListOfDocumentSymbols();\n    }\n};\nAbstractGotoSymbolQuickAccessProvider.PREFIX = '@';\nAbstractGotoSymbolQuickAccessProvider.SCOPE_PREFIX = ':';\nAbstractGotoSymbolQuickAccessProvider.PREFIX_BY_CATEGORY = `${AbstractGotoSymbolQuickAccessProvider_1.PREFIX}${AbstractGotoSymbolQuickAccessProvider_1.SCOPE_PREFIX}`;\nAbstractGotoSymbolQuickAccessProvider = AbstractGotoSymbolQuickAccessProvider_1 = __decorate([\n    __param(0, ILanguageFeaturesService),\n    __param(1, IOutlineModelService)\n], AbstractGotoSymbolQuickAccessProvider);\nexport { AbstractGotoSymbolQuickAccessProvider };\n// #region NLS Helpers\nconst FALLBACK_NLS_SYMBOL_KIND = localize('property', \"properties ({0})\");\nconst NLS_SYMBOL_KIND_CACHE = {\n    [5 /* SymbolKind.Method */]: localize('method', \"methods ({0})\"),\n    [11 /* SymbolKind.Function */]: localize('function', \"functions ({0})\"),\n    [8 /* SymbolKind.Constructor */]: localize('_constructor', \"constructors ({0})\"),\n    [12 /* SymbolKind.Variable */]: localize('variable', \"variables ({0})\"),\n    [4 /* SymbolKind.Class */]: localize('class', \"classes ({0})\"),\n    [22 /* SymbolKind.Struct */]: localize('struct', \"structs ({0})\"),\n    [23 /* SymbolKind.Event */]: localize('event', \"events ({0})\"),\n    [24 /* SymbolKind.Operator */]: localize('operator', \"operators ({0})\"),\n    [10 /* SymbolKind.Interface */]: localize('interface', \"interfaces ({0})\"),\n    [2 /* SymbolKind.Namespace */]: localize('namespace', \"namespaces ({0})\"),\n    [3 /* SymbolKind.Package */]: localize('package', \"packages ({0})\"),\n    [25 /* SymbolKind.TypeParameter */]: localize('typeParameter', \"type parameters ({0})\"),\n    [1 /* SymbolKind.Module */]: localize('modules', \"modules ({0})\"),\n    [6 /* SymbolKind.Property */]: localize('property', \"properties ({0})\"),\n    [9 /* SymbolKind.Enum */]: localize('enum', \"enumerations ({0})\"),\n    [21 /* SymbolKind.EnumMember */]: localize('enumMember', \"enumeration members ({0})\"),\n    [14 /* SymbolKind.String */]: localize('string', \"strings ({0})\"),\n    [0 /* SymbolKind.File */]: localize('file', \"files ({0})\"),\n    [17 /* SymbolKind.Array */]: localize('array', \"arrays ({0})\"),\n    [15 /* SymbolKind.Number */]: localize('number', \"numbers ({0})\"),\n    [16 /* SymbolKind.Boolean */]: localize('boolean', \"booleans ({0})\"),\n    [18 /* SymbolKind.Object */]: localize('object', \"objects ({0})\"),\n    [19 /* SymbolKind.Key */]: localize('key', \"keys ({0})\"),\n    [7 /* SymbolKind.Field */]: localize('field', \"fields ({0})\"),\n    [13 /* SymbolKind.Constant */]: localize('constant', \"constants ({0})\")\n};\n//#endregion\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,IAAIA,UAAU,GAAI,IAAI,IAAI,IAAI,CAACA,UAAU,IAAK,UAAUC,UAAU,EAAEC,MAAM,EAAEC,GAAG,EAAEC,IAAI,EAAE;EACnF,IAAIC,CAAC,GAAGC,SAAS,CAACC,MAAM;IAAEC,CAAC,GAAGH,CAAC,GAAG,CAAC,GAAGH,MAAM,GAAGE,IAAI,KAAK,IAAI,GAAGA,IAAI,GAAGK,MAAM,CAACC,wBAAwB,CAACR,MAAM,EAAEC,GAAG,CAAC,GAAGC,IAAI;IAAEO,CAAC;EAC5H,IAAI,OAAOC,OAAO,KAAK,QAAQ,IAAI,OAAOA,OAAO,CAACC,QAAQ,KAAK,UAAU,EAAEL,CAAC,GAAGI,OAAO,CAACC,QAAQ,CAACZ,UAAU,EAAEC,MAAM,EAAEC,GAAG,EAAEC,IAAI,CAAC,CAAC,KAC1H,KAAK,IAAIU,CAAC,GAAGb,UAAU,CAACM,MAAM,GAAG,CAAC,EAAEO,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE,IAAIH,CAAC,GAAGV,UAAU,CAACa,CAAC,CAAC,EAAEN,CAAC,GAAG,CAACH,CAAC,GAAG,CAAC,GAAGM,CAAC,CAACH,CAAC,CAAC,GAAGH,CAAC,GAAG,CAAC,GAAGM,CAAC,CAACT,MAAM,EAAEC,GAAG,EAAEK,CAAC,CAAC,GAAGG,CAAC,CAACT,MAAM,EAAEC,GAAG,CAAC,KAAKK,CAAC;EACjJ,OAAOH,CAAC,GAAG,CAAC,IAAIG,CAAC,IAAIC,MAAM,CAACM,cAAc,CAACb,MAAM,EAAEC,GAAG,EAAEK,CAAC,CAAC,EAAEA,CAAC;AACjE,CAAC;AACD,IAAIQ,OAAO,GAAI,IAAI,IAAI,IAAI,CAACA,OAAO,IAAK,UAAUC,UAAU,EAAEC,SAAS,EAAE;EACrE,OAAO,UAAUhB,MAAM,EAAEC,GAAG,EAAE;IAAEe,SAAS,CAAChB,MAAM,EAAEC,GAAG,EAAEc,UAAU,CAAC;EAAE,CAAC;AACzE,CAAC;AACD,IAAIE,uCAAuC;AAC3C,SAASC,eAAe,QAAQ,kCAAkC;AAClE,SAASC,uBAAuB,QAAQ,yCAAyC;AACjF,SAASC,OAAO,QAAQ,qCAAqC;AAC7D,SAASC,SAAS,QAAQ,sCAAsC;AAChE,SAASC,YAAY,EAAEC,YAAY,EAAEC,WAAW,QAAQ,wCAAwC;AAChG,SAASC,UAAU,EAAEC,eAAe,EAAEC,YAAY,QAAQ,sCAAsC;AAChG,SAASC,MAAM,EAAEC,IAAI,QAAQ,oCAAoC;AACjE,SAASC,KAAK,QAAQ,+BAA+B;AACrD,SAASC,WAAW,EAAEC,qBAAqB,QAAQ,8BAA8B;AACjF,SAASC,oBAAoB,QAAQ,+CAA+C;AACpF,SAASC,2CAA2C,QAAQ,kCAAkC;AAC9F,SAASC,QAAQ,QAAQ,oBAAoB;AAC7C,SAASC,wBAAwB,QAAQ,8CAA8C;AACvF,SAASC,QAAQ,QAAQ,uCAAuC;AAChE,IAAIC,qCAAqC,GAAGrB,uCAAuC,GAAG,MAAMqB,qCAAqC,SAASJ,2CAA2C,CAAC;EAClLK,WAAWA,CAACC,wBAAwB,EAAEC,oBAAoB,EAAiC;IAAA,IAA/BC,OAAO,GAAAtC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAuC,SAAA,GAAAvC,SAAA,MAAGG,MAAM,CAACqC,MAAM,CAAC,IAAI,CAAC;IACrF,KAAK,CAACF,OAAO,CAAC;IACd,IAAI,CAACF,wBAAwB,GAAGA,wBAAwB;IACxD,IAAI,CAACC,oBAAoB,GAAGA,oBAAoB;IAChD,IAAI,CAACC,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACA,OAAO,CAACG,qBAAqB,GAAG,IAAI;EAC7C;EACAC,wBAAwBA,CAACC,MAAM,EAAE;IAC7B,IAAI,CAACC,gBAAgB,CAACD,MAAM,EAAEZ,QAAQ,CAAC,kCAAkC,EAAE,sEAAsE,CAAC,CAAC;IACnJ,OAAOV,UAAU,CAACwB,IAAI;EAC1B;EACAC,qBAAqBA,CAACC,OAAO,EAAEJ,MAAM,EAAEK,KAAK,EAAEC,UAAU,EAAE;IACtD,MAAMC,MAAM,GAAGH,OAAO,CAACG,MAAM;IAC7B,MAAMC,KAAK,GAAG,IAAI,CAACC,QAAQ,CAACF,MAAM,CAAC;IACnC,IAAI,CAACC,KAAK,EAAE;MACR,OAAO9B,UAAU,CAACwB,IAAI;IAC1B;IACA;IACA,IAAI,IAAI,CAACT,wBAAwB,CAACiB,sBAAsB,CAACC,GAAG,CAACH,KAAK,CAAC,EAAE;MACjE,OAAO,IAAI,CAACI,0BAA0B,CAACR,OAAO,EAAEI,KAAK,EAAER,MAAM,EAAEK,KAAK,EAAEC,UAAU,CAAC;IACrF;IACA;IACA;IACA;IACA,OAAO,IAAI,CAACO,6BAA6B,CAACT,OAAO,EAAEI,KAAK,EAAER,MAAM,EAAEK,KAAK,CAAC;EAC5E;EACAQ,6BAA6BA,CAACT,OAAO,EAAEI,KAAK,EAAER,MAAM,EAAEK,KAAK,EAAE;IACzD,MAAMS,WAAW,GAAG,IAAInC,eAAe,CAAC,CAAC;IACzC;IACA,IAAI,CAACsB,gBAAgB,CAACD,MAAM,EAAEZ,QAAQ,CAAC,0CAA0C,EAAE,6DAA6D,CAAC,CAAC;IAClJ;IACA;IACA;IACA;IACA;IACA,CAAC,YAAY;MACT,MAAM2B,MAAM,GAAG,MAAM,IAAI,CAACC,6BAA6B,CAACR,KAAK,EAAEM,WAAW,CAAC;MAC3E,IAAI,CAACC,MAAM,IAAIV,KAAK,CAACY,uBAAuB,EAAE;QAC1C;MACJ;MACAH,WAAW,CAACI,GAAG,CAAC,IAAI,CAACN,0BAA0B,CAACR,OAAO,EAAEI,KAAK,EAAER,MAAM,EAAEK,KAAK,CAAC,CAAC;IACnF,CAAC,EAAE,CAAC;IACJ,OAAOS,WAAW;EACtB;EACAb,gBAAgBA,CAACD,MAAM,EAAEmB,KAAK,EAAE;IAC5BnB,MAAM,CAACoB,KAAK,GAAG,CAAC;MAAED,KAAK;MAAEE,KAAK,EAAE,CAAC;MAAEC,IAAI,EAAE,EAAE,CAAC;IAAwB,CAAC,CAAC;IACtEtB,MAAM,CAACuB,SAAS,GAAGJ,KAAK;EAC5B;EACA,MAAMH,6BAA6BA,CAACR,KAAK,EAAEM,WAAW,EAAE;IACpD,IAAI,IAAI,CAACrB,wBAAwB,CAACiB,sBAAsB,CAACC,GAAG,CAACH,KAAK,CAAC,EAAE;MACjE,OAAO,IAAI;IACf;IACA,MAAMgB,6BAA6B,GAAG,IAAIrD,eAAe,CAAC,CAAC;IAC3D;IACA,MAAMsD,sBAAsB,GAAGX,WAAW,CAACI,GAAG,CAAC,IAAI,CAACzB,wBAAwB,CAACiB,sBAAsB,CAACgB,WAAW,CAAC,MAAM;MAClH,IAAI,IAAI,CAACjC,wBAAwB,CAACiB,sBAAsB,CAACC,GAAG,CAACH,KAAK,CAAC,EAAE;QACjEiB,sBAAsB,CAACE,OAAO,CAAC,CAAC;QAChCH,6BAA6B,CAACI,QAAQ,CAAC,IAAI,CAAC;MAChD;IACJ,CAAC,CAAC,CAAC;IACH;IACAd,WAAW,CAACI,GAAG,CAACtC,YAAY,CAAC,MAAM4C,6BAA6B,CAACI,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC;IAClF,OAAOJ,6BAA6B,CAACK,CAAC;EAC1C;EACAjB,0BAA0BA,CAACR,OAAO,EAAEI,KAAK,EAAER,MAAM,EAAEK,KAAK,EAAEC,UAAU,EAAE;IAClE,IAAIwB,EAAE;IACN,MAAMvB,MAAM,GAAGH,OAAO,CAACG,MAAM;IAC7B,MAAMO,WAAW,GAAG,IAAInC,eAAe,CAAC,CAAC;IACzC;IACAmC,WAAW,CAACI,GAAG,CAAClB,MAAM,CAAC+B,WAAW,CAACC,KAAK,IAAI;MACxC,IAAIF,EAAE;MACN,MAAM,CAACG,IAAI,CAAC,GAAGjC,MAAM,CAACkC,aAAa;MACnC,IAAID,IAAI,IAAIA,IAAI,CAACE,KAAK,EAAE;QACpB,IAAI,CAACC,YAAY,CAAChC,OAAO,EAAE;UAAE+B,KAAK,EAAEF,IAAI,CAACE,KAAK,CAACE,SAAS;UAAEC,OAAO,EAAEtC,MAAM,CAACsC,OAAO;UAAEC,aAAa,EAAEP,KAAK,CAACQ;QAAa,CAAC,CAAC;QACvH,CAACV,EAAE,GAAGxB,UAAU,KAAK,IAAI,IAAIA,UAAU,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,UAAU,CAACmC,YAAY,MAAM,IAAI,IAAIX,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACY,IAAI,CAACpC,UAAU,EAAE2B,IAAI,CAAC;QACrJ,IAAI,CAACD,KAAK,CAACQ,YAAY,EAAE;UACrBxC,MAAM,CAAC2C,IAAI,CAAC,CAAC;QACjB;MACJ;IACJ,CAAC,CAAC,CAAC;IACH;IACA7B,WAAW,CAACI,GAAG,CAAClB,MAAM,CAAC4C,sBAAsB,CAACC,IAAA,IAAc;MAAA,IAAb;QAAEZ;MAAK,CAAC,GAAAY,IAAA;MACnD,IAAIZ,IAAI,IAAIA,IAAI,CAACE,KAAK,EAAE;QACpB,IAAI,CAACC,YAAY,CAAChC,OAAO,EAAE;UAAE+B,KAAK,EAAEF,IAAI,CAACE,KAAK,CAACE,SAAS;UAAEC,OAAO,EAAEtC,MAAM,CAACsC,OAAO;UAAEQ,eAAe,EAAE;QAAK,CAAC,CAAC;QAC3G9C,MAAM,CAAC2C,IAAI,CAAC,CAAC;MACjB;IACJ,CAAC,CAAC,CAAC;IACH;IACA;IACA,MAAMI,cAAc,GAAG,IAAI,CAACC,kBAAkB,CAACxC,KAAK,EAAEH,KAAK,CAAC;IAC5D;IACA,IAAI4C,QAAQ,GAAGrD,SAAS;IACxB,MAAMsD,iBAAiB,GAAG,MAAOC,iBAAiB,IAAK;MACnD;MACAF,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,QAAQ,CAACtB,OAAO,CAAC,IAAI,CAAC;MAC1E3B,MAAM,CAACoD,IAAI,GAAG,KAAK;MACnB;MACAH,QAAQ,GAAG,IAAI7E,uBAAuB,CAACiC,KAAK,CAAC;MAC7C;MACAL,MAAM,CAACoD,IAAI,GAAG,IAAI;MAClB,IAAI;QACA,MAAMC,KAAK,GAAG7E,YAAY,CAACwB,MAAM,CAACsD,KAAK,CAACC,MAAM,CAACrF,uCAAuC,CAACsF,MAAM,CAAClG,MAAM,CAAC,CAACwB,IAAI,CAAC,CAAC,CAAC;QAC7G,MAAMsC,KAAK,GAAG,MAAM,IAAI,CAACqC,gBAAgB,CAACV,cAAc,EAAEM,KAAK,EAAEzD,SAAS,EAAEqD,QAAQ,CAAC5C,KAAK,EAAEG,KAAK,CAAC;QAClG,IAAIH,KAAK,CAACY,uBAAuB,EAAE;UAC/B;QACJ;QACA,IAAIG,KAAK,CAAC9D,MAAM,GAAG,CAAC,EAAE;UAClB0C,MAAM,CAACoB,KAAK,GAAGA,KAAK;UACpB,IAAI+B,iBAAiB,IAAIE,KAAK,CAACK,QAAQ,CAACpG,MAAM,KAAK,CAAC,EAAE;YAClD,MAAMqG,SAAS,GAAGrE,QAAQ,CAAC8B,KAAK,EAAEa,IAAI,IAAI2B,OAAO,CAAC3B,IAAI,CAAC4B,IAAI,KAAK,WAAW,IAAI5B,IAAI,CAACE,KAAK,IAAIpD,KAAK,CAAC+E,gBAAgB,CAAC7B,IAAI,CAACE,KAAK,CAAC4B,UAAU,EAAEZ,iBAAiB,CAAC,CAAC,CAAC;YAC/J,IAAIQ,SAAS,EAAE;cACX3D,MAAM,CAACgE,WAAW,GAAG,CAACL,SAAS,CAAC;YACpC;UACJ;QACJ,CAAC,MACI;UACD,IAAIN,KAAK,CAACK,QAAQ,CAACpG,MAAM,GAAG,CAAC,EAAE;YAC3B,IAAI,CAAC2C,gBAAgB,CAACD,MAAM,EAAEZ,QAAQ,CAAC,yBAAyB,EAAE,4BAA4B,CAAC,CAAC;UACpG,CAAC,MACI;YACD,IAAI,CAACa,gBAAgB,CAACD,MAAM,EAAEZ,QAAQ,CAAC,iBAAiB,EAAE,mBAAmB,CAAC,CAAC;UACnF;QACJ;MACJ,CAAC,SACO;QACJ,IAAI,CAACiB,KAAK,CAACY,uBAAuB,EAAE;UAChCjB,MAAM,CAACoD,IAAI,GAAG,KAAK;QACvB;MACJ;IACJ,CAAC;IACDtC,WAAW,CAACI,GAAG,CAAClB,MAAM,CAACiE,gBAAgB,CAAC,MAAMf,iBAAiB,CAACtD,SAAS,CAAC,CAAC,CAAC;IAC5EsD,iBAAiB,CAAC,CAACpB,EAAE,GAAGvB,MAAM,CAAC2D,YAAY,CAAC,CAAC,MAAM,IAAI,IAAIpC,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACqC,WAAW,CAAC,CAAC,CAAC;IACrG;IACArD,WAAW,CAACI,GAAG,CAAClB,MAAM,CAACoE,iBAAiB,CAAC,MAAM;MAC3C,MAAM,CAACnC,IAAI,CAAC,GAAGjC,MAAM,CAACgE,WAAW;MACjC,IAAI/B,IAAI,IAAIA,IAAI,CAACE,KAAK,EAAE;QACpB;QACA5B,MAAM,CAAC8D,mBAAmB,CAACpC,IAAI,CAACE,KAAK,CAACE,SAAS,EAAE,CAAC,CAAC,uBAAuB,CAAC;QAC3E;QACA,IAAI,CAACiC,cAAc,CAAC/D,MAAM,EAAE0B,IAAI,CAACE,KAAK,CAAC4B,UAAU,CAAC;MACtD;IACJ,CAAC,CAAC,CAAC;IACH,OAAOjD,WAAW;EACtB;EACA,MAAM2C,gBAAgBA,CAACV,cAAc,EAAEM,KAAK,EAAE1D,OAAO,EAAEU,KAAK,EAAEG,KAAK,EAAE;IACjE,IAAIsB,EAAE,EAAEyC,EAAE;IACV,MAAMC,OAAO,GAAG,MAAMzB,cAAc;IACpC,IAAI1C,KAAK,CAACY,uBAAuB,EAAE;MAC/B,OAAO,EAAE;IACb;IACA,MAAMwD,kBAAkB,GAAGpB,KAAK,CAACK,QAAQ,CAACgB,OAAO,CAACxG,uCAAuC,CAACyG,YAAY,CAAC,KAAK,CAAC;IAC7G,MAAMC,SAAS,GAAGH,kBAAkB,GAAG,CAAC,GAAG,CAAC;IAC5C;IACA,IAAII,WAAW;IACf,IAAIC,cAAc;IAClB,IAAIzB,KAAK,CAAC0B,MAAM,IAAI1B,KAAK,CAAC0B,MAAM,CAACzH,MAAM,GAAG,CAAC,EAAE;MACzCuH,WAAW,GAAGtG,YAAY,CAAC8E,KAAK,CAAC0B,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;MAC7CD,cAAc,GAAGvG,YAAY,CAAC8E,KAAK,CAAC0B,MAAM,CAACC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAC1D,CAAC,MACI;MACDH,WAAW,GAAGxB,KAAK;IACvB;IACA;IACA,IAAI4B,OAAO;IACX,MAAMC,uBAAuB,GAAG,CAACX,EAAE,GAAG,CAACzC,EAAE,GAAG,IAAI,CAACnC,OAAO,MAAM,IAAI,IAAImC,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACoD,uBAAuB,MAAM,IAAI,IAAIX,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC7B,IAAI,CAACZ,EAAE,CAAC;IAC3K,IAAIoD,uBAAuB,EAAE;MACzBD,OAAO,GAAG,CAAC;QACHE,SAAS,EAAED,uBAAuB,KAAK,OAAO,GAAG5G,SAAS,CAAC8G,WAAW,CAAC/G,OAAO,CAACgH,eAAe,CAAC,GAAG/G,SAAS,CAAC8G,WAAW,CAAC/G,OAAO,CAACiH,aAAa,CAAC;QAC9IC,OAAO,EAAEL,uBAAuB,KAAK,OAAO,GAAG9F,QAAQ,CAAC,YAAY,EAAE,kBAAkB,CAAC,GAAGA,QAAQ,CAAC,cAAc,EAAE,oBAAoB;MAC7I,CAAC,CAAC;IACV;IACA,MAAMoG,mBAAmB,GAAG,EAAE;IAC9B,KAAK,IAAInE,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGmD,OAAO,CAAClH,MAAM,EAAE+D,KAAK,EAAE,EAAE;MACjD,MAAMoE,MAAM,GAAGjB,OAAO,CAACnD,KAAK,CAAC;MAC7B,MAAMqE,WAAW,GAAG5G,IAAI,CAAC2G,MAAM,CAACE,IAAI,CAAC;MACrC,MAAMC,mBAAmB,GAAG,KAAK5G,WAAW,CAAC6G,MAAM,CAACJ,MAAM,CAACnE,IAAI,CAAC,CAACwE,EAAE,KAAKJ,WAAW,EAAE;MACrF,MAAMK,qBAAqB,GAAGH,mBAAmB,CAACtI,MAAM,GAAGoI,WAAW,CAACpI,MAAM;MAC7E,IAAI0I,cAAc,GAAGP,MAAM,CAACQ,aAAa;MACzC,IAAItG,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACuG,mBAAmB,EAAE;QAC/E,IAAIF,cAAc,EAAE;UAChBA,cAAc,GAAG,GAAGrG,OAAO,CAACuG,mBAAmB,MAAMF,cAAc,EAAE;QACzE,CAAC,MACI;UACDA,cAAc,GAAGrG,OAAO,CAACuG,mBAAmB;QAChD;MACJ;MACA,IAAIC,WAAW,GAAGvG,SAAS;MAC3B,IAAIwG,aAAa,GAAGxG,SAAS;MAC7B,IAAIyG,cAAc,GAAGzG,SAAS;MAC9B,IAAI0G,gBAAgB,GAAG1G,SAAS;MAChC,IAAIyD,KAAK,CAACK,QAAQ,CAACpG,MAAM,GAAGsH,SAAS,EAAE;QACnC;QACA;QACA;QACA;QACA,IAAI2B,kBAAkB,GAAG,KAAK;QAC9B,IAAI1B,WAAW,KAAKxB,KAAK,EAAE;UACvB,CAAC8C,WAAW,EAAEC,aAAa,CAAC,GAAG3H,WAAW,CAACmH,mBAAmB,EAAE;YAAE,GAAGvC,KAAK;YAAE0B,MAAM,EAAEnF,SAAS,CAAC;UAAkC,CAAC,EAAEgF,SAAS,EAAEmB,qBAAqB,CAAC;UACpK,IAAI,OAAOI,WAAW,KAAK,QAAQ,EAAE;YACjCI,kBAAkB,GAAG,IAAI,CAAC,CAAC;UAC/B;QACJ;QACA;QACA,IAAI,OAAOJ,WAAW,KAAK,QAAQ,EAAE;UACjC,CAACA,WAAW,EAAEC,aAAa,CAAC,GAAG3H,WAAW,CAACmH,mBAAmB,EAAEf,WAAW,EAAED,SAAS,EAAEmB,qBAAqB,CAAC;UAC9G,IAAI,OAAOI,WAAW,KAAK,QAAQ,EAAE;YACjC;UACJ;QACJ;QACA;QACA,IAAI,CAACI,kBAAkB,IAAIzB,cAAc,EAAE;UACvC,IAAIkB,cAAc,IAAIlB,cAAc,CAACpB,QAAQ,CAACpG,MAAM,GAAG,CAAC,EAAE;YACtD,CAAC+I,cAAc,EAAEC,gBAAgB,CAAC,GAAG7H,WAAW,CAACuH,cAAc,EAAElB,cAAc,CAAC;UACpF;UACA,IAAI,OAAOuB,cAAc,KAAK,QAAQ,EAAE;YACpC;UACJ;UACA,IAAI,OAAOF,WAAW,KAAK,QAAQ,EAAE;YACjCA,WAAW,IAAIE,cAAc,CAAC,CAAC;UACnC;QACJ;MACJ;MACA,MAAMG,UAAU,GAAGf,MAAM,CAACgB,IAAI,IAAIhB,MAAM,CAACgB,IAAI,CAAC/B,OAAO,CAAC,CAAC,CAAC,0BAA0B,CAAC,IAAI,CAAC;MACxFc,mBAAmB,CAACkB,IAAI,CAAC;QACrBrF,KAAK;QACLC,IAAI,EAAEmE,MAAM,CAACnE,IAAI;QACjBqF,KAAK,EAAER,WAAW;QAClBhF,KAAK,EAAEyE,mBAAmB;QAC1BrE,SAAS,EAAEtC,qBAAqB,CAACwG,MAAM,CAACE,IAAI,EAAEF,MAAM,CAACnE,IAAI,CAAC;QAC1DsF,WAAW,EAAEZ,cAAc;QAC3Ba,UAAU,EAAEL,UAAU,GAAG5G,SAAS,GAAG;UACjCuB,KAAK,EAAEiF,aAAa;UACpBQ,WAAW,EAAEN;QACjB,CAAC;QACDnE,KAAK,EAAE;UACHE,SAAS,EAAEtD,KAAK,CAAC+H,eAAe,CAACrB,MAAM,CAACsB,cAAc,CAAC;UACvDhD,UAAU,EAAE0B,MAAM,CAACtD;QACvB,CAAC;QACD6E,GAAG,EAAExG,KAAK,CAACwG,GAAG;QACdC,UAAU,EAAEvB,WAAW;QACvBwB,aAAa,EAAEV,UAAU;QACzBvB;MACJ,CAAC,CAAC;IACN;IACA;IACA,MAAMkC,yBAAyB,GAAG3B,mBAAmB,CAAC4B,IAAI,CAAC,CAACC,OAAO,EAAEC,OAAO,KAAK7C,kBAAkB,GAC/F,IAAI,CAAC8C,qBAAqB,CAACF,OAAO,EAAEC,OAAO,CAAC,GAC5C,IAAI,CAACE,cAAc,CAACH,OAAO,EAAEC,OAAO,CAAC,CAAC;IAC1C;IACA;IACA;IACA,IAAIG,WAAW,GAAG,EAAE;IACpB,IAAIhD,kBAAkB,EAAE;MACpB,IAAIiD,cAAc,GAAG9H,SAAS;MAC9B,IAAI+H,aAAa,GAAG/H,SAAS;MAC7B,IAAIgI,qBAAqB,GAAG,CAAC;MAC7B,SAASC,wBAAwBA,CAAA,EAAG;QAChC,IAAIF,aAAa,IAAI,OAAOD,cAAc,KAAK,QAAQ,IAAIE,qBAAqB,GAAG,CAAC,EAAE;UAClFD,aAAa,CAACxG,KAAK,GAAGtC,MAAM,CAACiJ,qBAAqB,CAACJ,cAAc,CAAC,IAAIK,wBAAwB,EAAEH,qBAAqB,CAAC;QAC1H;MACJ;MACA,KAAK,MAAMI,UAAU,IAAIb,yBAAyB,EAAE;QAChD;QACA,IAAIO,cAAc,KAAKM,UAAU,CAAC1G,IAAI,EAAE;UACpC;UACAuG,wBAAwB,CAAC,CAAC;UAC1BH,cAAc,GAAGM,UAAU,CAAC1G,IAAI;UAChCsG,qBAAqB,GAAG,CAAC;UACzB;UACAD,aAAa,GAAG;YAAE9D,IAAI,EAAE;UAAY,CAAC;UACrC4D,WAAW,CAACf,IAAI,CAACiB,aAAa,CAAC;QACnC;QACA;QAAA,KACK;UACDC,qBAAqB,EAAE;QAC3B;QACA;QACAH,WAAW,CAACf,IAAI,CAACsB,UAAU,CAAC;MAChC;MACA;MACAH,wBAAwB,CAAC,CAAC;IAC9B,CAAC,MACI,IAAIV,yBAAyB,CAAC7J,MAAM,GAAG,CAAC,EAAE;MAC3CmK,WAAW,GAAG,CACV;QAAEtG,KAAK,EAAE/B,QAAQ,CAAC,SAAS,EAAE,eAAe,EAAEoG,mBAAmB,CAAClI,MAAM,CAAC;QAAEuG,IAAI,EAAE;MAAY,CAAC,EAC9F,GAAGsD,yBAAyB,CAC/B;IACL;IACA,OAAOM,WAAW;EACtB;EACAD,cAAcA,CAACH,OAAO,EAAEC,OAAO,EAAE;IAC7B,IAAI,OAAOD,OAAO,CAACV,KAAK,KAAK,QAAQ,IAAI,OAAOW,OAAO,CAACX,KAAK,KAAK,QAAQ,EAAE;MACxE,OAAO,CAAC;IACZ,CAAC,MACI,IAAI,OAAOU,OAAO,CAACV,KAAK,KAAK,QAAQ,IAAI,OAAOW,OAAO,CAACX,KAAK,KAAK,QAAQ,EAAE;MAC7E,OAAO,CAAC,CAAC;IACb;IACA,IAAI,OAAOU,OAAO,CAACV,KAAK,KAAK,QAAQ,IAAI,OAAOW,OAAO,CAACX,KAAK,KAAK,QAAQ,EAAE;MACxE,IAAIU,OAAO,CAACV,KAAK,GAAGW,OAAO,CAACX,KAAK,EAAE;QAC/B,OAAO,CAAC,CAAC;MACb,CAAC,MACI,IAAIU,OAAO,CAACV,KAAK,GAAGW,OAAO,CAACX,KAAK,EAAE;QACpC,OAAO,CAAC;MACZ;IACJ;IACA,IAAIU,OAAO,CAAChG,KAAK,GAAGiG,OAAO,CAACjG,KAAK,EAAE;MAC/B,OAAO,CAAC,CAAC;IACb,CAAC,MACI,IAAIgG,OAAO,CAAChG,KAAK,GAAGiG,OAAO,CAACjG,KAAK,EAAE;MACpC,OAAO,CAAC;IACZ;IACA,OAAO,CAAC;EACZ;EACAkG,qBAAqBA,CAACF,OAAO,EAAEC,OAAO,EAAE;IACpC,MAAMW,KAAK,GAAGH,qBAAqB,CAACT,OAAO,CAAC/F,IAAI,CAAC,IAAIyG,wBAAwB;IAC7E,MAAMG,KAAK,GAAGJ,qBAAqB,CAACR,OAAO,CAAChG,IAAI,CAAC,IAAIyG,wBAAwB;IAC7E;IACA,MAAMhH,MAAM,GAAGkH,KAAK,CAACE,aAAa,CAACD,KAAK,CAAC;IACzC,IAAInH,MAAM,KAAK,CAAC,EAAE;MACd,OAAO,IAAI,CAACyG,cAAc,CAACH,OAAO,EAAEC,OAAO,CAAC;IAChD;IACA,OAAOvG,MAAM;EACjB;EACA,MAAMiC,kBAAkBA,CAACoF,QAAQ,EAAE/H,KAAK,EAAE;IACtC,MAAMG,KAAK,GAAG,MAAM,IAAI,CAACd,oBAAoB,CAAC2I,WAAW,CAACD,QAAQ,EAAE/H,KAAK,CAAC;IAC1E,OAAOA,KAAK,CAACY,uBAAuB,GAAG,EAAE,GAAGT,KAAK,CAAC8H,uBAAuB,CAAC,CAAC;EAC/E;AACJ,CAAC;AACD/I,qCAAqC,CAACiE,MAAM,GAAG,GAAG;AAClDjE,qCAAqC,CAACoF,YAAY,GAAG,GAAG;AACxDpF,qCAAqC,CAACgJ,kBAAkB,GAAG,GAAGrK,uCAAuC,CAACsF,MAAM,GAAGtF,uCAAuC,CAACyG,YAAY,EAAE;AACrKpF,qCAAqC,GAAGrB,uCAAuC,GAAGnB,UAAU,CAAC,CACzFgB,OAAO,CAAC,CAAC,EAAEsB,wBAAwB,CAAC,EACpCtB,OAAO,CAAC,CAAC,EAAEmB,oBAAoB,CAAC,CACnC,EAAEK,qCAAqC,CAAC;AACzC,SAASA,qCAAqC;AAC9C;AACA,MAAMwI,wBAAwB,GAAG3I,QAAQ,CAAC,UAAU,EAAE,kBAAkB,CAAC;AACzE,MAAM0I,qBAAqB,GAAG;EAC1B,CAAC,CAAC,CAAC,0BAA0B1I,QAAQ,CAAC,QAAQ,EAAE,eAAe,CAAC;EAChE,CAAC,EAAE,CAAC,4BAA4BA,QAAQ,CAAC,UAAU,EAAE,iBAAiB,CAAC;EACvE,CAAC,CAAC,CAAC,+BAA+BA,QAAQ,CAAC,cAAc,EAAE,oBAAoB,CAAC;EAChF,CAAC,EAAE,CAAC,4BAA4BA,QAAQ,CAAC,UAAU,EAAE,iBAAiB,CAAC;EACvE,CAAC,CAAC,CAAC,yBAAyBA,QAAQ,CAAC,OAAO,EAAE,eAAe,CAAC;EAC9D,CAAC,EAAE,CAAC,0BAA0BA,QAAQ,CAAC,QAAQ,EAAE,eAAe,CAAC;EACjE,CAAC,EAAE,CAAC,yBAAyBA,QAAQ,CAAC,OAAO,EAAE,cAAc,CAAC;EAC9D,CAAC,EAAE,CAAC,4BAA4BA,QAAQ,CAAC,UAAU,EAAE,iBAAiB,CAAC;EACvE,CAAC,EAAE,CAAC,6BAA6BA,QAAQ,CAAC,WAAW,EAAE,kBAAkB,CAAC;EAC1E,CAAC,CAAC,CAAC,6BAA6BA,QAAQ,CAAC,WAAW,EAAE,kBAAkB,CAAC;EACzE,CAAC,CAAC,CAAC,2BAA2BA,QAAQ,CAAC,SAAS,EAAE,gBAAgB,CAAC;EACnE,CAAC,EAAE,CAAC,iCAAiCA,QAAQ,CAAC,eAAe,EAAE,uBAAuB,CAAC;EACvF,CAAC,CAAC,CAAC,0BAA0BA,QAAQ,CAAC,SAAS,EAAE,eAAe,CAAC;EACjE,CAAC,CAAC,CAAC,4BAA4BA,QAAQ,CAAC,UAAU,EAAE,kBAAkB,CAAC;EACvE,CAAC,CAAC,CAAC,wBAAwBA,QAAQ,CAAC,MAAM,EAAE,oBAAoB,CAAC;EACjE,CAAC,EAAE,CAAC,8BAA8BA,QAAQ,CAAC,YAAY,EAAE,2BAA2B,CAAC;EACrF,CAAC,EAAE,CAAC,0BAA0BA,QAAQ,CAAC,QAAQ,EAAE,eAAe,CAAC;EACjE,CAAC,CAAC,CAAC,wBAAwBA,QAAQ,CAAC,MAAM,EAAE,aAAa,CAAC;EAC1D,CAAC,EAAE,CAAC,yBAAyBA,QAAQ,CAAC,OAAO,EAAE,cAAc,CAAC;EAC9D,CAAC,EAAE,CAAC,0BAA0BA,QAAQ,CAAC,QAAQ,EAAE,eAAe,CAAC;EACjE,CAAC,EAAE,CAAC,2BAA2BA,QAAQ,CAAC,SAAS,EAAE,gBAAgB,CAAC;EACpE,CAAC,EAAE,CAAC,0BAA0BA,QAAQ,CAAC,QAAQ,EAAE,eAAe,CAAC;EACjE,CAAC,EAAE,CAAC,uBAAuBA,QAAQ,CAAC,KAAK,EAAE,YAAY,CAAC;EACxD,CAAC,CAAC,CAAC,yBAAyBA,QAAQ,CAAC,OAAO,EAAE,cAAc,CAAC;EAC7D,CAAC,EAAE,CAAC,4BAA4BA,QAAQ,CAAC,UAAU,EAAE,iBAAiB;AAC1E,CAAC;AACD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}