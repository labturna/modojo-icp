{"ast":null,"code":"import { Buffer } from 'buffer/';\nimport { getDefaultAgent, ReplicaRejectCode } from './agent';\nimport { AgentError } from './errors';\nimport { bufFromBufLike, IDL } from '@dfinity/candid';\nimport { pollForResponse, strategy } from './polling';\nimport { Principal } from '@dfinity/principal';\nimport { toHex } from './utils/buffer';\nimport { Certificate, lookupResultToBuffer } from './certificate';\nimport managementCanisterIdl from './canisters/management_idl';\nexport class ActorCallError extends AgentError {\n  constructor(canisterId, methodName, type, props) {\n    super([`Call failed:`, `  Canister: ${canisterId.toText()}`, `  Method: ${methodName} (${type})`, ...Object.getOwnPropertyNames(props).map(n => `  \"${n}\": ${JSON.stringify(props[n])}`)].join('\\n'));\n    this.canisterId = canisterId;\n    this.methodName = methodName;\n    this.type = type;\n    this.props = props;\n  }\n}\nexport class QueryCallRejectedError extends ActorCallError {\n  constructor(canisterId, methodName, result) {\n    var _a;\n    super(canisterId, methodName, 'query', {\n      Status: result.status,\n      Code: (_a = ReplicaRejectCode[result.reject_code]) !== null && _a !== void 0 ? _a : `Unknown Code \"${result.reject_code}\"`,\n      Message: result.reject_message\n    });\n    this.result = result;\n  }\n}\nexport class UpdateCallRejectedError extends ActorCallError {\n  constructor(canisterId, methodName, requestId, response) {\n    super(canisterId, methodName, 'update', Object.assign({\n      'Request ID': toHex(requestId)\n    }, response.body ? Object.assign(Object.assign({}, response.body.error_code ? {\n      'Error code': response.body.error_code\n    } : {}), {\n      'Reject code': String(response.body.reject_code),\n      'Reject message': response.body.reject_message\n    }) : {\n      'HTTP status code': response.status.toString(),\n      'HTTP status text': response.statusText\n    }));\n    this.requestId = requestId;\n    this.response = response;\n  }\n}\nconst metadataSymbol = Symbol.for('ic-agent-metadata');\n/**\n * An actor base class. An actor is an object containing only functions that will\n * return a promise. These functions are derived from the IDL definition.\n */\nexport class Actor {\n  constructor(metadata) {\n    this[metadataSymbol] = Object.freeze(metadata);\n  }\n  /**\n   * Get the Agent class this Actor would call, or undefined if the Actor would use\n   * the default agent (global.ic.agent).\n   * @param actor The actor to get the agent of.\n   */\n  static agentOf(actor) {\n    return actor[metadataSymbol].config.agent;\n  }\n  /**\n   * Get the interface of an actor, in the form of an instance of a Service.\n   * @param actor The actor to get the interface of.\n   */\n  static interfaceOf(actor) {\n    return actor[metadataSymbol].service;\n  }\n  static canisterIdOf(actor) {\n    return Principal.from(actor[metadataSymbol].config.canisterId);\n  }\n  static async install(fields, config) {\n    const mode = fields.mode === undefined ? {\n      install: null\n    } : fields.mode;\n    // Need to transform the arg into a number array.\n    const arg = fields.arg ? [...new Uint8Array(fields.arg)] : [];\n    // Same for module.\n    const wasmModule = [...new Uint8Array(fields.module)];\n    const canisterId = typeof config.canisterId === 'string' ? Principal.fromText(config.canisterId) : config.canisterId;\n    await getManagementCanister(config).install_code({\n      mode,\n      arg,\n      wasm_module: wasmModule,\n      canister_id: canisterId,\n      sender_canister_version: []\n    });\n  }\n  static async createCanister(config, settings) {\n    function settingsToCanisterSettings(settings) {\n      return [{\n        controllers: settings.controllers ? [settings.controllers] : [],\n        compute_allocation: settings.compute_allocation ? [settings.compute_allocation] : [],\n        freezing_threshold: settings.freezing_threshold ? [settings.freezing_threshold] : [],\n        memory_allocation: settings.memory_allocation ? [settings.memory_allocation] : [],\n        reserved_cycles_limit: [],\n        log_visibility: [],\n        wasm_memory_limit: []\n      }];\n    }\n    const {\n      canister_id: canisterId\n    } = await getManagementCanister(config || {}).provisional_create_canister_with_cycles({\n      amount: [],\n      settings: settingsToCanisterSettings(settings || {}),\n      specified_id: [],\n      sender_canister_version: []\n    });\n    return canisterId;\n  }\n  static async createAndInstallCanister(interfaceFactory, fields, config) {\n    const canisterId = await this.createCanister(config);\n    await this.install(Object.assign({}, fields), Object.assign(Object.assign({}, config), {\n      canisterId\n    }));\n    return this.createActor(interfaceFactory, Object.assign(Object.assign({}, config), {\n      canisterId\n    }));\n  }\n  static createActorClass(interfaceFactory, options) {\n    const service = interfaceFactory({\n      IDL\n    });\n    class CanisterActor extends Actor {\n      constructor(config) {\n        if (!config.canisterId) throw new AgentError(`Canister ID is required, but received ${typeof config.canisterId} instead. If you are using automatically generated declarations, this may be because your application is not setting the canister ID in process.env correctly.`);\n        const canisterId = typeof config.canisterId === 'string' ? Principal.fromText(config.canisterId) : config.canisterId;\n        super({\n          config: Object.assign(Object.assign(Object.assign({}, DEFAULT_ACTOR_CONFIG), config), {\n            canisterId\n          }),\n          service\n        });\n        for (const [methodName, func] of service._fields) {\n          if (options === null || options === void 0 ? void 0 : options.httpDetails) {\n            func.annotations.push(ACTOR_METHOD_WITH_HTTP_DETAILS);\n          }\n          if (options === null || options === void 0 ? void 0 : options.certificate) {\n            func.annotations.push(ACTOR_METHOD_WITH_CERTIFICATE);\n          }\n          this[methodName] = _createActorMethod(this, methodName, func, config.blsVerify);\n        }\n      }\n    }\n    return CanisterActor;\n  }\n  static createActor(interfaceFactory, configuration) {\n    if (!configuration.canisterId) {\n      throw new AgentError(`Canister ID is required, but received ${typeof configuration.canisterId} instead. If you are using automatically generated declarations, this may be because your application is not setting the canister ID in process.env correctly.`);\n    }\n    return new (this.createActorClass(interfaceFactory))(configuration);\n  }\n  /**\n   * Returns an actor with methods that return the http response details along with the result\n   * @param interfaceFactory - the interface factory for the actor\n   * @param configuration - the configuration for the actor\n   * @deprecated - use createActor with actorClassOptions instead\n   */\n  static createActorWithHttpDetails(interfaceFactory, configuration) {\n    return new (this.createActorClass(interfaceFactory, {\n      httpDetails: true\n    }))(configuration);\n  }\n  /**\n   * Returns an actor with methods that return the http response details along with the result\n   * @param interfaceFactory - the interface factory for the actor\n   * @param configuration - the configuration for the actor\n   * @param actorClassOptions - options for the actor class extended details to return with the result\n   */\n  static createActorWithExtendedDetails(interfaceFactory, configuration) {\n    let actorClassOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      httpDetails: true,\n      certificate: true\n    };\n    return new (this.createActorClass(interfaceFactory, actorClassOptions))(configuration);\n  }\n}\n// IDL functions can have multiple return values, so decoding always\n// produces an array. Ensure that functions with single or zero return\n// values behave as expected.\nfunction decodeReturnValue(types, msg) {\n  const returnValues = IDL.decode(types, Buffer.from(msg));\n  switch (returnValues.length) {\n    case 0:\n      return undefined;\n    case 1:\n      return returnValues[0];\n    default:\n      return returnValues;\n  }\n}\nconst DEFAULT_ACTOR_CONFIG = {\n  pollingStrategyFactory: strategy.defaultStrategy\n};\nexport const ACTOR_METHOD_WITH_HTTP_DETAILS = 'http-details';\nexport const ACTOR_METHOD_WITH_CERTIFICATE = 'certificate';\nfunction _createActorMethod(actor, methodName, func, blsVerify) {\n  let caller;\n  if (func.annotations.includes('query') || func.annotations.includes('composite_query')) {\n    caller = async function (options) {\n      var _a, _b;\n      // First, if there's a config transformation, call it.\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      options = Object.assign(Object.assign({}, options), (_b = (_a = actor[metadataSymbol].config).queryTransform) === null || _b === void 0 ? void 0 : _b.call(_a, methodName, args, Object.assign(Object.assign({}, actor[metadataSymbol].config), options)));\n      const agent = options.agent || actor[metadataSymbol].config.agent || getDefaultAgent();\n      const cid = Principal.from(options.canisterId || actor[metadataSymbol].config.canisterId);\n      const arg = IDL.encode(func.argTypes, args);\n      const result = await agent.query(cid, {\n        methodName,\n        arg,\n        effectiveCanisterId: options.effectiveCanisterId\n      });\n      const httpDetails = Object.assign(Object.assign({}, result.httpDetails), {\n        requestDetails: result.requestDetails\n      });\n      switch (result.status) {\n        case \"rejected\" /* QueryResponseStatus.Rejected */:\n          throw new QueryCallRejectedError(cid, methodName, result);\n        case \"replied\" /* QueryResponseStatus.Replied */:\n          return func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS) ? {\n            httpDetails,\n            result: decodeReturnValue(func.retTypes, result.reply.arg)\n          } : decodeReturnValue(func.retTypes, result.reply.arg);\n      }\n    };\n  } else {\n    caller = async function (options) {\n      var _a, _b;\n      // First, if there's a config transformation, call it.\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n      options = Object.assign(Object.assign({}, options), (_b = (_a = actor[metadataSymbol].config).callTransform) === null || _b === void 0 ? void 0 : _b.call(_a, methodName, args, Object.assign(Object.assign({}, actor[metadataSymbol].config), options)));\n      const agent = options.agent || actor[metadataSymbol].config.agent || getDefaultAgent();\n      const {\n        canisterId,\n        effectiveCanisterId,\n        pollingStrategyFactory\n      } = Object.assign(Object.assign(Object.assign({}, DEFAULT_ACTOR_CONFIG), actor[metadataSymbol].config), options);\n      const cid = Principal.from(canisterId);\n      const ecid = effectiveCanisterId !== undefined ? Principal.from(effectiveCanisterId) : cid;\n      const arg = IDL.encode(func.argTypes, args);\n      if (agent.rootKey == null) throw new AgentError('Agent root key not initialized before making call');\n      const {\n        requestId,\n        response,\n        requestDetails\n      } = await agent.call(cid, {\n        methodName,\n        arg,\n        effectiveCanisterId: ecid\n      });\n      let reply;\n      let certificate;\n      if (response.body && response.body.certificate) {\n        const cert = response.body.certificate;\n        certificate = await Certificate.create({\n          certificate: bufFromBufLike(cert),\n          rootKey: agent.rootKey,\n          canisterId: Principal.from(canisterId),\n          blsVerify\n        });\n        const path = [new TextEncoder().encode('request_status'), requestId];\n        const status = new TextDecoder().decode(lookupResultToBuffer(certificate.lookup([...path, 'status'])));\n        switch (status) {\n          case 'replied':\n            reply = lookupResultToBuffer(certificate.lookup([...path, 'reply']));\n            break;\n          case 'rejected':\n            throw new UpdateCallRejectedError(cid, methodName, requestId, response);\n        }\n      }\n      // Fall back to polling if we recieve an Accepted response code\n      if (response.status === 202) {\n        const pollStrategy = pollingStrategyFactory();\n        // Contains the certificate and the reply from the boundary node\n        const response = await pollForResponse(agent, ecid, requestId, pollStrategy, blsVerify);\n        certificate = response.certificate;\n        reply = response.reply;\n      }\n      const shouldIncludeHttpDetails = func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS);\n      const shouldIncludeCertificate = func.annotations.includes(ACTOR_METHOD_WITH_CERTIFICATE);\n      const httpDetails = Object.assign(Object.assign({}, response), {\n        requestDetails\n      });\n      if (reply !== undefined) {\n        if (shouldIncludeHttpDetails && shouldIncludeCertificate) {\n          return {\n            httpDetails,\n            certificate,\n            result: decodeReturnValue(func.retTypes, reply)\n          };\n        } else if (shouldIncludeCertificate) {\n          return {\n            certificate,\n            result: decodeReturnValue(func.retTypes, reply)\n          };\n        } else if (shouldIncludeHttpDetails) {\n          return {\n            httpDetails,\n            result: decodeReturnValue(func.retTypes, reply)\n          };\n        }\n        return decodeReturnValue(func.retTypes, reply);\n      } else if (func.retTypes.length === 0) {\n        return shouldIncludeHttpDetails ? {\n          httpDetails: response,\n          result: undefined\n        } : undefined;\n      } else {\n        throw new Error(`Call was returned undefined, but type [${func.retTypes.join(',')}].`);\n      }\n    };\n  }\n  const handler = function () {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    return caller({}, ...args);\n  };\n  handler.withOptions = options => function () {\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n    return caller(options, ...args);\n  };\n  return handler;\n}\n/**\n * Create a management canister actor\n * @param config - a CallConfig\n */\nexport function getManagementCanister(config) {\n  function transform(_methodName, args) {\n    if (config.effectiveCanisterId) {\n      return {\n        effectiveCanisterId: Principal.from(config.effectiveCanisterId)\n      };\n    }\n    const first = args[0];\n    let effectiveCanisterId = Principal.fromHex('');\n    if (first && typeof first === 'object' && first.canister_id) {\n      effectiveCanisterId = Principal.from(first.canister_id);\n    }\n    return {\n      effectiveCanisterId\n    };\n  }\n  return Actor.createActor(managementCanisterIdl, Object.assign(Object.assign(Object.assign({}, config), {\n    canisterId: Principal.fromHex('')\n  }), {\n    callTransform: transform,\n    queryTransform: transform\n  }));\n}\nexport class AdvancedActor extends Actor {\n  constructor(metadata) {\n    super(metadata);\n  }\n}","map":{"version":3,"names":["Buffer","getDefaultAgent","ReplicaRejectCode","AgentError","bufFromBufLike","IDL","pollForResponse","strategy","Principal","toHex","Certificate","lookupResultToBuffer","managementCanisterIdl","ActorCallError","constructor","canisterId","methodName","type","props","toText","Object","getOwnPropertyNames","map","n","JSON","stringify","join","QueryCallRejectedError","result","Status","status","Code","_a","reject_code","Message","reject_message","UpdateCallRejectedError","requestId","response","assign","body","error_code","String","toString","statusText","metadataSymbol","Symbol","for","Actor","metadata","freeze","agentOf","actor","config","agent","interfaceOf","service","canisterIdOf","from","install","fields","mode","undefined","arg","Uint8Array","wasmModule","module","fromText","getManagementCanister","install_code","wasm_module","canister_id","sender_canister_version","createCanister","settings","settingsToCanisterSettings","controllers","compute_allocation","freezing_threshold","memory_allocation","reserved_cycles_limit","log_visibility","wasm_memory_limit","provisional_create_canister_with_cycles","amount","specified_id","createAndInstallCanister","interfaceFactory","createActor","createActorClass","options","CanisterActor","DEFAULT_ACTOR_CONFIG","func","_fields","httpDetails","annotations","push","ACTOR_METHOD_WITH_HTTP_DETAILS","certificate","ACTOR_METHOD_WITH_CERTIFICATE","_createActorMethod","blsVerify","configuration","createActorWithHttpDetails","createActorWithExtendedDetails","actorClassOptions","arguments","length","decodeReturnValue","types","msg","returnValues","decode","pollingStrategyFactory","defaultStrategy","caller","includes","_len","args","Array","_key","_b","queryTransform","call","cid","encode","argTypes","query","effectiveCanisterId","requestDetails","retTypes","reply","_len2","_key2","callTransform","ecid","rootKey","cert","create","path","TextEncoder","TextDecoder","lookup","pollStrategy","shouldIncludeHttpDetails","shouldIncludeCertificate","Error","handler","_len3","_key3","withOptions","_len4","_key4","transform","_methodName","first","fromHex","AdvancedActor"],"sources":["/home/arslan/modojo/node_modules/@dfinity/agent/src/actor.ts"],"sourcesContent":["import { Buffer } from 'buffer/';\nimport {\n  Agent,\n  getDefaultAgent,\n  HttpDetailsResponse,\n  QueryResponseRejected,\n  QueryResponseStatus,\n  ReplicaRejectCode,\n  SubmitResponse,\n} from './agent';\nimport { AgentError } from './errors';\nimport { bufFromBufLike, IDL } from '@dfinity/candid';\nimport { pollForResponse, PollStrategyFactory, strategy } from './polling';\nimport { Principal } from '@dfinity/principal';\nimport { RequestId } from './request_id';\nimport { toHex } from './utils/buffer';\nimport { Certificate, CreateCertificateOptions, lookupResultToBuffer } from './certificate';\nimport managementCanisterIdl from './canisters/management_idl';\nimport _SERVICE, { canister_install_mode, canister_settings } from './canisters/management_service';\n\nexport class ActorCallError extends AgentError {\n  constructor(\n    public readonly canisterId: Principal,\n    public readonly methodName: string,\n    public readonly type: 'query' | 'update',\n    public readonly props: Record<string, string>,\n  ) {\n    super(\n      [\n        `Call failed:`,\n        `  Canister: ${canisterId.toText()}`,\n        `  Method: ${methodName} (${type})`,\n        ...Object.getOwnPropertyNames(props).map(n => `  \"${n}\": ${JSON.stringify(props[n])}`),\n      ].join('\\n'),\n    );\n  }\n}\n\nexport class QueryCallRejectedError extends ActorCallError {\n  constructor(\n    canisterId: Principal,\n    methodName: string,\n    public readonly result: QueryResponseRejected,\n  ) {\n    super(canisterId, methodName, 'query', {\n      Status: result.status,\n      Code: ReplicaRejectCode[result.reject_code] ?? `Unknown Code \"${result.reject_code}\"`,\n      Message: result.reject_message,\n    });\n  }\n}\n\nexport class UpdateCallRejectedError extends ActorCallError {\n  constructor(\n    canisterId: Principal,\n    methodName: string,\n    public readonly requestId: RequestId,\n    public readonly response: SubmitResponse['response'],\n  ) {\n    super(canisterId, methodName, 'update', {\n      'Request ID': toHex(requestId),\n      ...(response.body\n        ? {\n            ...(response.body.error_code\n              ? {\n                  'Error code': response.body.error_code,\n                }\n              : {}),\n            'Reject code': String(response.body.reject_code),\n            'Reject message': response.body.reject_message,\n          }\n        : {\n            'HTTP status code': response.status.toString(),\n            'HTTP status text': response.statusText,\n          }),\n    });\n  }\n}\n\n/**\n * Configuration to make calls to the Replica.\n */\nexport interface CallConfig {\n  /**\n   * An agent to use in this call, otherwise the actor or call will try to discover the\n   * agent to use.\n   */\n  agent?: Agent;\n\n  /**\n   * A polling strategy factory that dictates how much and often we should poll the\n   * read_state endpoint to get the result of an update call.\n   */\n  pollingStrategyFactory?: PollStrategyFactory;\n\n  /**\n   * The canister ID of this Actor.\n   */\n  canisterId?: string | Principal;\n\n  /**\n   * The effective canister ID. This should almost always be ignored.\n   */\n  effectiveCanisterId?: Principal;\n}\n\n/**\n * Configuration that can be passed to customize the Actor behaviour.\n */\nexport interface ActorConfig extends CallConfig {\n  /**\n   * The Canister ID of this Actor. This is required for an Actor.\n   */\n  canisterId: string | Principal;\n\n  /**\n   * An override function for update calls' CallConfig. This will be called on every calls.\n   */\n  callTransform?(\n    methodName: string,\n    args: unknown[],\n    callConfig: CallConfig,\n  ): Partial<CallConfig> | void;\n\n  /**\n   * An override function for query calls' CallConfig. This will be called on every query.\n   */\n  queryTransform?(\n    methodName: string,\n    args: unknown[],\n    callConfig: CallConfig,\n  ): Partial<CallConfig> | void;\n\n  /**\n   * Polyfill for BLS Certificate verification in case wasm is not supported\n   */\n  blsVerify?: CreateCertificateOptions['blsVerify'];\n}\n\n// TODO: move this to proper typing when Candid support TypeScript.\n/**\n * A subclass of an actor. Actor class itself is meant to be a based class.\n */\nexport type ActorSubclass<T = Record<string, ActorMethod>> = Actor & T;\n\n/**\n * An actor method type, defined for each methods of the actor service.\n */\nexport interface ActorMethod<Args extends unknown[] = unknown[], Ret = unknown> {\n  (...args: Args): Promise<Ret>;\n  withOptions(options: CallConfig): (...args: Args) => Promise<Ret>;\n}\n\n/**\n * An actor method type, defined for each methods of the actor service.\n */\nexport interface ActorMethodWithHttpDetails<Args extends unknown[] = unknown[], Ret = unknown>\n  extends ActorMethod {\n  (...args: Args): Promise<{ httpDetails: HttpDetailsResponse; result: Ret }>;\n}\n\n/**\n * An actor method type, defined for each methods of the actor service.\n */\nexport interface ActorMethodExtended<Args extends unknown[] = unknown[], Ret = unknown>\n  extends ActorMethod {\n  (...args: Args): Promise<{\n    certificate?: Certificate;\n    httpDetails?: HttpDetailsResponse;\n    result: Ret;\n  }>;\n}\n\nexport type FunctionWithArgsAndReturn<Args extends unknown[] = unknown[], Ret = unknown> = (\n  ...args: Args\n) => Ret;\n\n// Update all entries of T with the extra information from ActorMethodWithInfo\nexport type ActorMethodMappedWithHttpDetails<T> = {\n  [K in keyof T]: T[K] extends FunctionWithArgsAndReturn<infer Args, infer Ret>\n    ? ActorMethodWithHttpDetails<Args, Ret>\n    : never;\n};\n\n// Update all entries of T with the extra information from ActorMethodWithInfo\nexport type ActorMethodMappedExtended<T> = {\n  [K in keyof T]: T[K] extends FunctionWithArgsAndReturn<infer Args, infer Ret>\n    ? ActorMethodExtended<Args, Ret>\n    : never;\n};\n\n/**\n * The mode used when installing a canister.\n */\nexport type CanisterInstallMode =\n  | {\n      reinstall: null;\n    }\n  | {\n      upgrade:\n        | []\n        | [\n            {\n              skip_pre_upgrade: [] | [boolean];\n            },\n          ];\n    }\n  | {\n      install: null;\n    };\n\n/**\n * Internal metadata for actors. It's an enhanced version of ActorConfig with\n * some fields marked as required (as they are defaulted) and canisterId as\n * a Principal type.\n */\ninterface ActorMetadata {\n  service: IDL.ServiceClass;\n  agent?: Agent;\n  config: ActorConfig;\n}\n\nconst metadataSymbol = Symbol.for('ic-agent-metadata');\n\nexport interface CreateActorClassOpts {\n  httpDetails?: boolean;\n  certificate?: boolean;\n}\n\ninterface CreateCanisterSettings {\n  freezing_threshold?: bigint;\n  controllers?: Array<Principal>;\n  memory_allocation?: bigint;\n  compute_allocation?: bigint;\n}\n\n/**\n * An actor base class. An actor is an object containing only functions that will\n * return a promise. These functions are derived from the IDL definition.\n */\nexport class Actor {\n  /**\n   * Get the Agent class this Actor would call, or undefined if the Actor would use\n   * the default agent (global.ic.agent).\n   * @param actor The actor to get the agent of.\n   */\n  public static agentOf(actor: Actor): Agent | undefined {\n    return actor[metadataSymbol].config.agent;\n  }\n\n  /**\n   * Get the interface of an actor, in the form of an instance of a Service.\n   * @param actor The actor to get the interface of.\n   */\n  public static interfaceOf(actor: Actor): IDL.ServiceClass {\n    return actor[metadataSymbol].service;\n  }\n\n  public static canisterIdOf(actor: Actor): Principal {\n    return Principal.from(actor[metadataSymbol].config.canisterId);\n  }\n\n  public static async install(\n    fields: {\n      module: ArrayBuffer;\n      mode?: canister_install_mode;\n      arg?: ArrayBuffer;\n    },\n    config: ActorConfig,\n  ): Promise<void> {\n    const mode = fields.mode === undefined ? { install: null } : fields.mode;\n    // Need to transform the arg into a number array.\n    const arg = fields.arg ? [...new Uint8Array(fields.arg)] : [];\n    // Same for module.\n    const wasmModule = [...new Uint8Array(fields.module)];\n    const canisterId =\n      typeof config.canisterId === 'string'\n        ? Principal.fromText(config.canisterId)\n        : config.canisterId;\n\n    await getManagementCanister(config).install_code({\n      mode,\n      arg,\n      wasm_module: wasmModule,\n      canister_id: canisterId,\n      sender_canister_version: [],\n    });\n  }\n\n  public static async createCanister(\n    config?: CallConfig,\n    settings?: CreateCanisterSettings,\n  ): Promise<Principal> {\n    function settingsToCanisterSettings(settings: CreateCanisterSettings): [canister_settings] {\n      return [\n        {\n          controllers: settings.controllers ? [settings.controllers] : [],\n          compute_allocation: settings.compute_allocation ? [settings.compute_allocation] : [],\n          freezing_threshold: settings.freezing_threshold ? [settings.freezing_threshold] : [],\n          memory_allocation: settings.memory_allocation ? [settings.memory_allocation] : [],\n          reserved_cycles_limit: [],\n          log_visibility: [],\n          wasm_memory_limit: [],\n        },\n      ];\n    }\n\n    const { canister_id: canisterId } = await getManagementCanister(\n      config || {},\n    ).provisional_create_canister_with_cycles({\n      amount: [],\n      settings: settingsToCanisterSettings(settings || {}),\n      specified_id: [],\n      sender_canister_version: [],\n    });\n\n    return canisterId;\n  }\n\n  public static async createAndInstallCanister(\n    interfaceFactory: IDL.InterfaceFactory,\n    fields: {\n      module: ArrayBuffer;\n      arg?: ArrayBuffer;\n    },\n    config?: CallConfig,\n  ): Promise<ActorSubclass> {\n    const canisterId = await this.createCanister(config);\n    await this.install(\n      {\n        ...fields,\n      },\n      { ...config, canisterId },\n    );\n\n    return this.createActor(interfaceFactory, { ...config, canisterId });\n  }\n\n  public static createActorClass(\n    interfaceFactory: IDL.InterfaceFactory,\n    options?: CreateActorClassOpts,\n  ): ActorConstructor {\n    const service = interfaceFactory({ IDL });\n\n    class CanisterActor extends Actor {\n      [x: string]: ActorMethod;\n\n      constructor(config: ActorConfig) {\n        if (!config.canisterId)\n          throw new AgentError(\n            `Canister ID is required, but received ${typeof config.canisterId} instead. If you are using automatically generated declarations, this may be because your application is not setting the canister ID in process.env correctly.`,\n          );\n        const canisterId =\n          typeof config.canisterId === 'string'\n            ? Principal.fromText(config.canisterId)\n            : config.canisterId;\n\n        super({\n          config: {\n            ...DEFAULT_ACTOR_CONFIG,\n            ...config,\n            canisterId,\n          },\n          service,\n        });\n\n        for (const [methodName, func] of service._fields) {\n          if (options?.httpDetails) {\n            func.annotations.push(ACTOR_METHOD_WITH_HTTP_DETAILS);\n          }\n          if (options?.certificate) {\n            func.annotations.push(ACTOR_METHOD_WITH_CERTIFICATE);\n          }\n\n          this[methodName] = _createActorMethod(this, methodName, func, config.blsVerify);\n        }\n      }\n    }\n\n    return CanisterActor;\n  }\n\n  public static createActor<T = Record<string, ActorMethod>>(\n    interfaceFactory: IDL.InterfaceFactory,\n    configuration: ActorConfig,\n  ): ActorSubclass<T> {\n    if (!configuration.canisterId) {\n      throw new AgentError(\n        `Canister ID is required, but received ${typeof configuration.canisterId} instead. If you are using automatically generated declarations, this may be because your application is not setting the canister ID in process.env correctly.`,\n      );\n    }\n    return new (this.createActorClass(interfaceFactory))(\n      configuration,\n    ) as unknown as ActorSubclass<T>;\n  }\n\n  /**\n   * Returns an actor with methods that return the http response details along with the result\n   * @param interfaceFactory - the interface factory for the actor\n   * @param configuration - the configuration for the actor\n   * @deprecated - use createActor with actorClassOptions instead\n   */\n  public static createActorWithHttpDetails<T = Record<string, ActorMethod>>(\n    interfaceFactory: IDL.InterfaceFactory,\n    configuration: ActorConfig,\n  ): ActorSubclass<ActorMethodMappedWithHttpDetails<T>> {\n    return new (this.createActorClass(interfaceFactory, { httpDetails: true }))(\n      configuration,\n    ) as unknown as ActorSubclass<ActorMethodMappedWithHttpDetails<T>>;\n  }\n\n  /**\n   * Returns an actor with methods that return the http response details along with the result\n   * @param interfaceFactory - the interface factory for the actor\n   * @param configuration - the configuration for the actor\n   * @param actorClassOptions - options for the actor class extended details to return with the result\n   */\n  public static createActorWithExtendedDetails<T = Record<string, ActorMethod>>(\n    interfaceFactory: IDL.InterfaceFactory,\n    configuration: ActorConfig,\n    actorClassOptions: CreateActorClassOpts = {\n      httpDetails: true,\n      certificate: true,\n    },\n  ): ActorSubclass<ActorMethodMappedExtended<T>> {\n    return new (this.createActorClass(interfaceFactory, actorClassOptions))(\n      configuration,\n    ) as unknown as ActorSubclass<ActorMethodMappedExtended<T>>;\n  }\n\n  private [metadataSymbol]: ActorMetadata;\n\n  protected constructor(metadata: ActorMetadata) {\n    this[metadataSymbol] = Object.freeze(metadata);\n  }\n}\n\n// IDL functions can have multiple return values, so decoding always\n// produces an array. Ensure that functions with single or zero return\n// values behave as expected.\nfunction decodeReturnValue(types: IDL.Type[], msg: ArrayBuffer) {\n  const returnValues = IDL.decode(types, Buffer.from(msg));\n  switch (returnValues.length) {\n    case 0:\n      return undefined;\n    case 1:\n      return returnValues[0];\n    default:\n      return returnValues;\n  }\n}\n\nconst DEFAULT_ACTOR_CONFIG = {\n  pollingStrategyFactory: strategy.defaultStrategy,\n};\n\nexport type ActorConstructor = new (config: ActorConfig) => ActorSubclass;\n\nexport const ACTOR_METHOD_WITH_HTTP_DETAILS = 'http-details';\nexport const ACTOR_METHOD_WITH_CERTIFICATE = 'certificate';\n\nfunction _createActorMethod(\n  actor: Actor,\n  methodName: string,\n  func: IDL.FuncClass,\n  blsVerify?: CreateCertificateOptions['blsVerify'],\n): ActorMethod {\n  let caller: (options: CallConfig, ...args: unknown[]) => Promise<unknown>;\n  if (func.annotations.includes('query') || func.annotations.includes('composite_query')) {\n    caller = async (options, ...args) => {\n      // First, if there's a config transformation, call it.\n      options = {\n        ...options,\n        ...actor[metadataSymbol].config.queryTransform?.(methodName, args, {\n          ...actor[metadataSymbol].config,\n          ...options,\n        }),\n      };\n\n      const agent = options.agent || actor[metadataSymbol].config.agent || getDefaultAgent();\n      const cid = Principal.from(options.canisterId || actor[metadataSymbol].config.canisterId);\n      const arg = IDL.encode(func.argTypes, args);\n\n      const result = await agent.query(cid, {\n        methodName,\n        arg,\n        effectiveCanisterId: options.effectiveCanisterId,\n      });\n      const httpDetails = {\n        ...result.httpDetails,\n        requestDetails: result.requestDetails,\n      } as HttpDetailsResponse;\n\n      switch (result.status) {\n        case QueryResponseStatus.Rejected:\n          throw new QueryCallRejectedError(cid, methodName, result);\n\n        case QueryResponseStatus.Replied:\n          return func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS)\n            ? {\n                httpDetails,\n                result: decodeReturnValue(func.retTypes, result.reply.arg),\n              }\n            : decodeReturnValue(func.retTypes, result.reply.arg);\n      }\n    };\n  } else {\n    caller = async (options, ...args) => {\n      // First, if there's a config transformation, call it.\n      options = {\n        ...options,\n        ...actor[metadataSymbol].config.callTransform?.(methodName, args, {\n          ...actor[metadataSymbol].config,\n          ...options,\n        }),\n      };\n\n      const agent = options.agent || actor[metadataSymbol].config.agent || getDefaultAgent();\n      const { canisterId, effectiveCanisterId, pollingStrategyFactory } = {\n        ...DEFAULT_ACTOR_CONFIG,\n        ...actor[metadataSymbol].config,\n        ...options,\n      };\n      const cid = Principal.from(canisterId);\n      const ecid = effectiveCanisterId !== undefined ? Principal.from(effectiveCanisterId) : cid;\n      const arg = IDL.encode(func.argTypes, args);\n\n      if (agent.rootKey == null)\n        throw new AgentError('Agent root key not initialized before making call');\n\n      const { requestId, response, requestDetails } = await agent.call(cid, {\n        methodName,\n        arg,\n        effectiveCanisterId: ecid,\n      });\n      let reply: ArrayBuffer | undefined;\n      let certificate: Certificate | undefined;\n      if (response.body && response.body.certificate) {\n        const cert = response.body.certificate;\n        certificate = await Certificate.create({\n          certificate: bufFromBufLike(cert),\n          rootKey: agent.rootKey,\n          canisterId: Principal.from(canisterId),\n          blsVerify,\n        });\n        const path = [new TextEncoder().encode('request_status'), requestId];\n        const status = new TextDecoder().decode(\n          lookupResultToBuffer(certificate.lookup([...path, 'status'])),\n        );\n\n        switch (status) {\n          case 'replied':\n            reply = lookupResultToBuffer(certificate.lookup([...path, 'reply']));\n            break;\n          case 'rejected':\n            throw new UpdateCallRejectedError(cid, methodName, requestId, response);\n        }\n      }\n      // Fall back to polling if we recieve an Accepted response code\n      if (response.status === 202) {\n        const pollStrategy = pollingStrategyFactory();\n        // Contains the certificate and the reply from the boundary node\n        const response = await pollForResponse(agent, ecid, requestId, pollStrategy, blsVerify);\n        certificate = response.certificate;\n        reply = response.reply;\n      }\n      const shouldIncludeHttpDetails = func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS);\n      const shouldIncludeCertificate = func.annotations.includes(ACTOR_METHOD_WITH_CERTIFICATE);\n\n      const httpDetails = { ...response, requestDetails } as HttpDetailsResponse;\n      if (reply !== undefined) {\n        if (shouldIncludeHttpDetails && shouldIncludeCertificate) {\n          return {\n            httpDetails,\n            certificate,\n            result: decodeReturnValue(func.retTypes, reply),\n          };\n        } else if (shouldIncludeCertificate) {\n          return {\n            certificate,\n            result: decodeReturnValue(func.retTypes, reply),\n          };\n        } else if (shouldIncludeHttpDetails) {\n          return {\n            httpDetails,\n            result: decodeReturnValue(func.retTypes, reply),\n          };\n        }\n        return decodeReturnValue(func.retTypes, reply);\n      } else if (func.retTypes.length === 0) {\n        return shouldIncludeHttpDetails\n          ? {\n              httpDetails: response,\n              result: undefined,\n            }\n          : undefined;\n      } else {\n        throw new Error(`Call was returned undefined, but type [${func.retTypes.join(',')}].`);\n      }\n    };\n  }\n\n  const handler = (...args: unknown[]) => caller({}, ...args);\n  handler.withOptions =\n    (options: CallConfig) =>\n    (...args: unknown[]) =>\n      caller(options, ...args);\n  return handler as ActorMethod;\n}\n\nexport type ManagementCanisterRecord = _SERVICE;\n\n/**\n * Create a management canister actor\n * @param config - a CallConfig\n */\nexport function getManagementCanister(config: CallConfig): ActorSubclass<ManagementCanisterRecord> {\n  function transform(\n    _methodName: string,\n    args: Record<string, unknown> & { canister_id: string }[],\n  ) {\n    if (config.effectiveCanisterId) {\n      return { effectiveCanisterId: Principal.from(config.effectiveCanisterId) };\n    }\n    const first = args[0];\n    let effectiveCanisterId = Principal.fromHex('');\n    if (first && typeof first === 'object' && first.canister_id) {\n      effectiveCanisterId = Principal.from(first.canister_id as unknown);\n    }\n    return { effectiveCanisterId };\n  }\n\n  return Actor.createActor<ManagementCanisterRecord>(managementCanisterIdl, {\n    ...config,\n    canisterId: Principal.fromHex(''),\n    ...{\n      callTransform: transform,\n      queryTransform: transform,\n    },\n  });\n}\n\nexport class AdvancedActor extends Actor {\n  constructor(metadata: ActorMetadata) {\n    super(metadata);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}