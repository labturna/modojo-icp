{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ObjectTreeModel } from './objectTreeModel.js';\nimport { TreeError, WeakMapper } from './tree.js';\nimport { equals } from '../../../common/arrays.js';\nimport { Event } from '../../../common/event.js';\nimport { Iterable } from '../../../common/iterator.js';\nfunction noCompress(element) {\n  const elements = [element.element];\n  const incompressible = element.incompressible || false;\n  return {\n    element: {\n      elements,\n      incompressible\n    },\n    children: Iterable.map(Iterable.from(element.children), noCompress),\n    collapsible: element.collapsible,\n    collapsed: element.collapsed\n  };\n}\n// Exported only for test reasons, do not use directly\nexport function compress(element) {\n  const elements = [element.element];\n  const incompressible = element.incompressible || false;\n  let childrenIterator;\n  let children;\n  while (true) {\n    [children, childrenIterator] = Iterable.consume(Iterable.from(element.children), 2);\n    if (children.length !== 1) {\n      break;\n    }\n    if (children[0].incompressible) {\n      break;\n    }\n    element = children[0];\n    elements.push(element.element);\n  }\n  return {\n    element: {\n      elements,\n      incompressible\n    },\n    children: Iterable.map(Iterable.concat(children, childrenIterator), compress),\n    collapsible: element.collapsible,\n    collapsed: element.collapsed\n  };\n}\nfunction _decompress(element) {\n  let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let children;\n  if (index < element.element.elements.length - 1) {\n    children = [_decompress(element, index + 1)];\n  } else {\n    children = Iterable.map(Iterable.from(element.children), el => _decompress(el, 0));\n  }\n  if (index === 0 && element.element.incompressible) {\n    return {\n      element: element.element.elements[index],\n      children,\n      incompressible: true,\n      collapsible: element.collapsible,\n      collapsed: element.collapsed\n    };\n  }\n  return {\n    element: element.element.elements[index],\n    children,\n    collapsible: element.collapsible,\n    collapsed: element.collapsed\n  };\n}\n// Exported only for test reasons, do not use directly\nexport function decompress(element) {\n  return _decompress(element, 0);\n}\nfunction splice(treeElement, element, children) {\n  if (treeElement.element === element) {\n    return {\n      ...treeElement,\n      children\n    };\n  }\n  return {\n    ...treeElement,\n    children: Iterable.map(Iterable.from(treeElement.children), e => splice(e, element, children))\n  };\n}\nconst wrapIdentityProvider = base => ({\n  getId(node) {\n    return node.elements.map(e => base.getId(e).toString()).join('\\0');\n  }\n});\n// Exported only for test reasons, do not use directly\nexport class CompressedObjectTreeModel {\n  get onDidSplice() {\n    return this.model.onDidSplice;\n  }\n  get onDidChangeCollapseState() {\n    return this.model.onDidChangeCollapseState;\n  }\n  get onDidChangeRenderNodeCount() {\n    return this.model.onDidChangeRenderNodeCount;\n  }\n  constructor(user, list) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this.user = user;\n    this.rootRef = null;\n    this.nodes = new Map();\n    this.model = new ObjectTreeModel(user, list, options);\n    this.enabled = typeof options.compressionEnabled === 'undefined' ? true : options.compressionEnabled;\n    this.identityProvider = options.identityProvider;\n  }\n  setChildren(element) {\n    let children = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Iterable.empty();\n    let options = arguments.length > 2 ? arguments[2] : undefined;\n    // Diffs must be deep, since the compression can affect nested elements.\n    // @see https://github.com/microsoft/vscode/pull/114237#issuecomment-759425034\n    const diffIdentityProvider = options.diffIdentityProvider && wrapIdentityProvider(options.diffIdentityProvider);\n    if (element === null) {\n      const compressedChildren = Iterable.map(children, this.enabled ? compress : noCompress);\n      this._setChildren(null, compressedChildren, {\n        diffIdentityProvider,\n        diffDepth: Infinity\n      });\n      return;\n    }\n    const compressedNode = this.nodes.get(element);\n    if (!compressedNode) {\n      throw new TreeError(this.user, 'Unknown compressed tree node');\n    }\n    const node = this.model.getNode(compressedNode);\n    const compressedParentNode = this.model.getParentNodeLocation(compressedNode);\n    const parent = this.model.getNode(compressedParentNode);\n    const decompressedElement = decompress(node);\n    const splicedElement = splice(decompressedElement, element, children);\n    const recompressedElement = (this.enabled ? compress : noCompress)(splicedElement);\n    // If the recompressed node is identical to the original, just set its children.\n    // Saves work and churn diffing the parent element.\n    const elementComparator = options.diffIdentityProvider ? (a, b) => options.diffIdentityProvider.getId(a) === options.diffIdentityProvider.getId(b) : undefined;\n    if (equals(recompressedElement.element.elements, node.element.elements, elementComparator)) {\n      this._setChildren(compressedNode, recompressedElement.children || Iterable.empty(), {\n        diffIdentityProvider,\n        diffDepth: 1\n      });\n      return;\n    }\n    const parentChildren = parent.children.map(child => child === node ? recompressedElement : child);\n    this._setChildren(parent.element, parentChildren, {\n      diffIdentityProvider,\n      diffDepth: node.depth - parent.depth\n    });\n  }\n  isCompressionEnabled() {\n    return this.enabled;\n  }\n  setCompressionEnabled(enabled) {\n    if (enabled === this.enabled) {\n      return;\n    }\n    this.enabled = enabled;\n    const root = this.model.getNode();\n    const rootChildren = root.children;\n    const decompressedRootChildren = Iterable.map(rootChildren, decompress);\n    const recompressedRootChildren = Iterable.map(decompressedRootChildren, enabled ? compress : noCompress);\n    // it should be safe to always use deep diff mode here if an identity\n    // provider is available, since we know the raw nodes are unchanged.\n    this._setChildren(null, recompressedRootChildren, {\n      diffIdentityProvider: this.identityProvider,\n      diffDepth: Infinity\n    });\n  }\n  _setChildren(node, children, options) {\n    const insertedElements = new Set();\n    const onDidCreateNode = node => {\n      for (const element of node.element.elements) {\n        insertedElements.add(element);\n        this.nodes.set(element, node.element);\n      }\n    };\n    const onDidDeleteNode = node => {\n      for (const element of node.element.elements) {\n        if (!insertedElements.has(element)) {\n          this.nodes.delete(element);\n        }\n      }\n    };\n    this.model.setChildren(node, children, {\n      ...options,\n      onDidCreateNode,\n      onDidDeleteNode\n    });\n  }\n  has(element) {\n    return this.nodes.has(element);\n  }\n  getListIndex(location) {\n    const node = this.getCompressedNode(location);\n    return this.model.getListIndex(node);\n  }\n  getListRenderCount(location) {\n    const node = this.getCompressedNode(location);\n    return this.model.getListRenderCount(node);\n  }\n  getNode(location) {\n    if (typeof location === 'undefined') {\n      return this.model.getNode();\n    }\n    const node = this.getCompressedNode(location);\n    return this.model.getNode(node);\n  }\n  // TODO: review this\n  getNodeLocation(node) {\n    const compressedNode = this.model.getNodeLocation(node);\n    if (compressedNode === null) {\n      return null;\n    }\n    return compressedNode.elements[compressedNode.elements.length - 1];\n  }\n  // TODO: review this\n  getParentNodeLocation(location) {\n    const compressedNode = this.getCompressedNode(location);\n    const parentNode = this.model.getParentNodeLocation(compressedNode);\n    if (parentNode === null) {\n      return null;\n    }\n    return parentNode.elements[parentNode.elements.length - 1];\n  }\n  getFirstElementChild(location) {\n    const compressedNode = this.getCompressedNode(location);\n    return this.model.getFirstElementChild(compressedNode);\n  }\n  isCollapsible(location) {\n    const compressedNode = this.getCompressedNode(location);\n    return this.model.isCollapsible(compressedNode);\n  }\n  setCollapsible(location, collapsible) {\n    const compressedNode = this.getCompressedNode(location);\n    return this.model.setCollapsible(compressedNode, collapsible);\n  }\n  isCollapsed(location) {\n    const compressedNode = this.getCompressedNode(location);\n    return this.model.isCollapsed(compressedNode);\n  }\n  setCollapsed(location, collapsed, recursive) {\n    const compressedNode = this.getCompressedNode(location);\n    return this.model.setCollapsed(compressedNode, collapsed, recursive);\n  }\n  expandTo(location) {\n    const compressedNode = this.getCompressedNode(location);\n    this.model.expandTo(compressedNode);\n  }\n  rerender(location) {\n    const compressedNode = this.getCompressedNode(location);\n    this.model.rerender(compressedNode);\n  }\n  refilter() {\n    this.model.refilter();\n  }\n  getCompressedNode(element) {\n    if (element === null) {\n      return null;\n    }\n    const node = this.nodes.get(element);\n    if (!node) {\n      throw new TreeError(this.user, `Tree element not found: ${element}`);\n    }\n    return node;\n  }\n}\nexport const DefaultElementMapper = elements => elements[elements.length - 1];\nclass CompressedTreeNodeWrapper {\n  get element() {\n    return this.node.element === null ? null : this.unwrapper(this.node.element);\n  }\n  get children() {\n    return this.node.children.map(node => new CompressedTreeNodeWrapper(this.unwrapper, node));\n  }\n  get depth() {\n    return this.node.depth;\n  }\n  get visibleChildrenCount() {\n    return this.node.visibleChildrenCount;\n  }\n  get visibleChildIndex() {\n    return this.node.visibleChildIndex;\n  }\n  get collapsible() {\n    return this.node.collapsible;\n  }\n  get collapsed() {\n    return this.node.collapsed;\n  }\n  get visible() {\n    return this.node.visible;\n  }\n  get filterData() {\n    return this.node.filterData;\n  }\n  constructor(unwrapper, node) {\n    this.unwrapper = unwrapper;\n    this.node = node;\n  }\n}\nfunction mapList(nodeMapper, list) {\n  return {\n    splice(start, deleteCount, toInsert) {\n      list.splice(start, deleteCount, toInsert.map(node => nodeMapper.map(node)));\n    },\n    updateElementHeight(index, height) {\n      list.updateElementHeight(index, height);\n    }\n  };\n}\nfunction mapOptions(compressedNodeUnwrapper, options) {\n  return {\n    ...options,\n    identityProvider: options.identityProvider && {\n      getId(node) {\n        return options.identityProvider.getId(compressedNodeUnwrapper(node));\n      }\n    },\n    sorter: options.sorter && {\n      compare(node, otherNode) {\n        return options.sorter.compare(node.elements[0], otherNode.elements[0]);\n      }\n    },\n    filter: options.filter && {\n      filter(node, parentVisibility) {\n        return options.filter.filter(compressedNodeUnwrapper(node), parentVisibility);\n      }\n    }\n  };\n}\nexport class CompressibleObjectTreeModel {\n  get onDidSplice() {\n    return Event.map(this.model.onDidSplice, _ref => {\n      let {\n        insertedNodes,\n        deletedNodes\n      } = _ref;\n      return {\n        insertedNodes: insertedNodes.map(node => this.nodeMapper.map(node)),\n        deletedNodes: deletedNodes.map(node => this.nodeMapper.map(node))\n      };\n    });\n  }\n  get onDidChangeCollapseState() {\n    return Event.map(this.model.onDidChangeCollapseState, _ref2 => {\n      let {\n        node,\n        deep\n      } = _ref2;\n      return {\n        node: this.nodeMapper.map(node),\n        deep\n      };\n    });\n  }\n  get onDidChangeRenderNodeCount() {\n    return Event.map(this.model.onDidChangeRenderNodeCount, node => this.nodeMapper.map(node));\n  }\n  constructor(user, list) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this.rootRef = null;\n    this.elementMapper = options.elementMapper || DefaultElementMapper;\n    const compressedNodeUnwrapper = node => this.elementMapper(node.elements);\n    this.nodeMapper = new WeakMapper(node => new CompressedTreeNodeWrapper(compressedNodeUnwrapper, node));\n    this.model = new CompressedObjectTreeModel(user, mapList(this.nodeMapper, list), mapOptions(compressedNodeUnwrapper, options));\n  }\n  setChildren(element) {\n    let children = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Iterable.empty();\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this.model.setChildren(element, children, options);\n  }\n  isCompressionEnabled() {\n    return this.model.isCompressionEnabled();\n  }\n  setCompressionEnabled(enabled) {\n    this.model.setCompressionEnabled(enabled);\n  }\n  has(location) {\n    return this.model.has(location);\n  }\n  getListIndex(location) {\n    return this.model.getListIndex(location);\n  }\n  getListRenderCount(location) {\n    return this.model.getListRenderCount(location);\n  }\n  getNode(location) {\n    return this.nodeMapper.map(this.model.getNode(location));\n  }\n  getNodeLocation(node) {\n    return node.element;\n  }\n  getParentNodeLocation(location) {\n    return this.model.getParentNodeLocation(location);\n  }\n  getFirstElementChild(location) {\n    const result = this.model.getFirstElementChild(location);\n    if (result === null || typeof result === 'undefined') {\n      return result;\n    }\n    return this.elementMapper(result.elements);\n  }\n  isCollapsible(location) {\n    return this.model.isCollapsible(location);\n  }\n  setCollapsible(location, collapsed) {\n    return this.model.setCollapsible(location, collapsed);\n  }\n  isCollapsed(location) {\n    return this.model.isCollapsed(location);\n  }\n  setCollapsed(location, collapsed, recursive) {\n    return this.model.setCollapsed(location, collapsed, recursive);\n  }\n  expandTo(location) {\n    return this.model.expandTo(location);\n  }\n  rerender(location) {\n    return this.model.rerender(location);\n  }\n  refilter() {\n    return this.model.refilter();\n  }\n  getCompressedTreeNode() {\n    let location = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    return this.model.getNode(location);\n  }\n}","map":{"version":3,"names":["ObjectTreeModel","TreeError","WeakMapper","equals","Event","Iterable","noCompress","element","elements","incompressible","children","map","from","collapsible","collapsed","compress","childrenIterator","consume","length","push","concat","_decompress","index","arguments","undefined","el","decompress","splice","treeElement","e","wrapIdentityProvider","base","getId","node","toString","join","CompressedObjectTreeModel","onDidSplice","model","onDidChangeCollapseState","onDidChangeRenderNodeCount","constructor","user","list","options","rootRef","nodes","Map","enabled","compressionEnabled","identityProvider","setChildren","empty","diffIdentityProvider","compressedChildren","_setChildren","diffDepth","Infinity","compressedNode","get","getNode","compressedParentNode","getParentNodeLocation","parent","decompressedElement","splicedElement","recompressedElement","elementComparator","a","b","parentChildren","child","depth","isCompressionEnabled","setCompressionEnabled","root","rootChildren","decompressedRootChildren","recompressedRootChildren","insertedElements","Set","onDidCreateNode","add","set","onDidDeleteNode","has","delete","getListIndex","location","getCompressedNode","getListRenderCount","getNodeLocation","parentNode","getFirstElementChild","isCollapsible","setCollapsible","isCollapsed","setCollapsed","recursive","expandTo","rerender","refilter","DefaultElementMapper","CompressedTreeNodeWrapper","unwrapper","visibleChildrenCount","visibleChildIndex","visible","filterData","mapList","nodeMapper","start","deleteCount","toInsert","updateElementHeight","height","mapOptions","compressedNodeUnwrapper","sorter","compare","otherNode","filter","parentVisibility","CompressibleObjectTreeModel","_ref","insertedNodes","deletedNodes","_ref2","deep","elementMapper","result","getCompressedTreeNode"],"sources":["/home/arslan/modojo/node_modules/monaco-editor/esm/vs/base/browser/ui/tree/compressedObjectTreeModel.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ObjectTreeModel } from './objectTreeModel.js';\nimport { TreeError, WeakMapper } from './tree.js';\nimport { equals } from '../../../common/arrays.js';\nimport { Event } from '../../../common/event.js';\nimport { Iterable } from '../../../common/iterator.js';\nfunction noCompress(element) {\n    const elements = [element.element];\n    const incompressible = element.incompressible || false;\n    return {\n        element: { elements, incompressible },\n        children: Iterable.map(Iterable.from(element.children), noCompress),\n        collapsible: element.collapsible,\n        collapsed: element.collapsed\n    };\n}\n// Exported only for test reasons, do not use directly\nexport function compress(element) {\n    const elements = [element.element];\n    const incompressible = element.incompressible || false;\n    let childrenIterator;\n    let children;\n    while (true) {\n        [children, childrenIterator] = Iterable.consume(Iterable.from(element.children), 2);\n        if (children.length !== 1) {\n            break;\n        }\n        if (children[0].incompressible) {\n            break;\n        }\n        element = children[0];\n        elements.push(element.element);\n    }\n    return {\n        element: { elements, incompressible },\n        children: Iterable.map(Iterable.concat(children, childrenIterator), compress),\n        collapsible: element.collapsible,\n        collapsed: element.collapsed\n    };\n}\nfunction _decompress(element, index = 0) {\n    let children;\n    if (index < element.element.elements.length - 1) {\n        children = [_decompress(element, index + 1)];\n    }\n    else {\n        children = Iterable.map(Iterable.from(element.children), el => _decompress(el, 0));\n    }\n    if (index === 0 && element.element.incompressible) {\n        return {\n            element: element.element.elements[index],\n            children,\n            incompressible: true,\n            collapsible: element.collapsible,\n            collapsed: element.collapsed\n        };\n    }\n    return {\n        element: element.element.elements[index],\n        children,\n        collapsible: element.collapsible,\n        collapsed: element.collapsed\n    };\n}\n// Exported only for test reasons, do not use directly\nexport function decompress(element) {\n    return _decompress(element, 0);\n}\nfunction splice(treeElement, element, children) {\n    if (treeElement.element === element) {\n        return { ...treeElement, children };\n    }\n    return { ...treeElement, children: Iterable.map(Iterable.from(treeElement.children), e => splice(e, element, children)) };\n}\nconst wrapIdentityProvider = (base) => ({\n    getId(node) {\n        return node.elements.map(e => base.getId(e).toString()).join('\\0');\n    }\n});\n// Exported only for test reasons, do not use directly\nexport class CompressedObjectTreeModel {\n    get onDidSplice() { return this.model.onDidSplice; }\n    get onDidChangeCollapseState() { return this.model.onDidChangeCollapseState; }\n    get onDidChangeRenderNodeCount() { return this.model.onDidChangeRenderNodeCount; }\n    constructor(user, list, options = {}) {\n        this.user = user;\n        this.rootRef = null;\n        this.nodes = new Map();\n        this.model = new ObjectTreeModel(user, list, options);\n        this.enabled = typeof options.compressionEnabled === 'undefined' ? true : options.compressionEnabled;\n        this.identityProvider = options.identityProvider;\n    }\n    setChildren(element, children = Iterable.empty(), options) {\n        // Diffs must be deep, since the compression can affect nested elements.\n        // @see https://github.com/microsoft/vscode/pull/114237#issuecomment-759425034\n        const diffIdentityProvider = options.diffIdentityProvider && wrapIdentityProvider(options.diffIdentityProvider);\n        if (element === null) {\n            const compressedChildren = Iterable.map(children, this.enabled ? compress : noCompress);\n            this._setChildren(null, compressedChildren, { diffIdentityProvider, diffDepth: Infinity });\n            return;\n        }\n        const compressedNode = this.nodes.get(element);\n        if (!compressedNode) {\n            throw new TreeError(this.user, 'Unknown compressed tree node');\n        }\n        const node = this.model.getNode(compressedNode);\n        const compressedParentNode = this.model.getParentNodeLocation(compressedNode);\n        const parent = this.model.getNode(compressedParentNode);\n        const decompressedElement = decompress(node);\n        const splicedElement = splice(decompressedElement, element, children);\n        const recompressedElement = (this.enabled ? compress : noCompress)(splicedElement);\n        // If the recompressed node is identical to the original, just set its children.\n        // Saves work and churn diffing the parent element.\n        const elementComparator = options.diffIdentityProvider\n            ? ((a, b) => options.diffIdentityProvider.getId(a) === options.diffIdentityProvider.getId(b))\n            : undefined;\n        if (equals(recompressedElement.element.elements, node.element.elements, elementComparator)) {\n            this._setChildren(compressedNode, recompressedElement.children || Iterable.empty(), { diffIdentityProvider, diffDepth: 1 });\n            return;\n        }\n        const parentChildren = parent.children\n            .map(child => child === node ? recompressedElement : child);\n        this._setChildren(parent.element, parentChildren, {\n            diffIdentityProvider,\n            diffDepth: node.depth - parent.depth,\n        });\n    }\n    isCompressionEnabled() {\n        return this.enabled;\n    }\n    setCompressionEnabled(enabled) {\n        if (enabled === this.enabled) {\n            return;\n        }\n        this.enabled = enabled;\n        const root = this.model.getNode();\n        const rootChildren = root.children;\n        const decompressedRootChildren = Iterable.map(rootChildren, decompress);\n        const recompressedRootChildren = Iterable.map(decompressedRootChildren, enabled ? compress : noCompress);\n        // it should be safe to always use deep diff mode here if an identity\n        // provider is available, since we know the raw nodes are unchanged.\n        this._setChildren(null, recompressedRootChildren, {\n            diffIdentityProvider: this.identityProvider,\n            diffDepth: Infinity,\n        });\n    }\n    _setChildren(node, children, options) {\n        const insertedElements = new Set();\n        const onDidCreateNode = (node) => {\n            for (const element of node.element.elements) {\n                insertedElements.add(element);\n                this.nodes.set(element, node.element);\n            }\n        };\n        const onDidDeleteNode = (node) => {\n            for (const element of node.element.elements) {\n                if (!insertedElements.has(element)) {\n                    this.nodes.delete(element);\n                }\n            }\n        };\n        this.model.setChildren(node, children, { ...options, onDidCreateNode, onDidDeleteNode });\n    }\n    has(element) {\n        return this.nodes.has(element);\n    }\n    getListIndex(location) {\n        const node = this.getCompressedNode(location);\n        return this.model.getListIndex(node);\n    }\n    getListRenderCount(location) {\n        const node = this.getCompressedNode(location);\n        return this.model.getListRenderCount(node);\n    }\n    getNode(location) {\n        if (typeof location === 'undefined') {\n            return this.model.getNode();\n        }\n        const node = this.getCompressedNode(location);\n        return this.model.getNode(node);\n    }\n    // TODO: review this\n    getNodeLocation(node) {\n        const compressedNode = this.model.getNodeLocation(node);\n        if (compressedNode === null) {\n            return null;\n        }\n        return compressedNode.elements[compressedNode.elements.length - 1];\n    }\n    // TODO: review this\n    getParentNodeLocation(location) {\n        const compressedNode = this.getCompressedNode(location);\n        const parentNode = this.model.getParentNodeLocation(compressedNode);\n        if (parentNode === null) {\n            return null;\n        }\n        return parentNode.elements[parentNode.elements.length - 1];\n    }\n    getFirstElementChild(location) {\n        const compressedNode = this.getCompressedNode(location);\n        return this.model.getFirstElementChild(compressedNode);\n    }\n    isCollapsible(location) {\n        const compressedNode = this.getCompressedNode(location);\n        return this.model.isCollapsible(compressedNode);\n    }\n    setCollapsible(location, collapsible) {\n        const compressedNode = this.getCompressedNode(location);\n        return this.model.setCollapsible(compressedNode, collapsible);\n    }\n    isCollapsed(location) {\n        const compressedNode = this.getCompressedNode(location);\n        return this.model.isCollapsed(compressedNode);\n    }\n    setCollapsed(location, collapsed, recursive) {\n        const compressedNode = this.getCompressedNode(location);\n        return this.model.setCollapsed(compressedNode, collapsed, recursive);\n    }\n    expandTo(location) {\n        const compressedNode = this.getCompressedNode(location);\n        this.model.expandTo(compressedNode);\n    }\n    rerender(location) {\n        const compressedNode = this.getCompressedNode(location);\n        this.model.rerender(compressedNode);\n    }\n    refilter() {\n        this.model.refilter();\n    }\n    getCompressedNode(element) {\n        if (element === null) {\n            return null;\n        }\n        const node = this.nodes.get(element);\n        if (!node) {\n            throw new TreeError(this.user, `Tree element not found: ${element}`);\n        }\n        return node;\n    }\n}\nexport const DefaultElementMapper = elements => elements[elements.length - 1];\nclass CompressedTreeNodeWrapper {\n    get element() { return this.node.element === null ? null : this.unwrapper(this.node.element); }\n    get children() { return this.node.children.map(node => new CompressedTreeNodeWrapper(this.unwrapper, node)); }\n    get depth() { return this.node.depth; }\n    get visibleChildrenCount() { return this.node.visibleChildrenCount; }\n    get visibleChildIndex() { return this.node.visibleChildIndex; }\n    get collapsible() { return this.node.collapsible; }\n    get collapsed() { return this.node.collapsed; }\n    get visible() { return this.node.visible; }\n    get filterData() { return this.node.filterData; }\n    constructor(unwrapper, node) {\n        this.unwrapper = unwrapper;\n        this.node = node;\n    }\n}\nfunction mapList(nodeMapper, list) {\n    return {\n        splice(start, deleteCount, toInsert) {\n            list.splice(start, deleteCount, toInsert.map(node => nodeMapper.map(node)));\n        },\n        updateElementHeight(index, height) {\n            list.updateElementHeight(index, height);\n        }\n    };\n}\nfunction mapOptions(compressedNodeUnwrapper, options) {\n    return {\n        ...options,\n        identityProvider: options.identityProvider && {\n            getId(node) {\n                return options.identityProvider.getId(compressedNodeUnwrapper(node));\n            }\n        },\n        sorter: options.sorter && {\n            compare(node, otherNode) {\n                return options.sorter.compare(node.elements[0], otherNode.elements[0]);\n            }\n        },\n        filter: options.filter && {\n            filter(node, parentVisibility) {\n                return options.filter.filter(compressedNodeUnwrapper(node), parentVisibility);\n            }\n        }\n    };\n}\nexport class CompressibleObjectTreeModel {\n    get onDidSplice() {\n        return Event.map(this.model.onDidSplice, ({ insertedNodes, deletedNodes }) => ({\n            insertedNodes: insertedNodes.map(node => this.nodeMapper.map(node)),\n            deletedNodes: deletedNodes.map(node => this.nodeMapper.map(node)),\n        }));\n    }\n    get onDidChangeCollapseState() {\n        return Event.map(this.model.onDidChangeCollapseState, ({ node, deep }) => ({\n            node: this.nodeMapper.map(node),\n            deep\n        }));\n    }\n    get onDidChangeRenderNodeCount() {\n        return Event.map(this.model.onDidChangeRenderNodeCount, node => this.nodeMapper.map(node));\n    }\n    constructor(user, list, options = {}) {\n        this.rootRef = null;\n        this.elementMapper = options.elementMapper || DefaultElementMapper;\n        const compressedNodeUnwrapper = node => this.elementMapper(node.elements);\n        this.nodeMapper = new WeakMapper(node => new CompressedTreeNodeWrapper(compressedNodeUnwrapper, node));\n        this.model = new CompressedObjectTreeModel(user, mapList(this.nodeMapper, list), mapOptions(compressedNodeUnwrapper, options));\n    }\n    setChildren(element, children = Iterable.empty(), options = {}) {\n        this.model.setChildren(element, children, options);\n    }\n    isCompressionEnabled() {\n        return this.model.isCompressionEnabled();\n    }\n    setCompressionEnabled(enabled) {\n        this.model.setCompressionEnabled(enabled);\n    }\n    has(location) {\n        return this.model.has(location);\n    }\n    getListIndex(location) {\n        return this.model.getListIndex(location);\n    }\n    getListRenderCount(location) {\n        return this.model.getListRenderCount(location);\n    }\n    getNode(location) {\n        return this.nodeMapper.map(this.model.getNode(location));\n    }\n    getNodeLocation(node) {\n        return node.element;\n    }\n    getParentNodeLocation(location) {\n        return this.model.getParentNodeLocation(location);\n    }\n    getFirstElementChild(location) {\n        const result = this.model.getFirstElementChild(location);\n        if (result === null || typeof result === 'undefined') {\n            return result;\n        }\n        return this.elementMapper(result.elements);\n    }\n    isCollapsible(location) {\n        return this.model.isCollapsible(location);\n    }\n    setCollapsible(location, collapsed) {\n        return this.model.setCollapsible(location, collapsed);\n    }\n    isCollapsed(location) {\n        return this.model.isCollapsed(location);\n    }\n    setCollapsed(location, collapsed, recursive) {\n        return this.model.setCollapsed(location, collapsed, recursive);\n    }\n    expandTo(location) {\n        return this.model.expandTo(location);\n    }\n    rerender(location) {\n        return this.model.rerender(location);\n    }\n    refilter() {\n        return this.model.refilter();\n    }\n    getCompressedTreeNode(location = null) {\n        return this.model.getNode(location);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}