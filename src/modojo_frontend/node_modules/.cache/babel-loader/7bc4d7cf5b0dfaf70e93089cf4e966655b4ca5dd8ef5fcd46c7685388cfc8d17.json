{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { timeout } from '../../../base/common/async.js';\nimport { CancellationTokenSource } from '../../../base/common/cancellation.js';\nimport { Disposable, DisposableStore, MutableDisposable } from '../../../base/common/lifecycle.js';\nimport { isFunction } from '../../../base/common/types.js';\nexport var TriggerAction;\n(function (TriggerAction) {\n  /**\n   * Do nothing after the button was clicked.\n   */\n  TriggerAction[TriggerAction[\"NO_ACTION\"] = 0] = \"NO_ACTION\";\n  /**\n   * Close the picker.\n   */\n  TriggerAction[TriggerAction[\"CLOSE_PICKER\"] = 1] = \"CLOSE_PICKER\";\n  /**\n   * Update the results of the picker.\n   */\n  TriggerAction[TriggerAction[\"REFRESH_PICKER\"] = 2] = \"REFRESH_PICKER\";\n  /**\n   * Remove the item from the picker.\n   */\n  TriggerAction[TriggerAction[\"REMOVE_ITEM\"] = 3] = \"REMOVE_ITEM\";\n})(TriggerAction || (TriggerAction = {}));\nfunction isPicksWithActive(obj) {\n  const candidate = obj;\n  return Array.isArray(candidate.items);\n}\nfunction isFastAndSlowPicks(obj) {\n  const candidate = obj;\n  return !!candidate.picks && candidate.additionalPicks instanceof Promise;\n}\nexport class PickerQuickAccessProvider extends Disposable {\n  constructor(prefix, options) {\n    super();\n    this.prefix = prefix;\n    this.options = options;\n  }\n  provide(picker, token, runOptions) {\n    var _a;\n    const disposables = new DisposableStore();\n    // Apply options if any\n    picker.canAcceptInBackground = !!((_a = this.options) === null || _a === void 0 ? void 0 : _a.canAcceptInBackground);\n    // Disable filtering & sorting, we control the results\n    picker.matchOnLabel = picker.matchOnDescription = picker.matchOnDetail = picker.sortByLabel = false;\n    // Set initial picks and update on type\n    let picksCts = undefined;\n    const picksDisposable = disposables.add(new MutableDisposable());\n    const updatePickerItems = async () => {\n      var _a;\n      const picksDisposables = picksDisposable.value = new DisposableStore();\n      // Cancel any previous ask for picks and busy\n      picksCts === null || picksCts === void 0 ? void 0 : picksCts.dispose(true);\n      picker.busy = false;\n      // Create new cancellation source for this run\n      picksCts = new CancellationTokenSource(token);\n      // Collect picks and support both long running and short or combined\n      const picksToken = picksCts.token;\n      let picksFilter = picker.value.substring(this.prefix.length);\n      if (!((_a = this.options) === null || _a === void 0 ? void 0 : _a.shouldSkipTrimPickFilter)) {\n        picksFilter = picksFilter.trim();\n      }\n      const providedPicks = this._getPicks(picksFilter, picksDisposables, picksToken, runOptions);\n      const applyPicks = (picks, skipEmpty) => {\n        var _a;\n        let items;\n        let activeItem = undefined;\n        if (isPicksWithActive(picks)) {\n          items = picks.items;\n          activeItem = picks.active;\n        } else {\n          items = picks;\n        }\n        if (items.length === 0) {\n          if (skipEmpty) {\n            return false;\n          }\n          // We show the no results pick if we have no input to prevent completely empty pickers #172613\n          if ((picksFilter.length > 0 || picker.hideInput) && ((_a = this.options) === null || _a === void 0 ? void 0 : _a.noResultsPick)) {\n            if (isFunction(this.options.noResultsPick)) {\n              items = [this.options.noResultsPick(picksFilter)];\n            } else {\n              items = [this.options.noResultsPick];\n            }\n          }\n        }\n        picker.items = items;\n        if (activeItem) {\n          picker.activeItems = [activeItem];\n        }\n        return true;\n      };\n      const applyFastAndSlowPicks = async fastAndSlowPicks => {\n        let fastPicksApplied = false;\n        let slowPicksApplied = false;\n        await Promise.all([\n        // Fast Picks: if `mergeDelay` is configured, in order to reduce\n        // amount of flicker, we race against the slow picks over some delay\n        // and then set the fast picks.\n        // If the slow picks are faster, we reduce the flicker by only\n        // setting the items once.\n        (async () => {\n          if (typeof fastAndSlowPicks.mergeDelay === 'number') {\n            await timeout(fastAndSlowPicks.mergeDelay);\n            if (picksToken.isCancellationRequested) {\n              return;\n            }\n          }\n          if (!slowPicksApplied) {\n            fastPicksApplied = applyPicks(fastAndSlowPicks.picks, true /* skip over empty to reduce flicker */);\n          }\n        })(),\n        // Slow Picks: we await the slow picks and then set them at\n        // once together with the fast picks, but only if we actually\n        // have additional results.\n        (async () => {\n          picker.busy = true;\n          try {\n            const awaitedAdditionalPicks = await fastAndSlowPicks.additionalPicks;\n            if (picksToken.isCancellationRequested) {\n              return;\n            }\n            let picks;\n            let activePick = undefined;\n            if (isPicksWithActive(fastAndSlowPicks.picks)) {\n              picks = fastAndSlowPicks.picks.items;\n              activePick = fastAndSlowPicks.picks.active;\n            } else {\n              picks = fastAndSlowPicks.picks;\n            }\n            let additionalPicks;\n            let additionalActivePick = undefined;\n            if (isPicksWithActive(awaitedAdditionalPicks)) {\n              additionalPicks = awaitedAdditionalPicks.items;\n              additionalActivePick = awaitedAdditionalPicks.active;\n            } else {\n              additionalPicks = awaitedAdditionalPicks;\n            }\n            if (additionalPicks.length > 0 || !fastPicksApplied) {\n              // If we do not have any activePick or additionalActivePick\n              // we try to preserve the currently active pick from the\n              // fast results. This fixes an issue where the user might\n              // have made a pick active before the additional results\n              // kick in.\n              // See https://github.com/microsoft/vscode/issues/102480\n              let fallbackActivePick = undefined;\n              if (!activePick && !additionalActivePick) {\n                const fallbackActivePickCandidate = picker.activeItems[0];\n                if (fallbackActivePickCandidate && picks.indexOf(fallbackActivePickCandidate) !== -1) {\n                  fallbackActivePick = fallbackActivePickCandidate;\n                }\n              }\n              applyPicks({\n                items: [...picks, ...additionalPicks],\n                active: activePick || additionalActivePick || fallbackActivePick\n              });\n            }\n          } finally {\n            if (!picksToken.isCancellationRequested) {\n              picker.busy = false;\n            }\n            slowPicksApplied = true;\n          }\n        })()]);\n      };\n      // No Picks\n      if (providedPicks === null) {\n        // Ignore\n      }\n      // Fast and Slow Picks\n      else if (isFastAndSlowPicks(providedPicks)) {\n        await applyFastAndSlowPicks(providedPicks);\n      }\n      // Fast Picks\n      else if (!(providedPicks instanceof Promise)) {\n        applyPicks(providedPicks);\n      }\n      // Slow Picks\n      else {\n        picker.busy = true;\n        try {\n          const awaitedPicks = await providedPicks;\n          if (picksToken.isCancellationRequested) {\n            return;\n          }\n          if (isFastAndSlowPicks(awaitedPicks)) {\n            await applyFastAndSlowPicks(awaitedPicks);\n          } else {\n            applyPicks(awaitedPicks);\n          }\n        } finally {\n          if (!picksToken.isCancellationRequested) {\n            picker.busy = false;\n          }\n        }\n      }\n    };\n    disposables.add(picker.onDidChangeValue(() => updatePickerItems()));\n    updatePickerItems();\n    // Accept the pick on accept and hide picker\n    disposables.add(picker.onDidAccept(event => {\n      var _a;\n      if (runOptions === null || runOptions === void 0 ? void 0 : runOptions.handleAccept) {\n        if (!event.inBackground) {\n          picker.hide(); // hide picker unless we accept in background\n        }\n        (_a = runOptions.handleAccept) === null || _a === void 0 ? void 0 : _a.call(runOptions, picker.activeItems[0]);\n        return;\n      }\n      const [item] = picker.selectedItems;\n      if (typeof (item === null || item === void 0 ? void 0 : item.accept) === 'function') {\n        if (!event.inBackground) {\n          picker.hide(); // hide picker unless we accept in background\n        }\n        item.accept(picker.keyMods, event);\n      }\n    }));\n    const buttonTrigger = async (button, item) => {\n      var _a, _b;\n      if (typeof item.trigger !== 'function') {\n        return;\n      }\n      const buttonIndex = (_b = (_a = item.buttons) === null || _a === void 0 ? void 0 : _a.indexOf(button)) !== null && _b !== void 0 ? _b : -1;\n      if (buttonIndex >= 0) {\n        const result = item.trigger(buttonIndex, picker.keyMods);\n        const action = typeof result === 'number' ? result : await result;\n        if (token.isCancellationRequested) {\n          return;\n        }\n        switch (action) {\n          case TriggerAction.NO_ACTION:\n            break;\n          case TriggerAction.CLOSE_PICKER:\n            picker.hide();\n            break;\n          case TriggerAction.REFRESH_PICKER:\n            updatePickerItems();\n            break;\n          case TriggerAction.REMOVE_ITEM:\n            {\n              const index = picker.items.indexOf(item);\n              if (index !== -1) {\n                const items = picker.items.slice();\n                const removed = items.splice(index, 1);\n                const activeItems = picker.activeItems.filter(activeItem => activeItem !== removed[0]);\n                const keepScrollPositionBefore = picker.keepScrollPosition;\n                picker.keepScrollPosition = true;\n                picker.items = items;\n                if (activeItems) {\n                  picker.activeItems = activeItems;\n                }\n                picker.keepScrollPosition = keepScrollPositionBefore;\n              }\n              break;\n            }\n        }\n      }\n    };\n    // Trigger the pick with button index if button triggered\n    disposables.add(picker.onDidTriggerItemButton(_ref => {\n      let {\n        button,\n        item\n      } = _ref;\n      return buttonTrigger(button, item);\n    }));\n    disposables.add(picker.onDidTriggerSeparatorButton(_ref2 => {\n      let {\n        button,\n        separator\n      } = _ref2;\n      return buttonTrigger(button, separator);\n    }));\n    return disposables;\n  }\n}","map":{"version":3,"names":["timeout","CancellationTokenSource","Disposable","DisposableStore","MutableDisposable","isFunction","TriggerAction","isPicksWithActive","obj","candidate","Array","isArray","items","isFastAndSlowPicks","picks","additionalPicks","Promise","PickerQuickAccessProvider","constructor","prefix","options","provide","picker","token","runOptions","_a","disposables","canAcceptInBackground","matchOnLabel","matchOnDescription","matchOnDetail","sortByLabel","picksCts","undefined","picksDisposable","add","updatePickerItems","picksDisposables","value","dispose","busy","picksToken","picksFilter","substring","length","shouldSkipTrimPickFilter","trim","providedPicks","_getPicks","applyPicks","skipEmpty","activeItem","active","hideInput","noResultsPick","activeItems","applyFastAndSlowPicks","fastAndSlowPicks","fastPicksApplied","slowPicksApplied","all","mergeDelay","isCancellationRequested","awaitedAdditionalPicks","activePick","additionalActivePick","fallbackActivePick","fallbackActivePickCandidate","indexOf","awaitedPicks","onDidChangeValue","onDidAccept","event","handleAccept","inBackground","hide","call","item","selectedItems","accept","keyMods","buttonTrigger","button","_b","trigger","buttonIndex","buttons","result","action","NO_ACTION","CLOSE_PICKER","REFRESH_PICKER","REMOVE_ITEM","index","slice","removed","splice","filter","keepScrollPositionBefore","keepScrollPosition","onDidTriggerItemButton","_ref","onDidTriggerSeparatorButton","_ref2","separator"],"sources":["/home/arslan/modojo/node_modules/monaco-editor/esm/vs/platform/quickinput/browser/pickerQuickAccess.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { timeout } from '../../../base/common/async.js';\nimport { CancellationTokenSource } from '../../../base/common/cancellation.js';\nimport { Disposable, DisposableStore, MutableDisposable } from '../../../base/common/lifecycle.js';\nimport { isFunction } from '../../../base/common/types.js';\nexport var TriggerAction;\n(function (TriggerAction) {\n    /**\n     * Do nothing after the button was clicked.\n     */\n    TriggerAction[TriggerAction[\"NO_ACTION\"] = 0] = \"NO_ACTION\";\n    /**\n     * Close the picker.\n     */\n    TriggerAction[TriggerAction[\"CLOSE_PICKER\"] = 1] = \"CLOSE_PICKER\";\n    /**\n     * Update the results of the picker.\n     */\n    TriggerAction[TriggerAction[\"REFRESH_PICKER\"] = 2] = \"REFRESH_PICKER\";\n    /**\n     * Remove the item from the picker.\n     */\n    TriggerAction[TriggerAction[\"REMOVE_ITEM\"] = 3] = \"REMOVE_ITEM\";\n})(TriggerAction || (TriggerAction = {}));\nfunction isPicksWithActive(obj) {\n    const candidate = obj;\n    return Array.isArray(candidate.items);\n}\nfunction isFastAndSlowPicks(obj) {\n    const candidate = obj;\n    return !!candidate.picks && candidate.additionalPicks instanceof Promise;\n}\nexport class PickerQuickAccessProvider extends Disposable {\n    constructor(prefix, options) {\n        super();\n        this.prefix = prefix;\n        this.options = options;\n    }\n    provide(picker, token, runOptions) {\n        var _a;\n        const disposables = new DisposableStore();\n        // Apply options if any\n        picker.canAcceptInBackground = !!((_a = this.options) === null || _a === void 0 ? void 0 : _a.canAcceptInBackground);\n        // Disable filtering & sorting, we control the results\n        picker.matchOnLabel = picker.matchOnDescription = picker.matchOnDetail = picker.sortByLabel = false;\n        // Set initial picks and update on type\n        let picksCts = undefined;\n        const picksDisposable = disposables.add(new MutableDisposable());\n        const updatePickerItems = async () => {\n            var _a;\n            const picksDisposables = picksDisposable.value = new DisposableStore();\n            // Cancel any previous ask for picks and busy\n            picksCts === null || picksCts === void 0 ? void 0 : picksCts.dispose(true);\n            picker.busy = false;\n            // Create new cancellation source for this run\n            picksCts = new CancellationTokenSource(token);\n            // Collect picks and support both long running and short or combined\n            const picksToken = picksCts.token;\n            let picksFilter = picker.value.substring(this.prefix.length);\n            if (!((_a = this.options) === null || _a === void 0 ? void 0 : _a.shouldSkipTrimPickFilter)) {\n                picksFilter = picksFilter.trim();\n            }\n            const providedPicks = this._getPicks(picksFilter, picksDisposables, picksToken, runOptions);\n            const applyPicks = (picks, skipEmpty) => {\n                var _a;\n                let items;\n                let activeItem = undefined;\n                if (isPicksWithActive(picks)) {\n                    items = picks.items;\n                    activeItem = picks.active;\n                }\n                else {\n                    items = picks;\n                }\n                if (items.length === 0) {\n                    if (skipEmpty) {\n                        return false;\n                    }\n                    // We show the no results pick if we have no input to prevent completely empty pickers #172613\n                    if ((picksFilter.length > 0 || picker.hideInput) && ((_a = this.options) === null || _a === void 0 ? void 0 : _a.noResultsPick)) {\n                        if (isFunction(this.options.noResultsPick)) {\n                            items = [this.options.noResultsPick(picksFilter)];\n                        }\n                        else {\n                            items = [this.options.noResultsPick];\n                        }\n                    }\n                }\n                picker.items = items;\n                if (activeItem) {\n                    picker.activeItems = [activeItem];\n                }\n                return true;\n            };\n            const applyFastAndSlowPicks = async (fastAndSlowPicks) => {\n                let fastPicksApplied = false;\n                let slowPicksApplied = false;\n                await Promise.all([\n                    // Fast Picks: if `mergeDelay` is configured, in order to reduce\n                    // amount of flicker, we race against the slow picks over some delay\n                    // and then set the fast picks.\n                    // If the slow picks are faster, we reduce the flicker by only\n                    // setting the items once.\n                    (async () => {\n                        if (typeof fastAndSlowPicks.mergeDelay === 'number') {\n                            await timeout(fastAndSlowPicks.mergeDelay);\n                            if (picksToken.isCancellationRequested) {\n                                return;\n                            }\n                        }\n                        if (!slowPicksApplied) {\n                            fastPicksApplied = applyPicks(fastAndSlowPicks.picks, true /* skip over empty to reduce flicker */);\n                        }\n                    })(),\n                    // Slow Picks: we await the slow picks and then set them at\n                    // once together with the fast picks, but only if we actually\n                    // have additional results.\n                    (async () => {\n                        picker.busy = true;\n                        try {\n                            const awaitedAdditionalPicks = await fastAndSlowPicks.additionalPicks;\n                            if (picksToken.isCancellationRequested) {\n                                return;\n                            }\n                            let picks;\n                            let activePick = undefined;\n                            if (isPicksWithActive(fastAndSlowPicks.picks)) {\n                                picks = fastAndSlowPicks.picks.items;\n                                activePick = fastAndSlowPicks.picks.active;\n                            }\n                            else {\n                                picks = fastAndSlowPicks.picks;\n                            }\n                            let additionalPicks;\n                            let additionalActivePick = undefined;\n                            if (isPicksWithActive(awaitedAdditionalPicks)) {\n                                additionalPicks = awaitedAdditionalPicks.items;\n                                additionalActivePick = awaitedAdditionalPicks.active;\n                            }\n                            else {\n                                additionalPicks = awaitedAdditionalPicks;\n                            }\n                            if (additionalPicks.length > 0 || !fastPicksApplied) {\n                                // If we do not have any activePick or additionalActivePick\n                                // we try to preserve the currently active pick from the\n                                // fast results. This fixes an issue where the user might\n                                // have made a pick active before the additional results\n                                // kick in.\n                                // See https://github.com/microsoft/vscode/issues/102480\n                                let fallbackActivePick = undefined;\n                                if (!activePick && !additionalActivePick) {\n                                    const fallbackActivePickCandidate = picker.activeItems[0];\n                                    if (fallbackActivePickCandidate && picks.indexOf(fallbackActivePickCandidate) !== -1) {\n                                        fallbackActivePick = fallbackActivePickCandidate;\n                                    }\n                                }\n                                applyPicks({\n                                    items: [...picks, ...additionalPicks],\n                                    active: activePick || additionalActivePick || fallbackActivePick\n                                });\n                            }\n                        }\n                        finally {\n                            if (!picksToken.isCancellationRequested) {\n                                picker.busy = false;\n                            }\n                            slowPicksApplied = true;\n                        }\n                    })()\n                ]);\n            };\n            // No Picks\n            if (providedPicks === null) {\n                // Ignore\n            }\n            // Fast and Slow Picks\n            else if (isFastAndSlowPicks(providedPicks)) {\n                await applyFastAndSlowPicks(providedPicks);\n            }\n            // Fast Picks\n            else if (!(providedPicks instanceof Promise)) {\n                applyPicks(providedPicks);\n            }\n            // Slow Picks\n            else {\n                picker.busy = true;\n                try {\n                    const awaitedPicks = await providedPicks;\n                    if (picksToken.isCancellationRequested) {\n                        return;\n                    }\n                    if (isFastAndSlowPicks(awaitedPicks)) {\n                        await applyFastAndSlowPicks(awaitedPicks);\n                    }\n                    else {\n                        applyPicks(awaitedPicks);\n                    }\n                }\n                finally {\n                    if (!picksToken.isCancellationRequested) {\n                        picker.busy = false;\n                    }\n                }\n            }\n        };\n        disposables.add(picker.onDidChangeValue(() => updatePickerItems()));\n        updatePickerItems();\n        // Accept the pick on accept and hide picker\n        disposables.add(picker.onDidAccept(event => {\n            var _a;\n            if (runOptions === null || runOptions === void 0 ? void 0 : runOptions.handleAccept) {\n                if (!event.inBackground) {\n                    picker.hide(); // hide picker unless we accept in background\n                }\n                (_a = runOptions.handleAccept) === null || _a === void 0 ? void 0 : _a.call(runOptions, picker.activeItems[0]);\n                return;\n            }\n            const [item] = picker.selectedItems;\n            if (typeof (item === null || item === void 0 ? void 0 : item.accept) === 'function') {\n                if (!event.inBackground) {\n                    picker.hide(); // hide picker unless we accept in background\n                }\n                item.accept(picker.keyMods, event);\n            }\n        }));\n        const buttonTrigger = async (button, item) => {\n            var _a, _b;\n            if (typeof item.trigger !== 'function') {\n                return;\n            }\n            const buttonIndex = (_b = (_a = item.buttons) === null || _a === void 0 ? void 0 : _a.indexOf(button)) !== null && _b !== void 0 ? _b : -1;\n            if (buttonIndex >= 0) {\n                const result = item.trigger(buttonIndex, picker.keyMods);\n                const action = (typeof result === 'number') ? result : await result;\n                if (token.isCancellationRequested) {\n                    return;\n                }\n                switch (action) {\n                    case TriggerAction.NO_ACTION:\n                        break;\n                    case TriggerAction.CLOSE_PICKER:\n                        picker.hide();\n                        break;\n                    case TriggerAction.REFRESH_PICKER:\n                        updatePickerItems();\n                        break;\n                    case TriggerAction.REMOVE_ITEM: {\n                        const index = picker.items.indexOf(item);\n                        if (index !== -1) {\n                            const items = picker.items.slice();\n                            const removed = items.splice(index, 1);\n                            const activeItems = picker.activeItems.filter(activeItem => activeItem !== removed[0]);\n                            const keepScrollPositionBefore = picker.keepScrollPosition;\n                            picker.keepScrollPosition = true;\n                            picker.items = items;\n                            if (activeItems) {\n                                picker.activeItems = activeItems;\n                            }\n                            picker.keepScrollPosition = keepScrollPositionBefore;\n                        }\n                        break;\n                    }\n                }\n            }\n        };\n        // Trigger the pick with button index if button triggered\n        disposables.add(picker.onDidTriggerItemButton(({ button, item }) => buttonTrigger(button, item)));\n        disposables.add(picker.onDidTriggerSeparatorButton(({ button, separator }) => buttonTrigger(button, separator)));\n        return disposables;\n    }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,OAAO,QAAQ,+BAA+B;AACvD,SAASC,uBAAuB,QAAQ,sCAAsC;AAC9E,SAASC,UAAU,EAAEC,eAAe,EAAEC,iBAAiB,QAAQ,mCAAmC;AAClG,SAASC,UAAU,QAAQ,+BAA+B;AAC1D,OAAO,IAAIC,aAAa;AACxB,CAAC,UAAUA,aAAa,EAAE;EACtB;AACJ;AACA;EACIA,aAAa,CAACA,aAAa,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,GAAG,WAAW;EAC3D;AACJ;AACA;EACIA,aAAa,CAACA,aAAa,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC,GAAG,cAAc;EACjE;AACJ;AACA;EACIA,aAAa,CAACA,aAAa,CAAC,gBAAgB,CAAC,GAAG,CAAC,CAAC,GAAG,gBAAgB;EACrE;AACJ;AACA;EACIA,aAAa,CAACA,aAAa,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,GAAG,aAAa;AACnE,CAAC,EAAEA,aAAa,KAAKA,aAAa,GAAG,CAAC,CAAC,CAAC,CAAC;AACzC,SAASC,iBAAiBA,CAACC,GAAG,EAAE;EAC5B,MAAMC,SAAS,GAAGD,GAAG;EACrB,OAAOE,KAAK,CAACC,OAAO,CAACF,SAAS,CAACG,KAAK,CAAC;AACzC;AACA,SAASC,kBAAkBA,CAACL,GAAG,EAAE;EAC7B,MAAMC,SAAS,GAAGD,GAAG;EACrB,OAAO,CAAC,CAACC,SAAS,CAACK,KAAK,IAAIL,SAAS,CAACM,eAAe,YAAYC,OAAO;AAC5E;AACA,OAAO,MAAMC,yBAAyB,SAASf,UAAU,CAAC;EACtDgB,WAAWA,CAACC,MAAM,EAAEC,OAAO,EAAE;IACzB,KAAK,CAAC,CAAC;IACP,IAAI,CAACD,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,OAAO,GAAGA,OAAO;EAC1B;EACAC,OAAOA,CAACC,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAE;IAC/B,IAAIC,EAAE;IACN,MAAMC,WAAW,GAAG,IAAIvB,eAAe,CAAC,CAAC;IACzC;IACAmB,MAAM,CAACK,qBAAqB,GAAG,CAAC,EAAE,CAACF,EAAE,GAAG,IAAI,CAACL,OAAO,MAAM,IAAI,IAAIK,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACE,qBAAqB,CAAC;IACpH;IACAL,MAAM,CAACM,YAAY,GAAGN,MAAM,CAACO,kBAAkB,GAAGP,MAAM,CAACQ,aAAa,GAAGR,MAAM,CAACS,WAAW,GAAG,KAAK;IACnG;IACA,IAAIC,QAAQ,GAAGC,SAAS;IACxB,MAAMC,eAAe,GAAGR,WAAW,CAACS,GAAG,CAAC,IAAI/B,iBAAiB,CAAC,CAAC,CAAC;IAChE,MAAMgC,iBAAiB,GAAG,MAAAA,CAAA,KAAY;MAClC,IAAIX,EAAE;MACN,MAAMY,gBAAgB,GAAGH,eAAe,CAACI,KAAK,GAAG,IAAInC,eAAe,CAAC,CAAC;MACtE;MACA6B,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,QAAQ,CAACO,OAAO,CAAC,IAAI,CAAC;MAC1EjB,MAAM,CAACkB,IAAI,GAAG,KAAK;MACnB;MACAR,QAAQ,GAAG,IAAI/B,uBAAuB,CAACsB,KAAK,CAAC;MAC7C;MACA,MAAMkB,UAAU,GAAGT,QAAQ,CAACT,KAAK;MACjC,IAAImB,WAAW,GAAGpB,MAAM,CAACgB,KAAK,CAACK,SAAS,CAAC,IAAI,CAACxB,MAAM,CAACyB,MAAM,CAAC;MAC5D,IAAI,EAAE,CAACnB,EAAE,GAAG,IAAI,CAACL,OAAO,MAAM,IAAI,IAAIK,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACoB,wBAAwB,CAAC,EAAE;QACzFH,WAAW,GAAGA,WAAW,CAACI,IAAI,CAAC,CAAC;MACpC;MACA,MAAMC,aAAa,GAAG,IAAI,CAACC,SAAS,CAACN,WAAW,EAAEL,gBAAgB,EAAEI,UAAU,EAAEjB,UAAU,CAAC;MAC3F,MAAMyB,UAAU,GAAGA,CAACnC,KAAK,EAAEoC,SAAS,KAAK;QACrC,IAAIzB,EAAE;QACN,IAAIb,KAAK;QACT,IAAIuC,UAAU,GAAGlB,SAAS;QAC1B,IAAI1B,iBAAiB,CAACO,KAAK,CAAC,EAAE;UAC1BF,KAAK,GAAGE,KAAK,CAACF,KAAK;UACnBuC,UAAU,GAAGrC,KAAK,CAACsC,MAAM;QAC7B,CAAC,MACI;UACDxC,KAAK,GAAGE,KAAK;QACjB;QACA,IAAIF,KAAK,CAACgC,MAAM,KAAK,CAAC,EAAE;UACpB,IAAIM,SAAS,EAAE;YACX,OAAO,KAAK;UAChB;UACA;UACA,IAAI,CAACR,WAAW,CAACE,MAAM,GAAG,CAAC,IAAItB,MAAM,CAAC+B,SAAS,MAAM,CAAC5B,EAAE,GAAG,IAAI,CAACL,OAAO,MAAM,IAAI,IAAIK,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC6B,aAAa,CAAC,EAAE;YAC7H,IAAIjD,UAAU,CAAC,IAAI,CAACe,OAAO,CAACkC,aAAa,CAAC,EAAE;cACxC1C,KAAK,GAAG,CAAC,IAAI,CAACQ,OAAO,CAACkC,aAAa,CAACZ,WAAW,CAAC,CAAC;YACrD,CAAC,MACI;cACD9B,KAAK,GAAG,CAAC,IAAI,CAACQ,OAAO,CAACkC,aAAa,CAAC;YACxC;UACJ;QACJ;QACAhC,MAAM,CAACV,KAAK,GAAGA,KAAK;QACpB,IAAIuC,UAAU,EAAE;UACZ7B,MAAM,CAACiC,WAAW,GAAG,CAACJ,UAAU,CAAC;QACrC;QACA,OAAO,IAAI;MACf,CAAC;MACD,MAAMK,qBAAqB,GAAG,MAAOC,gBAAgB,IAAK;QACtD,IAAIC,gBAAgB,GAAG,KAAK;QAC5B,IAAIC,gBAAgB,GAAG,KAAK;QAC5B,MAAM3C,OAAO,CAAC4C,GAAG,CAAC;QACd;QACA;QACA;QACA;QACA;QACA,CAAC,YAAY;UACT,IAAI,OAAOH,gBAAgB,CAACI,UAAU,KAAK,QAAQ,EAAE;YACjD,MAAM7D,OAAO,CAACyD,gBAAgB,CAACI,UAAU,CAAC;YAC1C,IAAIpB,UAAU,CAACqB,uBAAuB,EAAE;cACpC;YACJ;UACJ;UACA,IAAI,CAACH,gBAAgB,EAAE;YACnBD,gBAAgB,GAAGT,UAAU,CAACQ,gBAAgB,CAAC3C,KAAK,EAAE,IAAI,CAAC,uCAAuC,CAAC;UACvG;QACJ,CAAC,EAAE,CAAC;QACJ;QACA;QACA;QACA,CAAC,YAAY;UACTQ,MAAM,CAACkB,IAAI,GAAG,IAAI;UAClB,IAAI;YACA,MAAMuB,sBAAsB,GAAG,MAAMN,gBAAgB,CAAC1C,eAAe;YACrE,IAAI0B,UAAU,CAACqB,uBAAuB,EAAE;cACpC;YACJ;YACA,IAAIhD,KAAK;YACT,IAAIkD,UAAU,GAAG/B,SAAS;YAC1B,IAAI1B,iBAAiB,CAACkD,gBAAgB,CAAC3C,KAAK,CAAC,EAAE;cAC3CA,KAAK,GAAG2C,gBAAgB,CAAC3C,KAAK,CAACF,KAAK;cACpCoD,UAAU,GAAGP,gBAAgB,CAAC3C,KAAK,CAACsC,MAAM;YAC9C,CAAC,MACI;cACDtC,KAAK,GAAG2C,gBAAgB,CAAC3C,KAAK;YAClC;YACA,IAAIC,eAAe;YACnB,IAAIkD,oBAAoB,GAAGhC,SAAS;YACpC,IAAI1B,iBAAiB,CAACwD,sBAAsB,CAAC,EAAE;cAC3ChD,eAAe,GAAGgD,sBAAsB,CAACnD,KAAK;cAC9CqD,oBAAoB,GAAGF,sBAAsB,CAACX,MAAM;YACxD,CAAC,MACI;cACDrC,eAAe,GAAGgD,sBAAsB;YAC5C;YACA,IAAIhD,eAAe,CAAC6B,MAAM,GAAG,CAAC,IAAI,CAACc,gBAAgB,EAAE;cACjD;cACA;cACA;cACA;cACA;cACA;cACA,IAAIQ,kBAAkB,GAAGjC,SAAS;cAClC,IAAI,CAAC+B,UAAU,IAAI,CAACC,oBAAoB,EAAE;gBACtC,MAAME,2BAA2B,GAAG7C,MAAM,CAACiC,WAAW,CAAC,CAAC,CAAC;gBACzD,IAAIY,2BAA2B,IAAIrD,KAAK,CAACsD,OAAO,CAACD,2BAA2B,CAAC,KAAK,CAAC,CAAC,EAAE;kBAClFD,kBAAkB,GAAGC,2BAA2B;gBACpD;cACJ;cACAlB,UAAU,CAAC;gBACPrC,KAAK,EAAE,CAAC,GAAGE,KAAK,EAAE,GAAGC,eAAe,CAAC;gBACrCqC,MAAM,EAAEY,UAAU,IAAIC,oBAAoB,IAAIC;cAClD,CAAC,CAAC;YACN;UACJ,CAAC,SACO;YACJ,IAAI,CAACzB,UAAU,CAACqB,uBAAuB,EAAE;cACrCxC,MAAM,CAACkB,IAAI,GAAG,KAAK;YACvB;YACAmB,gBAAgB,GAAG,IAAI;UAC3B;QACJ,CAAC,EAAE,CAAC,CACP,CAAC;MACN,CAAC;MACD;MACA,IAAIZ,aAAa,KAAK,IAAI,EAAE;QACxB;MAAA;MAEJ;MAAA,KACK,IAAIlC,kBAAkB,CAACkC,aAAa,CAAC,EAAE;QACxC,MAAMS,qBAAqB,CAACT,aAAa,CAAC;MAC9C;MACA;MAAA,KACK,IAAI,EAAEA,aAAa,YAAY/B,OAAO,CAAC,EAAE;QAC1CiC,UAAU,CAACF,aAAa,CAAC;MAC7B;MACA;MAAA,KACK;QACDzB,MAAM,CAACkB,IAAI,GAAG,IAAI;QAClB,IAAI;UACA,MAAM6B,YAAY,GAAG,MAAMtB,aAAa;UACxC,IAAIN,UAAU,CAACqB,uBAAuB,EAAE;YACpC;UACJ;UACA,IAAIjD,kBAAkB,CAACwD,YAAY,CAAC,EAAE;YAClC,MAAMb,qBAAqB,CAACa,YAAY,CAAC;UAC7C,CAAC,MACI;YACDpB,UAAU,CAACoB,YAAY,CAAC;UAC5B;QACJ,CAAC,SACO;UACJ,IAAI,CAAC5B,UAAU,CAACqB,uBAAuB,EAAE;YACrCxC,MAAM,CAACkB,IAAI,GAAG,KAAK;UACvB;QACJ;MACJ;IACJ,CAAC;IACDd,WAAW,CAACS,GAAG,CAACb,MAAM,CAACgD,gBAAgB,CAAC,MAAMlC,iBAAiB,CAAC,CAAC,CAAC,CAAC;IACnEA,iBAAiB,CAAC,CAAC;IACnB;IACAV,WAAW,CAACS,GAAG,CAACb,MAAM,CAACiD,WAAW,CAACC,KAAK,IAAI;MACxC,IAAI/C,EAAE;MACN,IAAID,UAAU,KAAK,IAAI,IAAIA,UAAU,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,UAAU,CAACiD,YAAY,EAAE;QACjF,IAAI,CAACD,KAAK,CAACE,YAAY,EAAE;UACrBpD,MAAM,CAACqD,IAAI,CAAC,CAAC,CAAC,CAAC;QACnB;QACA,CAAClD,EAAE,GAAGD,UAAU,CAACiD,YAAY,MAAM,IAAI,IAAIhD,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACmD,IAAI,CAACpD,UAAU,EAAEF,MAAM,CAACiC,WAAW,CAAC,CAAC,CAAC,CAAC;QAC9G;MACJ;MACA,MAAM,CAACsB,IAAI,CAAC,GAAGvD,MAAM,CAACwD,aAAa;MACnC,IAAI,QAAQD,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,IAAI,CAACE,MAAM,CAAC,KAAK,UAAU,EAAE;QACjF,IAAI,CAACP,KAAK,CAACE,YAAY,EAAE;UACrBpD,MAAM,CAACqD,IAAI,CAAC,CAAC,CAAC,CAAC;QACnB;QACAE,IAAI,CAACE,MAAM,CAACzD,MAAM,CAAC0D,OAAO,EAAER,KAAK,CAAC;MACtC;IACJ,CAAC,CAAC,CAAC;IACH,MAAMS,aAAa,GAAG,MAAAA,CAAOC,MAAM,EAAEL,IAAI,KAAK;MAC1C,IAAIpD,EAAE,EAAE0D,EAAE;MACV,IAAI,OAAON,IAAI,CAACO,OAAO,KAAK,UAAU,EAAE;QACpC;MACJ;MACA,MAAMC,WAAW,GAAG,CAACF,EAAE,GAAG,CAAC1D,EAAE,GAAGoD,IAAI,CAACS,OAAO,MAAM,IAAI,IAAI7D,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC2C,OAAO,CAACc,MAAM,CAAC,MAAM,IAAI,IAAIC,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,CAAC,CAAC;MAC1I,IAAIE,WAAW,IAAI,CAAC,EAAE;QAClB,MAAME,MAAM,GAAGV,IAAI,CAACO,OAAO,CAACC,WAAW,EAAE/D,MAAM,CAAC0D,OAAO,CAAC;QACxD,MAAMQ,MAAM,GAAI,OAAOD,MAAM,KAAK,QAAQ,GAAIA,MAAM,GAAG,MAAMA,MAAM;QACnE,IAAIhE,KAAK,CAACuC,uBAAuB,EAAE;UAC/B;QACJ;QACA,QAAQ0B,MAAM;UACV,KAAKlF,aAAa,CAACmF,SAAS;YACxB;UACJ,KAAKnF,aAAa,CAACoF,YAAY;YAC3BpE,MAAM,CAACqD,IAAI,CAAC,CAAC;YACb;UACJ,KAAKrE,aAAa,CAACqF,cAAc;YAC7BvD,iBAAiB,CAAC,CAAC;YACnB;UACJ,KAAK9B,aAAa,CAACsF,WAAW;YAAE;cAC5B,MAAMC,KAAK,GAAGvE,MAAM,CAACV,KAAK,CAACwD,OAAO,CAACS,IAAI,CAAC;cACxC,IAAIgB,KAAK,KAAK,CAAC,CAAC,EAAE;gBACd,MAAMjF,KAAK,GAAGU,MAAM,CAACV,KAAK,CAACkF,KAAK,CAAC,CAAC;gBAClC,MAAMC,OAAO,GAAGnF,KAAK,CAACoF,MAAM,CAACH,KAAK,EAAE,CAAC,CAAC;gBACtC,MAAMtC,WAAW,GAAGjC,MAAM,CAACiC,WAAW,CAAC0C,MAAM,CAAC9C,UAAU,IAAIA,UAAU,KAAK4C,OAAO,CAAC,CAAC,CAAC,CAAC;gBACtF,MAAMG,wBAAwB,GAAG5E,MAAM,CAAC6E,kBAAkB;gBAC1D7E,MAAM,CAAC6E,kBAAkB,GAAG,IAAI;gBAChC7E,MAAM,CAACV,KAAK,GAAGA,KAAK;gBACpB,IAAI2C,WAAW,EAAE;kBACbjC,MAAM,CAACiC,WAAW,GAAGA,WAAW;gBACpC;gBACAjC,MAAM,CAAC6E,kBAAkB,GAAGD,wBAAwB;cACxD;cACA;YACJ;QACJ;MACJ;IACJ,CAAC;IACD;IACAxE,WAAW,CAACS,GAAG,CAACb,MAAM,CAAC8E,sBAAsB,CAACC,IAAA;MAAA,IAAC;QAAEnB,MAAM;QAAEL;MAAK,CAAC,GAAAwB,IAAA;MAAA,OAAKpB,aAAa,CAACC,MAAM,EAAEL,IAAI,CAAC;IAAA,EAAC,CAAC;IACjGnD,WAAW,CAACS,GAAG,CAACb,MAAM,CAACgF,2BAA2B,CAACC,KAAA;MAAA,IAAC;QAAErB,MAAM;QAAEsB;MAAU,CAAC,GAAAD,KAAA;MAAA,OAAKtB,aAAa,CAACC,MAAM,EAAEsB,SAAS,CAAC;IAAA,EAAC,CAAC;IAChH,OAAO9E,WAAW;EACtB;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}