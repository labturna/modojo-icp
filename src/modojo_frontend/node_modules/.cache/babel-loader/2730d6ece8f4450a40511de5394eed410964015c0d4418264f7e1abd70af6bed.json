{"ast":null,"code":"const alphabet = 'abcdefghijklmnopqrstuvwxyz234567';\n// Build a lookup table for decoding.\nconst lookupTable = Object.create(null);\nfor (let i = 0; i < alphabet.length; i++) {\n  lookupTable[alphabet[i]] = i;\n}\n// Add aliases for rfc4648.\nlookupTable['0'] = lookupTable.o;\nlookupTable['1'] = lookupTable.i;\n/**\n * @param input The input array to encode.\n * @returns A Base32 string encoding the input.\n */\nexport function encode(input) {\n  // How many bits will we skip from the first byte.\n  let skip = 0;\n  // 5 high bits, carry from one byte to the next.\n  let bits = 0;\n  // The output string in base32.\n  let output = '';\n  function encodeByte(byte) {\n    if (skip < 0) {\n      // we have a carry from the previous byte\n      bits |= byte >> -skip;\n    } else {\n      // no carry\n      bits = byte << skip & 248;\n    }\n    if (skip > 3) {\n      // Not enough data to produce a character, get us another one\n      skip -= 8;\n      return 1;\n    }\n    if (skip < 4) {\n      // produce a character\n      output += alphabet[bits >> 3];\n      skip += 5;\n    }\n    return 0;\n  }\n  for (let i = 0; i < input.length;) {\n    i += encodeByte(input[i]);\n  }\n  return output + (skip < 0 ? alphabet[bits >> 3] : '');\n}\n/**\n * @param input The base32 encoded string to decode.\n */\nexport function decode(input) {\n  // how many bits we have from the previous character.\n  let skip = 0;\n  // current byte we're producing.\n  let byte = 0;\n  const output = new Uint8Array(input.length * 4 / 3 | 0);\n  let o = 0;\n  function decodeChar(char) {\n    // Consume a character from the stream, store\n    // the output in this.output. As before, better\n    // to use update().\n    let val = lookupTable[char.toLowerCase()];\n    if (val === undefined) {\n      throw new Error(`Invalid character: ${JSON.stringify(char)}`);\n    }\n    // move to the high bits\n    val <<= 3;\n    byte |= val >>> skip;\n    skip += 5;\n    if (skip >= 8) {\n      // We have enough bytes to produce an output\n      output[o++] = byte;\n      skip -= 8;\n      if (skip > 0) {\n        byte = val << 5 - skip & 255;\n      } else {\n        byte = 0;\n      }\n    }\n  }\n  for (const c of input) {\n    decodeChar(c);\n  }\n  return output.slice(0, o);\n}","map":{"version":3,"names":["alphabet","lookupTable","Object","create","i","length","o","encode","input","skip","bits","output","encodeByte","byte","decode","Uint8Array","decodeChar","char","val","toLowerCase","undefined","Error","JSON","stringify","c","slice"],"sources":["/home/arslan/modojo/node_modules/@dfinity/principal/src/utils/base32.ts"],"sourcesContent":["const alphabet = 'abcdefghijklmnopqrstuvwxyz234567';\n\n// Build a lookup table for decoding.\nconst lookupTable: Record<string, number> = Object.create(null);\nfor (let i = 0; i < alphabet.length; i++) {\n  lookupTable[alphabet[i]] = i;\n}\n\n// Add aliases for rfc4648.\nlookupTable['0'] = lookupTable.o;\nlookupTable['1'] = lookupTable.i;\n\n/**\n * @param input The input array to encode.\n * @returns A Base32 string encoding the input.\n */\nexport function encode(input: Uint8Array): string {\n  // How many bits will we skip from the first byte.\n  let skip = 0;\n  // 5 high bits, carry from one byte to the next.\n  let bits = 0;\n\n  // The output string in base32.\n  let output = '';\n\n  function encodeByte(byte: number) {\n    if (skip < 0) {\n      // we have a carry from the previous byte\n      bits |= byte >> -skip;\n    } else {\n      // no carry\n      bits = (byte << skip) & 248;\n    }\n\n    if (skip > 3) {\n      // Not enough data to produce a character, get us another one\n      skip -= 8;\n      return 1;\n    }\n\n    if (skip < 4) {\n      // produce a character\n      output += alphabet[bits >> 3];\n      skip += 5;\n    }\n\n    return 0;\n  }\n\n  for (let i = 0; i < input.length; ) {\n    i += encodeByte(input[i]);\n  }\n\n  return output + (skip < 0 ? alphabet[bits >> 3] : '');\n}\n\n/**\n * @param input The base32 encoded string to decode.\n */\nexport function decode(input: string): Uint8Array {\n  // how many bits we have from the previous character.\n  let skip = 0;\n  // current byte we're producing.\n  let byte = 0;\n\n  const output = new Uint8Array(((input.length * 4) / 3) | 0);\n  let o = 0;\n\n  function decodeChar(char: string) {\n    // Consume a character from the stream, store\n    // the output in this.output. As before, better\n    // to use update().\n    let val = lookupTable[char.toLowerCase()];\n    if (val === undefined) {\n      throw new Error(`Invalid character: ${JSON.stringify(char)}`);\n    }\n\n    // move to the high bits\n    val <<= 3;\n    byte |= val >>> skip;\n    skip += 5;\n\n    if (skip >= 8) {\n      // We have enough bytes to produce an output\n      output[o++] = byte;\n      skip -= 8;\n\n      if (skip > 0) {\n        byte = (val << (5 - skip)) & 255;\n      } else {\n        byte = 0;\n      }\n    }\n  }\n\n  for (const c of input) {\n    decodeChar(c);\n  }\n\n  return output.slice(0, o);\n}\n"],"mappings":"AAAA,MAAMA,QAAQ,GAAG,kCAAkC;AAEnD;AACA,MAAMC,WAAW,GAA2BC,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;AAC/D,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,QAAQ,CAACK,MAAM,EAAED,CAAC,EAAE,EAAE;EACxCH,WAAW,CAACD,QAAQ,CAACI,CAAC,CAAC,CAAC,GAAGA,CAAC;;AAG9B;AACAH,WAAW,CAAC,GAAG,CAAC,GAAGA,WAAW,CAACK,CAAC;AAChCL,WAAW,CAAC,GAAG,CAAC,GAAGA,WAAW,CAACG,CAAC;AAEhC;;;;AAIA,OAAM,SAAUG,MAAMA,CAACC,KAAiB;EACtC;EACA,IAAIC,IAAI,GAAG,CAAC;EACZ;EACA,IAAIC,IAAI,GAAG,CAAC;EAEZ;EACA,IAAIC,MAAM,GAAG,EAAE;EAEf,SAASC,UAAUA,CAACC,IAAY;IAC9B,IAAIJ,IAAI,GAAG,CAAC,EAAE;MACZ;MACAC,IAAI,IAAIG,IAAI,IAAI,CAACJ,IAAI;KACtB,MAAM;MACL;MACAC,IAAI,GAAIG,IAAI,IAAIJ,IAAI,GAAI,GAAG;;IAG7B,IAAIA,IAAI,GAAG,CAAC,EAAE;MACZ;MACAA,IAAI,IAAI,CAAC;MACT,OAAO,CAAC;;IAGV,IAAIA,IAAI,GAAG,CAAC,EAAE;MACZ;MACAE,MAAM,IAAIX,QAAQ,CAACU,IAAI,IAAI,CAAC,CAAC;MAC7BD,IAAI,IAAI,CAAC;;IAGX,OAAO,CAAC;EACV;EAEA,KAAK,IAAIL,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGI,KAAK,CAACH,MAAM,GAAI;IAClCD,CAAC,IAAIQ,UAAU,CAACJ,KAAK,CAACJ,CAAC,CAAC,CAAC;;EAG3B,OAAOO,MAAM,IAAIF,IAAI,GAAG,CAAC,GAAGT,QAAQ,CAACU,IAAI,IAAI,CAAC,CAAC,GAAG,EAAE,CAAC;AACvD;AAEA;;;AAGA,OAAM,SAAUI,MAAMA,CAACN,KAAa;EAClC;EACA,IAAIC,IAAI,GAAG,CAAC;EACZ;EACA,IAAII,IAAI,GAAG,CAAC;EAEZ,MAAMF,MAAM,GAAG,IAAII,UAAU,CAAGP,KAAK,CAACH,MAAM,GAAG,CAAC,GAAI,CAAC,GAAI,CAAC,CAAC;EAC3D,IAAIC,CAAC,GAAG,CAAC;EAET,SAASU,UAAUA,CAACC,IAAY;IAC9B;IACA;IACA;IACA,IAAIC,GAAG,GAAGjB,WAAW,CAACgB,IAAI,CAACE,WAAW,EAAE,CAAC;IACzC,IAAID,GAAG,KAAKE,SAAS,EAAE;MACrB,MAAM,IAAIC,KAAK,CAAC,sBAAsBC,IAAI,CAACC,SAAS,CAACN,IAAI,CAAC,EAAE,CAAC;;IAG/D;IACAC,GAAG,KAAK,CAAC;IACTL,IAAI,IAAIK,GAAG,KAAKT,IAAI;IACpBA,IAAI,IAAI,CAAC;IAET,IAAIA,IAAI,IAAI,CAAC,EAAE;MACb;MACAE,MAAM,CAACL,CAAC,EAAE,CAAC,GAAGO,IAAI;MAClBJ,IAAI,IAAI,CAAC;MAET,IAAIA,IAAI,GAAG,CAAC,EAAE;QACZI,IAAI,GAAIK,GAAG,IAAK,CAAC,GAAGT,IAAK,GAAI,GAAG;OACjC,MAAM;QACLI,IAAI,GAAG,CAAC;;;EAGd;EAEA,KAAK,MAAMW,CAAC,IAAIhB,KAAK,EAAE;IACrBQ,UAAU,CAACQ,CAAC,CAAC;;EAGf,OAAOb,MAAM,CAACc,KAAK,CAAC,CAAC,EAAEnB,CAAC,CAAC;AAC3B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}