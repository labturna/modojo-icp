{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst ast_1 = require(\"./ast\");\nconst file_1 = require(\"./file\");\nconst package_1 = require(\"./package\");\nconst asciiToUtf8_1 = require(\"./utils/asciiToUtf8\");\nconst resolveEntryPoint_1 = require(\"./utils/resolveEntryPoint\");\nfunction wrapMotoko(compiler) {\n  const version = compiler.version || '(unknown)';\n  const debug = require('debug')(`motoko:${version}`);\n  const invoke = (key, unwrap, args) => {\n    if (typeof compiler[key] !== 'function') {\n      throw new Error(`Unknown compiler function: '${key}'`);\n    }\n    let result;\n    try {\n      result = compiler[key](...args);\n    } catch (err) {\n      if (err instanceof Error) {\n        throw err;\n      }\n      throw new Error(`Unable to execute ${key}(${[...args].map(x => typeof x).join(', ')}):\\n${JSON.stringify(err)}`);\n    }\n    if (!unwrap) {\n      return result;\n    }\n    if (!result.code) {\n      throw new Error(result.diagnostics ? result.diagnostics.map(_ref => {\n        let {\n          message\n        } = _ref;\n        return message;\n      }).join('; ') : '(no diagnostics)');\n    }\n    return result.code;\n  };\n  function parseMotokoTyped(paths) {\n    if (typeof paths === 'string') {\n      return mo.parseMotokoTyped([paths])[0];\n    }\n    return invoke('parseMotokoTyped', true, [paths]).map(_ref2 => {\n      let {\n        ast,\n        typ\n      } = _ref2;\n      return {\n        ast: (0, ast_1.simplifyAST)(ast),\n        type: (0, ast_1.simplifyAST)(typ)\n      };\n    });\n  }\n  const mo = {\n    version,\n    compiler,\n    file(path) {\n      return (0, file_1.file)(mo, path);\n    },\n    read(path) {\n      return invoke('readFile', false, [path]);\n    },\n    write(path) {\n      let content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n      if (typeof content !== 'string') {\n        throw new Error('Non-string file content');\n      }\n      debug('+file', path);\n      invoke('saveFile', false, [path, content]);\n    },\n    rename(path, newPath) {\n      invoke('renameFile', false, [path, newPath]);\n    },\n    delete(path) {\n      debug('-file', path);\n      invoke('removeFile', false, [path]);\n    },\n    list(directory) {\n      return invoke('readDir', false, [directory]);\n    },\n    fetchPackage(name, info) {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (!info) {\n          throw new Error('Please specify both a name and source');\n        }\n        return (0, package_1.fetchPackage)(name, info);\n      });\n    },\n    installPackages(packages) {\n      return __awaiter(this, void 0, void 0, function* () {\n        return (0, package_1.installPackages)(mo, packages);\n      });\n    },\n    loadPackage(pkg) {\n      debug('+package', pkg.name);\n      mo.validatePackage(pkg);\n      const directory = `.node-motoko/${pkg.name}/${pkg.version}`;\n      Object.entries(pkg.files).forEach(_ref3 => {\n        let [path, file] = _ref3;\n        mo.write(`${directory}/${path}`, file.content);\n      });\n      mo.usePackage(pkg.name, directory);\n    },\n    usePackage(name, directory) {\n      debug('@package', name, directory);\n      invoke('addPackage', false, [name, directory]);\n    },\n    clearPackages() {\n      debug('-packages');\n      invoke('clearPackage', false, []);\n    },\n    validatePackage(pkg) {\n      (0, package_1.validatePackage)(pkg);\n    },\n    setAliases(directory, aliases) {\n      debug('aliases', directory, aliases);\n      invoke('setCandidPath', false, [directory]);\n      invoke('setActorAliases', false, [Object.entries(aliases)]);\n    },\n    setMetadata(values) {\n      invoke('setPublicMetadata', false, [values]);\n    },\n    setRunStepLimit(limit) {\n      invoke('setRunStepLimit', false, [limit]);\n    },\n    check(path) {\n      const result = invoke('check', false, [path]);\n      return result.diagnostics;\n    },\n    run(path, libPaths) {\n      const run = invoke('run', false, [libPaths || [], path]);\n      run.stdout = (0, asciiToUtf8_1.asciiToUtf8)(run.stdout);\n      run.stderr = (0, asciiToUtf8_1.asciiToUtf8)(run.stderr);\n      return run;\n    },\n    candid(path) {\n      return invoke('candid', true, [path]);\n    },\n    wasm(path, mode) {\n      if (!mode) {\n        mode = 'ic';\n      } else if (mode !== 'ic' && mode !== 'wasi') {\n        throw new Error(`Invalid WASM format: ${mode}`);\n      }\n      return invoke('compileWasm', true, [mode, path]);\n    },\n    parseCandid(content) {\n      return invoke('parseCandid', true, [content]);\n    },\n    parseMotoko(content) {\n      const ast = invoke('parseMotoko', true, [content]);\n      return (0, ast_1.simplifyAST)(ast);\n    },\n    parseMotokoTyped,\n    resolveMain() {\n      let directory = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      return (0, resolveEntryPoint_1.resolveMain)(mo, directory);\n    },\n    resolveLib() {\n      let directory = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      return (0, resolveEntryPoint_1.resolveLib)(mo, directory);\n    }\n  };\n  // @ts-ignore\n  mo.default = mo;\n  return mo;\n}\nexports.default = wrapMotoko;","map":{"version":3,"names":["ast_1","require","file_1","package_1","asciiToUtf8_1","resolveEntryPoint_1","wrapMotoko","compiler","version","debug","invoke","key","unwrap","args","Error","result","err","map","x","join","JSON","stringify","code","diagnostics","_ref","message","parseMotokoTyped","paths","mo","_ref2","ast","typ","simplifyAST","type","file","path","read","write","content","arguments","length","undefined","rename","newPath","delete","list","directory","fetchPackage","name","info","installPackages","packages","loadPackage","pkg","validatePackage","Object","entries","files","forEach","_ref3","usePackage","clearPackages","setAliases","aliases","setMetadata","values","setRunStepLimit","limit","check","run","libPaths","stdout","asciiToUtf8","stderr","candid","wasm","mode","parseCandid","parseMotoko","resolveMain","resolveLib","default","exports"],"sources":["/home/arslan/modojo/node_modules/motoko/src/index.ts"],"sourcesContent":["import { CompilerNode, Node, simplifyAST } from './ast';\nimport { file } from './file';\nimport {\n    Package,\n    PackageInfo,\n    fetchPackage,\n    installPackages,\n    validatePackage,\n} from './package';\nimport { asciiToUtf8 } from './utils/asciiToUtf8';\nimport { resolveLib, resolveMain } from './utils/resolveEntryPoint';\n\nexport type Motoko = ReturnType<typeof wrapMotoko>;\n\ntype Compiler = any; // TODO: generate from `js_of_ocaml`?\n\nexport type Diagnostic = {\n    source: string;\n    range: {\n        start: { line: number; character: number };\n        end: { line: number; character: number };\n    };\n    severity: number;\n    code: string;\n    category: string;\n    message: string;\n};\n\nexport type WasmMode = 'ic' | 'wasi';\n\nexport type Result = {\n    value?: any;\n    error: {\n        message?: string;\n    } | null;\n};\n\nexport default function wrapMotoko(compiler: Compiler) {\n    const version = compiler.version || '(unknown)';\n    const debug = require('debug')(`motoko:${version}`);\n\n    const invoke = (key: string, unwrap: boolean, args: any[]) => {\n        if (typeof compiler[key] !== 'function') {\n            throw new Error(`Unknown compiler function: '${key}'`);\n        }\n        let result;\n        try {\n            result = compiler[key](...args);\n        } catch (err) {\n            if (err instanceof Error) {\n                throw err;\n            }\n            throw new Error(\n                `Unable to execute ${key}(${[...args]\n                    .map((x) => typeof x)\n                    .join(', ')}):\\n${JSON.stringify(err)}`,\n            );\n        }\n        if (!unwrap) {\n            return result;\n        }\n        if (!result.code) {\n            throw new Error(\n                result.diagnostics\n                    ? result.diagnostics\n                          .map(({ message }: Diagnostic) => message)\n                          .join('; ')\n                    : '(no diagnostics)',\n            );\n        }\n        return result.code;\n    };\n\n    // Function signatures for `mo.parseMotokoTyped()`\n    type ParseMotokoTypedResult = { ast: Node; type: Node };\n    function parseMotokoTyped(paths: string): ParseMotokoTypedResult;\n    function parseMotokoTyped(paths: string[]): ParseMotokoTypedResult[];\n    function parseMotokoTyped(\n        paths: string | string[],\n    ): ParseMotokoTypedResult | ParseMotokoTypedResult[] {\n        if (typeof paths === 'string') {\n            return mo.parseMotokoTyped([paths])[0];\n        }\n        return invoke('parseMotokoTyped', true, [paths]).map(\n            ({ ast, typ }: { ast: CompilerNode; typ: CompilerNode }) => {\n                return {\n                    ast: simplifyAST(ast),\n                    type: simplifyAST(typ),\n                };\n            },\n        );\n    }\n\n    const mo = {\n        version,\n        compiler,\n        file(path: string) {\n            return file(mo, path);\n        },\n        read(path: string): string {\n            return invoke('readFile', false, [path]);\n        },\n        write(path: string, content: string = '') {\n            if (typeof content !== 'string') {\n                throw new Error('Non-string file content');\n            }\n            debug('+file', path);\n            invoke('saveFile', false, [path, content]);\n        },\n        rename(path: string, newPath: string) {\n            invoke('renameFile', false, [path, newPath]);\n        },\n        delete(path: string) {\n            debug('-file', path);\n            invoke('removeFile', false, [path]);\n        },\n        list(directory: string): string[] {\n            return invoke('readDir', false, [directory]);\n        },\n        async fetchPackage(name: string, info: string | PackageInfo) {\n            if (!info) {\n                throw new Error('Please specify both a name and source');\n            }\n            return fetchPackage(name, info);\n        },\n        async installPackages(packages: Record<string, string | PackageInfo>) {\n            return installPackages(mo, packages);\n        },\n        loadPackage(pkg: Package) {\n            debug('+package', pkg.name);\n            mo.validatePackage(pkg);\n            const directory = `.node-motoko/${pkg.name}/${pkg.version}`;\n            Object.entries(pkg.files).forEach(([path, file]) => {\n                mo.write(`${directory}/${path}`, file.content);\n            });\n            mo.usePackage(pkg.name, directory);\n        },\n        usePackage(name: string, directory: string) {\n            debug('@package', name, directory);\n            invoke('addPackage', false, [name, directory]);\n        },\n        clearPackages() {\n            debug('-packages');\n            invoke('clearPackage', false, []);\n        },\n        validatePackage(pkg: Package) {\n            validatePackage(pkg);\n        },\n        setAliases(directory: string, aliases: Record<string, string>) {\n            debug('aliases', directory, aliases);\n            invoke('setCandidPath', false, [directory]);\n            invoke('setActorAliases', false, [Object.entries(aliases)]);\n        },\n        setMetadata(values: string) {\n            invoke('setPublicMetadata', false, [values]);\n        },\n        setRunStepLimit(limit: number) {\n            invoke('setRunStepLimit', false, [limit]);\n        },\n        check(path: string): Diagnostic[] {\n            const result = invoke('check', false, [path]);\n            return result.diagnostics;\n        },\n        run(\n            path: string,\n            libPaths?: string[] | undefined,\n        ): { stdout: string; stderr: string; result: Result } {\n            const run = invoke('run', false, [libPaths || [], path]);\n            run.stdout = asciiToUtf8(run.stdout);\n            run.stderr = asciiToUtf8(run.stderr);\n            return run;\n        },\n        candid(path: string): string {\n            return invoke('candid', true, [path]);\n        },\n        wasm(path: string, mode: WasmMode) {\n            if (!mode) {\n                mode = 'ic';\n            } else if (mode !== 'ic' && mode !== 'wasi') {\n                throw new Error(`Invalid WASM format: ${mode}`);\n            }\n            return invoke('compileWasm', true, [mode, path]);\n        },\n        parseCandid(content: string): object {\n            return invoke('parseCandid', true, [content]);\n        },\n        parseMotoko(content: string): Node {\n            const ast = invoke('parseMotoko', true, [content]);\n            return simplifyAST(ast);\n        },\n        parseMotokoTyped,\n        resolveMain(directory: string = ''): string | undefined {\n            return resolveMain(mo, directory);\n        },\n        resolveLib(directory: string = ''): string | undefined {\n            return resolveLib(mo, directory);\n        },\n    };\n    // @ts-ignore\n    mo.default = mo;\n    return mo;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}