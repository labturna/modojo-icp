{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ResourceTextEdit } from '../../../browser/services/bulkEditService.js';\nimport { SnippetParser } from '../../snippet/browser/snippetParser.js';\n/**\n * Given a {@link DropOrPasteEdit} and set of ranges, creates a {@link WorkspaceEdit} that applies the insert text from\n * the {@link DropOrPasteEdit} at each range plus any additional edits.\n */\nexport function createCombinedWorkspaceEdit(uri, ranges, edit) {\n  var _a, _b, _c, _d;\n  // If the edit insert text is empty, skip applying at each range\n  if (typeof edit.insertText === 'string' ? edit.insertText === '' : edit.insertText.snippet === '') {\n    return {\n      edits: (_b = (_a = edit.additionalEdit) === null || _a === void 0 ? void 0 : _a.edits) !== null && _b !== void 0 ? _b : []\n    };\n  }\n  return {\n    edits: [...ranges.map(range => new ResourceTextEdit(uri, {\n      range,\n      text: typeof edit.insertText === 'string' ? SnippetParser.escape(edit.insertText) + '$0' : edit.insertText.snippet,\n      insertAsSnippet: true\n    })), ...((_d = (_c = edit.additionalEdit) === null || _c === void 0 ? void 0 : _c.edits) !== null && _d !== void 0 ? _d : [])]\n  };\n}\nexport function sortEditsByYieldTo(edits) {\n  var _a;\n  function yieldsTo(yTo, other) {\n    if ('mimeType' in yTo) {\n      return yTo.mimeType === other.handledMimeType;\n    }\n    return !!other.kind && yTo.kind.contains(other.kind);\n  }\n  // Build list of nodes each node yields to\n  const yieldsToMap = new Map();\n  for (const edit of edits) {\n    for (const yTo of (_a = edit.yieldTo) !== null && _a !== void 0 ? _a : []) {\n      for (const other of edits) {\n        if (other === edit) {\n          continue;\n        }\n        if (yieldsTo(yTo, other)) {\n          let arr = yieldsToMap.get(edit);\n          if (!arr) {\n            arr = [];\n            yieldsToMap.set(edit, arr);\n          }\n          arr.push(other);\n        }\n      }\n    }\n  }\n  if (!yieldsToMap.size) {\n    return Array.from(edits);\n  }\n  // Topological sort\n  const visited = new Set();\n  const tempStack = [];\n  function visit(nodes) {\n    if (!nodes.length) {\n      return [];\n    }\n    const node = nodes[0];\n    if (tempStack.includes(node)) {\n      console.warn('Yield to cycle detected', node);\n      return nodes;\n    }\n    if (visited.has(node)) {\n      return visit(nodes.slice(1));\n    }\n    let pre = [];\n    const yTo = yieldsToMap.get(node);\n    if (yTo) {\n      tempStack.push(node);\n      pre = visit(yTo);\n      tempStack.pop();\n    }\n    visited.add(node);\n    return [...pre, node, ...visit(nodes.slice(1))];\n  }\n  return visit(Array.from(edits));\n}","map":{"version":3,"names":["ResourceTextEdit","SnippetParser","createCombinedWorkspaceEdit","uri","ranges","edit","_a","_b","_c","_d","insertText","snippet","edits","additionalEdit","map","range","text","escape","insertAsSnippet","sortEditsByYieldTo","yieldsTo","yTo","other","mimeType","handledMimeType","kind","contains","yieldsToMap","Map","yieldTo","arr","get","set","push","size","Array","from","visited","Set","tempStack","visit","nodes","length","node","includes","console","warn","has","slice","pre","pop","add"],"sources":["/home/arslan/modojo/node_modules/monaco-editor/esm/vs/editor/contrib/dropOrPasteInto/browser/edit.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ResourceTextEdit } from '../../../browser/services/bulkEditService.js';\nimport { SnippetParser } from '../../snippet/browser/snippetParser.js';\n/**\n * Given a {@link DropOrPasteEdit} and set of ranges, creates a {@link WorkspaceEdit} that applies the insert text from\n * the {@link DropOrPasteEdit} at each range plus any additional edits.\n */\nexport function createCombinedWorkspaceEdit(uri, ranges, edit) {\n    var _a, _b, _c, _d;\n    // If the edit insert text is empty, skip applying at each range\n    if (typeof edit.insertText === 'string' ? edit.insertText === '' : edit.insertText.snippet === '') {\n        return {\n            edits: (_b = (_a = edit.additionalEdit) === null || _a === void 0 ? void 0 : _a.edits) !== null && _b !== void 0 ? _b : []\n        };\n    }\n    return {\n        edits: [\n            ...ranges.map(range => new ResourceTextEdit(uri, { range, text: typeof edit.insertText === 'string' ? SnippetParser.escape(edit.insertText) + '$0' : edit.insertText.snippet, insertAsSnippet: true })),\n            ...((_d = (_c = edit.additionalEdit) === null || _c === void 0 ? void 0 : _c.edits) !== null && _d !== void 0 ? _d : [])\n        ]\n    };\n}\nexport function sortEditsByYieldTo(edits) {\n    var _a;\n    function yieldsTo(yTo, other) {\n        if ('mimeType' in yTo) {\n            return yTo.mimeType === other.handledMimeType;\n        }\n        return !!other.kind && yTo.kind.contains(other.kind);\n    }\n    // Build list of nodes each node yields to\n    const yieldsToMap = new Map();\n    for (const edit of edits) {\n        for (const yTo of (_a = edit.yieldTo) !== null && _a !== void 0 ? _a : []) {\n            for (const other of edits) {\n                if (other === edit) {\n                    continue;\n                }\n                if (yieldsTo(yTo, other)) {\n                    let arr = yieldsToMap.get(edit);\n                    if (!arr) {\n                        arr = [];\n                        yieldsToMap.set(edit, arr);\n                    }\n                    arr.push(other);\n                }\n            }\n        }\n    }\n    if (!yieldsToMap.size) {\n        return Array.from(edits);\n    }\n    // Topological sort\n    const visited = new Set();\n    const tempStack = [];\n    function visit(nodes) {\n        if (!nodes.length) {\n            return [];\n        }\n        const node = nodes[0];\n        if (tempStack.includes(node)) {\n            console.warn('Yield to cycle detected', node);\n            return nodes;\n        }\n        if (visited.has(node)) {\n            return visit(nodes.slice(1));\n        }\n        let pre = [];\n        const yTo = yieldsToMap.get(node);\n        if (yTo) {\n            tempStack.push(node);\n            pre = visit(yTo);\n            tempStack.pop();\n        }\n        visited.add(node);\n        return [...pre, node, ...visit(nodes.slice(1))];\n    }\n    return visit(Array.from(edits));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}