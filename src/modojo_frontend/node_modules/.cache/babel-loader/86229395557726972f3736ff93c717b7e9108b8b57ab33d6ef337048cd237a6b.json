{"ast":null,"code":"/** @module AuthClient */\nimport { AnonymousIdentity } from '@dfinity/agent';\nimport { Delegation, DelegationChain, isDelegationValid, DelegationIdentity, Ed25519KeyIdentity, ECDSAKeyIdentity, PartialDelegationIdentity } from '@dfinity/identity';\nimport { IdleManager } from './idleManager';\nimport { IdbStorage, isBrowser, KEY_STORAGE_DELEGATION, KEY_STORAGE_KEY, KEY_VECTOR, LocalStorage } from './storage';\nexport { IdbStorage, LocalStorage, KEY_STORAGE_DELEGATION, KEY_STORAGE_KEY } from './storage';\nexport { IdbKeyVal } from './db';\nconst IDENTITY_PROVIDER_DEFAULT = 'https://identity.ic0.app';\nconst IDENTITY_PROVIDER_ENDPOINT = '#authorize';\nconst ECDSA_KEY_LABEL = 'ECDSA';\nconst ED25519_KEY_LABEL = 'Ed25519';\nconst INTERRUPT_CHECK_INTERVAL = 500;\nexport const ERROR_USER_INTERRUPT = 'UserInterrupt';\nexport * from './idleManager';\n/**\n * Tool to manage authentication and identity\n * @see {@link AuthClient}\n */\nexport class AuthClient {\n  constructor(_identity, _key, _chain, _storage, idleManager, _createOptions,\n  // A handle on the IdP window.\n  _idpWindow,\n  // The event handler for processing events from the IdP.\n  _eventHandler) {\n    this._identity = _identity;\n    this._key = _key;\n    this._chain = _chain;\n    this._storage = _storage;\n    this.idleManager = idleManager;\n    this._createOptions = _createOptions;\n    this._idpWindow = _idpWindow;\n    this._eventHandler = _eventHandler;\n    this._registerDefaultIdleCallback();\n  }\n  /**\n   * Create an AuthClient to manage authentication and identity\n   * @constructs\n   * @param {AuthClientCreateOptions} options - Options for creating an {@link AuthClient}\n   * @see {@link AuthClientCreateOptions}\n   * @param options.identity Optional Identity to use as the base\n   * @see {@link SignIdentity}\n   * @param options.storage Storage mechanism for delegration credentials\n   * @see {@link AuthClientStorage}\n   * @param options.keyType Type of key to use for the base key\n   * @param {IdleOptions} options.idleOptions Configures an {@link IdleManager}\n   * @see {@link IdleOptions}\n   * Default behavior is to clear stored identity and reload the page when a user goes idle, unless you set the disableDefaultIdleCallback flag or pass in a custom idle callback.\n   * @example\n   * const authClient = await AuthClient.create({\n   *   idleOptions: {\n   *     disableIdle: true\n   *   }\n   * })\n   */\n  static async create() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var _a, _b, _c;\n    const storage = (_a = options.storage) !== null && _a !== void 0 ? _a : new IdbStorage();\n    const keyType = (_b = options.keyType) !== null && _b !== void 0 ? _b : ECDSA_KEY_LABEL;\n    let key = null;\n    if (options.identity) {\n      key = options.identity;\n    } else {\n      let maybeIdentityStorage = await storage.get(KEY_STORAGE_KEY);\n      if (!maybeIdentityStorage && isBrowser) {\n        // Attempt to migrate from localstorage\n        try {\n          const fallbackLocalStorage = new LocalStorage();\n          const localChain = await fallbackLocalStorage.get(KEY_STORAGE_DELEGATION);\n          const localKey = await fallbackLocalStorage.get(KEY_STORAGE_KEY);\n          // not relevant for Ed25519\n          if (localChain && localKey && keyType === ECDSA_KEY_LABEL) {\n            console.log('Discovered an identity stored in localstorage. Migrating to IndexedDB');\n            await storage.set(KEY_STORAGE_DELEGATION, localChain);\n            await storage.set(KEY_STORAGE_KEY, localKey);\n            maybeIdentityStorage = localChain;\n            // clean up\n            await fallbackLocalStorage.remove(KEY_STORAGE_DELEGATION);\n            await fallbackLocalStorage.remove(KEY_STORAGE_KEY);\n          }\n        } catch (error) {\n          console.error('error while attempting to recover localstorage: ' + error);\n        }\n      }\n      if (maybeIdentityStorage) {\n        try {\n          if (typeof maybeIdentityStorage === 'object') {\n            if (keyType === ED25519_KEY_LABEL && typeof maybeIdentityStorage === 'string') {\n              key = await Ed25519KeyIdentity.fromJSON(maybeIdentityStorage);\n            } else {\n              key = await ECDSAKeyIdentity.fromKeyPair(maybeIdentityStorage);\n            }\n          } else if (typeof maybeIdentityStorage === 'string') {\n            // This is a legacy identity, which is a serialized Ed25519KeyIdentity.\n            key = Ed25519KeyIdentity.fromJSON(maybeIdentityStorage);\n          }\n        } catch (_d) {\n          // Ignore this, this means that the localStorage value isn't a valid Ed25519KeyIdentity or ECDSAKeyIdentity\n          // serialization.\n        }\n      }\n    }\n    let identity = new AnonymousIdentity();\n    let chain = null;\n    if (key) {\n      try {\n        const chainStorage = await storage.get(KEY_STORAGE_DELEGATION);\n        if (typeof chainStorage === 'object' && chainStorage !== null) {\n          throw new Error('Delegation chain is incorrectly stored. A delegation chain should be stored as a string.');\n        }\n        if (options.identity) {\n          identity = options.identity;\n        } else if (chainStorage) {\n          chain = DelegationChain.fromJSON(chainStorage);\n          // Verify that the delegation isn't expired.\n          if (!isDelegationValid(chain)) {\n            await _deleteStorage(storage);\n            key = null;\n          } else {\n            // If the key is a public key, then we create a PartialDelegationIdentity.\n            if ('toDer' in key) {\n              identity = PartialDelegationIdentity.fromDelegation(key, chain);\n              // otherwise, we create a DelegationIdentity.\n            } else {\n              identity = DelegationIdentity.fromDelegation(key, chain);\n            }\n          }\n        }\n      } catch (e) {\n        console.error(e);\n        // If there was a problem loading the chain, delete the key.\n        await _deleteStorage(storage);\n        key = null;\n      }\n    }\n    let idleManager = undefined;\n    if ((_c = options.idleOptions) === null || _c === void 0 ? void 0 : _c.disableIdle) {\n      idleManager = undefined;\n    }\n    // if there is a delegation chain or provided identity, setup idleManager\n    else if (chain || options.identity) {\n      idleManager = IdleManager.create(options.idleOptions);\n    }\n    if (!key) {\n      // Create a new key (whether or not one was in storage).\n      if (keyType === ED25519_KEY_LABEL) {\n        key = await Ed25519KeyIdentity.generate();\n        await storage.set(KEY_STORAGE_KEY, JSON.stringify(key.toJSON()));\n      } else {\n        if (options.storage && keyType === ECDSA_KEY_LABEL) {\n          console.warn(`You are using a custom storage provider that may not support CryptoKey storage. If you are using a custom storage provider that does not support CryptoKey storage, you should use '${ED25519_KEY_LABEL}' as the key type, as it can serialize to a string`);\n        }\n        key = await ECDSAKeyIdentity.generate();\n        await storage.set(KEY_STORAGE_KEY, key.getKeyPair());\n      }\n    }\n    return new this(identity, key, chain, storage, idleManager, options);\n  }\n  _registerDefaultIdleCallback() {\n    var _a, _b;\n    const idleOptions = (_a = this._createOptions) === null || _a === void 0 ? void 0 : _a.idleOptions;\n    /**\n     * Default behavior is to clear stored identity and reload the page.\n     * By either setting the disableDefaultIdleCallback flag or passing in a custom idle callback, we will ignore this config\n     */\n    if (!(idleOptions === null || idleOptions === void 0 ? void 0 : idleOptions.onIdle) && !(idleOptions === null || idleOptions === void 0 ? void 0 : idleOptions.disableDefaultIdleCallback)) {\n      (_b = this.idleManager) === null || _b === void 0 ? void 0 : _b.registerCallback(() => {\n        this.logout();\n        location.reload();\n      });\n    }\n  }\n  async _handleSuccess(message, onSuccess) {\n    var _a, _b;\n    const delegations = message.delegations.map(signedDelegation => {\n      return {\n        delegation: new Delegation(signedDelegation.delegation.pubkey, signedDelegation.delegation.expiration, signedDelegation.delegation.targets),\n        signature: signedDelegation.signature.buffer\n      };\n    });\n    const delegationChain = DelegationChain.fromDelegations(delegations, message.userPublicKey.buffer);\n    const key = this._key;\n    if (!key) {\n      return;\n    }\n    this._chain = delegationChain;\n    if ('toDer' in key) {\n      this._identity = PartialDelegationIdentity.fromDelegation(key, this._chain);\n    } else {\n      this._identity = DelegationIdentity.fromDelegation(key, this._chain);\n    }\n    (_a = this._idpWindow) === null || _a === void 0 ? void 0 : _a.close();\n    const idleOptions = (_b = this._createOptions) === null || _b === void 0 ? void 0 : _b.idleOptions;\n    // create the idle manager on a successful login if we haven't disabled it\n    // and it doesn't already exist.\n    if (!this.idleManager && !(idleOptions === null || idleOptions === void 0 ? void 0 : idleOptions.disableIdle)) {\n      this.idleManager = IdleManager.create(idleOptions);\n      this._registerDefaultIdleCallback();\n    }\n    this._removeEventListener();\n    delete this._idpWindow;\n    if (this._chain) {\n      await this._storage.set(KEY_STORAGE_DELEGATION, JSON.stringify(this._chain.toJSON()));\n    }\n    // onSuccess should be the last thing to do to avoid consumers\n    // interfering by navigating or refreshing the page\n    onSuccess === null || onSuccess === void 0 ? void 0 : onSuccess(message);\n  }\n  getIdentity() {\n    return this._identity;\n  }\n  async isAuthenticated() {\n    return !this.getIdentity().getPrincipal().isAnonymous() && this._chain !== null;\n  }\n  /**\n   * AuthClient Login -\n   * Opens up a new window to authenticate with Internet Identity\n   * @param {AuthClientLoginOptions} options - Options for logging in\n   * @param options.identityProvider Identity provider\n   * @param options.maxTimeToLive Expiration of the authentication in nanoseconds\n   * @param options.allowPinAuthentication If present, indicates whether or not the Identity Provider should allow the user to authenticate and/or register using a temporary key/PIN identity. Authenticating dapps may want to prevent users from using Temporary keys/PIN identities because Temporary keys/PIN identities are less secure than Passkeys (webauthn credentials) and because Temporary keys/PIN identities generally only live in a browser database (which may get cleared by the browser/OS).\n   * @param options.derivationOrigin Origin for Identity Provider to use while generating the delegated identity\n   * @param options.windowOpenerFeatures Configures the opened authentication window\n   * @param options.onSuccess Callback once login has completed\n   * @param options.onError Callback in case authentication fails\n   * @example\n   * const authClient = await AuthClient.create();\n   * authClient.login({\n   *  identityProvider: 'http://<canisterID>.127.0.0.1:8000',\n   *  maxTimeToLive: BigInt (7) * BigInt(24) * BigInt(3_600_000_000_000), // 1 week\n   *  windowOpenerFeatures: \"toolbar=0,location=0,menubar=0,width=500,height=500,left=100,top=100\",\n   *  onSuccess: () => {\n   *    console.log('Login Successful!');\n   *  },\n   *  onError: (error) => {\n   *    console.error('Login Failed: ', error);\n   *  }\n   * });\n   */\n  async login(options) {\n    var _a, _b, _c, _d;\n    // Set default maxTimeToLive to 8 hours\n    const defaultTimeToLive = /* hours */BigInt(8) * /* nanoseconds */BigInt(3600000000000);\n    // Create the URL of the IDP. (e.g. https://XXXX/#authorize)\n    const identityProviderUrl = new URL(((_a = options === null || options === void 0 ? void 0 : options.identityProvider) === null || _a === void 0 ? void 0 : _a.toString()) || IDENTITY_PROVIDER_DEFAULT);\n    // Set the correct hash if it isn't already set.\n    identityProviderUrl.hash = IDENTITY_PROVIDER_ENDPOINT;\n    // If `login` has been called previously, then close/remove any previous windows\n    // and event listeners.\n    (_b = this._idpWindow) === null || _b === void 0 ? void 0 : _b.close();\n    this._removeEventListener();\n    // Add an event listener to handle responses.\n    this._eventHandler = this._getEventHandler(identityProviderUrl, Object.assign({\n      maxTimeToLive: (_c = options === null || options === void 0 ? void 0 : options.maxTimeToLive) !== null && _c !== void 0 ? _c : defaultTimeToLive\n    }, options));\n    window.addEventListener('message', this._eventHandler);\n    // Open a new window with the IDP provider.\n    this._idpWindow = (_d = window.open(identityProviderUrl.toString(), 'idpWindow', options === null || options === void 0 ? void 0 : options.windowOpenerFeatures)) !== null && _d !== void 0 ? _d : undefined;\n    // Check if the _idpWindow is closed by user.\n    const checkInterruption = () => {\n      // The _idpWindow is opened and not yet closed by the client\n      if (this._idpWindow) {\n        if (this._idpWindow.closed) {\n          this._handleFailure(ERROR_USER_INTERRUPT, options === null || options === void 0 ? void 0 : options.onError);\n        } else {\n          setTimeout(checkInterruption, INTERRUPT_CHECK_INTERVAL);\n        }\n      }\n    };\n    checkInterruption();\n  }\n  _getEventHandler(identityProviderUrl, options) {\n    return async event => {\n      var _a, _b, _c;\n      if (event.origin !== identityProviderUrl.origin) {\n        console.warn(`WARNING: expected origin '${identityProviderUrl.origin}', got '${event.origin}' (ignoring)`);\n        return;\n      }\n      const message = event.data;\n      switch (message.kind) {\n        case 'authorize-ready':\n          {\n            // IDP is ready. Send a message to request authorization.\n            const request = Object.assign({\n              kind: 'authorize-client',\n              sessionPublicKey: new Uint8Array((_a = this._key) === null || _a === void 0 ? void 0 : _a.getPublicKey().toDer()),\n              maxTimeToLive: options === null || options === void 0 ? void 0 : options.maxTimeToLive,\n              allowPinAuthentication: options === null || options === void 0 ? void 0 : options.allowPinAuthentication,\n              derivationOrigin: (_b = options === null || options === void 0 ? void 0 : options.derivationOrigin) === null || _b === void 0 ? void 0 : _b.toString()\n            }, options === null || options === void 0 ? void 0 : options.customValues);\n            (_c = this._idpWindow) === null || _c === void 0 ? void 0 : _c.postMessage(request, identityProviderUrl.origin);\n            break;\n          }\n        case 'authorize-client-success':\n          // Create the delegation chain and store it.\n          try {\n            await this._handleSuccess(message, options === null || options === void 0 ? void 0 : options.onSuccess);\n          } catch (err) {\n            this._handleFailure(err.message, options === null || options === void 0 ? void 0 : options.onError);\n          }\n          break;\n        case 'authorize-client-failure':\n          this._handleFailure(message.text, options === null || options === void 0 ? void 0 : options.onError);\n          break;\n        default:\n          break;\n      }\n    };\n  }\n  _handleFailure(errorMessage, onError) {\n    var _a;\n    (_a = this._idpWindow) === null || _a === void 0 ? void 0 : _a.close();\n    onError === null || onError === void 0 ? void 0 : onError(errorMessage);\n    this._removeEventListener();\n    delete this._idpWindow;\n  }\n  _removeEventListener() {\n    if (this._eventHandler) {\n      window.removeEventListener('message', this._eventHandler);\n    }\n    this._eventHandler = undefined;\n  }\n  async logout() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    await _deleteStorage(this._storage);\n    // Reset this auth client to a non-authenticated state.\n    this._identity = new AnonymousIdentity();\n    this._chain = null;\n    if (options.returnTo) {\n      try {\n        window.history.pushState({}, '', options.returnTo);\n      } catch (_a) {\n        window.location.href = options.returnTo;\n      }\n    }\n  }\n}\nasync function _deleteStorage(storage) {\n  await storage.remove(KEY_STORAGE_KEY);\n  await storage.remove(KEY_STORAGE_DELEGATION);\n  await storage.remove(KEY_VECTOR);\n}","map":{"version":3,"names":["AnonymousIdentity","Delegation","DelegationChain","isDelegationValid","DelegationIdentity","Ed25519KeyIdentity","ECDSAKeyIdentity","PartialDelegationIdentity","IdleManager","IdbStorage","isBrowser","KEY_STORAGE_DELEGATION","KEY_STORAGE_KEY","KEY_VECTOR","LocalStorage","IdbKeyVal","IDENTITY_PROVIDER_DEFAULT","IDENTITY_PROVIDER_ENDPOINT","ECDSA_KEY_LABEL","ED25519_KEY_LABEL","INTERRUPT_CHECK_INTERVAL","ERROR_USER_INTERRUPT","AuthClient","constructor","_identity","_key","_chain","_storage","idleManager","_createOptions","_idpWindow","_eventHandler","_registerDefaultIdleCallback","create","options","arguments","length","undefined","storage","_a","keyType","_b","key","identity","maybeIdentityStorage","get","fallbackLocalStorage","localChain","localKey","console","log","set","remove","error","fromJSON","fromKeyPair","_d","chain","chainStorage","Error","_deleteStorage","fromDelegation","e","_c","idleOptions","disableIdle","generate","JSON","stringify","toJSON","warn","getKeyPair","onIdle","disableDefaultIdleCallback","registerCallback","logout","location","reload","_handleSuccess","message","onSuccess","delegations","map","signedDelegation","delegation","pubkey","expiration","targets","signature","buffer","delegationChain","fromDelegations","userPublicKey","close","_removeEventListener","getIdentity","isAuthenticated","getPrincipal","isAnonymous","login","defaultTimeToLive","BigInt","identityProviderUrl","URL","identityProvider","toString","hash","_getEventHandler","Object","assign","maxTimeToLive","window","addEventListener","open","windowOpenerFeatures","checkInterruption","closed","_handleFailure","onError","setTimeout","event","origin","data","kind","request","sessionPublicKey","Uint8Array","getPublicKey","toDer","allowPinAuthentication","derivationOrigin","customValues","postMessage","err","text","errorMessage","removeEventListener","returnTo","history","pushState","href"],"sources":["/home/arslan/modojo/node_modules/@dfinity/auth-client/src/index.ts"],"sourcesContent":["/** @module AuthClient */\nimport {\n  AnonymousIdentity,\n  DerEncodedPublicKey,\n  Identity,\n  Signature,\n  SignIdentity,\n} from '@dfinity/agent';\nimport {\n  Delegation,\n  DelegationChain,\n  isDelegationValid,\n  DelegationIdentity,\n  Ed25519KeyIdentity,\n  ECDSAKeyIdentity,\n  PartialDelegationIdentity,\n} from '@dfinity/identity';\nimport { Principal } from '@dfinity/principal';\nimport { IdleManager, IdleManagerOptions } from './idleManager';\nimport {\n  AuthClientStorage,\n  IdbStorage,\n  isBrowser,\n  KEY_STORAGE_DELEGATION,\n  KEY_STORAGE_KEY,\n  KEY_VECTOR,\n  LocalStorage,\n} from './storage';\nimport { PartialIdentity } from '@dfinity/identity/lib/cjs/identity/partial';\n\nexport { AuthClientStorage, IdbStorage, LocalStorage, KEY_STORAGE_DELEGATION, KEY_STORAGE_KEY } from './storage';\nexport { IdbKeyVal, DBCreateOptions } from './db';\n\nconst IDENTITY_PROVIDER_DEFAULT = 'https://identity.ic0.app';\nconst IDENTITY_PROVIDER_ENDPOINT = '#authorize';\n\nconst ECDSA_KEY_LABEL = 'ECDSA';\nconst ED25519_KEY_LABEL = 'Ed25519';\ntype BaseKeyType = typeof ECDSA_KEY_LABEL | typeof ED25519_KEY_LABEL;\n\nconst INTERRUPT_CHECK_INTERVAL = 500;\n\nexport const ERROR_USER_INTERRUPT = 'UserInterrupt';\n\n/**\n * List of options for creating an {@link AuthClient}.\n */\nexport interface AuthClientCreateOptions {\n  /**\n   * An identity to use as the base\n   */\n  identity?: SignIdentity | PartialIdentity;\n  /**\n   * Optional storage with get, set, and remove. Uses {@link IdbStorage} by default\n   */\n  storage?: AuthClientStorage;\n  /**\n   * type to use for the base key\n   * @default 'ECDSA'\n   * If you are using a custom storage provider that does not support CryptoKey storage,\n   * you should use 'Ed25519' as the key type, as it can serialize to a string\n   */\n  keyType?: BaseKeyType;\n\n  /**\n   * Options to handle idle timeouts\n   * @default after 30 minutes, invalidates the identity\n   */\n  idleOptions?: IdleOptions;\n}\n\nexport interface IdleOptions extends IdleManagerOptions {\n  /**\n   * Disables idle functionality for {@link IdleManager}\n   * @default false\n   */\n  disableIdle?: boolean;\n\n  /**\n   * Disables default idle behavior - call logout & reload window\n   * @default false\n   */\n  disableDefaultIdleCallback?: boolean;\n}\n\nexport * from './idleManager';\n\nexport type OnSuccessFunc =\n  | (() => void | Promise<void>)\n  | ((message: InternetIdentityAuthResponseSuccess) => void | Promise<void>);\n\nexport type OnErrorFunc = (error?: string) => void | Promise<void>;\n\nexport interface AuthClientLoginOptions {\n  /**\n   * Identity provider\n   * @default \"https://identity.ic0.app\"\n   */\n  identityProvider?: string | URL;\n  /**\n   * Expiration of the authentication in nanoseconds\n   * @default  BigInt(8) hours * BigInt(3_600_000_000_000) nanoseconds\n   */\n  maxTimeToLive?: bigint;\n  /**\n   * If present, indicates whether or not the Identity Provider should allow the user to authenticate and/or register using a temporary key/PIN identity. Authenticating dapps may want to prevent users from using Temporary keys/PIN identities because Temporary keys/PIN identities are less secure than Passkeys (webauthn credentials) and because Temporary keys/PIN identities generally only live in a browser database (which may get cleared by the browser/OS).\n   */\n  allowPinAuthentication?: boolean;\n  /**\n   * Origin for Identity Provider to use while generating the delegated identity. For II, the derivation origin must authorize this origin by setting a record at `<derivation-origin>/.well-known/ii-alternative-origins`.\n   * @see https://github.com/dfinity/internet-identity/blob/main/docs/internet-identity-spec.adoc\n   */\n  derivationOrigin?: string | URL;\n  /**\n   * Auth Window feature config string\n   * @example \"toolbar=0,location=0,menubar=0,width=500,height=500,left=100,top=100\"\n   */\n  windowOpenerFeatures?: string;\n  /**\n   * Callback once login has completed\n   */\n  onSuccess?: OnSuccessFunc;\n  /**\n   * Callback in case authentication fails\n   */\n  onError?: OnErrorFunc;\n  /**\n   * Extra values to be passed in the login request during the authorize-ready phase\n   */\n  customValues?: Record<string, unknown>;\n}\n\ninterface InternetIdentityAuthRequest {\n  kind: 'authorize-client';\n  sessionPublicKey: Uint8Array;\n  maxTimeToLive?: bigint;\n  allowPinAuthentication?: boolean;\n  derivationOrigin?: string;\n}\n\nexport interface InternetIdentityAuthResponseSuccess {\n  kind: 'authorize-client-success';\n  delegations: {\n    delegation: {\n      pubkey: Uint8Array;\n      expiration: bigint;\n      targets?: Principal[];\n    };\n    signature: Uint8Array;\n  }[];\n  userPublicKey: Uint8Array;\n  authnMethod: 'passkey' | 'pin' | 'recovery';\n}\n\ninterface AuthReadyMessage {\n  kind: 'authorize-ready';\n}\n\ninterface AuthResponseSuccess {\n  kind: 'authorize-client-success';\n  delegations: {\n    delegation: {\n      pubkey: Uint8Array;\n      expiration: bigint;\n      targets?: Principal[];\n    };\n    signature: Uint8Array;\n  }[];\n  userPublicKey: Uint8Array;\n  authnMethod: 'passkey' | 'pin' | 'recovery';\n}\n\ninterface AuthResponseFailure {\n  kind: 'authorize-client-failure';\n  text: string;\n}\n\ntype IdentityServiceResponseMessage = AuthReadyMessage | AuthResponse;\ntype AuthResponse = AuthResponseSuccess | AuthResponseFailure;\n\n/**\n * Tool to manage authentication and identity\n * @see {@link AuthClient}\n */\nexport class AuthClient {\n  /**\n   * Create an AuthClient to manage authentication and identity\n   * @constructs\n   * @param {AuthClientCreateOptions} options - Options for creating an {@link AuthClient}\n   * @see {@link AuthClientCreateOptions}\n   * @param options.identity Optional Identity to use as the base\n   * @see {@link SignIdentity}\n   * @param options.storage Storage mechanism for delegration credentials\n   * @see {@link AuthClientStorage}\n   * @param options.keyType Type of key to use for the base key\n   * @param {IdleOptions} options.idleOptions Configures an {@link IdleManager}\n   * @see {@link IdleOptions}\n   * Default behavior is to clear stored identity and reload the page when a user goes idle, unless you set the disableDefaultIdleCallback flag or pass in a custom idle callback.\n   * @example\n   * const authClient = await AuthClient.create({\n   *   idleOptions: {\n   *     disableIdle: true\n   *   }\n   * })\n   */\n  public static async create(\n    options: {\n      /**\n       * An {@link SignIdentity} or {@link PartialIdentity} to authenticate via delegation.\n       */\n      identity?: SignIdentity | PartialIdentity;\n      /**\n       * {@link AuthClientStorage}\n       * @description Optional storage with get, set, and remove. Uses {@link IdbStorage} by default\n       */\n      storage?: AuthClientStorage;\n      /**\n       * type to use for the base key\n       * @default 'ECDSA'\n       * If you are using a custom storage provider that does not support CryptoKey storage,\n       * you should use 'Ed25519' as the key type, as it can serialize to a string\n       */\n      keyType?: BaseKeyType;\n      /**\n       * Options to handle idle timeouts\n       * @default after 10 minutes, invalidates the identity\n       */\n      idleOptions?: IdleOptions;\n    } = {},\n  ): Promise<AuthClient> {\n    const storage = options.storage ?? new IdbStorage();\n    const keyType = options.keyType ?? ECDSA_KEY_LABEL;\n\n    let key: null | SignIdentity | PartialIdentity = null;\n    if (options.identity) {\n      key = options.identity;\n    } else {\n      let maybeIdentityStorage = await storage.get(KEY_STORAGE_KEY);\n      if (!maybeIdentityStorage && isBrowser) {\n        // Attempt to migrate from localstorage\n        try {\n          const fallbackLocalStorage = new LocalStorage();\n          const localChain = await fallbackLocalStorage.get(KEY_STORAGE_DELEGATION);\n          const localKey = await fallbackLocalStorage.get(KEY_STORAGE_KEY);\n          // not relevant for Ed25519\n          if (localChain && localKey && keyType === ECDSA_KEY_LABEL) {\n            console.log('Discovered an identity stored in localstorage. Migrating to IndexedDB');\n            await storage.set(KEY_STORAGE_DELEGATION, localChain);\n            await storage.set(KEY_STORAGE_KEY, localKey);\n\n            maybeIdentityStorage = localChain;\n            // clean up\n            await fallbackLocalStorage.remove(KEY_STORAGE_DELEGATION);\n            await fallbackLocalStorage.remove(KEY_STORAGE_KEY);\n          }\n        } catch (error) {\n          console.error('error while attempting to recover localstorage: ' + error);\n        }\n      }\n      if (maybeIdentityStorage) {\n        try {\n          if (typeof maybeIdentityStorage === 'object') {\n            if (keyType === ED25519_KEY_LABEL && typeof maybeIdentityStorage === 'string') {\n              key = await Ed25519KeyIdentity.fromJSON(maybeIdentityStorage);\n            } else {\n              key = await ECDSAKeyIdentity.fromKeyPair(maybeIdentityStorage);\n            }\n          } else if (typeof maybeIdentityStorage === 'string') {\n            // This is a legacy identity, which is a serialized Ed25519KeyIdentity.\n            key = Ed25519KeyIdentity.fromJSON(maybeIdentityStorage);\n          }\n        } catch {\n          // Ignore this, this means that the localStorage value isn't a valid Ed25519KeyIdentity or ECDSAKeyIdentity\n          // serialization.\n        }\n      }\n    }\n\n    let identity: SignIdentity | PartialIdentity = new AnonymousIdentity() as PartialIdentity;\n    let chain: null | DelegationChain = null;\n    if (key) {\n      try {\n        const chainStorage = await storage.get(KEY_STORAGE_DELEGATION);\n        if (typeof chainStorage === 'object' && chainStorage !== null) {\n          throw new Error(\n            'Delegation chain is incorrectly stored. A delegation chain should be stored as a string.',\n          );\n        }\n\n        if (options.identity) {\n          identity = options.identity;\n        } else if (chainStorage) {\n          chain = DelegationChain.fromJSON(chainStorage);\n\n          // Verify that the delegation isn't expired.\n          if (!isDelegationValid(chain)) {\n            await _deleteStorage(storage);\n            key = null;\n          } else {\n            // If the key is a public key, then we create a PartialDelegationIdentity.\n            if ('toDer' in key) {\n              identity = PartialDelegationIdentity.fromDelegation(key, chain);\n              // otherwise, we create a DelegationIdentity.\n            } else {\n              identity = DelegationIdentity.fromDelegation(key, chain);\n            }\n          }\n        }\n      } catch (e) {\n        console.error(e);\n        // If there was a problem loading the chain, delete the key.\n        await _deleteStorage(storage);\n        key = null;\n      }\n    }\n    let idleManager: IdleManager | undefined = undefined;\n    if (options.idleOptions?.disableIdle) {\n      idleManager = undefined;\n    }\n    // if there is a delegation chain or provided identity, setup idleManager\n    else if (chain || options.identity) {\n      idleManager = IdleManager.create(options.idleOptions);\n    }\n\n    if (!key) {\n      // Create a new key (whether or not one was in storage).\n      if (keyType === ED25519_KEY_LABEL) {\n        key = await Ed25519KeyIdentity.generate();\n        await storage.set(KEY_STORAGE_KEY, JSON.stringify((key as Ed25519KeyIdentity).toJSON()));\n      } else {\n        if (options.storage && keyType === ECDSA_KEY_LABEL) {\n          console.warn(\n            `You are using a custom storage provider that may not support CryptoKey storage. If you are using a custom storage provider that does not support CryptoKey storage, you should use '${ED25519_KEY_LABEL}' as the key type, as it can serialize to a string`,\n          );\n        }\n        key = await ECDSAKeyIdentity.generate();\n        await storage.set(KEY_STORAGE_KEY, (key as ECDSAKeyIdentity).getKeyPair());\n      }\n    }\n\n    return new this(identity, key, chain, storage, idleManager, options);\n  }\n\n  protected constructor(\n    private _identity: Identity | PartialIdentity,\n    private _key: SignIdentity | PartialIdentity,\n    private _chain: DelegationChain | null,\n    private _storage: AuthClientStorage,\n    public idleManager: IdleManager | undefined,\n    private _createOptions: AuthClientCreateOptions | undefined,\n    // A handle on the IdP window.\n    private _idpWindow?: Window,\n    // The event handler for processing events from the IdP.\n    private _eventHandler?: (event: MessageEvent) => void,\n  ) {\n    this._registerDefaultIdleCallback();\n  }\n\n  private _registerDefaultIdleCallback() {\n    const idleOptions = this._createOptions?.idleOptions;\n    /**\n     * Default behavior is to clear stored identity and reload the page.\n     * By either setting the disableDefaultIdleCallback flag or passing in a custom idle callback, we will ignore this config\n     */\n    if (!idleOptions?.onIdle && !idleOptions?.disableDefaultIdleCallback) {\n      this.idleManager?.registerCallback(() => {\n        this.logout();\n        location.reload();\n      });\n    }\n  }\n\n  private async _handleSuccess(\n    message: InternetIdentityAuthResponseSuccess,\n    onSuccess?: OnSuccessFunc,\n  ) {\n    const delegations = message.delegations.map(signedDelegation => {\n      return {\n        delegation: new Delegation(\n          signedDelegation.delegation.pubkey,\n          signedDelegation.delegation.expiration,\n          signedDelegation.delegation.targets,\n        ),\n        signature: signedDelegation.signature.buffer as Signature,\n      };\n    });\n\n    const delegationChain = DelegationChain.fromDelegations(\n      delegations,\n      message.userPublicKey.buffer as DerEncodedPublicKey,\n    );\n\n    const key = this._key;\n    if (!key) {\n      return;\n    }\n\n    this._chain = delegationChain;\n\n    if ('toDer' in key) {\n      this._identity = PartialDelegationIdentity.fromDelegation(key, this._chain);\n    } else {\n      this._identity = DelegationIdentity.fromDelegation(key, this._chain);\n    }\n\n    this._idpWindow?.close();\n    const idleOptions = this._createOptions?.idleOptions;\n    // create the idle manager on a successful login if we haven't disabled it\n    // and it doesn't already exist.\n    if (!this.idleManager && !idleOptions?.disableIdle) {\n      this.idleManager = IdleManager.create(idleOptions);\n      this._registerDefaultIdleCallback();\n    }\n\n    this._removeEventListener();\n    delete this._idpWindow;\n\n    if (this._chain) {\n      await this._storage.set(KEY_STORAGE_DELEGATION, JSON.stringify(this._chain.toJSON()));\n    }\n\n    // onSuccess should be the last thing to do to avoid consumers\n    // interfering by navigating or refreshing the page\n    onSuccess?.(message);\n  }\n\n  public getIdentity(): Identity {\n    return this._identity;\n  }\n\n  public async isAuthenticated(): Promise<boolean> {\n    return !this.getIdentity().getPrincipal().isAnonymous() && this._chain !== null;\n  }\n\n  /**\n   * AuthClient Login -\n   * Opens up a new window to authenticate with Internet Identity\n   * @param {AuthClientLoginOptions} options - Options for logging in\n   * @param options.identityProvider Identity provider\n   * @param options.maxTimeToLive Expiration of the authentication in nanoseconds\n   * @param options.allowPinAuthentication If present, indicates whether or not the Identity Provider should allow the user to authenticate and/or register using a temporary key/PIN identity. Authenticating dapps may want to prevent users from using Temporary keys/PIN identities because Temporary keys/PIN identities are less secure than Passkeys (webauthn credentials) and because Temporary keys/PIN identities generally only live in a browser database (which may get cleared by the browser/OS).\n   * @param options.derivationOrigin Origin for Identity Provider to use while generating the delegated identity\n   * @param options.windowOpenerFeatures Configures the opened authentication window\n   * @param options.onSuccess Callback once login has completed\n   * @param options.onError Callback in case authentication fails\n   * @example\n   * const authClient = await AuthClient.create();\n   * authClient.login({\n   *  identityProvider: 'http://<canisterID>.127.0.0.1:8000',\n   *  maxTimeToLive: BigInt (7) * BigInt(24) * BigInt(3_600_000_000_000), // 1 week\n   *  windowOpenerFeatures: \"toolbar=0,location=0,menubar=0,width=500,height=500,left=100,top=100\",\n   *  onSuccess: () => {\n   *    console.log('Login Successful!');\n   *  },\n   *  onError: (error) => {\n   *    console.error('Login Failed: ', error);\n   *  }\n   * });\n   */\n  public async login(options?: AuthClientLoginOptions): Promise<void> {\n    // Set default maxTimeToLive to 8 hours\n    const defaultTimeToLive = /* hours */ BigInt(8) * /* nanoseconds */ BigInt(3_600_000_000_000);\n\n    // Create the URL of the IDP. (e.g. https://XXXX/#authorize)\n    const identityProviderUrl = new URL(\n      options?.identityProvider?.toString() || IDENTITY_PROVIDER_DEFAULT,\n    );\n    // Set the correct hash if it isn't already set.\n    identityProviderUrl.hash = IDENTITY_PROVIDER_ENDPOINT;\n\n    // If `login` has been called previously, then close/remove any previous windows\n    // and event listeners.\n    this._idpWindow?.close();\n    this._removeEventListener();\n\n    // Add an event listener to handle responses.\n    this._eventHandler = this._getEventHandler(identityProviderUrl, {\n      maxTimeToLive: options?.maxTimeToLive ?? defaultTimeToLive,\n      ...options,\n    });\n    window.addEventListener('message', this._eventHandler);\n\n    // Open a new window with the IDP provider.\n    this._idpWindow =\n      window.open(identityProviderUrl.toString(), 'idpWindow', options?.windowOpenerFeatures) ??\n      undefined;\n\n    // Check if the _idpWindow is closed by user.\n    const checkInterruption = (): void => {\n      // The _idpWindow is opened and not yet closed by the client\n      if (this._idpWindow) {\n        if (this._idpWindow.closed) {\n          this._handleFailure(ERROR_USER_INTERRUPT, options?.onError);\n        } else {\n          setTimeout(checkInterruption, INTERRUPT_CHECK_INTERVAL);\n        }\n      }\n    };\n    checkInterruption();\n  }\n\n  private _getEventHandler(identityProviderUrl: URL, options?: AuthClientLoginOptions) {\n    return async (event: MessageEvent) => {\n      if (event.origin !== identityProviderUrl.origin) {\n        console.warn(\n          `WARNING: expected origin '${identityProviderUrl.origin}', got '${event.origin}' (ignoring)`,\n        );\n        return;\n      }\n\n      const message = event.data as IdentityServiceResponseMessage;\n\n      switch (message.kind) {\n        case 'authorize-ready': {\n          // IDP is ready. Send a message to request authorization.\n          const request: InternetIdentityAuthRequest = {\n            kind: 'authorize-client',\n            sessionPublicKey: new Uint8Array(this._key?.getPublicKey().toDer() as ArrayBuffer),\n            maxTimeToLive: options?.maxTimeToLive,\n            allowPinAuthentication: options?.allowPinAuthentication,\n            derivationOrigin: options?.derivationOrigin?.toString(),\n            // Pass any custom values to the IDP.\n            ...options?.customValues,\n          };\n          this._idpWindow?.postMessage(request, identityProviderUrl.origin);\n          break;\n        }\n        case 'authorize-client-success':\n          // Create the delegation chain and store it.\n          try {\n            await this._handleSuccess(message, options?.onSuccess);\n          } catch (err) {\n            this._handleFailure((err as Error).message, options?.onError);\n          }\n          break;\n        case 'authorize-client-failure':\n          this._handleFailure(message.text, options?.onError);\n          break;\n        default:\n          break;\n      }\n    };\n  }\n\n  private _handleFailure(errorMessage?: string, onError?: (error?: string) => void): void {\n    this._idpWindow?.close();\n    onError?.(errorMessage);\n    this._removeEventListener();\n    delete this._idpWindow;\n  }\n\n  private _removeEventListener() {\n    if (this._eventHandler) {\n      window.removeEventListener('message', this._eventHandler);\n    }\n    this._eventHandler = undefined;\n  }\n\n  public async logout(options: { returnTo?: string } = {}): Promise<void> {\n    await _deleteStorage(this._storage);\n\n    // Reset this auth client to a non-authenticated state.\n    this._identity = new AnonymousIdentity();\n    this._chain = null;\n\n    if (options.returnTo) {\n      try {\n        window.history.pushState({}, '', options.returnTo);\n      } catch {\n        window.location.href = options.returnTo;\n      }\n    }\n  }\n}\n\nasync function _deleteStorage(storage: AuthClientStorage) {\n  await storage.remove(KEY_STORAGE_KEY);\n  await storage.remove(KEY_STORAGE_DELEGATION);\n  await storage.remove(KEY_VECTOR);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}